#line 1 "E:/github/whippletree/segmentedStorage.cu"
#pragma section("__nv_managed_data__")
#line 1
static char __nv_inited_managed_rt = 0; static void **__nv_fatbinhandle_for_managed_rt; static void __nv_save_fatbinhandle_for_managed_rt(void **in){__nv_fatbinhandle_for_managed_rt = in;} static char __nv_init_managed_rt_with_module(void **); static inline void __nv_init_managed_rt(void) { __nv_inited_managed_rt = (__nv_inited_managed_rt ? __nv_inited_managed_rt                 : __nv_init_managed_rt_with_module(__nv_fatbinhandle_for_managed_rt));}
#line 1
#line 1
#line 62 "E:/CudaToolKit/include\\cuda_runtime.h"
#pragma warning(push)
#pragma warning(disable: 4820)
#line 717 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\sal.h"
#pragma region Input Buffer SAL 1 compatibility macros
#line 1481
#pragma endregion Input Buffer SAL 1 compatibility macros
#line 72 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
#pragma pack ( push, 8 )
#line 28 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\vadefs.h"
#pragma pack ( push, 8 )
#line 50 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\vadefs.h"
extern "C" { typedef unsigned __w64 uintptr_t; }
#line 59 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\vadefs.h"
extern "C" { typedef char *va_list; }
#line 144 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\vadefs.h"
#pragma pack ( pop )
#line 496 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
typedef unsigned __w64 size_t; 
#include "crt/host_runtime.h"
#line 503 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef size_t rsize_t; }
#line 512 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef int __w64 intptr_t; }
#line 530 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef int __w64 ptrdiff_t; }
#line 541 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef unsigned short wint_t; }
#line 542
extern "C" { typedef unsigned short wctype_t; }
#line 563 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef int errno_t; }
#line 567 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef long __w64 __time32_t; }
#line 572 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef __int64 __time64_t; }
#line 580 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { typedef __time64_t time_t; }
#line 637 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { __declspec(dllimport) void __cdecl _invalid_parameter_noinfo(); } 
#line 638
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(); } 
#line 642 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
extern "C" { 
#line 641
__declspec(dllimport) __declspec(noreturn) void __cdecl 
#line 642
_invoke_watson(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); } 
#line 2072 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
struct threadlocaleinfostruct; 
#line 2073
struct threadmbcinfostruct; 
#line 2074
extern "C" { typedef threadlocaleinfostruct *pthreadlocinfo; }
#line 2075
extern "C" { typedef threadmbcinfostruct *pthreadmbcinfo; }
#line 2076
struct __lc_time_data; 
#line 2082
extern "C" { typedef 
#line 2078
struct localeinfo_struct { 
#line 2080
pthreadlocinfo locinfo; 
#line 2081
pthreadmbcinfo mbcinfo; 
#line 2082
} _locale_tstruct, *_locale_t; }
#line 2090
extern "C" { typedef 
#line 2085
struct localerefcount { 
#line 2086
char *locale; 
#line 2087
__wchar_t *wlocale; 
#line 2088
int *refcount; 
#line 2089
int *wrefcount; 
#line 2090
} locrefcount; }
#line 2111
extern "C" { typedef 
#line 2092
struct threadlocaleinfostruct { 
#line 2093
int refcount; 
#line 2094
unsigned lc_codepage; 
#line 2095
unsigned lc_collate_cp; 
#line 2096
unsigned lc_time_cp; 
#line 2097
locrefcount lc_category[6]; 
#line 2098
int lc_clike; 
#line 2099
int mb_cur_max; 
#line 2100
int *lconv_intl_refcount; 
#line 2101
int *lconv_num_refcount; 
#line 2102
int *lconv_mon_refcount; 
#line 2103
struct lconv *lconv; 
#line 2104
int *ctype1_refcount; 
#line 2105
unsigned short *ctype1; 
#line 2106
const unsigned short *pctype; 
#line 2107
const unsigned char *pclmap; 
#line 2108
const unsigned char *pcumap; 
#line 2109
__lc_time_data *lc_time_curr; 
#line 2110
__wchar_t *locale_name[6]; 
#line 2111
} threadlocinfo; }
#line 2148 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdefs.h"
#pragma pack ( pop )
#line 61 "e:\\cudatoolkit\\include\\device_types.h"
#if 0
#line 61
enum cudaRoundMode { 
#line 63
cudaRoundNearest, 
#line 64
cudaRoundZero, 
#line 65
cudaRoundPosInf, 
#line 66
cudaRoundMinInf
#line 67
}; 
#endif
#line 36 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stddef.h"
namespace std { typedef decltype((__nullptr)) nullptr_t; }
#line 37
using std::nullptr_t;
#line 43 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stddef.h"
extern "C" { __declspec(dllimport) extern int *__cdecl _errno(); } 
#line 46
extern "C" { errno_t __cdecl _set_errno(int _Value); } 
#line 47
extern "C" { errno_t __cdecl _get_errno(int * _Value); } 
#line 69 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stddef.h"
extern "C" { __declspec(dllimport) extern unsigned long __cdecl __threadid(); } 
#line 71
extern "C" { __declspec(dllimport) extern uintptr_t __cdecl __threadhandle(); } 
#line 151 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 151
enum cudaError { 
#line 158
cudaSuccess, 
#line 164
cudaErrorMissingConfiguration, 
#line 170
cudaErrorMemoryAllocation, 
#line 176
cudaErrorInitializationError, 
#line 186
cudaErrorLaunchFailure, 
#line 195
cudaErrorPriorLaunchFailure, 
#line 205
cudaErrorLaunchTimeout, 
#line 214
cudaErrorLaunchOutOfResources, 
#line 220
cudaErrorInvalidDeviceFunction, 
#line 229
cudaErrorInvalidConfiguration, 
#line 235
cudaErrorInvalidDevice, 
#line 241
cudaErrorInvalidValue, 
#line 247
cudaErrorInvalidPitchValue, 
#line 253
cudaErrorInvalidSymbol, 
#line 258
cudaErrorMapBufferObjectFailed, 
#line 263
cudaErrorUnmapBufferObjectFailed, 
#line 269
cudaErrorInvalidHostPointer, 
#line 275
cudaErrorInvalidDevicePointer, 
#line 281
cudaErrorInvalidTexture, 
#line 287
cudaErrorInvalidTextureBinding, 
#line 294
cudaErrorInvalidChannelDescriptor, 
#line 300
cudaErrorInvalidMemcpyDirection, 
#line 310
cudaErrorAddressOfConstant, 
#line 319
cudaErrorTextureFetchFailed, 
#line 328
cudaErrorTextureNotBound, 
#line 337
cudaErrorSynchronizationError, 
#line 343
cudaErrorInvalidFilterSetting, 
#line 349
cudaErrorInvalidNormSetting, 
#line 357
cudaErrorMixedDeviceExecution, 
#line 364
cudaErrorCudartUnloading, 
#line 369
cudaErrorUnknown, 
#line 377
cudaErrorNotYetImplemented, 
#line 386
cudaErrorMemoryValueTooLarge, 
#line 393
cudaErrorInvalidResourceHandle, 
#line 401
cudaErrorNotReady, 
#line 408
cudaErrorInsufficientDriver, 
#line 421
cudaErrorSetOnActiveProcess, 
#line 427
cudaErrorInvalidSurface, 
#line 433
cudaErrorNoDevice, 
#line 439
cudaErrorECCUncorrectable, 
#line 444
cudaErrorSharedObjectSymbolNotFound, 
#line 449
cudaErrorSharedObjectInitFailed, 
#line 455
cudaErrorUnsupportedLimit, 
#line 461
cudaErrorDuplicateVariableName, 
#line 467
cudaErrorDuplicateTextureName, 
#line 473
cudaErrorDuplicateSurfaceName, 
#line 483
cudaErrorDevicesUnavailable, 
#line 488
cudaErrorInvalidKernelImage, 
#line 496
cudaErrorNoKernelImageForDevice, 
#line 509
cudaErrorIncompatibleDriverContext, 
#line 516
cudaErrorPeerAccessAlreadyEnabled, 
#line 523
cudaErrorPeerAccessNotEnabled, 
#line 529
cudaErrorDeviceAlreadyInUse = 54, 
#line 536
cudaErrorProfilerDisabled, 
#line 544
cudaErrorProfilerNotInitialized, 
#line 551
cudaErrorProfilerAlreadyStarted, 
#line 558
cudaErrorProfilerAlreadyStopped, 
#line 566
cudaErrorAssert, 
#line 573
cudaErrorTooManyPeers, 
#line 579
cudaErrorHostMemoryAlreadyRegistered, 
#line 585
cudaErrorHostMemoryNotRegistered, 
#line 590
cudaErrorOperatingSystem, 
#line 596
cudaErrorPeerAccessUnsupported, 
#line 603
cudaErrorLaunchMaxDepthExceeded, 
#line 611
cudaErrorLaunchFileScopedTex, 
#line 619
cudaErrorLaunchFileScopedSurf, 
#line 634
cudaErrorSyncDepthExceeded, 
#line 646
cudaErrorLaunchPendingCountExceeded, 
#line 651
cudaErrorNotPermitted, 
#line 657
cudaErrorNotSupported, 
#line 666
cudaErrorHardwareStackError, 
#line 674
cudaErrorIllegalInstruction, 
#line 683
cudaErrorMisalignedAddress, 
#line 694
cudaErrorInvalidAddressSpace, 
#line 702
cudaErrorInvalidPc, 
#line 710
cudaErrorIllegalAddress, 
#line 716
cudaErrorInvalidPtx, 
#line 721
cudaErrorInvalidGraphicsContext, 
#line 727
cudaErrorStartupFailure = 127, 
#line 735
cudaErrorApiFailureBase = 10000
#line 736
}; 
#endif
#line 741 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 741
enum cudaChannelFormatKind { 
#line 743
cudaChannelFormatKindSigned, 
#line 744
cudaChannelFormatKindUnsigned, 
#line 745
cudaChannelFormatKindFloat, 
#line 746
cudaChannelFormatKindNone
#line 747
}; 
#endif
#line 752 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 752
struct cudaChannelFormatDesc { 
#line 754
int x; 
#line 755
int y; 
#line 756
int z; 
#line 757
int w; 
#line 758
cudaChannelFormatKind f; 
#line 759
}; 
#endif
#line 764 "e:\\cudatoolkit\\include\\driver_types.h"
typedef struct cudaArray *cudaArray_t; 
#line 769
typedef const cudaArray *cudaArray_const_t; 
#line 771
struct cudaArray; 
#line 776
typedef struct cudaMipmappedArray *cudaMipmappedArray_t; 
#line 781
typedef const cudaMipmappedArray *cudaMipmappedArray_const_t; 
#line 783
struct cudaMipmappedArray; 
#line 788
#if 0
#line 788
enum cudaMemoryType { 
#line 790
cudaMemoryTypeHost = 1, 
#line 791
cudaMemoryTypeDevice
#line 792
}; 
#endif
#line 797 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 797
enum cudaMemcpyKind { 
#line 799
cudaMemcpyHostToHost, 
#line 800
cudaMemcpyHostToDevice, 
#line 801
cudaMemcpyDeviceToHost, 
#line 802
cudaMemcpyDeviceToDevice, 
#line 803
cudaMemcpyDefault
#line 804
}; 
#endif
#line 811 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 811
struct cudaPitchedPtr { 
#line 813
void *ptr; 
#line 814
size_t pitch; 
#line 815
size_t xsize; 
#line 816
size_t ysize; 
#line 817
}; 
#endif
#line 824 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 824
struct cudaExtent { 
#line 826
size_t width; 
#line 827
size_t height; 
#line 828
size_t depth; 
#line 829
}; 
#endif
#line 836 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 836
struct cudaPos { 
#line 838
size_t x; 
#line 839
size_t y; 
#line 840
size_t z; 
#line 841
}; 
#endif
#line 846 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 846
struct cudaMemcpy3DParms { 
#line 848
cudaArray_t srcArray; 
#line 849
cudaPos srcPos; 
#line 850
cudaPitchedPtr srcPtr; 
#line 852
cudaArray_t dstArray; 
#line 853
cudaPos dstPos; 
#line 854
cudaPitchedPtr dstPtr; 
#line 856
cudaExtent extent; 
#line 857
cudaMemcpyKind kind; 
#line 858
}; 
#endif
#line 863 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 863
struct cudaMemcpy3DPeerParms { 
#line 865
cudaArray_t srcArray; 
#line 866
cudaPos srcPos; 
#line 867
cudaPitchedPtr srcPtr; 
#line 868
int srcDevice; 
#line 870
cudaArray_t dstArray; 
#line 871
cudaPos dstPos; 
#line 872
cudaPitchedPtr dstPtr; 
#line 873
int dstDevice; 
#line 875
cudaExtent extent; 
#line 876
}; 
#endif
#line 881 "e:\\cudatoolkit\\include\\driver_types.h"
struct cudaGraphicsResource; 
#line 886
#if 0
#line 886
enum cudaGraphicsRegisterFlags { 
#line 888
cudaGraphicsRegisterFlagsNone, 
#line 889
cudaGraphicsRegisterFlagsReadOnly, 
#line 890
cudaGraphicsRegisterFlagsWriteDiscard, 
#line 891
cudaGraphicsRegisterFlagsSurfaceLoadStore = 4, 
#line 892
cudaGraphicsRegisterFlagsTextureGather = 8
#line 893
}; 
#endif
#line 898 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 898
enum cudaGraphicsMapFlags { 
#line 900
cudaGraphicsMapFlagsNone, 
#line 901
cudaGraphicsMapFlagsReadOnly, 
#line 902
cudaGraphicsMapFlagsWriteDiscard
#line 903
}; 
#endif
#line 908 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 908
enum cudaGraphicsCubeFace { 
#line 910
cudaGraphicsCubeFacePositiveX, 
#line 911
cudaGraphicsCubeFaceNegativeX, 
#line 912
cudaGraphicsCubeFacePositiveY, 
#line 913
cudaGraphicsCubeFaceNegativeY, 
#line 914
cudaGraphicsCubeFacePositiveZ, 
#line 915
cudaGraphicsCubeFaceNegativeZ
#line 916
}; 
#endif
#line 921 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 921
enum cudaResourceType { 
#line 923
cudaResourceTypeArray, 
#line 924
cudaResourceTypeMipmappedArray, 
#line 925
cudaResourceTypeLinear, 
#line 926
cudaResourceTypePitch2D
#line 927
}; 
#endif
#line 932 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 932
enum cudaResourceViewFormat { 
#line 934
cudaResViewFormatNone, 
#line 935
cudaResViewFormatUnsignedChar1, 
#line 936
cudaResViewFormatUnsignedChar2, 
#line 937
cudaResViewFormatUnsignedChar4, 
#line 938
cudaResViewFormatSignedChar1, 
#line 939
cudaResViewFormatSignedChar2, 
#line 940
cudaResViewFormatSignedChar4, 
#line 941
cudaResViewFormatUnsignedShort1, 
#line 942
cudaResViewFormatUnsignedShort2, 
#line 943
cudaResViewFormatUnsignedShort4, 
#line 944
cudaResViewFormatSignedShort1, 
#line 945
cudaResViewFormatSignedShort2, 
#line 946
cudaResViewFormatSignedShort4, 
#line 947
cudaResViewFormatUnsignedInt1, 
#line 948
cudaResViewFormatUnsignedInt2, 
#line 949
cudaResViewFormatUnsignedInt4, 
#line 950
cudaResViewFormatSignedInt1, 
#line 951
cudaResViewFormatSignedInt2, 
#line 952
cudaResViewFormatSignedInt4, 
#line 953
cudaResViewFormatHalf1, 
#line 954
cudaResViewFormatHalf2, 
#line 955
cudaResViewFormatHalf4, 
#line 956
cudaResViewFormatFloat1, 
#line 957
cudaResViewFormatFloat2, 
#line 958
cudaResViewFormatFloat4, 
#line 959
cudaResViewFormatUnsignedBlockCompressed1, 
#line 960
cudaResViewFormatUnsignedBlockCompressed2, 
#line 961
cudaResViewFormatUnsignedBlockCompressed3, 
#line 962
cudaResViewFormatUnsignedBlockCompressed4, 
#line 963
cudaResViewFormatSignedBlockCompressed4, 
#line 964
cudaResViewFormatUnsignedBlockCompressed5, 
#line 965
cudaResViewFormatSignedBlockCompressed5, 
#line 966
cudaResViewFormatUnsignedBlockCompressed6H, 
#line 967
cudaResViewFormatSignedBlockCompressed6H, 
#line 968
cudaResViewFormatUnsignedBlockCompressed7
#line 969
}; 
#endif
#line 974 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 974
struct cudaResourceDesc { 
#line 975
cudaResourceType resType; 
#line 977
union { 
#line 978
struct { 
#line 979
cudaArray_t array; 
#line 980
} array; 
#line 981
struct { 
#line 982
cudaMipmappedArray_t mipmap; 
#line 983
} mipmap; 
#line 984
struct { 
#line 985
void *devPtr; 
#line 986
cudaChannelFormatDesc desc; 
#line 987
size_t sizeInBytes; 
#line 988
} linear; 
#line 989
struct { 
#line 990
void *devPtr; 
#line 991
cudaChannelFormatDesc desc; 
#line 992
size_t width; 
#line 993
size_t height; 
#line 994
size_t pitchInBytes; 
#line 995
} pitch2D; 
#line 996
} res; 
#line 997
}; 
#endif
#line 1002 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1002
struct cudaResourceViewDesc { 
#line 1004
cudaResourceViewFormat format; 
#line 1005
size_t width; 
#line 1006
size_t height; 
#line 1007
size_t depth; 
#line 1008
unsigned firstMipmapLevel; 
#line 1009
unsigned lastMipmapLevel; 
#line 1010
unsigned firstLayer; 
#line 1011
unsigned lastLayer; 
#line 1012
}; 
#endif
#line 1017 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1017
struct cudaPointerAttributes { 
#line 1023
cudaMemoryType memoryType; 
#line 1034
int device; 
#line 1040
void *devicePointer; 
#line 1046
void *hostPointer; 
#line 1051
int isManaged; 
#line 1052
}; 
#endif
#line 1057 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1057
struct cudaFuncAttributes { 
#line 1064
size_t sharedSizeBytes; 
#line 1070
size_t constSizeBytes; 
#line 1075
size_t localSizeBytes; 
#line 1082
int maxThreadsPerBlock; 
#line 1087
int numRegs; 
#line 1094
int ptxVersion; 
#line 1101
int binaryVersion; 
#line 1107
int cacheModeCA; 
#line 1108
}; 
#endif
#line 1113 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1113
enum cudaFuncCache { 
#line 1115
cudaFuncCachePreferNone, 
#line 1116
cudaFuncCachePreferShared, 
#line 1117
cudaFuncCachePreferL1, 
#line 1118
cudaFuncCachePreferEqual
#line 1119
}; 
#endif
#line 1125 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1125
enum cudaSharedMemConfig { 
#line 1127
cudaSharedMemBankSizeDefault, 
#line 1128
cudaSharedMemBankSizeFourByte, 
#line 1129
cudaSharedMemBankSizeEightByte
#line 1130
}; 
#endif
#line 1135 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1135
enum cudaComputeMode { 
#line 1137
cudaComputeModeDefault, 
#line 1138
cudaComputeModeExclusive, 
#line 1139
cudaComputeModeProhibited, 
#line 1140
cudaComputeModeExclusiveProcess
#line 1141
}; 
#endif
#line 1146 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1146
enum cudaLimit { 
#line 1148
cudaLimitStackSize, 
#line 1149
cudaLimitPrintfFifoSize, 
#line 1150
cudaLimitMallocHeapSize, 
#line 1151
cudaLimitDevRuntimeSyncDepth, 
#line 1152
cudaLimitDevRuntimePendingLaunchCount
#line 1153
}; 
#endif
#line 1158 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1158
enum cudaOutputMode { 
#line 1160
cudaKeyValuePair, 
#line 1161
cudaCSV
#line 1162
}; 
#endif
#line 1167 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1167
enum cudaDeviceAttr { 
#line 1169
cudaDevAttrMaxThreadsPerBlock = 1, 
#line 1170
cudaDevAttrMaxBlockDimX, 
#line 1171
cudaDevAttrMaxBlockDimY, 
#line 1172
cudaDevAttrMaxBlockDimZ, 
#line 1173
cudaDevAttrMaxGridDimX, 
#line 1174
cudaDevAttrMaxGridDimY, 
#line 1175
cudaDevAttrMaxGridDimZ, 
#line 1176
cudaDevAttrMaxSharedMemoryPerBlock, 
#line 1177
cudaDevAttrTotalConstantMemory, 
#line 1178
cudaDevAttrWarpSize, 
#line 1179
cudaDevAttrMaxPitch, 
#line 1180
cudaDevAttrMaxRegistersPerBlock, 
#line 1181
cudaDevAttrClockRate, 
#line 1182
cudaDevAttrTextureAlignment, 
#line 1183
cudaDevAttrGpuOverlap, 
#line 1184
cudaDevAttrMultiProcessorCount, 
#line 1185
cudaDevAttrKernelExecTimeout, 
#line 1186
cudaDevAttrIntegrated, 
#line 1187
cudaDevAttrCanMapHostMemory, 
#line 1188
cudaDevAttrComputeMode, 
#line 1189
cudaDevAttrMaxTexture1DWidth, 
#line 1190
cudaDevAttrMaxTexture2DWidth, 
#line 1191
cudaDevAttrMaxTexture2DHeight, 
#line 1192
cudaDevAttrMaxTexture3DWidth, 
#line 1193
cudaDevAttrMaxTexture3DHeight, 
#line 1194
cudaDevAttrMaxTexture3DDepth, 
#line 1195
cudaDevAttrMaxTexture2DLayeredWidth, 
#line 1196
cudaDevAttrMaxTexture2DLayeredHeight, 
#line 1197
cudaDevAttrMaxTexture2DLayeredLayers, 
#line 1198
cudaDevAttrSurfaceAlignment, 
#line 1199
cudaDevAttrConcurrentKernels, 
#line 1200
cudaDevAttrEccEnabled, 
#line 1201
cudaDevAttrPciBusId, 
#line 1202
cudaDevAttrPciDeviceId, 
#line 1203
cudaDevAttrTccDriver, 
#line 1204
cudaDevAttrMemoryClockRate, 
#line 1205
cudaDevAttrGlobalMemoryBusWidth, 
#line 1206
cudaDevAttrL2CacheSize, 
#line 1207
cudaDevAttrMaxThreadsPerMultiProcessor, 
#line 1208
cudaDevAttrAsyncEngineCount, 
#line 1209
cudaDevAttrUnifiedAddressing, 
#line 1210
cudaDevAttrMaxTexture1DLayeredWidth, 
#line 1211
cudaDevAttrMaxTexture1DLayeredLayers, 
#line 1212
cudaDevAttrMaxTexture2DGatherWidth = 45, 
#line 1213
cudaDevAttrMaxTexture2DGatherHeight, 
#line 1214
cudaDevAttrMaxTexture3DWidthAlt, 
#line 1215
cudaDevAttrMaxTexture3DHeightAlt, 
#line 1216
cudaDevAttrMaxTexture3DDepthAlt, 
#line 1217
cudaDevAttrPciDomainId, 
#line 1218
cudaDevAttrTexturePitchAlignment, 
#line 1219
cudaDevAttrMaxTextureCubemapWidth, 
#line 1220
cudaDevAttrMaxTextureCubemapLayeredWidth, 
#line 1221
cudaDevAttrMaxTextureCubemapLayeredLayers, 
#line 1222
cudaDevAttrMaxSurface1DWidth, 
#line 1223
cudaDevAttrMaxSurface2DWidth, 
#line 1224
cudaDevAttrMaxSurface2DHeight, 
#line 1225
cudaDevAttrMaxSurface3DWidth, 
#line 1226
cudaDevAttrMaxSurface3DHeight, 
#line 1227
cudaDevAttrMaxSurface3DDepth, 
#line 1228
cudaDevAttrMaxSurface1DLayeredWidth, 
#line 1229
cudaDevAttrMaxSurface1DLayeredLayers, 
#line 1230
cudaDevAttrMaxSurface2DLayeredWidth, 
#line 1231
cudaDevAttrMaxSurface2DLayeredHeight, 
#line 1232
cudaDevAttrMaxSurface2DLayeredLayers, 
#line 1233
cudaDevAttrMaxSurfaceCubemapWidth, 
#line 1234
cudaDevAttrMaxSurfaceCubemapLayeredWidth, 
#line 1235
cudaDevAttrMaxSurfaceCubemapLayeredLayers, 
#line 1236
cudaDevAttrMaxTexture1DLinearWidth, 
#line 1237
cudaDevAttrMaxTexture2DLinearWidth, 
#line 1238
cudaDevAttrMaxTexture2DLinearHeight, 
#line 1239
cudaDevAttrMaxTexture2DLinearPitch, 
#line 1240
cudaDevAttrMaxTexture2DMipmappedWidth, 
#line 1241
cudaDevAttrMaxTexture2DMipmappedHeight, 
#line 1242
cudaDevAttrComputeCapabilityMajor, 
#line 1243
cudaDevAttrComputeCapabilityMinor, 
#line 1244
cudaDevAttrMaxTexture1DMipmappedWidth, 
#line 1245
cudaDevAttrStreamPrioritiesSupported, 
#line 1246
cudaDevAttrGlobalL1CacheSupported, 
#line 1247
cudaDevAttrLocalL1CacheSupported, 
#line 1248
cudaDevAttrMaxSharedMemoryPerMultiprocessor, 
#line 1249
cudaDevAttrMaxRegistersPerMultiprocessor, 
#line 1250
cudaDevAttrManagedMemory, 
#line 1251
cudaDevAttrIsMultiGpuBoard, 
#line 1252
cudaDevAttrMultiGpuBoardGroupID
#line 1253
}; 
#endif
#line 1258 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
#line 1258
struct cudaDeviceProp { 
#line 1260
char name[256]; 
#line 1261
size_t totalGlobalMem; 
#line 1262
size_t sharedMemPerBlock; 
#line 1263
int regsPerBlock; 
#line 1264
int warpSize; 
#line 1265
size_t memPitch; 
#line 1266
int maxThreadsPerBlock; 
#line 1267
int maxThreadsDim[3]; 
#line 1268
int maxGridSize[3]; 
#line 1269
int clockRate; 
#line 1270
size_t totalConstMem; 
#line 1271
int major; 
#line 1272
int minor; 
#line 1273
size_t textureAlignment; 
#line 1274
size_t texturePitchAlignment; 
#line 1275
int deviceOverlap; 
#line 1276
int multiProcessorCount; 
#line 1277
int kernelExecTimeoutEnabled; 
#line 1278
int integrated; 
#line 1279
int canMapHostMemory; 
#line 1280
int computeMode; 
#line 1281
int maxTexture1D; 
#line 1282
int maxTexture1DMipmap; 
#line 1283
int maxTexture1DLinear; 
#line 1284
int maxTexture2D[2]; 
#line 1285
int maxTexture2DMipmap[2]; 
#line 1286
int maxTexture2DLinear[3]; 
#line 1287
int maxTexture2DGather[2]; 
#line 1288
int maxTexture3D[3]; 
#line 1289
int maxTexture3DAlt[3]; 
#line 1290
int maxTextureCubemap; 
#line 1291
int maxTexture1DLayered[2]; 
#line 1292
int maxTexture2DLayered[3]; 
#line 1293
int maxTextureCubemapLayered[2]; 
#line 1294
int maxSurface1D; 
#line 1295
int maxSurface2D[2]; 
#line 1296
int maxSurface3D[3]; 
#line 1297
int maxSurface1DLayered[2]; 
#line 1298
int maxSurface2DLayered[3]; 
#line 1299
int maxSurfaceCubemap; 
#line 1300
int maxSurfaceCubemapLayered[2]; 
#line 1301
size_t surfaceAlignment; 
#line 1302
int concurrentKernels; 
#line 1303
int ECCEnabled; 
#line 1304
int pciBusID; 
#line 1305
int pciDeviceID; 
#line 1306
int pciDomainID; 
#line 1307
int tccDriver; 
#line 1308
int asyncEngineCount; 
#line 1309
int unifiedAddressing; 
#line 1310
int memoryClockRate; 
#line 1311
int memoryBusWidth; 
#line 1312
int l2CacheSize; 
#line 1313
int maxThreadsPerMultiProcessor; 
#line 1314
int streamPrioritiesSupported; 
#line 1315
int globalL1CacheSupported; 
#line 1316
int localL1CacheSupported; 
#line 1317
size_t sharedMemPerMultiprocessor; 
#line 1318
int regsPerMultiprocessor; 
#line 1319
int managedMemory; 
#line 1320
int isMultiGpuBoard; 
#line 1321
int multiGpuBoardGroupID; 
#line 1322
}; 
#endif
#line 1401 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef 
#line 1398
struct cudaIpcEventHandle_st { 
#line 1400
char reserved[64]; 
#line 1401
} cudaIpcEventHandle_t; 
#endif
#line 1409 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef 
#line 1406
struct cudaIpcMemHandle_st { 
#line 1408
char reserved[64]; 
#line 1409
} cudaIpcMemHandle_t; 
#endif
#line 1420 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef cudaError 
#line 1420
cudaError_t; 
#endif
#line 1425 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef struct CUstream_st *
#line 1425
cudaStream_t; 
#endif
#line 1430 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef struct CUevent_st *
#line 1430
cudaEvent_t; 
#endif
#line 1435 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef cudaGraphicsResource *
#line 1435
cudaGraphicsResource_t; 
#endif
#line 1440 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef struct CUuuid_st 
#line 1440
cudaUUID_t; 
#endif
#line 1445 "e:\\cudatoolkit\\include\\driver_types.h"
#if 0
typedef cudaOutputMode 
#line 1445
cudaOutputMode_t; 
#endif
#line 84 "e:\\cudatoolkit\\include\\surface_types.h"
#if 0
#line 84
enum cudaSurfaceBoundaryMode { 
#line 86
cudaBoundaryModeZero, 
#line 87
cudaBoundaryModeClamp, 
#line 88
cudaBoundaryModeTrap
#line 89
}; 
#endif
#line 94 "e:\\cudatoolkit\\include\\surface_types.h"
#if 0
#line 94
enum cudaSurfaceFormatMode { 
#line 96
cudaFormatModeForced, 
#line 97
cudaFormatModeAuto
#line 98
}; 
#endif
#line 103 "e:\\cudatoolkit\\include\\surface_types.h"
#if 0
#line 103
struct surfaceReference { 
#line 108
cudaChannelFormatDesc channelDesc; 
#line 109
}; 
#endif
#line 114 "e:\\cudatoolkit\\include\\surface_types.h"
#if 0
typedef unsigned __int64 
#line 114
cudaSurfaceObject_t; 
#endif
#line 84 "e:\\cudatoolkit\\include\\texture_types.h"
#if 0
#line 84
enum cudaTextureAddressMode { 
#line 86
cudaAddressModeWrap, 
#line 87
cudaAddressModeClamp, 
#line 88
cudaAddressModeMirror, 
#line 89
cudaAddressModeBorder
#line 90
}; 
#endif
#line 95 "e:\\cudatoolkit\\include\\texture_types.h"
#if 0
#line 95
enum cudaTextureFilterMode { 
#line 97
cudaFilterModePoint, 
#line 98
cudaFilterModeLinear
#line 99
}; 
#endif
#line 104 "e:\\cudatoolkit\\include\\texture_types.h"
#if 0
#line 104
enum cudaTextureReadMode { 
#line 106
cudaReadModeElementType, 
#line 107
cudaReadModeNormalizedFloat
#line 108
}; 
#endif
#line 113 "e:\\cudatoolkit\\include\\texture_types.h"
#if 0
#line 113
struct textureReference { 
#line 118
int normalized; 
#line 122
cudaTextureFilterMode filterMode; 
#line 126
cudaTextureAddressMode addressMode[3]; 
#line 130
cudaChannelFormatDesc channelDesc; 
#line 134
int sRGB; 
#line 138
unsigned maxAnisotropy; 
#line 142
cudaTextureFilterMode mipmapFilterMode; 
#line 146
float mipmapLevelBias; 
#line 150
float minMipmapLevelClamp; 
#line 154
float maxMipmapLevelClamp; 
#line 155
int __cudaReserved[15]; 
#line 156
}; 
#endif
#line 161 "e:\\cudatoolkit\\include\\texture_types.h"
#if 0
#line 161
struct cudaTextureDesc { 
#line 166
cudaTextureAddressMode addressMode[3]; 
#line 170
cudaTextureFilterMode filterMode; 
#line 174
cudaTextureReadMode readMode; 
#line 178
int sRGB; 
#line 182
int normalizedCoords; 
#line 186
unsigned maxAnisotropy; 
#line 190
cudaTextureFilterMode mipmapFilterMode; 
#line 194
float mipmapLevelBias; 
#line 198
float minMipmapLevelClamp; 
#line 202
float maxMipmapLevelClamp; 
#line 203
}; 
#endif
#line 208 "e:\\cudatoolkit\\include\\texture_types.h"
#if 0
typedef unsigned __int64 
#line 208
cudaTextureObject_t; 
#endif
#line 98 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 98
struct char1 { 
#line 100
signed char x; 
#line 101
}; 
#endif
#line 103 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 103
struct uchar1 { 
#line 105
unsigned char x; 
#line 106
}; 
#endif
#line 109 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 109
struct __declspec(align(2)) char2 { 
#line 111
signed char x, y; 
#line 112
}; 
#endif
#line 114 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 114
struct __declspec(align(2)) uchar2 { 
#line 116
unsigned char x, y; 
#line 117
}; 
#endif
#line 119 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 119
struct char3 { 
#line 121
signed char x, y, z; 
#line 122
}; 
#endif
#line 124 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 124
struct uchar3 { 
#line 126
unsigned char x, y, z; 
#line 127
}; 
#endif
#line 129 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 129
struct __declspec(align(4)) char4 { 
#line 131
signed char x, y, z, w; 
#line 132
}; 
#endif
#line 134 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 134
struct __declspec(align(4)) uchar4 { 
#line 136
unsigned char x, y, z, w; 
#line 137
}; 
#endif
#line 139 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 139
struct short1 { 
#line 141
short x; 
#line 142
}; 
#endif
#line 144 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 144
struct ushort1 { 
#line 146
unsigned short x; 
#line 147
}; 
#endif
#line 149 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 149
struct __declspec(align(4)) short2 { 
#line 151
short x, y; 
#line 152
}; 
#endif
#line 154 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 154
struct __declspec(align(4)) ushort2 { 
#line 156
unsigned short x, y; 
#line 157
}; 
#endif
#line 159 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 159
struct short3 { 
#line 161
short x, y, z; 
#line 162
}; 
#endif
#line 164 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 164
struct ushort3 { 
#line 166
unsigned short x, y, z; 
#line 167
}; 
#endif
#line 169 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 169
struct __declspec(align(8)) short4 { short x; short y; short z; short w; }; 
#endif
#line 170 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 170
struct __declspec(align(8)) ushort4 { unsigned short x; unsigned short y; unsigned short z; unsigned short w; }; 
#endif
#line 172 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 172
struct int1 { 
#line 174
int x; 
#line 175
}; 
#endif
#line 177 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 177
struct uint1 { 
#line 179
unsigned x; 
#line 180
}; 
#endif
#line 182 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 182
struct __declspec(align(8)) int2 { int x; int y; }; 
#endif
#line 183 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 183
struct __declspec(align(8)) uint2 { unsigned x; unsigned y; }; 
#endif
#line 185 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 185
struct int3 { 
#line 187
int x, y, z; 
#line 188
}; 
#endif
#line 190 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 190
struct uint3 { 
#line 192
unsigned x, y, z; 
#line 193
}; 
#endif
#line 195 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 195
struct __declspec(align(16)) int4 { 
#line 197
int x, y, z, w; 
#line 198
}; 
#endif
#line 200 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 200
struct __declspec(align(16)) uint4 { 
#line 202
unsigned x, y, z, w; 
#line 203
}; 
#endif
#line 205 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 205
struct long1 { 
#line 207
long x; 
#line 208
}; 
#endif
#line 210 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 210
struct ulong1 { 
#line 212
unsigned long x; 
#line 213
}; 
#endif
#line 216 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 216
struct __declspec(align(8)) long2 { long x; long y; }; 
#endif
#line 217 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 217
struct __declspec(align(8)) ulong2 { unsigned long x; unsigned long y; }; 
#endif
#line 232 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 232
struct long3 { 
#line 234
long x, y, z; 
#line 235
}; 
#endif
#line 237 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 237
struct ulong3 { 
#line 239
unsigned long x, y, z; 
#line 240
}; 
#endif
#line 242 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 242
struct __declspec(align(16)) long4 { 
#line 244
long x, y, z, w; 
#line 245
}; 
#endif
#line 247 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 247
struct __declspec(align(16)) ulong4 { 
#line 249
unsigned long x, y, z, w; 
#line 250
}; 
#endif
#line 252 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 252
struct float1 { 
#line 254
float x; 
#line 255
}; 
#endif
#line 274 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 274
struct __declspec(align(8)) float2 { float x; float y; }; 
#endif
#line 279 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 279
struct float3 { 
#line 281
float x, y, z; 
#line 282
}; 
#endif
#line 284 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 284
struct __declspec(align(16)) float4 { 
#line 286
float x, y, z, w; 
#line 287
}; 
#endif
#line 289 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 289
struct longlong1 { 
#line 291
__int64 x; 
#line 292
}; 
#endif
#line 294 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 294
struct ulonglong1 { 
#line 296
unsigned __int64 x; 
#line 297
}; 
#endif
#line 299 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 299
struct __declspec(align(16)) longlong2 { 
#line 301
__int64 x, y; 
#line 302
}; 
#endif
#line 304 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 304
struct __declspec(align(16)) ulonglong2 { 
#line 306
unsigned __int64 x, y; 
#line 307
}; 
#endif
#line 309 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 309
struct longlong3 { 
#line 311
__int64 x, y, z; 
#line 312
}; 
#endif
#line 314 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 314
struct ulonglong3 { 
#line 316
unsigned __int64 x, y, z; 
#line 317
}; 
#endif
#line 319 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 319
struct __declspec(align(16)) longlong4 { 
#line 321
__int64 x, y, z, w; 
#line 322
}; 
#endif
#line 324 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 324
struct __declspec(align(16)) ulonglong4 { 
#line 326
unsigned __int64 x, y, z, w; 
#line 327
}; 
#endif
#line 329 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 329
struct double1 { 
#line 331
double x; 
#line 332
}; 
#endif
#line 334 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 334
struct __declspec(align(16)) double2 { 
#line 336
double x, y; 
#line 337
}; 
#endif
#line 339 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 339
struct double3 { 
#line 341
double x, y, z; 
#line 342
}; 
#endif
#line 344 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 344
struct __declspec(align(16)) double4 { 
#line 346
double x, y, z, w; 
#line 347
}; 
#endif
#line 362 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef char1 
#line 362
char1; 
#endif
#line 363 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uchar1 
#line 363
uchar1; 
#endif
#line 364 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef char2 
#line 364
char2; 
#endif
#line 365 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uchar2 
#line 365
uchar2; 
#endif
#line 366 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef char3 
#line 366
char3; 
#endif
#line 367 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uchar3 
#line 367
uchar3; 
#endif
#line 368 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef char4 
#line 368
char4; 
#endif
#line 369 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uchar4 
#line 369
uchar4; 
#endif
#line 370 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef short1 
#line 370
short1; 
#endif
#line 371 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ushort1 
#line 371
ushort1; 
#endif
#line 372 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef short2 
#line 372
short2; 
#endif
#line 373 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ushort2 
#line 373
ushort2; 
#endif
#line 374 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef short3 
#line 374
short3; 
#endif
#line 375 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ushort3 
#line 375
ushort3; 
#endif
#line 376 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef short4 
#line 376
short4; 
#endif
#line 377 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ushort4 
#line 377
ushort4; 
#endif
#line 378 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef int1 
#line 378
int1; 
#endif
#line 379 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uint1 
#line 379
uint1; 
#endif
#line 380 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef int2 
#line 380
int2; 
#endif
#line 381 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uint2 
#line 381
uint2; 
#endif
#line 382 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef int3 
#line 382
int3; 
#endif
#line 383 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uint3 
#line 383
uint3; 
#endif
#line 384 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef int4 
#line 384
int4; 
#endif
#line 385 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef uint4 
#line 385
uint4; 
#endif
#line 386 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef long1 
#line 386
long1; 
#endif
#line 387 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulong1 
#line 387
ulong1; 
#endif
#line 388 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef long2 
#line 388
long2; 
#endif
#line 389 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulong2 
#line 389
ulong2; 
#endif
#line 390 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef long3 
#line 390
long3; 
#endif
#line 391 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulong3 
#line 391
ulong3; 
#endif
#line 392 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef long4 
#line 392
long4; 
#endif
#line 393 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulong4 
#line 393
ulong4; 
#endif
#line 394 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef float1 
#line 394
float1; 
#endif
#line 395 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef float2 
#line 395
float2; 
#endif
#line 396 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef float3 
#line 396
float3; 
#endif
#line 397 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef float4 
#line 397
float4; 
#endif
#line 398 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef longlong1 
#line 398
longlong1; 
#endif
#line 399 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulonglong1 
#line 399
ulonglong1; 
#endif
#line 400 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef longlong2 
#line 400
longlong2; 
#endif
#line 401 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulonglong2 
#line 401
ulonglong2; 
#endif
#line 402 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef longlong3 
#line 402
longlong3; 
#endif
#line 403 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulonglong3 
#line 403
ulonglong3; 
#endif
#line 404 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef longlong4 
#line 404
longlong4; 
#endif
#line 405 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef ulonglong4 
#line 405
ulonglong4; 
#endif
#line 406 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef double1 
#line 406
double1; 
#endif
#line 407 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef double2 
#line 407
double2; 
#endif
#line 408 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef double3 
#line 408
double3; 
#endif
#line 409 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef double4 
#line 409
double4; 
#endif
#line 417 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
#line 417
struct dim3 { 
#line 419
unsigned x, y, z; 
#line 425 "e:\\cudatoolkit\\include\\vector_types.h"
}; 
#endif
#line 427 "e:\\cudatoolkit\\include\\vector_types.h"
#if 0
typedef dim3 
#line 427
dim3; 
#endif
#line 106 "e:\\cudatoolkit\\include\\cuda_device_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); } 
#line 107
extern "C" { extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); } 
#line 108
extern "C" { extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); } 
#line 109
extern "C" { extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); } 
#line 110
extern "C" { extern cudaError_t __stdcall cudaDeviceSynchronize(); } 
#line 111
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
#line 112
extern "C" { extern cudaError_t __stdcall cudaPeekAtLastError(); } 
#line 113
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t error); } 
#line 114
extern "C" { extern const char *__stdcall cudaGetErrorName(cudaError_t error); } 
#line 115
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int * count); } 
#line 116
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int * device); } 
#line 117
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); } 
#line 118
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); } 
#line 119
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); } 
#line 120
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent_ptsz(cudaStream_t stream, cudaEvent_t event, unsigned flags); } 
#line 121
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); } 
#line 122
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream); } 
#line 123
extern "C" { extern cudaError_t __stdcall cudaEventRecord_ptsz(cudaEvent_t event, cudaStream_t stream); } 
#line 124
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); } 
#line 125
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); } 
#line 126
extern "C" { extern cudaError_t __stdcall cudaFree(void * devPtr); } 
#line 127
extern "C" { extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); } 
#line 128
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); } 
#line 129
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync_ptsz(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream); } 
#line 130
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); } 
#line 131
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync_ptsz(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream); } 
#line 132
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream); } 
#line 133
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync_ptsz(const cudaMemcpy3DParms * p, cudaStream_t stream); } 
#line 134
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream); } 
#line 135
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync_ptsz(void * devPtr, int value, size_t count, cudaStream_t stream); } 
#line 136
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); } 
#line 137
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync_ptsz(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream); } 
#line 138
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); } 
#line 139
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync_ptsz(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream); } 
#line 140
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); } 
#line 161
extern "C" { extern void *__stdcall cudaGetParameterBuffer(size_t alignment, size_t size); } 
#line 189
extern "C" { extern void *__stdcall cudaGetParameterBufferV2(void * func, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize); } 
#line 190
extern "C" { extern cudaError_t __stdcall cudaLaunchDevice_ptsz(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); } 
#line 191
extern "C" { extern cudaError_t __stdcall cudaLaunchDeviceV2_ptsz(void * parameterBuffer, cudaStream_t stream); } 
#line 209 "e:\\cudatoolkit\\include\\cuda_device_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaLaunchDevice(void * func, void * parameterBuffer, dim3 gridDimension, dim3 blockDimension, unsigned sharedMemSize, cudaStream_t stream); } 
#line 210
extern "C" { extern cudaError_t __stdcall cudaLaunchDeviceV2(void * parameterBuffer, cudaStream_t stream); } 
#line 213 "e:\\cudatoolkit\\include\\cuda_device_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize); } 
#line 214
extern "C" { extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSmemSize, unsigned flags); } 
#line 218
template< class T> static __inline cudaError_t cudaMalloc(T ** devPtr, size_t size); 
#line 219
template< class T> static __inline cudaError_t cudaFuncGetAttributes(cudaFuncAttributes * attr, T * entry); 
#line 220
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize); 
#line 221
template< class T> static __inline cudaError_t cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, T func, int blockSize, size_t dynamicSmemSize, unsigned flags); 
#line 251 "e:\\cudatoolkit\\include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaDeviceReset(); } 
#line 268
extern "C" { extern cudaError_t __stdcall cudaDeviceSynchronize(); } 
#line 343
extern "C" { extern cudaError_t __stdcall cudaDeviceSetLimit(cudaLimit limit, size_t value); } 
#line 372
extern "C" { extern cudaError_t __stdcall cudaDeviceGetLimit(size_t * pValue, cudaLimit limit); } 
#line 403
extern "C" { extern cudaError_t __stdcall cudaDeviceGetCacheConfig(cudaFuncCache * pCacheConfig); } 
#line 438
extern "C" { extern cudaError_t __stdcall cudaDeviceGetStreamPriorityRange(int * leastPriority, int * greatestPriority); } 
#line 480
extern "C" { extern cudaError_t __stdcall cudaDeviceSetCacheConfig(cudaFuncCache cacheConfig); } 
#line 509
extern "C" { extern cudaError_t __stdcall cudaDeviceGetSharedMemConfig(cudaSharedMemConfig * pConfig); } 
#line 551
extern "C" { extern cudaError_t __stdcall cudaDeviceSetSharedMemConfig(cudaSharedMemConfig config); } 
#line 574
extern "C" { extern cudaError_t __stdcall cudaDeviceGetByPCIBusId(int * device, const char * pciBusId); } 
#line 601
extern "C" { extern cudaError_t __stdcall cudaDeviceGetPCIBusId(char * pciBusId, int len, int device); } 
#line 643
extern "C" { extern cudaError_t __stdcall cudaIpcGetEventHandle(cudaIpcEventHandle_t * handle, cudaEvent_t event); } 
#line 678
extern "C" { extern cudaError_t __stdcall cudaIpcOpenEventHandle(cudaEvent_t * event, cudaIpcEventHandle_t handle); } 
#line 716
extern "C" { extern cudaError_t __stdcall cudaIpcGetMemHandle(cudaIpcMemHandle_t * handle, void * devPtr); } 
#line 766
extern "C" { extern cudaError_t __stdcall cudaIpcOpenMemHandle(void ** devPtr, cudaIpcMemHandle_t handle, unsigned flags); } 
#line 796
extern "C" { extern cudaError_t __stdcall cudaIpcCloseMemHandle(void * devPtr); } 
#line 836
extern "C" { extern cudaError_t __stdcall cudaThreadExit(); } 
#line 860
extern "C" { extern cudaError_t __stdcall cudaThreadSynchronize(); } 
#line 907
extern "C" { extern cudaError_t __stdcall cudaThreadSetLimit(cudaLimit limit, size_t value); } 
#line 938
extern "C" { extern cudaError_t __stdcall cudaThreadGetLimit(size_t * pValue, cudaLimit limit); } 
#line 973
extern "C" { extern cudaError_t __stdcall cudaThreadGetCacheConfig(cudaFuncCache * pCacheConfig); } 
#line 1019
extern "C" { extern cudaError_t __stdcall cudaThreadSetCacheConfig(cudaFuncCache cacheConfig); } 
#line 1073
extern "C" { extern cudaError_t __stdcall cudaGetLastError(); } 
#line 1114
extern "C" { extern cudaError_t __stdcall cudaPeekAtLastError(); } 
#line 1129
extern "C" { extern const char *__stdcall cudaGetErrorName(cudaError_t error); } 
#line 1144
extern "C" { extern const char *__stdcall cudaGetErrorString(cudaError_t error); } 
#line 1174
extern "C" { extern cudaError_t __stdcall cudaGetDeviceCount(int * count); } 
#line 1410
extern "C" { extern cudaError_t __stdcall cudaGetDeviceProperties(cudaDeviceProp * prop, int device); } 
#line 1570
extern "C" { extern cudaError_t __stdcall cudaDeviceGetAttribute(int * value, cudaDeviceAttr attr, int device); } 
#line 1589
extern "C" { extern cudaError_t __stdcall cudaChooseDevice(int * device, const cudaDeviceProp * prop); } 
#line 1623
extern "C" { extern cudaError_t __stdcall cudaSetDevice(int device); } 
#line 1640
extern "C" { extern cudaError_t __stdcall cudaGetDevice(int * device); } 
#line 1669
extern "C" { extern cudaError_t __stdcall cudaSetValidDevices(int * device_arr, int len); } 
#line 1731
extern "C" { extern cudaError_t __stdcall cudaSetDeviceFlags(unsigned flags); } 
#line 1772
extern "C" { extern cudaError_t __stdcall cudaGetDeviceFlags(unsigned * flags); } 
#line 1809
extern "C" { extern cudaError_t __stdcall cudaStreamCreate(cudaStream_t * pStream); } 
#line 1838
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithFlags(cudaStream_t * pStream, unsigned flags); } 
#line 1881
extern "C" { extern cudaError_t __stdcall cudaStreamCreateWithPriority(cudaStream_t * pStream, unsigned flags, int priority); } 
#line 1905
extern "C" { extern cudaError_t __stdcall cudaStreamGetPriority(cudaStream_t hStream, int * priority); } 
#line 1926
extern "C" { extern cudaError_t __stdcall cudaStreamGetFlags(cudaStream_t hStream, unsigned * flags); } 
#line 1947
extern "C" { extern cudaError_t __stdcall cudaStreamDestroy(cudaStream_t stream); } 
#line 1979
extern "C" { extern cudaError_t __stdcall cudaStreamWaitEvent(cudaStream_t stream, cudaEvent_t event, unsigned flags); } 
#line 1993 "e:\\cudatoolkit\\include\\cuda_runtime_api.h"
extern "C" { typedef void (__stdcall *cudaStreamCallback_t)(cudaStream_t stream, cudaError_t status, void * userData); }
#line 2050
extern "C" { extern cudaError_t __stdcall cudaStreamAddCallback(cudaStream_t stream, cudaStreamCallback_t callback, void * userData, unsigned flags); } 
#line 2070
extern "C" { extern cudaError_t __stdcall cudaStreamSynchronize(cudaStream_t stream); } 
#line 2091
extern "C" { extern cudaError_t __stdcall cudaStreamQuery(cudaStream_t stream); } 
#line 2157
extern "C" { extern cudaError_t __stdcall cudaStreamAttachMemAsync(cudaStream_t stream, void * devPtr, size_t length, unsigned flags); } 
#line 2193
extern "C" { extern cudaError_t __stdcall cudaEventCreate(cudaEvent_t * event); } 
#line 2227
extern "C" { extern cudaError_t __stdcall cudaEventCreateWithFlags(cudaEvent_t * event, unsigned flags); } 
#line 2258
extern "C" { extern cudaError_t __stdcall cudaEventRecord(cudaEvent_t event, cudaStream_t stream = 0); } 
#line 2290
extern "C" { extern cudaError_t __stdcall cudaEventQuery(cudaEvent_t event); } 
#line 2322
extern "C" { extern cudaError_t __stdcall cudaEventSynchronize(cudaEvent_t event); } 
#line 2347
extern "C" { extern cudaError_t __stdcall cudaEventDestroy(cudaEvent_t event); } 
#line 2388
extern "C" { extern cudaError_t __stdcall cudaEventElapsedTime(float * ms, cudaEvent_t start, cudaEvent_t end); } 
#line 2447
extern "C" { extern cudaError_t __stdcall cudaLaunchKernel(const void * func, dim3 gridDim, dim3 blockDim, void ** args, size_t sharedMem, cudaStream_t stream); } 
#line 2497 "e:\\cudatoolkit\\include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaFuncSetCacheConfig(const void * func, cudaFuncCache cacheConfig); } 
#line 2551
extern "C" { extern cudaError_t __stdcall cudaFuncSetSharedMemConfig(const void * func, cudaSharedMemConfig config); } 
#line 2585
extern "C" { extern cudaError_t __stdcall cudaFuncGetAttributes(cudaFuncAttributes * attr, const void * func); } 
#line 2608
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForDevice(double * d); } 
#line 2631
extern "C" { extern cudaError_t __stdcall cudaSetDoubleForHost(double * d); } 
#line 2687
extern "C" { extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessor(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize); } 
#line 2731
extern "C" { extern cudaError_t __stdcall cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int * numBlocks, const void * func, int blockSize, size_t dynamicSMemSize, unsigned flags); } 
#line 2782 "e:\\cudatoolkit\\include\\cuda_runtime_api.h"
extern "C" { extern cudaError_t __stdcall cudaConfigureCall(dim3 gridDim, dim3 blockDim, size_t sharedMem = 0, cudaStream_t stream = 0); } 
#line 2811
extern "C" { extern cudaError_t __stdcall cudaSetupArgument(const void * arg, size_t size, size_t offset); } 
#line 2849
extern "C" { extern cudaError_t __stdcall cudaLaunch(const void * func); } 
#line 2938
extern "C" { extern cudaError_t __stdcall cudaMallocManaged(void ** devPtr, size_t size, unsigned flags); } 
#line 2964
extern "C" { extern cudaError_t __stdcall cudaMalloc(void ** devPtr, size_t size); } 
#line 2993
extern "C" { extern cudaError_t __stdcall cudaMallocHost(void ** ptr, size_t size); } 
#line 3032
extern "C" { extern cudaError_t __stdcall cudaMallocPitch(void ** devPtr, size_t * pitch, size_t width, size_t height); } 
#line 3074
extern "C" { extern cudaError_t __stdcall cudaMallocArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, size_t width, size_t height = 0, unsigned flags = 0); } 
#line 3101
extern "C" { extern cudaError_t __stdcall cudaFree(void * devPtr); } 
#line 3121
extern "C" { extern cudaError_t __stdcall cudaFreeHost(void * ptr); } 
#line 3143
extern "C" { extern cudaError_t __stdcall cudaFreeArray(cudaArray_t array); } 
#line 3165
extern "C" { extern cudaError_t __stdcall cudaFreeMipmappedArray(cudaMipmappedArray_t mipmappedArray); } 
#line 3224
extern "C" { extern cudaError_t __stdcall cudaHostAlloc(void ** pHost, size_t size, unsigned flags); } 
#line 3286
extern "C" { extern cudaError_t __stdcall cudaHostRegister(void * ptr, size_t size, unsigned flags); } 
#line 3305
extern "C" { extern cudaError_t __stdcall cudaHostUnregister(void * ptr); } 
#line 3332
extern "C" { extern cudaError_t __stdcall cudaHostGetDevicePointer(void ** pDevice, void * pHost, unsigned flags); } 
#line 3351
extern "C" { extern cudaError_t __stdcall cudaHostGetFlags(unsigned * pFlags, void * pHost); } 
#line 3386
extern "C" { extern cudaError_t __stdcall cudaMalloc3D(cudaPitchedPtr * pitchedDevPtr, cudaExtent extent); } 
#line 3521
extern "C" { extern cudaError_t __stdcall cudaMalloc3DArray(cudaArray_t * array, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned flags = 0); } 
#line 3642
extern "C" { extern cudaError_t __stdcall cudaMallocMipmappedArray(cudaMipmappedArray_t * mipmappedArray, const cudaChannelFormatDesc * desc, cudaExtent extent, unsigned numLevels, unsigned flags = 0); } 
#line 3668
extern "C" { extern cudaError_t __stdcall cudaGetMipmappedArrayLevel(cudaArray_t * levelArray, cudaMipmappedArray_const_t mipmappedArray, unsigned level); } 
#line 3765
extern "C" { extern cudaError_t __stdcall cudaMemcpy3D(const cudaMemcpy3DParms * p); } 
#line 3793
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DPeer(const cudaMemcpy3DPeerParms * p); } 
#line 3901
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DAsync(const cudaMemcpy3DParms * p, cudaStream_t stream = 0); } 
#line 3924
extern "C" { extern cudaError_t __stdcall cudaMemcpy3DPeerAsync(const cudaMemcpy3DPeerParms * p, cudaStream_t stream = 0); } 
#line 3943
extern "C" { extern cudaError_t __stdcall cudaMemGetInfo(size_t * free, size_t * total); } 
#line 3964
extern "C" { extern cudaError_t __stdcall cudaArrayGetInfo(cudaChannelFormatDesc * desc, cudaExtent * extent, unsigned * flags, cudaArray_t array); } 
#line 3999
extern "C" { extern cudaError_t __stdcall cudaMemcpy(void * dst, const void * src, size_t count, cudaMemcpyKind kind); } 
#line 4031
extern "C" { extern cudaError_t __stdcall cudaMemcpyPeer(void * dst, int dstDevice, const void * src, int srcDevice, size_t count); } 
#line 4065
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind); } 
#line 4099
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArray(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind); } 
#line 4134
extern "C" { extern cudaError_t __stdcall cudaMemcpyArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t count, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); } 
#line 4176
extern "C" { extern cudaError_t __stdcall cudaMemcpy2D(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); } 
#line 4218
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArray(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind); } 
#line 4260
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArray(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind); } 
#line 4300
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DArrayToArray(cudaArray_t dst, size_t wOffsetDst, size_t hOffsetDst, cudaArray_const_t src, size_t wOffsetSrc, size_t hOffsetSrc, size_t width, size_t height, cudaMemcpyKind kind = cudaMemcpyDeviceToDevice); } 
#line 4335
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbol(const void * symbol, const void * src, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyHostToDevice); } 
#line 4370
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbol(void * dst, const void * symbol, size_t count, size_t offset = 0, cudaMemcpyKind kind = cudaMemcpyDeviceToHost); } 
#line 4416
extern "C" { extern cudaError_t __stdcall cudaMemcpyAsync(void * dst, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4448
extern "C" { extern cudaError_t __stdcall cudaMemcpyPeerAsync(void * dst, int dstDevice, const void * src, int srcDevice, size_t count, cudaStream_t stream = 0); } 
#line 4490
extern "C" { extern cudaError_t __stdcall cudaMemcpyToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4532
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromArrayAsync(void * dst, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t count, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4587
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DAsync(void * dst, size_t dpitch, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4638
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DToArrayAsync(cudaArray_t dst, size_t wOffset, size_t hOffset, const void * src, size_t spitch, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4688
extern "C" { extern cudaError_t __stdcall cudaMemcpy2DFromArrayAsync(void * dst, size_t dpitch, cudaArray_const_t src, size_t wOffset, size_t hOffset, size_t width, size_t height, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4731
extern "C" { extern cudaError_t __stdcall cudaMemcpyToSymbolAsync(const void * symbol, const void * src, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4774
extern "C" { extern cudaError_t __stdcall cudaMemcpyFromSymbolAsync(void * dst, const void * symbol, size_t count, size_t offset, cudaMemcpyKind kind, cudaStream_t stream = 0); } 
#line 4800
extern "C" { extern cudaError_t __stdcall cudaMemset(void * devPtr, int value, size_t count); } 
#line 4830
extern "C" { extern cudaError_t __stdcall cudaMemset2D(void * devPtr, size_t pitch, int value, size_t width, size_t height); } 
#line 4873
extern "C" { extern cudaError_t __stdcall cudaMemset3D(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent); } 
#line 4905
extern "C" { extern cudaError_t __stdcall cudaMemsetAsync(void * devPtr, int value, size_t count, cudaStream_t stream = 0); } 
#line 4942
extern "C" { extern cudaError_t __stdcall cudaMemset2DAsync(void * devPtr, size_t pitch, int value, size_t width, size_t height, cudaStream_t stream = 0); } 
#line 4992
extern "C" { extern cudaError_t __stdcall cudaMemset3DAsync(cudaPitchedPtr pitchedDevPtr, int value, cudaExtent extent, cudaStream_t stream = 0); } 
#line 5015
extern "C" { extern cudaError_t __stdcall cudaGetSymbolAddress(void ** devPtr, const void * symbol); } 
#line 5037
extern "C" { extern cudaError_t __stdcall cudaGetSymbolSize(size_t * size, const void * symbol); } 
#line 5190
extern "C" { extern cudaError_t __stdcall cudaPointerGetAttributes(cudaPointerAttributes * attributes, const void * ptr); } 
#line 5228
extern "C" { extern cudaError_t __stdcall cudaDeviceCanAccessPeer(int * canAccessPeer, int device, int peerDevice); } 
#line 5267
extern "C" { extern cudaError_t __stdcall cudaDeviceEnablePeerAccess(int peerDevice, unsigned flags); } 
#line 5286
extern "C" { extern cudaError_t __stdcall cudaDeviceDisablePeerAccess(int peerDevice); } 
#line 5344
extern "C" { extern cudaError_t __stdcall cudaGraphicsUnregisterResource(cudaGraphicsResource_t resource); } 
#line 5376
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceSetMapFlags(cudaGraphicsResource_t resource, unsigned flags); } 
#line 5412
extern "C" { extern cudaError_t __stdcall cudaGraphicsMapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); } 
#line 5444
extern "C" { extern cudaError_t __stdcall cudaGraphicsUnmapResources(int count, cudaGraphicsResource_t * resources, cudaStream_t stream = 0); } 
#line 5473
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceGetMappedPointer(void ** devPtr, size_t * size, cudaGraphicsResource_t resource); } 
#line 5507
extern "C" { extern cudaError_t __stdcall cudaGraphicsSubResourceGetMappedArray(cudaArray_t * array, cudaGraphicsResource_t resource, unsigned arrayIndex, unsigned mipLevel); } 
#line 5532
extern "C" { extern cudaError_t __stdcall cudaGraphicsResourceGetMappedMipmappedArray(cudaMipmappedArray_t * mipmappedArray, cudaGraphicsResource_t resource); } 
#line 5572
extern "C" { extern cudaError_t __stdcall cudaGetChannelDesc(cudaChannelFormatDesc * desc, cudaArray_const_t array); } 
#line 5607
extern "C" { extern cudaChannelFormatDesc __stdcall cudaCreateChannelDesc(int x, int y, int z, int w, cudaChannelFormatKind f); } 
#line 5654
extern "C" { extern cudaError_t __stdcall cudaBindTexture(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t size = 4294967295U); } 
#line 5705
extern "C" { extern cudaError_t __stdcall cudaBindTexture2D(size_t * offset, const textureReference * texref, const void * devPtr, const cudaChannelFormatDesc * desc, size_t width, size_t height, size_t pitch); } 
#line 5733
extern "C" { extern cudaError_t __stdcall cudaBindTextureToArray(const textureReference * texref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); } 
#line 5761
extern "C" { extern cudaError_t __stdcall cudaBindTextureToMipmappedArray(const textureReference * texref, cudaMipmappedArray_const_t mipmappedArray, const cudaChannelFormatDesc * desc); } 
#line 5782
extern "C" { extern cudaError_t __stdcall cudaUnbindTexture(const textureReference * texref); } 
#line 5807
extern "C" { extern cudaError_t __stdcall cudaGetTextureAlignmentOffset(size_t * offset, const textureReference * texref); } 
#line 5832
extern "C" { extern cudaError_t __stdcall cudaGetTextureReference(const textureReference ** texref, const void * symbol); } 
#line 5872
extern "C" { extern cudaError_t __stdcall cudaBindSurfaceToArray(const surfaceReference * surfref, cudaArray_const_t array, const cudaChannelFormatDesc * desc); } 
#line 5891
extern "C" { extern cudaError_t __stdcall cudaGetSurfaceReference(const surfaceReference ** surfref, const void * symbol); } 
#line 6108
extern "C" { extern cudaError_t __stdcall cudaCreateTextureObject(cudaTextureObject_t * pTexObject, const cudaResourceDesc * pResDesc, const cudaTextureDesc * pTexDesc, const cudaResourceViewDesc * pResViewDesc); } 
#line 6123
extern "C" { extern cudaError_t __stdcall cudaDestroyTextureObject(cudaTextureObject_t texObject); } 
#line 6139
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectResourceDesc(cudaResourceDesc * pResDesc, cudaTextureObject_t texObject); } 
#line 6155
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectTextureDesc(cudaTextureDesc * pTexDesc, cudaTextureObject_t texObject); } 
#line 6172
extern "C" { extern cudaError_t __stdcall cudaGetTextureObjectResourceViewDesc(cudaResourceViewDesc * pResViewDesc, cudaTextureObject_t texObject); } 
#line 6211
extern "C" { extern cudaError_t __stdcall cudaCreateSurfaceObject(cudaSurfaceObject_t * pSurfObject, const cudaResourceDesc * pResDesc); } 
#line 6226
extern "C" { extern cudaError_t __stdcall cudaDestroySurfaceObject(cudaSurfaceObject_t surfObject); } 
#line 6241
extern "C" { extern cudaError_t __stdcall cudaGetSurfaceObjectResourceDesc(cudaResourceDesc * pResDesc, cudaSurfaceObject_t surfObject); } 
#line 6268
extern "C" { extern cudaError_t __stdcall cudaDriverGetVersion(int * driverVersion); } 
#line 6285
extern "C" { extern cudaError_t __stdcall cudaRuntimeGetVersion(int * runtimeVersion); } 
#line 6290
extern "C" { extern cudaError_t __stdcall cudaGetExportTable(const void ** ppExportTable, const cudaUUID_t * pExportTableId); } 
#line 107 "e:\\cudatoolkit\\include\\channel_descriptor.h"
template< class T> __inline ::cudaChannelFormatDesc cudaCreateChannelDesc() 
#line 108
{ 
#line 109
return cudaCreateChannelDesc(0, 0, 0, 0, cudaChannelFormatKindNone); 
#line 110
} 
#line 112
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf() 
#line 113
{ 
#line 114
int e = (((int)sizeof(unsigned short)) * 8); 
#line 116
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 117
} 
#line 119
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf1() 
#line 120
{ 
#line 121
int e = (((int)sizeof(unsigned short)) * 8); 
#line 123
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 124
} 
#line 126
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf2() 
#line 127
{ 
#line 128
int e = (((int)sizeof(unsigned short)) * 8); 
#line 130
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 131
} 
#line 133
static __inline cudaChannelFormatDesc cudaCreateChannelDescHalf4() 
#line 134
{ 
#line 135
int e = (((int)sizeof(unsigned short)) * 8); 
#line 137
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 138
} 
#line 140
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char> () 
#line 141
{ 
#line 142
int e = (((int)sizeof(char)) * 8); 
#line 147 "e:\\cudatoolkit\\include\\channel_descriptor.h"
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 149 "e:\\cudatoolkit\\include\\channel_descriptor.h"
} 
#line 151
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< signed char> () 
#line 152
{ 
#line 153
int e = (((int)sizeof(signed char)) * 8); 
#line 155
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 156
} 
#line 158
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned char> () 
#line 159
{ 
#line 160
int e = (((int)sizeof(unsigned char)) * 8); 
#line 162
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 163
} 
#line 165
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char1> () 
#line 166
{ 
#line 167
int e = (((int)sizeof(signed char)) * 8); 
#line 169
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 170
} 
#line 172
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar1> () 
#line 173
{ 
#line 174
int e = (((int)sizeof(unsigned char)) * 8); 
#line 176
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 177
} 
#line 179
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char2> () 
#line 180
{ 
#line 181
int e = (((int)sizeof(signed char)) * 8); 
#line 183
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 184
} 
#line 186
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar2> () 
#line 187
{ 
#line 188
int e = (((int)sizeof(unsigned char)) * 8); 
#line 190
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 191
} 
#line 193
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< char4> () 
#line 194
{ 
#line 195
int e = (((int)sizeof(signed char)) * 8); 
#line 197
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 198
} 
#line 200
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uchar4> () 
#line 201
{ 
#line 202
int e = (((int)sizeof(unsigned char)) * 8); 
#line 204
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 205
} 
#line 207
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short> () 
#line 208
{ 
#line 209
int e = (((int)sizeof(short)) * 8); 
#line 211
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 212
} 
#line 214
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned short> () 
#line 215
{ 
#line 216
int e = (((int)sizeof(unsigned short)) * 8); 
#line 218
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 219
} 
#line 221
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short1> () 
#line 222
{ 
#line 223
int e = (((int)sizeof(short)) * 8); 
#line 225
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 226
} 
#line 228
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort1> () 
#line 229
{ 
#line 230
int e = (((int)sizeof(unsigned short)) * 8); 
#line 232
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 233
} 
#line 235
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short2> () 
#line 236
{ 
#line 237
int e = (((int)sizeof(short)) * 8); 
#line 239
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 240
} 
#line 242
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort2> () 
#line 243
{ 
#line 244
int e = (((int)sizeof(unsigned short)) * 8); 
#line 246
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 247
} 
#line 249
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< short4> () 
#line 250
{ 
#line 251
int e = (((int)sizeof(short)) * 8); 
#line 253
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 254
} 
#line 256
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ushort4> () 
#line 257
{ 
#line 258
int e = (((int)sizeof(unsigned short)) * 8); 
#line 260
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 261
} 
#line 263
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int> () 
#line 264
{ 
#line 265
int e = (((int)sizeof(int)) * 8); 
#line 267
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 268
} 
#line 270
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned> () 
#line 271
{ 
#line 272
int e = (((int)sizeof(unsigned)) * 8); 
#line 274
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 275
} 
#line 277
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int1> () 
#line 278
{ 
#line 279
int e = (((int)sizeof(int)) * 8); 
#line 281
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 282
} 
#line 284
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint1> () 
#line 285
{ 
#line 286
int e = (((int)sizeof(unsigned)) * 8); 
#line 288
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 289
} 
#line 291
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int2> () 
#line 292
{ 
#line 293
int e = (((int)sizeof(int)) * 8); 
#line 295
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 296
} 
#line 298
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint2> () 
#line 299
{ 
#line 300
int e = (((int)sizeof(unsigned)) * 8); 
#line 302
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 303
} 
#line 305
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< int4> () 
#line 306
{ 
#line 307
int e = (((int)sizeof(int)) * 8); 
#line 309
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 310
} 
#line 312
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< uint4> () 
#line 313
{ 
#line 314
int e = (((int)sizeof(unsigned)) * 8); 
#line 316
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 317
} 
#line 321
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long> () 
#line 322
{ 
#line 323
int e = (((int)sizeof(long)) * 8); 
#line 325
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 326
} 
#line 328
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< unsigned long> () 
#line 329
{ 
#line 330
int e = (((int)sizeof(unsigned long)) * 8); 
#line 332
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 333
} 
#line 335
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long1> () 
#line 336
{ 
#line 337
int e = (((int)sizeof(long)) * 8); 
#line 339
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindSigned); 
#line 340
} 
#line 342
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong1> () 
#line 343
{ 
#line 344
int e = (((int)sizeof(unsigned long)) * 8); 
#line 346
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindUnsigned); 
#line 347
} 
#line 349
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long2> () 
#line 350
{ 
#line 351
int e = (((int)sizeof(long)) * 8); 
#line 353
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindSigned); 
#line 354
} 
#line 356
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong2> () 
#line 357
{ 
#line 358
int e = (((int)sizeof(unsigned long)) * 8); 
#line 360
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindUnsigned); 
#line 361
} 
#line 363
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< long4> () 
#line 364
{ 
#line 365
int e = (((int)sizeof(long)) * 8); 
#line 367
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindSigned); 
#line 368
} 
#line 370
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< ulong4> () 
#line 371
{ 
#line 372
int e = (((int)sizeof(unsigned long)) * 8); 
#line 374
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindUnsigned); 
#line 375
} 
#line 379 "e:\\cudatoolkit\\include\\channel_descriptor.h"
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float> () 
#line 380
{ 
#line 381
int e = (((int)sizeof(float)) * 8); 
#line 383
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 384
} 
#line 386
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float1> () 
#line 387
{ 
#line 388
int e = (((int)sizeof(float)) * 8); 
#line 390
return cudaCreateChannelDesc(e, 0, 0, 0, cudaChannelFormatKindFloat); 
#line 391
} 
#line 393
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float2> () 
#line 394
{ 
#line 395
int e = (((int)sizeof(float)) * 8); 
#line 397
return cudaCreateChannelDesc(e, e, 0, 0, cudaChannelFormatKindFloat); 
#line 398
} 
#line 400
template<> __inline cudaChannelFormatDesc cudaCreateChannelDesc< float4> () 
#line 401
{ 
#line 402
int e = (((int)sizeof(float)) * 8); 
#line 404
return cudaCreateChannelDesc(e, e, e, e, cudaChannelFormatKindFloat); 
#line 405
} 
#line 79 "e:\\cudatoolkit\\include\\driver_functions.h"
static __inline cudaPitchedPtr make_cudaPitchedPtr(void *d, size_t p, size_t xsz, size_t ysz) 
#line 80
{ 
#line 81
cudaPitchedPtr s; 
#line 83
(s.ptr) = d; 
#line 84
(s.pitch) = p; 
#line 85
(s.xsize) = xsz; 
#line 86
(s.ysize) = ysz; 
#line 88
return s; 
#line 89
} 
#line 106
static __inline cudaPos make_cudaPos(size_t x, size_t y, size_t z) 
#line 107
{ 
#line 108
cudaPos p; 
#line 110
(p.x) = x; 
#line 111
(p.y) = y; 
#line 112
(p.z) = z; 
#line 114
return p; 
#line 115
} 
#line 132
static __inline cudaExtent make_cudaExtent(size_t w, size_t h, size_t d) 
#line 133
{ 
#line 134
cudaExtent e; 
#line 136
(e.width) = w; 
#line 137
(e.height) = h; 
#line 138
(e.depth) = d; 
#line 140
return e; 
#line 141
} 
#line 75 "e:\\cudatoolkit\\include\\vector_functions.h"
static __inline char1 make_char1(signed char x); 
#line 77
static __inline uchar1 make_uchar1(unsigned char x); 
#line 79
static __inline char2 make_char2(signed char x, signed char y); 
#line 81
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y); 
#line 83
static __inline char3 make_char3(signed char x, signed char y, signed char z); 
#line 85
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z); 
#line 87
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w); 
#line 89
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w); 
#line 91
static __inline short1 make_short1(short x); 
#line 93
static __inline ushort1 make_ushort1(unsigned short x); 
#line 95
static __inline short2 make_short2(short x, short y); 
#line 97
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y); 
#line 99
static __inline short3 make_short3(short x, short y, short z); 
#line 101
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z); 
#line 103
static __inline short4 make_short4(short x, short y, short z, short w); 
#line 105
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w); 
#line 107
static __inline int1 make_int1(int x); 
#line 109
static __inline uint1 make_uint1(unsigned x); 
#line 111
static __inline int2 make_int2(int x, int y); 
#line 113
static __inline uint2 make_uint2(unsigned x, unsigned y); 
#line 115
static __inline int3 make_int3(int x, int y, int z); 
#line 117
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z); 
#line 119
static __inline int4 make_int4(int x, int y, int z, int w); 
#line 121
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w); 
#line 123
static __inline long1 make_long1(long x); 
#line 125
static __inline ulong1 make_ulong1(unsigned long x); 
#line 127
static __inline long2 make_long2(long x, long y); 
#line 129
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y); 
#line 131
static __inline long3 make_long3(long x, long y, long z); 
#line 133
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z); 
#line 135
static __inline long4 make_long4(long x, long y, long z, long w); 
#line 137
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w); 
#line 139
static __inline float1 make_float1(float x); 
#line 141
static __inline float2 make_float2(float x, float y); 
#line 143
static __inline float3 make_float3(float x, float y, float z); 
#line 145
static __inline float4 make_float4(float x, float y, float z, float w); 
#line 147
static __inline longlong1 make_longlong1(__int64 x); 
#line 149
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x); 
#line 151
static __inline longlong2 make_longlong2(__int64 x, __int64 y); 
#line 153
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y); 
#line 155
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z); 
#line 157
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z); 
#line 159
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w); 
#line 161
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w); 
#line 163
static __inline double1 make_double1(double x); 
#line 165
static __inline double2 make_double2(double x, double y); 
#line 167
static __inline double3 make_double3(double x, double y, double z); 
#line 169
static __inline double4 make_double4(double x, double y, double z, double w); 
#line 75 "e:\\cudatoolkit\\include\\vector_functions.hpp"
static __inline char1 make_char1(signed char x) 
#line 76
{ 
#line 77
char1 t; (t.x) = x; return t; 
#line 78
} 
#line 80
static __inline uchar1 make_uchar1(unsigned char x) 
#line 81
{ 
#line 82
uchar1 t; (t.x) = x; return t; 
#line 83
} 
#line 85
static __inline char2 make_char2(signed char x, signed char y) 
#line 86
{ 
#line 87
char2 t; (t.x) = x; (t.y) = y; return t; 
#line 88
} 
#line 90
static __inline uchar2 make_uchar2(unsigned char x, unsigned char y) 
#line 91
{ 
#line 92
uchar2 t; (t.x) = x; (t.y) = y; return t; 
#line 93
} 
#line 95
static __inline char3 make_char3(signed char x, signed char y, signed char z) 
#line 96
{ 
#line 97
char3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 98
} 
#line 100
static __inline uchar3 make_uchar3(unsigned char x, unsigned char y, unsigned char z) 
#line 101
{ 
#line 102
uchar3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 103
} 
#line 105
static __inline char4 make_char4(signed char x, signed char y, signed char z, signed char w) 
#line 106
{ 
#line 107
char4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 108
} 
#line 110
static __inline uchar4 make_uchar4(unsigned char x, unsigned char y, unsigned char z, unsigned char w) 
#line 111
{ 
#line 112
uchar4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 113
} 
#line 115
static __inline short1 make_short1(short x) 
#line 116
{ 
#line 117
short1 t; (t.x) = x; return t; 
#line 118
} 
#line 120
static __inline ushort1 make_ushort1(unsigned short x) 
#line 121
{ 
#line 122
ushort1 t; (t.x) = x; return t; 
#line 123
} 
#line 125
static __inline short2 make_short2(short x, short y) 
#line 126
{ 
#line 127
short2 t; (t.x) = x; (t.y) = y; return t; 
#line 128
} 
#line 130
static __inline ushort2 make_ushort2(unsigned short x, unsigned short y) 
#line 131
{ 
#line 132
ushort2 t; (t.x) = x; (t.y) = y; return t; 
#line 133
} 
#line 135
static __inline short3 make_short3(short x, short y, short z) 
#line 136
{ 
#line 137
short3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 138
} 
#line 140
static __inline ushort3 make_ushort3(unsigned short x, unsigned short y, unsigned short z) 
#line 141
{ 
#line 142
ushort3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 143
} 
#line 145
static __inline short4 make_short4(short x, short y, short z, short w) 
#line 146
{ 
#line 147
short4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 148
} 
#line 150
static __inline ushort4 make_ushort4(unsigned short x, unsigned short y, unsigned short z, unsigned short w) 
#line 151
{ 
#line 152
ushort4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 153
} 
#line 155
static __inline int1 make_int1(int x) 
#line 156
{ 
#line 157
int1 t; (t.x) = x; return t; 
#line 158
} 
#line 160
static __inline uint1 make_uint1(unsigned x) 
#line 161
{ 
#line 162
uint1 t; (t.x) = x; return t; 
#line 163
} 
#line 165
static __inline int2 make_int2(int x, int y) 
#line 166
{ 
#line 167
int2 t; (t.x) = x; (t.y) = y; return t; 
#line 168
} 
#line 170
static __inline uint2 make_uint2(unsigned x, unsigned y) 
#line 171
{ 
#line 172
uint2 t; (t.x) = x; (t.y) = y; return t; 
#line 173
} 
#line 175
static __inline int3 make_int3(int x, int y, int z) 
#line 176
{ 
#line 177
int3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 178
} 
#line 180
static __inline uint3 make_uint3(unsigned x, unsigned y, unsigned z) 
#line 181
{ 
#line 182
uint3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 183
} 
#line 185
static __inline int4 make_int4(int x, int y, int z, int w) 
#line 186
{ 
#line 187
int4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 188
} 
#line 190
static __inline uint4 make_uint4(unsigned x, unsigned y, unsigned z, unsigned w) 
#line 191
{ 
#line 192
uint4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 193
} 
#line 195
static __inline long1 make_long1(long x) 
#line 196
{ 
#line 197
long1 t; (t.x) = x; return t; 
#line 198
} 
#line 200
static __inline ulong1 make_ulong1(unsigned long x) 
#line 201
{ 
#line 202
ulong1 t; (t.x) = x; return t; 
#line 203
} 
#line 205
static __inline long2 make_long2(long x, long y) 
#line 206
{ 
#line 207
long2 t; (t.x) = x; (t.y) = y; return t; 
#line 208
} 
#line 210
static __inline ulong2 make_ulong2(unsigned long x, unsigned long y) 
#line 211
{ 
#line 212
ulong2 t; (t.x) = x; (t.y) = y; return t; 
#line 213
} 
#line 215
static __inline long3 make_long3(long x, long y, long z) 
#line 216
{ 
#line 217
long3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 218
} 
#line 220
static __inline ulong3 make_ulong3(unsigned long x, unsigned long y, unsigned long z) 
#line 221
{ 
#line 222
ulong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 223
} 
#line 225
static __inline long4 make_long4(long x, long y, long z, long w) 
#line 226
{ 
#line 227
long4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 228
} 
#line 230
static __inline ulong4 make_ulong4(unsigned long x, unsigned long y, unsigned long z, unsigned long w) 
#line 231
{ 
#line 232
ulong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 233
} 
#line 235
static __inline float1 make_float1(float x) 
#line 236
{ 
#line 237
float1 t; (t.x) = x; return t; 
#line 238
} 
#line 240
static __inline float2 make_float2(float x, float y) 
#line 241
{ 
#line 242
float2 t; (t.x) = x; (t.y) = y; return t; 
#line 243
} 
#line 245
static __inline float3 make_float3(float x, float y, float z) 
#line 246
{ 
#line 247
float3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 248
} 
#line 250
static __inline float4 make_float4(float x, float y, float z, float w) 
#line 251
{ 
#line 252
float4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 253
} 
#line 255
static __inline longlong1 make_longlong1(__int64 x) 
#line 256
{ 
#line 257
longlong1 t; (t.x) = x; return t; 
#line 258
} 
#line 260
static __inline ulonglong1 make_ulonglong1(unsigned __int64 x) 
#line 261
{ 
#line 262
ulonglong1 t; (t.x) = x; return t; 
#line 263
} 
#line 265
static __inline longlong2 make_longlong2(__int64 x, __int64 y) 
#line 266
{ 
#line 267
longlong2 t; (t.x) = x; (t.y) = y; return t; 
#line 268
} 
#line 270
static __inline ulonglong2 make_ulonglong2(unsigned __int64 x, unsigned __int64 y) 
#line 271
{ 
#line 272
ulonglong2 t; (t.x) = x; (t.y) = y; return t; 
#line 273
} 
#line 275
static __inline longlong3 make_longlong3(__int64 x, __int64 y, __int64 z) 
#line 276
{ 
#line 277
longlong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 278
} 
#line 280
static __inline ulonglong3 make_ulonglong3(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z) 
#line 281
{ 
#line 282
ulonglong3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 283
} 
#line 285
static __inline longlong4 make_longlong4(__int64 x, __int64 y, __int64 z, __int64 w) 
#line 286
{ 
#line 287
longlong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 288
} 
#line 290
static __inline ulonglong4 make_ulonglong4(unsigned __int64 x, unsigned __int64 y, unsigned __int64 z, unsigned __int64 w) 
#line 291
{ 
#line 292
ulonglong4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 293
} 
#line 295
static __inline double1 make_double1(double x) 
#line 296
{ 
#line 297
double1 t; (t.x) = x; return t; 
#line 298
} 
#line 300
static __inline double2 make_double2(double x, double y) 
#line 301
{ 
#line 302
double2 t; (t.x) = x; (t.y) = y; return t; 
#line 303
} 
#line 305
static __inline double3 make_double3(double x, double y, double z) 
#line 306
{ 
#line 307
double3 t; (t.x) = x; (t.y) = y; (t.z) = z; return t; 
#line 308
} 
#line 310
static __inline double4 make_double4(double x, double y, double z, double w) 
#line 311
{ 
#line 312
double4 t; (t.x) = x; (t.y) = y; (t.z) = z; (t.w) = w; return t; 
#line 313
} 
#line 47 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl _memccpy(void * _Dst, const void * _Src, int _Val, size_t _MaxCount); } 
#line 48
extern "C" { __declspec(dllimport) const void *__cdecl memchr(const void * _Buf, int _Val, size_t _MaxCount); } 
#line 49
extern "C" { __declspec(dllimport) int __cdecl _memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); } 
#line 50
extern "C" { __declspec(dllimport) int __cdecl _memicmp_l(const void * _Buf1, const void * _Buf2, size_t _Size, _locale_t _Locale); } 
#line 51
extern "C" { int __cdecl memcmp(const void * _Buf1, const void * _Buf2, size_t _Size); } 
#line 55
extern "C" { void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); } 
#line 57
extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
#line 94 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { void *__cdecl memset(void * _Dst, int _Val, size_t _Size); } 
#line 98
extern "C" { __declspec(dllimport) void *__cdecl memccpy(void * _Dst, const void * _Src, int _Val, size_t _Size); } 
#line 99
extern "C" { __declspec(dllimport) int __cdecl memicmp(const void * _Buf1, const void * _Buf2, size_t _Size); } 
#line 105 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _strset_s(char * _Dst, size_t _DstSize, int _Value); } 
#line 106
template < size_t _Size > inline errno_t __cdecl _strset_s ( char ( & _Dest ) [ _Size ], int _Value ) throw ( ) { return _strset_s ( _Dest, _Size, _Value ); }
#line 107
extern "C" { char *__cdecl _strset(char * _Dest, int _Value); } 
#line 109
extern "C" { __declspec(dllimport) errno_t __cdecl strcpy_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src); } 
#line 111 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strcpy_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcpy_s ( _Dest, _Size, _Source ); }
#line 112
extern "C" { char *__cdecl strcpy(char * _Dest, const char * _Source); } 
#line 114
extern "C" { __declspec(dllimport) errno_t __cdecl strcat_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src); } 
#line 116 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strcat_s ( char ( & _Dest ) [ _Size ], const char * _Source ) throw ( ) { return strcat_s ( _Dest, _Size, _Source ); }
#line 118
extern "C" { char *__cdecl strcat(char * _Dest, const char * _Source); } 
#line 120 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { int __cdecl strcmp(const char * _Str1, const char * _Str2); } 
#line 121
extern "C" { size_t __cdecl strlen(const char * _Str); } 
#line 125
extern "C" { 
#line 122
__declspec(dllimport) size_t __cdecl 
#line 125
strnlen(const char * _Str, size_t _MaxCount); } 
#line 130
extern "C" { static __inline size_t __cdecl strnlen_s(const char *_Str, size_t _MaxCount) 
#line 131
{ 
#line 132
return (_Str == (0)) ? 0 : strnlen(_Str, _MaxCount); 
#line 133
} } 
#line 136 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl memmove_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
#line 139 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); } 
#line 146 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) char *__cdecl _strdup(const char * _Src); } 
#line 152 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) const char *__cdecl strchr(const char * _Str, int _Val); } 
#line 153
extern "C" { __declspec(dllimport) int __cdecl _stricmp(const char * _Str1, const char * _Str2); } 
#line 154
extern "C" { __declspec(dllimport) int __cdecl _strcmpi(const char * _Str1, const char * _Str2); } 
#line 155
extern "C" { __declspec(dllimport) int __cdecl _stricmp_l(const char * _Str1, const char * _Str2, _locale_t _Locale); } 
#line 156
extern "C" { __declspec(dllimport) int __cdecl strcoll(const char * _Str1, const char * _Str2); } 
#line 157
extern "C" { __declspec(dllimport) int __cdecl _strcoll_l(const char * _Str1, const char * _Str2, _locale_t _Locale); } 
#line 158
extern "C" { __declspec(dllimport) int __cdecl _stricoll(const char * _Str1, const char * _Str2); } 
#line 159
extern "C" { __declspec(dllimport) int __cdecl _stricoll_l(const char * _Str1, const char * _Str2, _locale_t _Locale); } 
#line 160
extern "C" { __declspec(dllimport) int __cdecl _strncoll(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
#line 161
extern "C" { __declspec(dllimport) int __cdecl _strncoll_l(const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 162
extern "C" { __declspec(dllimport) int __cdecl _strnicoll(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
#line 163
extern "C" { __declspec(dllimport) int __cdecl _strnicoll_l(const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 164
extern "C" { __declspec(dllimport) size_t __cdecl strcspn(const char * _Str, const char * _Control); } 
#line 165
extern "C" { __declspec(dllimport) char *__cdecl _strerror(const char * _ErrMsg); } 
#line 166
extern "C" { __declspec(dllimport) errno_t __cdecl _strerror_s(char * _Buf, size_t _SizeInBytes, const char * _ErrMsg); } 
#line 167
template < size_t _Size > inline errno_t __cdecl _strerror_s ( char ( & _Buffer ) [ _Size ], const char * _ErrorMessage ) throw ( ) { return _strerror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 168
extern "C" { __declspec(dllimport) char *__cdecl strerror(int); } 
#line 170
extern "C" { __declspec(dllimport) errno_t __cdecl strerror_s(char * _Buf, size_t _SizeInBytes, int _ErrNum); } 
#line 172 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strerror_s ( char ( & _Buffer ) [ _Size ], int _ErrorMessage ) throw ( ) { return strerror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 173
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s(char * _Str, size_t _Size); } 
#line 174
template < size_t _Size > inline errno_t __cdecl _strlwr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strlwr_s ( _String, _Size ); }
#line 175
extern "C" { __declspec(dllimport) char *__cdecl _strlwr(char * _String); } 
#line 176
extern "C" { __declspec(dllimport) errno_t __cdecl _strlwr_s_l(char * _Str, size_t _Size, _locale_t _Locale); } 
#line 177
template < size_t _Size > inline errno_t __cdecl _strlwr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strlwr_s_l ( _String, _Size, _Locale ); }
#line 178
extern "C" { __declspec(dllimport) char *__cdecl _strlwr_l(char * _String, _locale_t _Locale); } 
#line 180
extern "C" { __declspec(dllimport) errno_t __cdecl strncat_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount); } 
#line 182 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strncat_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
#line 186
extern "C" { __declspec(dllimport) char *__cdecl strncat(char * _Dest, const char * _Source, size_t _Count); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl strncmp(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
#line 189
extern "C" { __declspec(dllimport) int __cdecl _strnicmp(const char * _Str1, const char * _Str2, size_t _MaxCount); } 
#line 190
extern "C" { __declspec(dllimport) int __cdecl _strnicmp_l(const char * _Str1, const char * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 192
extern "C" { __declspec(dllimport) errno_t __cdecl strncpy_s(char * _Dst, rsize_t _SizeInBytes, const char * _Src, rsize_t _MaxCount); } 
#line 194 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl strncpy_s ( char ( & _Dest ) [ _Size ], const char * _Source, size_t _Count ) throw ( ) { return strncpy_s ( _Dest, _Size, _Source, _Count ); }
#line 195
extern "C" { __declspec(dllimport) char *__cdecl strncpy(char * _Dest, const char * _Source, size_t _Count); } 
#line 196
extern "C" { __declspec(dllimport) errno_t __cdecl _strnset_s(char * _Str, size_t _SizeInBytes, int _Val, size_t _MaxCount); } 
#line 197
template < size_t _Size > inline errno_t __cdecl _strnset_s ( char ( & _Dest ) [ _Size ], int _Val, size_t _Count ) throw ( ) { return _strnset_s ( _Dest, _Size, _Val, _Count ); }
#line 198
extern "C" { __declspec(dllimport) char *__cdecl _strnset(char * _Dest, int _Val, size_t _Count); } 
#line 199
extern "C" { __declspec(dllimport) const char *__cdecl strpbrk(const char * _Str, const char * _Control); } 
#line 200
extern "C" { __declspec(dllimport) const char *__cdecl strrchr(const char * _Str, int _Ch); } 
#line 201
extern "C" { __declspec(dllimport) char *__cdecl _strrev(char * _Str); } 
#line 202
extern "C" { __declspec(dllimport) size_t __cdecl strspn(const char * _Str, const char * _Control); } 
#line 203
extern "C" { __declspec(dllimport) const char *__cdecl strstr(const char * _Str, const char * _SubStr); } 
#line 204
extern "C" { __declspec(dllimport) char *__cdecl strtok(char * _Str, const char * _Delim); } 
#line 206
extern "C" { __declspec(dllimport) char *__cdecl strtok_s(char * _Str, const char * _Delim, char ** _Context); } 
#line 208 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s(char * _Str, size_t _Size); } 
#line 209
template < size_t _Size > inline errno_t __cdecl _strupr_s ( char ( & _String ) [ _Size ] ) throw ( ) { return _strupr_s ( _String, _Size ); }
#line 210
extern "C" { __declspec(dllimport) char *__cdecl _strupr(char * _String); } 
#line 211
extern "C" { __declspec(dllimport) errno_t __cdecl _strupr_s_l(char * _Str, size_t _Size, _locale_t _Locale); } 
#line 212
template < size_t _Size > inline errno_t __cdecl _strupr_s_l ( char ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _strupr_s_l ( _String, _Size, _Locale ); }
#line 213
extern "C" { __declspec(dllimport) char *__cdecl _strupr_l(char * _String, _locale_t _Locale); } 
#line 214
extern "C" { __declspec(dllimport) size_t __cdecl strxfrm(char * _Dst, const char * _Src, size_t _MaxCount); } 
#line 215
extern "C" { __declspec(dllimport) size_t __cdecl _strxfrm_l(char * _Dst, const char * _Src, size_t _MaxCount, _locale_t _Locale); } 
#line 221
inline char *__cdecl strchr(char *_Str, int _Ch) 
#line 222
{ return (char *)strchr((const char *)_Str, _Ch); } 
#line 223
inline char *__cdecl strpbrk(char *_Str, const char *_Control) 
#line 224
{ return (char *)strpbrk((const char *)_Str, _Control); } 
#line 225
inline char *__cdecl strrchr(char *_Str, int _Ch) 
#line 226
{ return (char *)strrchr((const char *)_Str, _Ch); } 
#line 227
inline char *__cdecl strstr(char *_Str, const char *_SubStr) 
#line 228
{ return (char *)strstr((const char *)_Str, _SubStr); } 
#line 232 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
inline void *__cdecl memchr(void *_Pv, int _C, size_t _N) 
#line 233
{ return (void *)memchr((const void *)_Pv, _C, _N); } 
#line 245 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) char *__cdecl strdup(const char * _Src); } 
#line 252 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) int __cdecl strcmpi(const char * _Str1, const char * _Str2); } 
#line 253
extern "C" { __declspec(dllimport) int __cdecl stricmp(const char * _Str1, const char * _Str2); } 
#line 254
extern "C" { __declspec(dllimport) char *__cdecl strlwr(char * _Str); } 
#line 255
extern "C" { __declspec(dllimport) int __cdecl strnicmp(const char * _Str1, const char * _Str, size_t _MaxCount); } 
#line 256
extern "C" { __declspec(dllimport) char *__cdecl strnset(char * _Str, int _Val, size_t _MaxCount); } 
#line 257
extern "C" { __declspec(dllimport) char *__cdecl strrev(char * _Str); } 
#line 258
extern "C" { char *__cdecl strset(char * _Str, int _Val); } 
#line 259
extern "C" { __declspec(dllimport) char *__cdecl strupr(char * _Str); } 
#line 273 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsdup(const __wchar_t * _Str); } 
#line 280 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl wcscat_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src); } 
#line 282 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscat_s ( _Dest, _Size, _Source ); }
#line 284
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscat(__wchar_t * _Dest, const __wchar_t * _Source); } 
#line 288 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcschr(const __wchar_t * _Str, __wchar_t _Ch); } 
#line 289
extern "C" { __declspec(dllimport) int __cdecl wcscmp(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 291
extern "C" { __declspec(dllimport) errno_t __cdecl wcscpy_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src); } 
#line 293 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcscpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source ) throw ( ) { return wcscpy_s ( _Dest, _Size, _Source ); }
#line 294
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcscpy(__wchar_t * _Dest, const __wchar_t * _Source); } 
#line 295
extern "C" { __declspec(dllimport) size_t __cdecl wcscspn(const __wchar_t * _Str, const __wchar_t * _Control); } 
#line 296
extern "C" { __declspec(dllimport) size_t __cdecl wcslen(const __wchar_t * _Str); } 
#line 300
extern "C" { 
#line 297
__declspec(dllimport) size_t __cdecl 
#line 300
wcsnlen(const __wchar_t * _Src, size_t _MaxCount); } 
#line 305
extern "C" { static __inline size_t __cdecl wcsnlen_s(const __wchar_t *_Src, size_t _MaxCount) 
#line 306
{ 
#line 307
return (_Src == (0)) ? 0 : wcsnlen(_Src, _MaxCount); 
#line 308
} } 
#line 311 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) errno_t __cdecl wcsncat_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src, rsize_t _MaxCount); } 
#line 313 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncat_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncat_s ( _Dest, _Size, _Source, _Count ); }
#pragma warning(push)
#pragma warning(disable:6059)
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsncat(__wchar_t * _Dest, const __wchar_t * _Source, size_t _Count); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl wcsncmp(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
#line 320
extern "C" { __declspec(dllimport) errno_t __cdecl wcsncpy_s(__wchar_t * _Dst, rsize_t _SizeInWords, const __wchar_t * _Src, rsize_t _MaxCount); } 
#line 322 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
template < size_t _Size > inline errno_t __cdecl wcsncpy_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _Count ) throw ( ) { return wcsncpy_s ( _Dest, _Size, _Source, _Count ); }
#line 323
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsncpy(__wchar_t * _Dest, const __wchar_t * _Source, size_t _Count); } 
#line 324
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcspbrk(const __wchar_t * _Str, const __wchar_t * _Control); } 
#line 325
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsrchr(const __wchar_t * _Str, __wchar_t _Ch); } 
#line 326
extern "C" { __declspec(dllimport) size_t __cdecl wcsspn(const __wchar_t * _Str, const __wchar_t * _Control); } 
#line 329
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl wcsstr(const __wchar_t * _Str, const __wchar_t * _SubStr); } 
#line 330
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok(__wchar_t * _Str, const __wchar_t * _Delim); } 
#line 332
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcstok_s(__wchar_t * _Str, const __wchar_t * _Delim, __wchar_t ** _Context); } 
#line 334 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcserror(int _ErrNum); } 
#line 335
extern "C" { __declspec(dllimport) errno_t __cdecl _wcserror_s(__wchar_t * _Buf, size_t _SizeInWords, int _ErrNum); } 
#line 336
template < size_t _Size > inline errno_t __cdecl _wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], int _Error ) throw ( ) { return _wcserror_s ( _Buffer, _Size, _Error ); }
#line 337
extern "C" { __declspec(dllimport) __wchar_t *__cdecl __wcserror(const __wchar_t * _Str); } 
#line 338
extern "C" { __declspec(dllimport) errno_t __cdecl __wcserror_s(__wchar_t * _Buffer, size_t _SizeInWords, const __wchar_t * _ErrMsg); } 
#line 339
template < size_t _Size > inline errno_t __cdecl __wcserror_s ( wchar_t ( & _Buffer ) [ _Size ], const wchar_t * _ErrorMessage ) throw ( ) { return __wcserror_s ( _Buffer, _Size, _ErrorMessage ); }
#line 341
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 342
extern "C" { __declspec(dllimport) int __cdecl _wcsicmp_l(const __wchar_t * _Str1, const __wchar_t * _Str2, _locale_t _Locale); } 
#line 343
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
#line 344
extern "C" { __declspec(dllimport) int __cdecl _wcsnicmp_l(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 345
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsnset_s(__wchar_t * _Dst, size_t _SizeInWords, __wchar_t _Val, size_t _MaxCount); } 
#line 346
template < size_t _Size > inline errno_t __cdecl _wcsnset_s ( wchar_t ( & _Dst ) [ _Size ], wchar_t _Val, size_t _MaxCount ) throw ( ) { return _wcsnset_s ( _Dst, _Size, _Val, _MaxCount ); }
#line 347
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsnset(__wchar_t * _Str, __wchar_t _Val, size_t _MaxCount); } 
#line 348
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsrev(__wchar_t * _Str); } 
#line 349
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsset_s(__wchar_t * _Dst, size_t _SizeInWords, __wchar_t _Value); } 
#line 350
template < size_t _Size > inline errno_t __cdecl _wcsset_s ( wchar_t ( & _Str ) [ _Size ], wchar_t _Val ) throw ( ) { return _wcsset_s ( _Str, _Size, _Val ); }
#line 351
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsset(__wchar_t * _Str, __wchar_t _Val); } 
#line 353
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s(__wchar_t * _Str, size_t _SizeInWords); } 
#line 354
template < size_t _Size > inline errno_t __cdecl _wcslwr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcslwr_s ( _String, _Size ); }
#line 355
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcslwr(__wchar_t * _String); } 
#line 356
extern "C" { __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(__wchar_t * _Str, size_t _SizeInWords, _locale_t _Locale); } 
#line 357
template < size_t _Size > inline errno_t __cdecl _wcslwr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcslwr_s_l ( _String, _Size, _Locale ); }
#line 358
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcslwr_l(__wchar_t * _String, _locale_t _Locale); } 
#line 359
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s(__wchar_t * _Str, size_t _Size); } 
#line 360
template < size_t _Size > inline errno_t __cdecl _wcsupr_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _wcsupr_s ( _String, _Size ); }
#line 361
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsupr(__wchar_t * _String); } 
#line 362
extern "C" { __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(__wchar_t * _Str, size_t _Size, _locale_t _Locale); } 
#line 363
template < size_t _Size > inline errno_t __cdecl _wcsupr_s_l ( wchar_t ( & _String ) [ _Size ], _locale_t _Locale ) throw ( ) { return _wcsupr_s_l ( _String, _Size, _Locale ); }
#line 364
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wcsupr_l(__wchar_t * _String, _locale_t _Locale); } 
#line 365
extern "C" { __declspec(dllimport) size_t __cdecl wcsxfrm(__wchar_t * _Dst, const __wchar_t * _Src, size_t _MaxCount); } 
#line 366
extern "C" { __declspec(dllimport) size_t __cdecl _wcsxfrm_l(__wchar_t * _Dst, const __wchar_t * _Src, size_t _MaxCount, _locale_t _Locale); } 
#line 367
extern "C" { __declspec(dllimport) int __cdecl wcscoll(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 368
extern "C" { __declspec(dllimport) int __cdecl _wcscoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, _locale_t _Locale); } 
#line 369
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 370
extern "C" { __declspec(dllimport) int __cdecl _wcsicoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, _locale_t _Locale); } 
#line 371
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
#line 372
extern "C" { __declspec(dllimport) int __cdecl _wcsncoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 373
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
#line 374
extern "C" { __declspec(dllimport) int __cdecl _wcsnicoll_l(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount, _locale_t _Locale); } 
#line 382
inline __wchar_t *__cdecl wcschr(__wchar_t *_Str, __wchar_t _Ch) 
#line 383
{ return (__wchar_t *)wcschr((const __wchar_t *)_Str, _Ch); } 
#line 384
inline __wchar_t *__cdecl wcspbrk(__wchar_t *_Str, const __wchar_t *_Control) 
#line 385
{ return (__wchar_t *)wcspbrk((const __wchar_t *)_Str, _Control); } 
#line 386
inline __wchar_t *__cdecl wcsrchr(__wchar_t *_Str, __wchar_t _Ch) 
#line 387
{ return (__wchar_t *)wcsrchr((const __wchar_t *)_Str, _Ch); } 
#line 390
inline __wchar_t *__cdecl wcsstr(__wchar_t *_Str, const __wchar_t *_SubStr) 
#line 391
{ return (__wchar_t *)wcsstr((const __wchar_t *)_Str, _SubStr); } 
#line 403 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsdup(const __wchar_t * _Str); } 
#line 413 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string.h"
extern "C" { __declspec(dllimport) int __cdecl wcsicmp(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 414
extern "C" { __declspec(dllimport) int __cdecl wcsnicmp(const __wchar_t * _Str1, const __wchar_t * _Str2, size_t _MaxCount); } 
#line 415
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsnset(__wchar_t * _Str, __wchar_t _Val, size_t _MaxCount); } 
#line 416
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsrev(__wchar_t * _Str); } 
#line 417
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsset(__wchar_t * _Str, __wchar_t _Val); } 
#line 418
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcslwr(__wchar_t * _Str); } 
#line 419
extern "C" { __declspec(dllimport) __wchar_t *__cdecl wcsupr(__wchar_t * _Str); } 
#line 420
extern "C" { __declspec(dllimport) int __cdecl wcsicoll(const __wchar_t * _Str1, const __wchar_t * _Str2); } 
#line 32 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
#pragma pack ( push, 8 )
#line 89 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" { typedef long clock_t; }
#line 113 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" { struct tm { 
#line 114
int tm_sec; 
#line 115
int tm_min; 
#line 116
int tm_hour; 
#line 117
int tm_mday; 
#line 118
int tm_mon; 
#line 119
int tm_year; 
#line 120
int tm_wday; 
#line 121
int tm_yday; 
#line 122
int tm_isdst; 
#line 123
}; }
#line 147 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" { __declspec(dllimport) int *__cdecl __daylight(); } 
#line 151
extern "C" { __declspec(dllimport) long *__cdecl __dstbias(); } 
#line 155
extern "C" { __declspec(dllimport) long *__cdecl __timezone(); } 
#line 159
extern "C" { __declspec(dllimport) char **__cdecl __tzname(); } 
#line 162
extern "C" { __declspec(dllimport) errno_t __cdecl _get_daylight(int * _Daylight); } 
#line 163
extern "C" { __declspec(dllimport) errno_t __cdecl _get_dstbias(long * _Daylight_savings_bias); } 
#line 164
extern "C" { __declspec(dllimport) errno_t __cdecl _get_timezone(long * _Timezone); } 
#line 165
extern "C" { __declspec(dllimport) errno_t __cdecl _get_tzname(size_t * _ReturnValue, char * _Buffer, size_t _SizeInBytes, int _Index); } 
#line 174
extern "C" { __declspec(dllimport) char *__cdecl asctime(const tm * _Tm); } 
#line 176
extern "C" { __declspec(dllimport) errno_t __cdecl asctime_s(char * _Buf, size_t _SizeInBytes, const tm * _Tm); } 
#line 178 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
template < size_t _Size > inline errno_t __cdecl asctime_s ( char ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return asctime_s ( _Buffer, _Size, _Time ); }
#line 180
extern "C" { __declspec(dllimport) char *__cdecl _ctime32(const __time32_t * _Time); } 
#line 181
extern "C" { __declspec(dllimport) errno_t __cdecl _ctime32_s(char * _Buf, size_t _SizeInBytes, const __time32_t * _Time); } 
#line 182
template < size_t _Size > inline errno_t __cdecl _ctime32_s ( char ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _ctime32_s ( _Buffer, _Size, _Time ); }
#line 184
extern "C" { __declspec(dllimport) clock_t __cdecl clock(); } 
#line 185
extern "C" { __declspec(dllimport) double __cdecl _difftime32(__time32_t _Time1, __time32_t _Time2); } 
#line 187
extern "C" { __declspec(dllimport) tm *__cdecl _gmtime32(const __time32_t * _Time); } 
#line 188
extern "C" { __declspec(dllimport) errno_t __cdecl _gmtime32_s(tm * _Tm, const __time32_t * _Time); } 
#line 190
extern "C" { __declspec(dllimport) tm *__cdecl _localtime32(const __time32_t * _Time); } 
#line 191
extern "C" { __declspec(dllimport) errno_t __cdecl _localtime32_s(tm * _Tm, const __time32_t * _Time); } 
#line 193
extern "C" { __declspec(dllimport) size_t __cdecl strftime(char * _Buf, size_t _SizeInBytes, const char * _Format, const tm * _Tm); } 
#line 194
extern "C" { __declspec(dllimport) size_t __cdecl _strftime_l(char * _Buf, size_t _Max_size, const char * _Format, const tm * _Tm, _locale_t _Locale); } 
#line 196
extern "C" { __declspec(dllimport) errno_t __cdecl _strdate_s(char * _Buf, size_t _SizeInBytes); } 
#line 197
template < size_t _Size > inline errno_t __cdecl _strdate_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strdate_s ( _Buffer, _Size ); }
#line 198
extern "C" { __declspec(dllimport) char *__cdecl _strdate(char * _Buffer); } 
#line 200
extern "C" { __declspec(dllimport) errno_t __cdecl _strtime_s(char * _Buf, size_t _SizeInBytes); } 
#line 201
template < size_t _Size > inline errno_t __cdecl _strtime_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return _strtime_s ( _Buffer, _Size ); }
#line 202
extern "C" { __declspec(dllimport) char *__cdecl _strtime(char * _Buffer); } 
#line 204
extern "C" { __declspec(dllimport) __time32_t __cdecl _time32(__time32_t * _Time); } 
#line 205
extern "C" { __declspec(dllimport) __time32_t __cdecl _mktime32(tm * _Tm); } 
#line 206
extern "C" { __declspec(dllimport) __time32_t __cdecl _mkgmtime32(tm * _Tm); } 
#line 210
extern "C" { __declspec(dllimport) void __cdecl _tzset(); } 
#line 214 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" { __declspec(dllimport) double __cdecl _difftime64(__time64_t _Time1, __time64_t _Time2); } 
#line 215
extern "C" { __declspec(dllimport) char *__cdecl _ctime64(const __time64_t * _Time); } 
#line 216
extern "C" { __declspec(dllimport) errno_t __cdecl _ctime64_s(char * _Buf, size_t _SizeInBytes, const __time64_t * _Time); } 
#line 217
template < size_t _Size > inline errno_t __cdecl _ctime64_s ( char ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _ctime64_s ( _Buffer, _Size, _Time ); }
#line 219
extern "C" { __declspec(dllimport) tm *__cdecl _gmtime64(const __time64_t * _Time); } 
#line 220
extern "C" { __declspec(dllimport) errno_t __cdecl _gmtime64_s(tm * _Tm, const __time64_t * _Time); } 
#line 222
extern "C" { __declspec(dllimport) tm *__cdecl _localtime64(const __time64_t * _Time); } 
#line 223
extern "C" { __declspec(dllimport) errno_t __cdecl _localtime64_s(tm * _Tm, const __time64_t * _Time); } 
#line 225
extern "C" { __declspec(dllimport) __time64_t __cdecl _mktime64(tm * _Tm); } 
#line 226
extern "C" { __declspec(dllimport) __time64_t __cdecl _mkgmtime64(tm * _Tm); } 
#line 227
extern "C" { __declspec(dllimport) __time64_t __cdecl _time64(__time64_t * _Time); } 
#line 231
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using GetLocalTime in" "stead. See online help for details.")) unsigned __cdecl _getsystime(tm * _Tm); } 
#line 232
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetLocalTime in" "stead. See online help for details.")) unsigned __cdecl _setsystime(tm * _Tm, unsigned _MilliSec); } 
#line 245 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wasctime(const tm * _Tm); } 
#line 246
extern "C" { __declspec(dllimport) errno_t __cdecl _wasctime_s(__wchar_t * _Buf, size_t _SizeInWords, const tm * _Tm); } 
#line 247
template < size_t _Size > inline errno_t __cdecl _wasctime_s ( wchar_t ( & _Buffer ) [ _Size ], const struct tm * _Time ) throw ( ) { return _wasctime_s ( _Buffer, _Size, _Time ); }
#line 249
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wctime32(const __time32_t * _Time); } 
#line 250
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime32_s(__wchar_t * _Buf, size_t _SizeInWords, const __time32_t * _Time); } 
#line 251
template < size_t _Size > inline errno_t __cdecl _wctime32_s ( wchar_t ( & _Buffer ) [ _Size ], const __time32_t * _Time ) throw ( ) { return _wctime32_s ( _Buffer, _Size, _Time ); }
#line 253
extern "C" { __declspec(dllimport) size_t __cdecl wcsftime(__wchar_t * _Buf, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm); } 
#line 254
extern "C" { __declspec(dllimport) size_t __cdecl _wcsftime_l(__wchar_t * _Buf, size_t _SizeInWords, const __wchar_t * _Format, const tm * _Tm, _locale_t _Locale); } 
#line 256
extern "C" { __declspec(dllimport) errno_t __cdecl _wstrdate_s(__wchar_t * _Buf, size_t _SizeInWords); } 
#line 257
template < size_t _Size > inline errno_t __cdecl _wstrdate_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrdate_s ( _Buffer, _Size ); }
#line 258
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wstrdate(__wchar_t * _Buffer); } 
#line 260
extern "C" { __declspec(dllimport) errno_t __cdecl _wstrtime_s(__wchar_t * _Buf, size_t _SizeInWords); } 
#line 261
template < size_t _Size > inline errno_t __cdecl _wstrtime_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wstrtime_s ( _Buffer, _Size ); }
#line 262
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wstrtime(__wchar_t * _Buffer); } 
#line 264
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wctime64(const __time64_t * _Time); } 
#line 265
extern "C" { __declspec(dllimport) errno_t __cdecl _wctime64_s(__wchar_t * _Buf, size_t _SizeInWords, const __time64_t * _Time); } 
#line 266
template < size_t _Size > inline errno_t __cdecl _wctime64_s ( wchar_t ( & _Buffer ) [ _Size ], const __time64_t * _Time ) throw ( ) { return _wctime64_s ( _Buffer, _Size, _Time ); }
#line 27 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wtime.inl"
#pragma warning(push)
#pragma warning(disable:4996)
#line 44
extern "C" { static __inline __wchar_t *__cdecl _wctime(const time_t *_Time) 
#line 45
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _wctime64(_Time); 
#pragma warning( pop )
} } 
#line 52
extern "C" { static __inline errno_t __cdecl _wctime_s(__wchar_t *_Buffer, size_t _SizeInWords, const time_t *_Time) 
#line 53
{ 
#line 54
return _wctime64_s(_Buffer, _SizeInWords, _Time); 
#line 55
} } 
#line 58 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wtime.inl"
#pragma warning(pop)
#line 82 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.inl"
extern "C" { static __inline double __cdecl difftime(time_t _Time1, time_t _Time2) 
#line 83
{ 
#line 84
return _difftime64(_Time1, _Time2); 
#line 85
} } 
#line 86
extern "C" { static __inline char *__cdecl ctime(const time_t *_Time) 
#line 87
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _ctime64(_Time); 
#pragma warning( pop )
} } 
#line 94
extern "C" { static __inline errno_t __cdecl ctime_s(char *_Buffer, size_t _SizeInBytes, const time_t *_Time) 
#line 95
{ 
#line 96
return _ctime64_s(_Buffer, _SizeInBytes, _Time); 
#line 97
} } 
#line 99 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.inl"
extern "C" { static __inline tm *__cdecl gmtime(const time_t *_Time) 
#line 100
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _gmtime64(_Time); 
#pragma warning( pop )
} } 
#line 107
extern "C" { static __inline errno_t __cdecl gmtime_s(tm *_Tm, const time_t *_Time) 
#line 108
{ 
#line 109
return _gmtime64_s(_Tm, _Time); 
#line 110
} } 
#line 112 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.inl"
extern "C" { static __inline tm *__cdecl localtime(const time_t *_Time) 
#line 113
{ 
#pragma warning( push )
#pragma warning( disable : 4996 )
return _localtime64(_Time); 
#pragma warning( pop )
} } 
#line 119
extern "C" { static __inline errno_t __cdecl localtime_s(tm *_Tm, const time_t *_Time) 
#line 120
{ 
#line 121
return _localtime64_s(_Tm, _Time); 
#line 122
} } 
#line 123
extern "C" { static __inline time_t __cdecl mktime(tm *_Tm) 
#line 124
{ 
#line 125
return _mktime64(_Tm); 
#line 126
} } 
#line 127
extern "C" { static __inline time_t __cdecl _mkgmtime(tm *_Tm) 
#line 128
{ 
#line 129
return _mkgmtime64(_Tm); 
#line 130
} } 
#line 131
extern "C" { static __inline time_t __cdecl time(time_t *_Time) 
#line 132
{ 
#line 133
return _time64(_Time); 
#line 134
} } 
#line 291 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" __declspec(dllimport) int daylight; 
#line 292
extern "C" __declspec(dllimport) long timezone; 
#line 293
extern "C" __declspec(dllimport) char *tzname[2]; 
#line 297 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
extern "C" { __declspec(dllimport) void __cdecl tzset(); } 
#line 307 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\time.h"
#pragma pack ( pop )
#line 71 "e:\\cudatoolkit\\include\\common_functions.h"
extern "C" { __declspec(dllimport) extern clock_t __cdecl clock(); } 
#line 72
extern "C" { extern void *__cdecl memset(void *, int, size_t); } 
#line 73
extern "C" { extern void *__cdecl memcpy(void *, const void *, size_t); } 
#line 154 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern int __cdecl abs(int); } 
#line 155
extern "C" { extern long __cdecl labs(long); } 
#line 156
extern "C" { extern __int64 llabs(__int64); } 
#line 206 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern double __cdecl fabs(double x); } 
#line 247
extern "C" { extern __inline float fabsf(float x); } 
#line 251
extern inline int min(int, int); 
#line 253
extern inline unsigned umin(unsigned, unsigned); 
#line 254
extern inline __int64 llmin(__int64, __int64); 
#line 255
extern inline unsigned __int64 ullmin(unsigned __int64, unsigned __int64); 
#line 278 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl fminf(float x, float y); } 
#line 298 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl fmin(double x, double y); 
#line 303 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline int max(int, int); 
#line 305
extern inline unsigned umax(unsigned, unsigned); 
#line 306
extern inline __int64 llmax(__int64, __int64); 
#line 307
extern inline unsigned __int64 ullmax(unsigned __int64, unsigned __int64); 
#line 330 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl fmaxf(float x, float y); } 
#line 350 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl fmax(double, double); 
#line 392 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" double __cdecl sin(double x); 
#line 425
extern "C" double __cdecl cos(double x); 
#line 444
extern "C" { extern void sincos(double x, double * sptr, double * cptr); } 
#line 460
extern "C" { extern void sincosf(float x, float * sptr, float * cptr); } 
#line 505
extern "C" double __cdecl tan(double x); 
#line 574
extern "C" double __cdecl sqrt(double x); 
#line 646
extern "C" { extern double rsqrt(double x); } 
#line 716
extern "C" { extern float rsqrtf(float x); } 
#line 774 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl log2(double x); 
#line 799 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl exp2(double x); 
#line 824 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl exp2f(float x); } 
#line 849 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern double exp10(double x); } 
#line 872
extern "C" { extern float exp10f(float x); } 
#line 920 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl expm1(double x); 
#line 965 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl expm1f(float x); } 
#line 1020 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl log2f(float x); } 
#line 1072 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" double __cdecl log10(double x); 
#line 1143
extern "C" double __cdecl log(double x); 
#line 1239 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl log1p(double x); 
#line 1336 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl log1pf(float x); } 
#line 1409 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl floor(double x); 
#line 1448
extern "C" double __cdecl exp(double x); 
#line 1479
extern "C" double __cdecl cosh(double x); 
#line 1509
extern "C" double __cdecl sinh(double x); 
#line 1539
extern "C" double __cdecl tanh(double x); 
#line 1576 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl acosh(double x); 
#line 1614 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl acoshf(float x); } 
#line 1630 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl asinh(double x); 
#line 1646 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl asinhf(float x); } 
#line 1700 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl atanh(double x); 
#line 1754 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl atanhf(float x); } 
#line 1811 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl ldexp(double x, int exp); 
#line 1867
extern "C" { extern __inline float ldexpf(float x, int exp); } 
#line 1921 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl logb(double x); 
#line 1976 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl logbf(float x); } 
#line 2006 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) int __cdecl ilogb(double x); 
#line 2036 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern int __cdecl ilogbf(float x); } 
#line 2112 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl scalbn(double x, int n); 
#line 2188 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl scalbnf(float x, int n); } 
#line 2264 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl scalbln(double x, long n); 
#line 2340 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl scalblnf(float x, long n); } 
#line 2416 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl frexp(double x, int * nptr); 
#line 2491
extern "C" { extern __inline float frexpf(float x, int * nptr); } 
#line 2507 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl round(double x); 
#line 2524 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl roundf(float x); } 
#line 2542 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) long __cdecl lround(double x); 
#line 2560 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern long __cdecl lroundf(float x); } 
#line 2578 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) __int64 __cdecl llround(double x); 
#line 2596 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern __int64 __cdecl llroundf(float x); } 
#line 2611 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl rint(double x); 
#line 2626 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl rintf(float x); } 
#line 2642 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) long __cdecl lrint(double x); 
#line 2658 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern long __cdecl lrintf(float x); } 
#line 2674 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) __int64 __cdecl llrint(double x); 
#line 2690 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern __int64 __cdecl llrintf(float x); } 
#line 2743 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl nearbyint(double x); 
#line 2796 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl nearbyintf(float x); } 
#line 2856 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl ceil(double x); 
#line 2870 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl trunc(double x); 
#line 2885 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl truncf(float x); } 
#line 2911 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl fdim(double x, double y); 
#line 2937 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl fdimf(float x, float y); } 
#line 2971 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" double __cdecl atan2(double y, double x); 
#line 3002
extern "C" double __cdecl atan(double x); 
#line 3025
extern "C" double __cdecl acos(double x); 
#line 3057
extern "C" double __cdecl asin(double x); 
#line 3097
extern "C" { static __inline double __cdecl hypot(double x, double y); } 
#line 3151 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern double rhypot(double x, double y); } 
#line 3195
extern "C" { static __inline float __cdecl hypotf(float x, float y); } 
#line 3249 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern float rhypotf(float x, float y); } 
#line 3296
extern "C" { __declspec(dllimport) extern double __cdecl norm3d(double a, double b, double c); } 
#line 3347
extern "C" { extern double rnorm3d(double a, double b, double c); } 
#line 3396
extern "C" { __declspec(dllimport) extern double __cdecl norm4d(double a, double b, double c, double d); } 
#line 3452
extern "C" { extern double rnorm4d(double a, double b, double c, double d); } 
#line 3497
extern "C" { extern double norm(int dim, const double * t); } 
#line 3548
extern "C" { extern double rnorm(int dim, const double * t); } 
#line 3600
extern "C" { extern float rnormf(int dim, const float * a); } 
#line 3644
extern "C" { extern float normf(int dim, const float * a); } 
#line 3689
extern "C" { extern float norm3df(float a, float b, float c); } 
#line 3740
extern "C" { extern float rnorm3df(float a, float b, float c); } 
#line 3789
extern "C" { extern float norm4df(float a, float b, float c, float d); } 
#line 3845
extern "C" { extern float rnorm4df(float a, float b, float c, float d); } 
#line 3931 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl cbrt(double x); 
#line 4017 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl cbrtf(float x); } 
#line 4070 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern double rcbrt(double x); } 
#line 4120
extern "C" { extern float rcbrtf(float x); } 
#line 4180
extern "C" { extern double sinpi(double x); } 
#line 4240
extern "C" { extern float sinpif(float x); } 
#line 4292
extern "C" { extern double cospi(double x); } 
#line 4344
extern "C" { extern float cospif(float x); } 
#line 4374
extern "C" { extern void sincospi(double x, double * sptr, double * cptr); } 
#line 4404
extern "C" { extern void sincospif(float x, float * sptr, float * cptr); } 
#line 4716
extern "C" double __cdecl pow(double x, double y); 
#line 4772
extern "C" { __declspec(dllimport) extern double __cdecl modf(double x, double * iptr); } 
#line 4831
extern "C" double __cdecl fmod(double x, double y); 
#line 4919 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl remainder(double x, double y); 
#line 5009 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl remainderf(float x, float y); } 
#line 5063 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl remquo(double x, double y, int * quo); } 
#line 5117 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl remquof(float x, float y, int * quo); } 
#line 5156 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl j0(double x); } 
#line 5198
extern "C" { extern float j0f(float x); } 
#line 5259
extern "C" { __declspec(dllimport) extern double __cdecl j1(double x); } 
#line 5320
extern "C" { extern float j1f(float x); } 
#line 5363
extern "C" { __declspec(dllimport) extern double __cdecl jn(int n, double x); } 
#line 5406
extern "C" { extern float jnf(int n, float x); } 
#line 5458
extern "C" { __declspec(dllimport) extern double __cdecl y0(double x); } 
#line 5510
extern "C" { extern float y0f(float x); } 
#line 5562
extern "C" { __declspec(dllimport) extern double __cdecl y1(double x); } 
#line 5614
extern "C" { extern float y1f(float x); } 
#line 5667
extern "C" { __declspec(dllimport) extern double __cdecl yn(int n, double x); } 
#line 5720
extern "C" { extern float ynf(int n, float x); } 
#line 5747
extern "C" { __declspec(dllimport) extern double __cdecl cyl_bessel_i0(double x); } 
#line 5773
extern "C" { extern float cyl_bessel_i0f(float x); } 
#line 5800
extern "C" { __declspec(dllimport) extern double __cdecl cyl_bessel_i1(double x); } 
#line 5826
extern "C" { extern float cyl_bessel_i1f(float x); } 
#line 5911 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl erf(double x); 
#line 5993 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl erff(float x); } 
#line 6055 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern double erfinv(double y); } 
#line 6112
extern "C" { extern float erfinvf(float y); } 
#line 6153 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl erfc(double x); 
#line 6191 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl erfcf(float x); } 
#line 6319 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl lgamma(double x); 
#line 6380 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern double erfcinv(double y); } 
#line 6436
extern "C" { extern float erfcinvf(float y); } 
#line 6494
extern "C" { extern double normcdfinv(double y); } 
#line 6552
extern "C" { extern float normcdfinvf(float y); } 
#line 6595
extern "C" { extern double normcdf(double y); } 
#line 6638
extern "C" { extern float normcdff(float y); } 
#line 6713
extern "C" { extern double erfcx(double x); } 
#line 6788
extern "C" { extern float erfcxf(float x); } 
#line 6924 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl lgammaf(float x); } 
#line 7033 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl tgamma(double x); 
#line 7142 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl tgammaf(float x); } 
#line 7155 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl copysign(double x, double y); 
#line 7168 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl copysignf(float x, float y); } 
#line 7205 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" __declspec(dllimport) double __cdecl nextafter(double x, double y); 
#line 7242 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl nextafterf(float x, float y); } 
#line 7258 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl nan(const char * tagp); } 
#line 7274 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl nanf(const char * tagp); } 
#line 7279 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern int __isinff(float); } 
#line 7280
extern "C" { extern int __isnanf(float); } 
#line 7290 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern int __finite(double); } 
#line 7291
extern "C" { extern int __finitef(float); } 
#line 7292
extern "C" { extern int __signbit(double); } 
#line 7293
extern "C" { extern int __isnan(double); } 
#line 7294
extern "C" { extern int __isinf(double); } 
#line 7297 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern int __signbitf(float); } 
#line 7458 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl fma(double x, double y, double z); } 
#line 7616 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern float __cdecl fmaf(float x, float y, float z); } 
#line 7625 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern int __signbitl(long double); } 
#line 7631 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern int __finitel(long double); } 
#line 7632
extern "C" { extern int __isinfl(long double); } 
#line 7633
extern "C" { extern int __isnanl(long double); } 
#line 7683 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { extern __inline float acosf(float x); } 
#line 7723
extern "C" { extern __inline float asinf(float x); } 
#line 7763
extern "C" { extern __inline float atanf(float x); } 
#line 7796
extern "C" { extern __inline float atan2f(float y, float x); } 
#line 7820
extern "C" { extern __inline float cosf(float x); } 
#line 7862
extern "C" { extern __inline float sinf(float x); } 
#line 7904
extern "C" { extern __inline float tanf(float x); } 
#line 7928
extern "C" { extern __inline float coshf(float x); } 
#line 7969
extern "C" { extern __inline float sinhf(float x); } 
#line 7999
extern "C" { extern __inline float tanhf(float x); } 
#line 8050
extern "C" { extern __inline float logf(float x); } 
#line 8100
extern "C" { extern __inline float expf(float x); } 
#line 8151
extern "C" { extern __inline float log10f(float x); } 
#line 8206
extern "C" { extern __inline float modff(float x, float * iptr); } 
#line 8514
extern "C" { extern __inline float powf(float x, float y); } 
#line 8583
extern "C" { extern __inline float sqrtf(float x); } 
#line 8642
extern "C" { extern __inline float ceilf(float x); } 
#line 8714
extern "C" { extern __inline float floorf(float x); } 
#line 8773
extern "C" { extern __inline float fmodf(float x, float y); } 
#line 24 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
#pragma pack ( push, 8 )
#line 37 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { struct _exception { 
#line 38
int type; 
#line 39
char *name; 
#line 40
double arg1; 
#line 41
double arg2; 
#line 42
double retval; 
#line 43
}; }
#line 54 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { struct _complex { 
#line 55
double x, y; 
#line 56
}; }
#line 67 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { typedef float float_t; }
#line 68
extern "C" { typedef double double_t; }
#line 90
extern "C" __declspec(dllimport) double _HUGE; 
#line 184 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { void __cdecl _fperrraise(int _Except); } 
#line 186
extern "C" { __declspec(dllimport) short __cdecl _dclass(double _X); } 
#line 187
extern "C" { __declspec(dllimport) short __cdecl _ldclass(long double _X); } 
#line 188
extern "C" { __declspec(dllimport) short __cdecl _fdclass(float _X); } 
#line 190
extern "C" { __declspec(dllimport) int __cdecl _dsign(double _X); } 
#line 191
extern "C" { __declspec(dllimport) int __cdecl _ldsign(long double _X); } 
#line 192
extern "C" { __declspec(dllimport) int __cdecl _fdsign(float _X); } 
#line 194
extern "C" { __declspec(dllimport) int __cdecl _dpcomp(double _X, double _Y); } 
#line 195
extern "C" { __declspec(dllimport) int __cdecl _ldpcomp(long double _X, long double _Y); } 
#line 196
extern "C" { __declspec(dllimport) int __cdecl _fdpcomp(float _X, float _Y); } 
#line 198
extern "C" { __declspec(dllimport) short __cdecl _dtest(double * _Px); } 
#line 199
extern "C" { __declspec(dllimport) short __cdecl _ldtest(long double * _Px); } 
#line 200
extern "C" { __declspec(dllimport) short __cdecl _fdtest(float * _Px); } 
#line 202
extern "C" { __declspec(dllimport) short __cdecl _d_int(double * _Px, short _Xexp); } 
#line 203
extern "C" { __declspec(dllimport) short __cdecl _ld_int(long double * _Px, short _Xexp); } 
#line 204
extern "C" { __declspec(dllimport) short __cdecl _fd_int(float * _Px, short _Xexp); } 
#line 206
extern "C" { __declspec(dllimport) short __cdecl _dscale(double * _Px, long _Lexp); } 
#line 207
extern "C" { __declspec(dllimport) short __cdecl _ldscale(long double * _Px, long _Lexp); } 
#line 208
extern "C" { __declspec(dllimport) short __cdecl _fdscale(float * _Px, long _Lexp); } 
#line 210
extern "C" { __declspec(dllimport) short __cdecl _dunscale(short * _Pex, double * _Px); } 
#line 211
extern "C" { __declspec(dllimport) short __cdecl _ldunscale(short * _Pex, long double * _Px); } 
#line 212
extern "C" { __declspec(dllimport) short __cdecl _fdunscale(short * _Pex, float * _Px); } 
#line 214
extern "C" { __declspec(dllimport) short __cdecl _dexp(double * _Px, double _Y, long _Eoff); } 
#line 215
extern "C" { __declspec(dllimport) short __cdecl _ldexp(long double * _Px, long double _Y, long _Eoff); } 
#line 216
extern "C" { __declspec(dllimport) short __cdecl _fdexp(float * _Px, float _Y, long _Eoff); } 
#line 218
extern "C" { __declspec(dllimport) short __cdecl _dnorm(unsigned short * _Ps); } 
#line 219
extern "C" { __declspec(dllimport) short __cdecl _fdnorm(unsigned short * _Ps); } 
#line 221
extern "C" { double __cdecl _dpoly(double _X, const double * _Tab, int _N); } 
#line 222
extern "C" { long double __cdecl _ldpoly(long double _X, const long double * _Tab, int _N); } 
#line 223
extern "C" { float __cdecl _fdpoly(float _X, const float * _Tab, int _N); } 
#line 225
extern "C" { __declspec(dllimport) double __cdecl _dlog(double _X, int _Baseflag); } 
#line 226
extern "C" { __declspec(dllimport) long double __cdecl _ldlog(long double _X, int _Baseflag); } 
#line 227
extern "C" { __declspec(dllimport) float __cdecl _fdlog(float _X, int _Baseflag); } 
#line 229
extern "C" { __declspec(dllimport) double __cdecl _dsin(double _X, unsigned _Qoff); } 
#line 230
extern "C" { __declspec(dllimport) long double __cdecl _ldsin(long double _X, unsigned _Qoff); } 
#line 231
extern "C" { __declspec(dllimport) float __cdecl _fdsin(float _X, unsigned _Qoff); } 
#line 238
extern "C" { typedef 
#line 235
union { 
#line 236
unsigned short _Sh[8]; 
#line 237
double _Val; 
#line 238
} _double_val; }
#line 245
extern "C" { typedef 
#line 242
union { 
#line 243
unsigned short _Sh[8]; 
#line 244
float _Val; 
#line 245
} _float_val; }
#line 252
extern "C" { typedef 
#line 249
union { 
#line 250
unsigned short _Sh[8]; 
#line 251
long double _Val; 
#line 252
} _ldouble_val; }
#line 260
extern "C" { typedef 
#line 255
union { 
#line 256
unsigned short _Word[8]; 
#line 257
float _Float; 
#line 258
double _Double; 
#line 259
long double _Long_double; 
#line 260
} _float_const; }
#line 262
extern "C" const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C; 
#line 263
extern "C" const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C; 
#line 264
extern "C" const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C; 
#line 266
extern "C" const _float_const _Eps_C, _Rteps_C; 
#line 267
extern "C" const _float_const _FEps_C, _FRteps_C; 
#line 268
extern "C" const _float_const _LEps_C, _LRteps_C; 
#line 270
extern "C" const double _Zero_C, _Xbig_C; 
#line 271
extern "C" const float _FZero_C, _FXbig_C; 
#line 272
extern "C" const long double _LZero_C, _LXbig_C; 
#line 304
__declspec(nothrow) inline int fpclassify(float _X) 
#line 305
{ 
#line 306
return _fdtest(&_X); 
#line 307
} 
#line 309
__declspec(nothrow) inline int fpclassify(double _X) 
#line 310
{ 
#line 311
return _dtest(&_X); 
#line 312
} 
#line 314
__declspec(nothrow) inline int fpclassify(long double _X) 
#line 315
{ 
#line 316
return _ldtest(&_X); 
#line 317
} 
#line 319
__declspec(nothrow) inline bool signbit(float _X) 
#line 320
{ 
#line 321
return _fdsign(_X) != 0; 
#line 322
} 
#line 324
__declspec(nothrow) inline bool signbit(double _X) 
#line 325
{ 
#line 326
return _dsign(_X) != 0; 
#line 327
} 
#line 329
__declspec(nothrow) inline bool signbit(long double _X) 
#line 330
{ 
#line 331
return _ldsign(_X) != 0; 
#line 332
} 
#line 334
__declspec(nothrow) inline int _fpcomp(float _X, float _Y) 
#line 335
{ 
#line 336
return _fdpcomp(_X, _Y); 
#line 337
} 
#line 339
__declspec(nothrow) inline int _fpcomp(double _X, double _Y) 
#line 340
{ 
#line 341
return _dpcomp(_X, _Y); 
#line 342
} 
#line 344
__declspec(nothrow) inline int _fpcomp(long double _X, long double _Y) 
#line 345
{ 
#line 346
return _ldpcomp(_X, _Y); 
#line 347
} 
#line 349
template< class _Trc, class _Tre> struct _Combined_type { 
#line 351
typedef float _Type; 
#line 352
}; 
#line 354
template<> struct _Combined_type< float, double>  { 
#line 356
typedef double _Type; 
#line 357
}; 
#line 359
template<> struct _Combined_type< float, long double>  { 
#line 361
typedef long double _Type; 
#line 362
}; 
#line 364
template< class _Ty, class _T2> struct _Real_widened { 
#line 366
typedef long double _Type; 
#line 367
}; 
#line 369
template<> struct _Real_widened< float, float>  { 
#line 371
typedef float _Type; 
#line 372
}; 
#line 374
template<> struct _Real_widened< float, double>  { 
#line 376
typedef double _Type; 
#line 377
}; 
#line 379
template<> struct _Real_widened< double, float>  { 
#line 381
typedef double _Type; 
#line 382
}; 
#line 384
template<> struct _Real_widened< double, double>  { 
#line 386
typedef double _Type; 
#line 387
}; 
#line 389
template< class _Ty> struct _Real_type { 
#line 391
typedef double _Type; 
#line 392
}; 
#line 394
template<> struct _Real_type< float>  { 
#line 396
typedef float _Type; 
#line 397
}; 
#line 399
template<> struct _Real_type< long double>  { 
#line 401
typedef long double _Type; 
#line 402
}; 
#line 404
template < class _T1, class _T2 > inline __declspec ( nothrow ) int _fpcomp ( _T1 _X, _T2 _Y )
{
    typedef typename _Combined_type < float,
        typename _Real_widened <
        typename _Real_type < _T1 > :: _Type,
        typename _Real_type < _T2 > :: _Type > :: _Type > :: _Type _Tw;
    return ( _fpcomp ( ( _Tw ) _X, ( _Tw ) _Y ) );
}
#line 413
template < class _Ty > inline __declspec ( nothrow ) bool isfinite ( _Ty _X )
{
    return ( fpclassify ( _X ) <= 0 );
}
#line 418
template < class _Ty > inline __declspec ( nothrow ) bool isinf ( _Ty _X )
{
    return ( fpclassify ( _X ) == 1 );
}
#line 423
template < class _Ty > inline __declspec ( nothrow ) bool isnan ( _Ty _X )
{
    return ( fpclassify ( _X ) == 2 );
}
#line 428
template < class _Ty > inline __declspec ( nothrow ) bool isnormal ( _Ty _X )
{
    return ( fpclassify ( _X ) == ( - 1 ) );
}
#line 433
template < class _Ty1, class _Ty2 > inline __declspec ( nothrow ) bool isgreater ( _Ty1 _X, _Ty2 _Y )
{
    return ( ( _fpcomp ( _X, _Y ) & 4 ) != 0 );
}
#line 438
template < class _Ty1, class _Ty2 > inline __declspec ( nothrow ) bool isgreaterequal ( _Ty1 _X, _Ty2 _Y )
{
    return ( ( _fpcomp ( _X, _Y ) & ( 2 | 4 ) ) != 0 );
}
#line 443
template < class _Ty1, class _Ty2 > inline __declspec ( nothrow ) bool isless ( _Ty1 _X, _Ty2 _Y )
{
    return ( ( _fpcomp ( _X, _Y ) & 1 ) != 0 );
}
#line 448
template < class _Ty1, class _Ty2 > inline __declspec ( nothrow ) bool islessequal ( _Ty1 _X, _Ty2 _Y )
{
    return ( ( _fpcomp ( _X, _Y ) & ( 1 | 2 ) ) != 0 );
}
#line 453
template < class _Ty1, class _Ty2 > inline __declspec ( nothrow ) bool islessgreater ( _Ty1 _X, _Ty2 _Y )
{
    return ( ( _fpcomp ( _X, _Y ) & ( 1 | 4 ) ) != 0 );
}
#line 458
template < class _Ty1, class _Ty2 > inline __declspec ( nothrow ) bool isunordered ( _Ty1 _X, _Ty2 _Y )
{
    return ( _fpcomp ( _X, _Y ) == 0 );
}
#line 470 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { int __cdecl abs(int _X); } 
#line 471
extern "C" { long __cdecl labs(long _X); } 
#line 472
extern "C" { __int64 __cdecl llabs(__int64 _X); } 
#line 474
extern "C" double __cdecl acos(double _X); 
#line 475
extern "C" __declspec(dllimport) double __cdecl acosh(double _X); 
#line 476
extern "C" double __cdecl asin(double _X); 
#line 477
extern "C" __declspec(dllimport) double __cdecl asinh(double _X); 
#line 478
extern "C" double __cdecl atan(double _X); 
#line 479
extern "C" __declspec(dllimport) double __cdecl atanh(double _X); 
#line 480
extern "C" double __cdecl atan2(double _Y, double _X); 
#line 482
extern "C" __declspec(dllimport) double __cdecl cbrt(double _X); 
#line 483
extern "C" __declspec(dllimport) double __cdecl copysign(double _X, double _Y); 
#line 484
extern "C" double __cdecl cos(double _X); 
#line 485
extern "C" double __cdecl cosh(double _X); 
#line 486
extern "C" __declspec(dllimport) double __cdecl erf(double _X); 
#line 487
extern "C" __declspec(dllimport) double __cdecl erfc(double _X); 
#line 488
extern "C" double __cdecl exp(double _X); 
#line 489
extern "C" __declspec(dllimport) double __cdecl exp2(double _X); 
#line 490
extern "C" __declspec(dllimport) double __cdecl expm1(double _X); 
#line 491
extern "C" { double __cdecl fabs(double _X); } 
#line 492
extern "C" __declspec(dllimport) double __cdecl fdim(double _X, double _Y); 
#line 493
extern "C" { __declspec(dllimport) double __cdecl fma(double _X, double _Y, double _Z); } 
#line 494
extern "C" __declspec(dllimport) double __cdecl fmax(double _X, double _Y); 
#line 495
extern "C" __declspec(dllimport) double __cdecl fmin(double _X, double _Y); 
#line 496
extern "C" double __cdecl fmod(double _X, double _Y); 
#line 497
extern "C" __declspec(dllimport) int __cdecl ilogb(double _X); 
#line 498
extern "C" __declspec(dllimport) double __cdecl lgamma(double _X); 
#line 499
extern "C" __declspec(dllimport) __int64 __cdecl llrint(double _X); 
#line 500
extern "C" __declspec(dllimport) __int64 __cdecl llround(double _X); 
#line 501
extern "C" double __cdecl log(double _X); 
#line 502
extern "C" double __cdecl log10(double _X); 
#line 503
extern "C" __declspec(dllimport) double __cdecl log1p(double _X); 
#line 504
extern "C" __declspec(dllimport) double __cdecl log2(double _X); 
#line 505
extern "C" __declspec(dllimport) double __cdecl logb(double _X); 
#line 506
extern "C" __declspec(dllimport) long __cdecl lrint(double _X); 
#line 507
extern "C" __declspec(dllimport) long __cdecl lround(double _X); 
#line 508
extern "C" { __declspec(dllimport) double __cdecl nan(const char *); } 
#line 509
extern "C" __declspec(dllimport) double __cdecl nearbyint(double _X); 
#line 510
extern "C" __declspec(dllimport) double __cdecl nextafter(double _X, double _Y); 
#line 511
extern "C" __declspec(dllimport) double __cdecl nexttoward(double _X, long double _Y); 
#line 512
extern "C" double __cdecl pow(double _X, double _Y); 
#line 513
extern "C" __declspec(dllimport) double __cdecl remainder(double _X, double _Y); 
#line 514
extern "C" { __declspec(dllimport) double __cdecl remquo(double _X, double _Y, int * _Z); } 
#line 515
extern "C" __declspec(dllimport) double __cdecl rint(double _X); 
#line 516
extern "C" __declspec(dllimport) double __cdecl round(double _X); 
#line 517
extern "C" __declspec(dllimport) double __cdecl scalbln(double _X, long _Y); 
#line 518
extern "C" __declspec(dllimport) double __cdecl scalbn(double _X, int _Y); 
#line 519
extern "C" double __cdecl sin(double _X); 
#line 520
extern "C" double __cdecl sinh(double _X); 
#line 521
extern "C" double __cdecl sqrt(double _X); 
#line 522
extern "C" double __cdecl tan(double _X); 
#line 523
extern "C" double __cdecl tanh(double _X); 
#line 524
extern "C" __declspec(dllimport) double __cdecl tgamma(double _X); 
#line 525
extern "C" __declspec(dllimport) double __cdecl trunc(double _X); 
#line 527
extern "C" { __declspec(dllimport) double __cdecl atof(const char * _String); } 
#line 528
extern "C" { __declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); } 
#line 530
extern "C" { __declspec(dllimport) double __cdecl _cabs(_complex _Complex_value); } 
#line 531
extern "C" __declspec(dllimport) double __cdecl ceil(double _X); 
#line 533
extern "C" { __declspec(dllimport) double __cdecl _chgsign(double _X); } 
#line 534
extern "C" { __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); } 
#line 536
extern "C" __declspec(dllimport) double __cdecl floor(double _X); 
#line 537
extern "C" __declspec(dllimport) double __cdecl frexp(double _X, int * _Y); 
#line 538
extern "C" { __declspec(dllimport) double __cdecl _hypot(double _X, double _Y); } 
#line 539
extern "C" { __declspec(dllimport) double __cdecl _j0(double _X); } 
#line 540
extern "C" { __declspec(dllimport) double __cdecl _j1(double _X); } 
#line 541
extern "C" { __declspec(dllimport) double __cdecl _jn(int _X, double _Y); } 
#line 542
extern "C" __declspec(dllimport) double __cdecl ldexp(double _X, int _Y); 
#line 547 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { int __cdecl _matherr(_exception * _Except); } 
#line 550 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __declspec(dllimport) double __cdecl modf(double _X, double * _Y); } 
#line 551
extern "C" { __declspec(dllimport) double __cdecl _y0(double _X); } 
#line 552
extern "C" { __declspec(dllimport) double __cdecl _y1(double _X); } 
#line 553
extern "C" { __declspec(dllimport) double __cdecl _yn(int _X, double _Y); } 
#line 555
extern "C" { __inline double __cdecl hypot(double _X, double _Y) 
#line 556
{ 
#line 557
return _hypot(_X, _Y); 
#line 558
} } 
#line 561
extern "C" { __declspec(dllimport) float __cdecl acoshf(float _X); } 
#line 562
extern "C" { __declspec(dllimport) float __cdecl asinhf(float _X); } 
#line 563
extern "C" { __declspec(dllimport) float __cdecl atanhf(float _X); } 
#line 564
extern "C" { __declspec(dllimport) float __cdecl cbrtf(float _X); } 
#line 565
extern "C" { __declspec(dllimport) float __cdecl _chgsignf(float _X); } 
#line 566
extern "C" { __declspec(dllimport) float __cdecl copysignf(float _X, float _Y); } 
#line 567
extern "C" { __declspec(dllimport) float __cdecl _copysignf(float _Number, float _Sign); } 
#line 568
extern "C" { __declspec(dllimport) float __cdecl erff(float _X); } 
#line 569
extern "C" { __declspec(dllimport) float __cdecl erfcf(float _X); } 
#line 570
extern "C" { __declspec(dllimport) float __cdecl expm1f(float _X); } 
#line 571
extern "C" { __declspec(dllimport) float __cdecl exp2f(float _X); } 
#line 572
extern "C" { __declspec(dllimport) float __cdecl fdimf(float _X, float _Y); } 
#line 573
extern "C" { __declspec(dllimport) float __cdecl fmaf(float _X, float _Y, float _Z); } 
#line 574
extern "C" { __declspec(dllimport) float __cdecl fmaxf(float _X, float _Y); } 
#line 575
extern "C" { __declspec(dllimport) float __cdecl fminf(float _X, float _Y); } 
#line 576
extern "C" { __declspec(dllimport) float __cdecl _hypotf(float _X, float _Y); } 
#line 577
extern "C" { __declspec(dllimport) int __cdecl ilogbf(float _X); } 
#line 578
extern "C" { __declspec(dllimport) float __cdecl lgammaf(float _X); } 
#line 579
extern "C" { __declspec(dllimport) __int64 __cdecl llrintf(float _X); } 
#line 580
extern "C" { __declspec(dllimport) __int64 __cdecl llroundf(float _X); } 
#line 581
extern "C" { __declspec(dllimport) float __cdecl log1pf(float _X); } 
#line 582
extern "C" { __declspec(dllimport) float __cdecl log2f(float _X); } 
#line 583
extern "C" { __declspec(dllimport) float __cdecl logbf(float _X); } 
#line 584
extern "C" { __declspec(dllimport) long __cdecl lrintf(float _X); } 
#line 585
extern "C" { __declspec(dllimport) long __cdecl lroundf(float _X); } 
#line 586
extern "C" { __declspec(dllimport) float __cdecl nanf(const char *); } 
#line 587
extern "C" { __declspec(dllimport) float __cdecl nearbyintf(float _X); } 
#line 588
extern "C" { __declspec(dllimport) float __cdecl nextafterf(float _X, float _Y); } 
#line 589
extern "C" { __declspec(dllimport) float __cdecl nexttowardf(float _X, long double _Y); } 
#line 590
extern "C" { __declspec(dllimport) float __cdecl remainderf(float _X, float _Y); } 
#line 591
extern "C" { __declspec(dllimport) float __cdecl remquof(float _X, float _Y, int * _Z); } 
#line 592
extern "C" { __declspec(dllimport) float __cdecl rintf(float _X); } 
#line 593
extern "C" { __declspec(dllimport) float __cdecl roundf(float _X); } 
#line 594
extern "C" { __declspec(dllimport) float __cdecl scalblnf(float _X, long _Y); } 
#line 595
extern "C" { __declspec(dllimport) float __cdecl scalbnf(float _X, int _Y); } 
#line 596
extern "C" { __declspec(dllimport) float __cdecl tgammaf(float _X); } 
#line 597
extern "C" { __declspec(dllimport) float __cdecl truncf(float _X); } 
#line 601
extern "C" { __declspec(dllimport) int __cdecl _set_SSE2_enable(int _Flag); } 
#line 637 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __inline float __cdecl acosf(float _X) 
#line 638
{ 
#line 639
return (float)acos(_X); 
#line 640
} } 
#line 642
extern "C" { __inline float __cdecl asinf(float _X) 
#line 643
{ 
#line 644
return (float)asin(_X); 
#line 645
} } 
#line 647
extern "C" { __inline float __cdecl atan2f(float _Y, float _X) 
#line 648
{ 
#line 649
return (float)atan2(_Y, _X); 
#line 650
} } 
#line 652
extern "C" { __inline float __cdecl atanf(float _X) 
#line 653
{ 
#line 654
return (float)atan(_X); 
#line 655
} } 
#line 657
extern "C" { __inline float __cdecl ceilf(float _X) 
#line 658
{ 
#line 659
return (float)ceil(_X); 
#line 660
} } 
#line 662
extern "C" { __inline float __cdecl cosf(float _X) 
#line 663
{ 
#line 664
return (float)cos(_X); 
#line 665
} } 
#line 667
extern "C" { __inline float __cdecl coshf(float _X) 
#line 668
{ 
#line 669
return (float)cosh(_X); 
#line 670
} } 
#line 672
extern "C" { __inline float __cdecl expf(float _X) 
#line 673
{ 
#line 674
return (float)exp(_X); 
#line 675
} } 
#line 685 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __inline float __cdecl fabsf(float _X) 
#line 686
{ 
#line 687
return (float)fabs(_X); 
#line 688
} } 
#line 699 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __inline float __cdecl floorf(float _X) 
#line 700
{ 
#line 701
return (float)floor(_X); 
#line 702
} } 
#line 704
extern "C" { __inline float __cdecl fmodf(float _X, float _Y) 
#line 705
{ 
#line 706
return (float)fmod(_X, _Y); 
#line 707
} } 
#line 711 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __inline float __cdecl frexpf(float _X, int *_Y) 
#line 712
{ 
#line 713
return (float)frexp(_X, _Y); 
#line 714
} } 
#line 716
extern "C" { __inline float __cdecl hypotf(float _X, float _Y) 
#line 717
{ 
#line 718
return _hypotf(_X, _Y); 
#line 719
} } 
#line 721
extern "C" { __inline float __cdecl ldexpf(float _X, int _Y) 
#line 722
{ 
#line 723
return (float)ldexp(_X, _Y); 
#line 724
} } 
#line 740 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __inline float __cdecl log10f(float _X) 
#line 741
{ 
#line 742
return (float)log10(_X); 
#line 743
} } 
#line 745
extern "C" { __inline float __cdecl logf(float _X) 
#line 746
{ 
#line 747
return (float)log(_X); 
#line 748
} } 
#line 750
extern "C" { __inline float __cdecl modff(float _X, float *_Y) 
#line 751
{ 
#line 752
double _F, _I; 
#line 753
_F = modf(_X, &_I); 
#line 754
(*_Y) = ((float)_I); 
#line 755
return (float)_F; 
#line 756
} } 
#line 758
extern "C" { __inline float __cdecl powf(float _X, float _Y) 
#line 759
{ 
#line 760
return (float)pow(_X, _Y); 
#line 761
} } 
#line 763
extern "C" { __inline float __cdecl sinf(float _X) 
#line 764
{ 
#line 765
return (float)sin(_X); 
#line 766
} } 
#line 768
extern "C" { __inline float __cdecl sinhf(float _X) 
#line 769
{ 
#line 770
return (float)sinh(_X); 
#line 771
} } 
#line 773
extern "C" { __inline float __cdecl sqrtf(float _X) 
#line 774
{ 
#line 775
return (float)sqrt(_X); 
#line 776
} } 
#line 778
extern "C" { __inline float __cdecl tanf(float _X) 
#line 779
{ 
#line 780
return (float)tan(_X); 
#line 781
} } 
#line 783
extern "C" { __inline float __cdecl tanhf(float _X) 
#line 784
{ 
#line 785
return (float)tanh(_X); 
#line 786
} } 
#line 790 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __declspec(dllimport) long double __cdecl acoshl(long double _X); } 
#line 792
extern "C" { __inline long double __cdecl acosl(long double _X) 
#line 793
{ 
#line 794
return acos((double)_X); 
#line 795
} } 
#line 797
extern "C" { __declspec(dllimport) long double __cdecl asinhl(long double _X); } 
#line 799
extern "C" { __inline long double __cdecl asinl(long double _X) 
#line 800
{ 
#line 801
return asin((double)_X); 
#line 802
} } 
#line 804
extern "C" { __inline long double __cdecl atan2l(long double _Y, long double _X) 
#line 805
{ 
#line 806
return atan2((double)_Y, (double)_X); 
#line 807
} } 
#line 809
extern "C" { __declspec(dllimport) long double __cdecl atanhl(long double _X); } 
#line 811
extern "C" { __inline long double __cdecl atanl(long double _X) 
#line 812
{ 
#line 813
return atan((double)_X); 
#line 814
} } 
#line 816
extern "C" { __declspec(dllimport) long double __cdecl cbrtl(long double _X); } 
#line 818
extern "C" { __inline long double __cdecl ceill(long double _X) 
#line 819
{ 
#line 820
return ceil((double)_X); 
#line 821
} } 
#line 823
extern "C" { __inline long double __cdecl _chgsignl(long double _X) 
#line 824
{ 
#line 825
return _chgsign((double)_X); 
#line 826
} } 
#line 828
extern "C" { __declspec(dllimport) long double __cdecl copysignl(long double _X, long double _Y); } 
#line 830
extern "C" { __inline long double __cdecl _copysignl(long double _X, long double _Y) 
#line 831
{ 
#line 832
return _copysign((double)_X, (double)_Y); 
#line 833
} } 
#line 835
extern "C" { __inline long double __cdecl coshl(long double _X) 
#line 836
{ 
#line 837
return cosh((double)_X); 
#line 838
} } 
#line 840
extern "C" { __inline long double __cdecl cosl(long double _X) 
#line 841
{ 
#line 842
return cos((double)_X); 
#line 843
} } 
#line 845
extern "C" { __declspec(dllimport) long double __cdecl erfl(long double _X); } 
#line 846
extern "C" { __declspec(dllimport) long double __cdecl erfcl(long double _X); } 
#line 848
extern "C" { __inline long double __cdecl expl(long double _X) 
#line 849
{ 
#line 850
return exp((double)_X); 
#line 851
} } 
#line 853
extern "C" { __declspec(dllimport) long double __cdecl exp2l(long double _X); } 
#line 854
extern "C" { __declspec(dllimport) long double __cdecl expm1l(long double _X); } 
#line 856
extern "C" { __inline long double __cdecl fabsl(long double _X) 
#line 857
{ 
#line 858
return fabs((double)_X); 
#line 859
} } 
#line 861
extern "C" { __declspec(dllimport) long double __cdecl fdiml(long double _X, long double _Y); } 
#line 863
extern "C" { __inline long double __cdecl floorl(long double _X) 
#line 864
{ 
#line 865
return floor((double)_X); 
#line 866
} } 
#line 868
extern "C" { __declspec(dllimport) long double __cdecl fmal(long double _X, long double _Y, long double _Z); } 
#line 869
extern "C" { __declspec(dllimport) long double __cdecl fmaxl(long double _X, long double _Y); } 
#line 870
extern "C" { __declspec(dllimport) long double __cdecl fminl(long double _X, long double _Y); } 
#line 872
extern "C" { __inline long double __cdecl fmodl(long double _X, long double _Y) 
#line 873
{ 
#line 874
return fmod((double)_X, (double)_Y); 
#line 875
} } 
#line 877
extern "C" { __inline long double __cdecl frexpl(long double _X, int *_Y) 
#line 878
{ 
#line 879
return frexp((double)_X, _Y); 
#line 880
} } 
#line 882
extern "C" { __declspec(dllimport) int __cdecl ilogbl(long double _X); } 
#line 884
extern "C" { __inline long double __cdecl _hypotl(long double _X, long double _Y) 
#line 885
{ 
#line 886
return _hypot((double)_X, (double)_Y); 
#line 887
} } 
#line 889
extern "C" { __inline long double __cdecl hypotl(long double _X, long double _Y) 
#line 890
{ 
#line 891
return _hypot((double)_X, (double)_Y); 
#line 892
} } 
#line 894
extern "C" { __inline long double __cdecl ldexpl(long double _X, int _Y) 
#line 895
{ 
#line 896
return ldexp((double)_X, _Y); 
#line 897
} } 
#line 899
extern "C" { __declspec(dllimport) long double __cdecl lgammal(long double _X); } 
#line 900
extern "C" { __declspec(dllimport) __int64 __cdecl llrintl(long double _X); } 
#line 901
extern "C" { __declspec(dllimport) __int64 __cdecl llroundl(long double _X); } 
#line 903
extern "C" { __inline long double __cdecl logl(long double _X) 
#line 904
{ 
#line 905
return log((double)_X); 
#line 906
} } 
#line 908
extern "C" { __inline long double __cdecl log10l(long double _X) 
#line 909
{ 
#line 910
return log10((double)_X); 
#line 911
} } 
#line 913
extern "C" { __declspec(dllimport) long double __cdecl log1pl(long double _X); } 
#line 914
extern "C" { __declspec(dllimport) long double __cdecl log2l(long double _X); } 
#line 915
extern "C" { __declspec(dllimport) long double __cdecl logbl(long double _X); } 
#line 916
extern "C" { __declspec(dllimport) long __cdecl lrintl(long double _X); } 
#line 917
extern "C" { __declspec(dllimport) long __cdecl lroundl(long double _X); } 
#line 919
extern "C" { __inline long double __cdecl modfl(long double _X, long double *_Y) 
#line 920
{ 
#line 921
double _F, _I; 
#line 922
_F = modf((double)_X, &_I); 
#line 923
(*_Y) = _I; 
#line 924
return _F; 
#line 925
} } 
#line 926
extern "C" { __declspec(dllimport) long double __cdecl nanl(const char *); } 
#line 927
extern "C" { __declspec(dllimport) long double __cdecl nearbyintl(long double _X); } 
#line 928
extern "C" { __declspec(dllimport) long double __cdecl nextafterl(long double _X, long double _Y); } 
#line 929
extern "C" { __declspec(dllimport) long double __cdecl nexttowardl(long double _X, long double _Y); } 
#line 931
extern "C" { __inline long double __cdecl powl(long double _X, long double _Y) 
#line 932
{ 
#line 933
return pow((double)_X, (double)_Y); 
#line 934
} } 
#line 936
extern "C" { __declspec(dllimport) long double __cdecl remainderl(long double _X, long double _Y); } 
#line 937
extern "C" { __declspec(dllimport) long double __cdecl remquol(long double _X, long double _Y, int * _Z); } 
#line 938
extern "C" { __declspec(dllimport) long double __cdecl rintl(long double _X); } 
#line 939
extern "C" { __declspec(dllimport) long double __cdecl roundl(long double _X); } 
#line 940
extern "C" { __declspec(dllimport) long double __cdecl scalblnl(long double _X, long _Y); } 
#line 941
extern "C" { __declspec(dllimport) long double __cdecl scalbnl(long double _X, int _Y); } 
#line 943
extern "C" { __inline long double __cdecl sinhl(long double _X) 
#line 944
{ 
#line 945
return sinh((double)_X); 
#line 946
} } 
#line 948
extern "C" { __inline long double __cdecl sinl(long double _X) 
#line 949
{ 
#line 950
return sin((double)_X); 
#line 951
} } 
#line 953
extern "C" { __inline long double __cdecl sqrtl(long double _X) 
#line 954
{ 
#line 955
return sqrt((double)_X); 
#line 956
} } 
#line 958
extern "C" { __inline long double __cdecl tanhl(long double _X) 
#line 959
{ 
#line 960
return tanh((double)_X); 
#line 961
} } 
#line 963
extern "C" { __inline long double __cdecl tanl(long double _X) 
#line 964
{ 
#line 965
return tan((double)_X); 
#line 966
} } 
#line 968
extern "C" { __declspec(dllimport) long double __cdecl tgammal(long double _X); } 
#line 969
extern "C" { __declspec(dllimport) long double __cdecl truncl(long double _X); } 
#line 992 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" __declspec(dllimport) double HUGE; 
#line 997 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
extern "C" { __declspec(dllimport) double __cdecl j0(double _X); } 
#line 998
extern "C" { __declspec(dllimport) double __cdecl j1(double _X); } 
#line 999
extern "C" { __declspec(dllimport) double __cdecl jn(int _X, double _Y); } 
#line 1000
extern "C" { __declspec(dllimport) double __cdecl y0(double _X); } 
#line 1001
extern "C" { __declspec(dllimport) double __cdecl y1(double _X); } 
#line 1002
extern "C" { __declspec(dllimport) double __cdecl yn(int _X, double _Y); } 
#line 1012 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
template < class _Ty > inline
        _Ty _Pow_int ( _Ty _X, int _Y ) throw ( )
        { unsigned int _N;
        if ( _Y >= 0 )
                _N = ( unsigned int ) _Y;
        else
                _N = ( unsigned int ) ( - _Y );
        for ( _Ty _Z = _Ty ( 1 );; _X *= _X )
                { if ( ( _N & 1 ) != 0 )
                        _Z *= _X;
                if ( ( _N >>= 1 ) == 0 )
                        return ( _Y < 0 ? _Ty ( 1 ) / _Z : _Z ); } }
#line 1025
inline double __cdecl abs(double _X) throw() 
#line 1026
{ return fabs(_X); } 
#line 1027
inline double __cdecl pow(double _X, int _Y) throw() 
#line 1028
{ return _Pow_int(_X, _Y); } 
#line 1029
inline float __cdecl abs(float _X) throw() 
#line 1030
{ return fabsf(_X); } 
#line 1031
inline float __cdecl acos(float _X) throw() 
#line 1032
{ return acosf(_X); } 
#line 1033
inline float __cdecl acosh(float _X) throw() 
#line 1034
{ return acoshf(_X); } 
#line 1035
inline float __cdecl asin(float _X) throw() 
#line 1036
{ return asinf(_X); } 
#line 1037
inline float __cdecl asinh(float _X) throw() 
#line 1038
{ return asinhf(_X); } 
#line 1039
inline float __cdecl atan(float _X) throw() 
#line 1040
{ return atanf(_X); } 
#line 1041
inline float __cdecl atanh(float _X) throw() 
#line 1042
{ return atanhf(_X); } 
#line 1043
inline float __cdecl atan2(float _Y, float _X) throw() 
#line 1044
{ return atan2f(_Y, _X); } 
#line 1045
inline float __cdecl cbrt(float _X) throw() 
#line 1046
{ return cbrtf(_X); } 
#line 1047
inline float __cdecl ceil(float _X) throw() 
#line 1048
{ return ceilf(_X); } 
#line 1049
inline float __cdecl copysign(float _X, float _Y) throw() 
#line 1050
{ return copysignf(_X, _Y); } 
#line 1051
inline float __cdecl cos(float _X) throw() 
#line 1052
{ return cosf(_X); } 
#line 1053
inline float __cdecl cosh(float _X) throw() 
#line 1054
{ return coshf(_X); } 
#line 1055
inline float __cdecl erf(float _X) throw() 
#line 1056
{ return erff(_X); } 
#line 1057
inline float __cdecl erfc(float _X) throw() 
#line 1058
{ return erfcf(_X); } 
#line 1059
inline float __cdecl exp(float _X) throw() 
#line 1060
{ return expf(_X); } 
#line 1061
inline float __cdecl exp2(float _X) throw() 
#line 1062
{ return exp2f(_X); } 
#line 1063
inline float __cdecl expm1(float _X) throw() 
#line 1064
{ return expm1f(_X); } 
#line 1065
inline float __cdecl fabs(float _X) throw() 
#line 1066
{ return fabsf(_X); } 
#line 1067
inline float __cdecl fdim(float _X, float _Y) throw() 
#line 1068
{ return fdimf(_X, _Y); } 
#line 1069
inline float __cdecl floor(float _X) throw() 
#line 1070
{ return floorf(_X); } 
#line 1071
inline float __cdecl fma(float _X, float _Y, float _Z) throw() 
#line 1072
{ return fmaf(_X, _Y, _Z); } 
#line 1073
inline float __cdecl fmax(float _X, float _Y) throw() 
#line 1074
{ return fmaxf(_X, _Y); } 
#line 1075
inline float __cdecl fmin(float _X, float _Y) throw() 
#line 1076
{ return fminf(_X, _Y); } 
#line 1077
inline float __cdecl fmod(float _X, float _Y) throw() 
#line 1078
{ return fmodf(_X, _Y); } 
#line 1079
inline float __cdecl frexp(float _X, int *_Y) throw() 
#line 1080
{ return frexpf(_X, _Y); } 
#line 1081
inline float __cdecl hypot(float _X, float _Y) throw() 
#line 1082
{ return hypotf(_X, _Y); } 
#line 1083
inline int __cdecl ilogb(float _X) throw() 
#line 1084
{ return ilogbf(_X); } 
#line 1085
inline float __cdecl ldexp(float _X, int _Y) throw() 
#line 1086
{ return ldexpf(_X, _Y); } 
#line 1087
inline float __cdecl lgamma(float _X) throw() 
#line 1088
{ return lgammaf(_X); } 
#line 1089
inline __int64 __cdecl llrint(float _X) throw() 
#line 1090
{ return llrintf(_X); } 
#line 1091
inline __int64 __cdecl llround(float _X) throw() 
#line 1092
{ return llroundf(_X); } 
#line 1093
inline float __cdecl log(float _X) throw() 
#line 1094
{ return logf(_X); } 
#line 1095
inline float __cdecl log10(float _X) throw() 
#line 1096
{ return log10f(_X); } 
#line 1097
inline float __cdecl log1p(float _X) throw() 
#line 1098
{ return log1pf(_X); } 
#line 1099
inline float __cdecl log2(float _X) throw() 
#line 1100
{ return log2f(_X); } 
#line 1101
inline float __cdecl logb(float _X) throw() 
#line 1102
{ return logbf(_X); } 
#line 1103
inline long __cdecl lrint(float _X) throw() 
#line 1104
{ return lrintf(_X); } 
#line 1105
inline long __cdecl lround(float _X) throw() 
#line 1106
{ return lroundf(_X); } 
#line 1107
inline float __cdecl modf(float _X, float *_Y) throw() 
#line 1108
{ return modff(_X, _Y); } 
#line 1109
inline float __cdecl nearbyint(float _X) throw() 
#line 1110
{ return nearbyintf(_X); } 
#line 1111
inline float __cdecl nextafter(float _X, float _Y) throw() 
#line 1112
{ return nextafterf(_X, _Y); } 
#line 1113
inline float __cdecl nexttoward(float _X, long double _Y) throw() 
#line 1114
{ return nexttowardf(_X, _Y); } 
#line 1115
inline float __cdecl pow(float _X, float _Y) throw() 
#line 1116
{ return powf(_X, _Y); } 
#line 1117
inline float __cdecl pow(float _X, int _Y) throw() 
#line 1118
{ return _Pow_int(_X, _Y); } 
#line 1119
inline float __cdecl remainder(float _X, float _Y) throw() 
#line 1120
{ return remainderf(_X, _Y); } 
#line 1121
inline float __cdecl remquo(float _X, float _Y, int *_Z) throw() 
#line 1122
{ return remquof(_X, _Y, _Z); } 
#line 1123
inline float __cdecl rint(float _X) throw() 
#line 1124
{ return rintf(_X); } 
#line 1125
inline float __cdecl round(float _X) throw() 
#line 1126
{ return roundf(_X); } 
#line 1127
inline float __cdecl scalbln(float _X, long _Y) throw() 
#line 1128
{ return scalblnf(_X, _Y); } 
#line 1129
inline float __cdecl scalbn(float _X, int _Y) throw() 
#line 1130
{ return scalbnf(_X, _Y); } 
#line 1131
inline float __cdecl sin(float _X) throw() 
#line 1132
{ return sinf(_X); } 
#line 1133
inline float __cdecl sinh(float _X) throw() 
#line 1134
{ return sinhf(_X); } 
#line 1135
inline float __cdecl sqrt(float _X) throw() 
#line 1136
{ return sqrtf(_X); } 
#line 1137
inline float __cdecl tan(float _X) throw() 
#line 1138
{ return tanf(_X); } 
#line 1139
inline float __cdecl tanh(float _X) throw() 
#line 1140
{ return tanhf(_X); } 
#line 1141
inline float __cdecl tgamma(float _X) throw() 
#line 1142
{ return tgammaf(_X); } 
#line 1143
inline float __cdecl trunc(float _X) throw() 
#line 1144
{ return truncf(_X); } 
#line 1145
inline long double __cdecl abs(long double _X) throw() 
#line 1146
{ return fabsl(_X); } 
#line 1147
inline long double __cdecl acos(long double _X) throw() 
#line 1148
{ return acosl(_X); } 
#line 1149
inline long double __cdecl acosh(long double _X) throw() 
#line 1150
{ return acoshl(_X); } 
#line 1151
inline long double __cdecl asin(long double _X) throw() 
#line 1152
{ return asinl(_X); } 
#line 1153
inline long double __cdecl asinh(long double _X) throw() 
#line 1154
{ return asinhl(_X); } 
#line 1155
inline long double __cdecl atan(long double _X) throw() 
#line 1156
{ return atanl(_X); } 
#line 1157
inline long double __cdecl atanh(long double _X) throw() 
#line 1158
{ return atanhl(_X); } 
#line 1159
inline long double __cdecl atan2(long double _Y, long double _X) throw() 
#line 1160
{ return atan2l(_Y, _X); } 
#line 1161
inline long double __cdecl cbrt(long double _X) throw() 
#line 1162
{ return cbrtl(_X); } 
#line 1163
inline long double __cdecl ceil(long double _X) throw() 
#line 1164
{ return ceill(_X); } 
#line 1165
inline long double __cdecl copysign(long double _X, long double _Y) throw() 
#line 1166
{ return copysignl(_X, _Y); } 
#line 1167
inline long double __cdecl cos(long double _X) throw() 
#line 1168
{ return cosl(_X); } 
#line 1169
inline long double __cdecl cosh(long double _X) throw() 
#line 1170
{ return coshl(_X); } 
#line 1171
inline long double __cdecl erf(long double _X) throw() 
#line 1172
{ return erfl(_X); } 
#line 1173
inline long double __cdecl erfc(long double _X) throw() 
#line 1174
{ return erfcl(_X); } 
#line 1175
inline long double __cdecl exp(long double _X) throw() 
#line 1176
{ return expl(_X); } 
#line 1177
inline long double __cdecl exp2(long double _X) throw() 
#line 1178
{ return exp2l(_X); } 
#line 1179
inline long double __cdecl expm1(long double _X) throw() 
#line 1180
{ return expm1l(_X); } 
#line 1181
inline long double __cdecl fabs(long double _X) throw() 
#line 1182
{ return fabsl(_X); } 
#line 1183
inline long double __cdecl fdim(long double _X, long double _Y) throw() 
#line 1184
{ return fdiml(_X, _Y); } 
#line 1185
inline long double __cdecl floor(long double _X) throw() 
#line 1186
{ return floorl(_X); } 
#line 1187
inline long double __cdecl fma(long double _X, long double _Y, long double _Z) throw() 
#line 1188
{ return fmal(_X, _Y, _Z); } 
#line 1189
inline long double __cdecl fmax(long double _X, long double _Y) throw() 
#line 1190
{ return fmaxl(_X, _Y); } 
#line 1191
inline long double __cdecl fmin(long double _X, long double _Y) throw() 
#line 1192
{ return fminl(_X, _Y); } 
#line 1193
inline long double __cdecl fmod(long double _X, long double _Y) throw() 
#line 1194
{ return fmodl(_X, _Y); } 
#line 1195
inline long double __cdecl frexp(long double _X, int *_Y) throw() 
#line 1196
{ return frexpl(_X, _Y); } 
#line 1197
inline long double __cdecl hypot(long double _X, long double _Y) throw() 
#line 1198
{ return hypotl(_X, _Y); } 
#line 1199
inline int __cdecl ilogb(long double _X) throw() 
#line 1200
{ return ilogbl(_X); } 
#line 1201
inline long double __cdecl ldexp(long double _X, int _Y) throw() 
#line 1202
{ return ldexpl(_X, _Y); } 
#line 1203
inline long double __cdecl lgamma(long double _X) throw() 
#line 1204
{ return lgammal(_X); } 
#line 1205
inline __int64 __cdecl llrint(long double _X) throw() 
#line 1206
{ return llrintl(_X); } 
#line 1207
inline __int64 __cdecl llround(long double _X) throw() 
#line 1208
{ return llroundl(_X); } 
#line 1209
inline long double __cdecl log(long double _X) throw() 
#line 1210
{ return logl(_X); } 
#line 1211
inline long double __cdecl log10(long double _X) throw() 
#line 1212
{ return log10l(_X); } 
#line 1213
inline long double __cdecl log1p(long double _X) throw() 
#line 1214
{ return log1pl(_X); } 
#line 1215
inline long double __cdecl log2(long double _X) throw() 
#line 1216
{ return log2l(_X); } 
#line 1217
inline long double __cdecl logb(long double _X) throw() 
#line 1218
{ return logbl(_X); } 
#line 1219
inline long __cdecl lrint(long double _X) throw() 
#line 1220
{ return lrintl(_X); } 
#line 1221
inline long __cdecl lround(long double _X) throw() 
#line 1222
{ return lroundl(_X); } 
#line 1223
inline long double __cdecl modf(long double _X, long double *_Y) throw() 
#line 1224
{ return modfl(_X, _Y); } 
#line 1225
inline long double __cdecl nearbyint(long double _X) throw() 
#line 1226
{ return nearbyintl(_X); } 
#line 1227
inline long double __cdecl nextafter(long double _X, long double _Y) throw() 
#line 1228
{ return nextafterl(_X, _Y); } 
#line 1229
inline long double __cdecl nexttoward(long double _X, long double _Y) throw() 
#line 1230
{ return nexttowardl(_X, _Y); } 
#line 1231
inline long double __cdecl pow(long double _X, long double _Y) throw() 
#line 1232
{ return powl(_X, _Y); } 
#line 1233
inline long double __cdecl pow(long double _X, int _Y) throw() 
#line 1234
{ return _Pow_int(_X, _Y); } 
#line 1235
inline long double __cdecl remainder(long double _X, long double _Y) throw() 
#line 1236
{ return remainderl(_X, _Y); } 
#line 1237
inline long double __cdecl remquo(long double _X, long double _Y, int *_Z) throw() 
#line 1238
{ return remquol(_X, _Y, _Z); } 
#line 1239
inline long double __cdecl rint(long double _X) throw() 
#line 1240
{ return rintl(_X); } 
#line 1241
inline long double __cdecl round(long double _X) throw() 
#line 1242
{ return roundl(_X); } 
#line 1243
inline long double __cdecl scalbln(long double _X, long _Y) throw() 
#line 1244
{ return scalblnl(_X, _Y); } 
#line 1245
inline long double __cdecl scalbn(long double _X, int _Y) throw() 
#line 1246
{ return scalbnl(_X, _Y); } 
#line 1247
inline long double __cdecl sin(long double _X) throw() 
#line 1248
{ return sinl(_X); } 
#line 1249
inline long double __cdecl sinh(long double _X) throw() 
#line 1250
{ return sinhl(_X); } 
#line 1251
inline long double __cdecl sqrt(long double _X) throw() 
#line 1252
{ return sqrtl(_X); } 
#line 1253
inline long double __cdecl tan(long double _X) throw() 
#line 1254
{ return tanl(_X); } 
#line 1255
inline long double __cdecl tanh(long double _X) throw() 
#line 1256
{ return tanhl(_X); } 
#line 1257
inline long double __cdecl tgamma(long double _X) throw() 
#line 1258
{ return tgammal(_X); } 
#line 1259
inline long double __cdecl trunc(long double _X) throw() 
#line 1260
{ return truncl(_X); } 
#line 1265 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\math.h"
#pragma pack ( pop )
#line 28 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
#pragma pack ( push, 8 )
#line 52 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { typedef int (__cdecl *_onexit_t)(void); }
#line 78 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { typedef 
#line 75
struct _div_t { 
#line 76
int quot; 
#line 77
int rem; 
#line 78
} div_t; }
#line 83
extern "C" { typedef 
#line 80
struct _ldiv_t { 
#line 81
long quot; 
#line 82
long rem; 
#line 83
} ldiv_t; }
#line 88
extern "C" { typedef 
#line 85
struct _lldiv_t { 
#line 86
__int64 quot; 
#line 87
__int64 rem; 
#line 88
} lldiv_t; }
#line 102 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
#pragma pack ( 4 )
#line 105
extern "C" { typedef 
#line 103
struct { 
#line 104
unsigned char ld[10]; 
#line 105
} _LDOUBLE; }
#pragma pack ( )
#line 124 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { typedef 
#line 122
struct { 
#line 123
double x; 
#line 124
} _CRT_DOUBLE; }
#line 128
extern "C" { typedef 
#line 126
struct { 
#line 127
float f; 
#line 128
} _CRT_FLOAT; }
#line 139
extern "C" { typedef 
#line 134
struct { 
#line 138
long double x; 
#line 139
} _LONGDOUBLE; }
#line 143
#pragma pack ( 4 )
#line 146
extern "C" { typedef 
#line 144
struct { 
#line 145
unsigned char ld12[12]; 
#line 146
} _LDBL12; }
#pragma pack ( )
#line 170 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" __declspec(dllimport) int __mb_cur_max; 
#line 175 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_func(); } 
#line 176
extern "C" { __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t); } 
#line 215 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { typedef void (__cdecl *_purecall_handler)(void); }
#line 218
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler); } 
#line 219
extern "C" { __declspec(dllimport) _purecall_handler __cdecl _get_purecall_handler(); } 
#line 235 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { typedef void (__cdecl *_invalid_parameter_handler)(const __wchar_t *, const __wchar_t *, const __wchar_t *, unsigned, uintptr_t); }
#line 238
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler); } 
#line 239
extern "C" { __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(); } 
#line 252 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) unsigned long *__cdecl __doserrno(); } 
#line 255
extern "C" { errno_t __cdecl _set_doserrno(unsigned long _Value); } 
#line 256
extern "C" { errno_t __cdecl _get_doserrno(unsigned long * _Value); } 
#line 259
extern "C" { __declspec(dllimport) char **__cdecl __sys_errlist(); } 
#line 262
extern "C" { __declspec(dllimport) int *__cdecl __sys_nerr(); } 
#line 268
extern "C" { __declspec(dllimport) int *__cdecl __p___argc(); } 
#line 269
extern "C" { __declspec(dllimport) char ***__cdecl __p___argv(); } 
#line 270
extern "C" { __declspec(dllimport) __wchar_t ***__cdecl __p___wargv(); } 
#line 271
extern "C" { __declspec(dllimport) char ***__cdecl __p__environ(); } 
#line 272
extern "C" { __declspec(dllimport) __wchar_t ***__cdecl __p__wenviron(); } 
#line 275 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) char **__cdecl __p__pgmptr(); } 
#line 276
extern "C" { __declspec(dllimport) __wchar_t **__cdecl __p__wpgmptr(); } 
#line 288 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" __declspec(dllimport) int __argc; 
#line 289
extern "C" __declspec(dllimport) char **__argv; 
#line 290
extern "C" __declspec(dllimport) __wchar_t **__wargv; 
#line 306 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" __declspec(dllimport) char **_environ; 
#line 307
extern "C" __declspec(dllimport) __wchar_t **_wenviron; 
#line 311 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" __declspec(dllimport) char *_pgmptr; 
#line 312
extern "C" __declspec(dllimport) __wchar_t *_wpgmptr; 
#line 339 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { errno_t __cdecl _get_pgmptr(char ** _Value); } 
#line 340
extern "C" { errno_t __cdecl _get_wpgmptr(__wchar_t ** _Value); } 
#line 346 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" __declspec(dllimport) int _fmode; 
#line 353 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _set_fmode(int _Mode); } 
#line 354
extern "C" { __declspec(dllimport) errno_t __cdecl _get_fmode(int * _PMode); } 
#line 363 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
template< class _CountofType, size_t _SizeOfArray> char (*__countof_helper(_CountofType (& _Array)[_SizeOfArray]))[_SizeOfArray]; 
#line 376 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl exit(int _Code); } 
#line 378
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int _Code); } 
#line 379
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl abort(); } 
#line 382 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _set_abort_behavior(unsigned _Flags, unsigned _Mask); } 
#line 384
extern "C" { int __cdecl abs(int _X); } 
#line 385
extern "C" { long __cdecl labs(long _X); } 
#line 386
extern "C" { __int64 __cdecl llabs(__int64 _X); } 
#line 388
extern "C" { __int64 __cdecl _abs64(__int64); } 
#line 426 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { int __cdecl atexit(void (__cdecl *)(void)); } 
#line 428 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) double __cdecl atof(const char * _String); } 
#line 429
extern "C" { __declspec(dllimport) double __cdecl _atof_l(const char * _String, _locale_t _Locale); } 
#line 430
extern "C" { __declspec(dllimport) int __cdecl atoi(const char * _Str); } 
#line 431
extern "C" { __declspec(dllimport) int __cdecl _atoi_l(const char * _Str, _locale_t _Locale); } 
#line 432
extern "C" { __declspec(dllimport) long __cdecl atol(const char * _Str); } 
#line 433
extern "C" { __declspec(dllimport) long __cdecl _atol_l(const char * _Str, _locale_t _Locale); } 
#line 434
extern "C" { __declspec(dllimport) __int64 __cdecl atoll(const char * _Str); } 
#line 435
extern "C" { __declspec(dllimport) __int64 __cdecl _atoll_l(const char * _Str, _locale_t _Locale); } 
#line 439
extern "C" { __declspec(dllimport) void *__cdecl bsearch_s(const void * _Key, const void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context); } 
#line 443 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) void *__cdecl bsearch(const void * _Key, const void * _Base, size_t _NumOfElements, size_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(const void *, const void *)); } 
#line 448
extern "C" { __declspec(dllimport) void __cdecl qsort_s(void * _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(void *, const void *, const void *), void * _Context); } 
#line 452 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl qsort(void * _Base, size_t _NumOfElements, size_t _SizeOfElements, int (__cdecl * _PtFuncCompare)(const void *, const void *)); } 
#line 456 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { unsigned short __cdecl _byteswap_ushort(unsigned short _Short); } 
#line 457
extern "C" { unsigned long __cdecl _byteswap_ulong(unsigned long _Long); } 
#line 458
extern "C" { unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Int64); } 
#line 459
extern "C" { __declspec(dllimport) div_t __cdecl div(int _Numerator, int _Denominator); } 
#line 462
extern "C" { __declspec(dllimport) char *__cdecl getenv(const char * _VarName); } 
#line 464
extern "C" { __declspec(dllimport) errno_t __cdecl getenv_s(size_t * _ReturnSize, char * _DstBuf, rsize_t _DstSize, const char * _VarName); } 
#line 466 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
template < size_t _Size > inline errno_t __cdecl getenv_s ( size_t * _ReturnSize, char ( & _Dest ) [ _Size ], const char * _VarName ) throw ( ) { return getenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 472 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _dupenv_s(char ** _PBuffer, size_t * _PBufferSizeInBytes, const char * _VarName); } 
#line 479 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _itoa_s(int _Value, char * _DstBuf, size_t _Size, int _Radix); } 
#line 480
template < size_t _Size > inline errno_t __cdecl _itoa_s ( int _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 481
extern "C" { __declspec(dllimport) char *__cdecl _itoa(int _Value, char * _Dest, int _Radix); } 
#line 482
extern "C" { __declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 _Val, char * _DstBuf, size_t _Size, int _Radix); } 
#line 483
extern "C" { __declspec(dllimport) char *__cdecl _i64toa(__int64 _Val, char * _DstBuf, int _Radix); } 
#line 484
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 _Val, char * _DstBuf, size_t _Size, int _Radix); } 
#line 485
extern "C" { __declspec(dllimport) char *__cdecl _ui64toa(unsigned __int64 _Val, char * _DstBuf, int _Radix); } 
#line 486
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64(const char * _String); } 
#line 487
extern "C" { __declspec(dllimport) __int64 __cdecl _atoi64_l(const char * _String, _locale_t _Locale); } 
#line 488
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64(const char * _String, char ** _EndPtr, int _Radix); } 
#line 489
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoi64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 490
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(const char * _String, char ** _EndPtr, int _Radix); } 
#line 491
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(const char * _String, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 492
extern "C" { __declspec(dllimport) ldiv_t __cdecl ldiv(long _Numerator, long _Denominator); } 
#line 493
extern "C" { __declspec(dllimport) lldiv_t __cdecl lldiv(__int64 _Numerator, __int64 _Denominator); } 
#line 497
inline long abs(long _X) throw() 
#line 498
{ 
#line 499
return labs(_X); 
#line 500
} 
#line 501
inline __int64 abs(__int64 _X) throw() 
#line 502
{ 
#line 503
return llabs(_X); 
#line 504
} 
#line 505
inline ldiv_t div(long _A1, long _A2) throw() 
#line 506
{ 
#line 507
return ldiv(_A1, _A2); 
#line 508
} 
#line 509
inline lldiv_t div(__int64 _A1, __int64 _A2) throw() 
#line 510
{ 
#line 511
return lldiv(_A1, _A2); 
#line 512
} 
#line 515 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ltoa_s(long _Val, char * _DstBuf, size_t _Size, int _Radix); } 
#line 516
template < size_t _Size > inline errno_t __cdecl _ltoa_s ( long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 517
extern "C" { __declspec(dllimport) char *__cdecl _ltoa(long _Value, char * _Dest, int _Radix); } 
#line 518
extern "C" { __declspec(dllimport) int __cdecl mblen(const char * _Ch, size_t _MaxCount); } 
#line 519
extern "C" { __declspec(dllimport) int __cdecl _mblen_l(const char * _Ch, size_t _MaxCount, _locale_t _Locale); } 
#line 520
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen(const char * _Str); } 
#line 521
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrlen_l(const char * _Str, _locale_t _Locale); } 
#line 522
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen(const char * _Str, size_t _MaxCount); } 
#line 523
extern "C" { __declspec(dllimport) size_t __cdecl _mbstrnlen_l(const char * _Str, size_t _MaxCount, _locale_t _Locale); } 
#line 524
extern "C" { __declspec(dllimport) int __cdecl mbtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes); } 
#line 525
extern "C" { __declspec(dllimport) int __cdecl _mbtowc_l(__wchar_t * _DstCh, const char * _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale); } 
#line 526
extern "C" { __declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount); } 
#line 527
template < size_t _Size > inline errno_t __cdecl mbstowcs_s ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount ) throw ( ) { return mbstowcs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
#line 528
extern "C" { __declspec(dllimport) size_t __cdecl mbstowcs(__wchar_t * _Dest, const char * _Source, size_t _MaxCount); } 
#line 530
extern "C" { __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, __wchar_t * _DstBuf, size_t _SizeInWords, const char * _SrcBuf, size_t _MaxCount, _locale_t _Locale); } 
#line 531
template < size_t _Size > inline errno_t __cdecl _mbstowcs_s_l ( size_t * _PtNumOfCharConverted, wchar_t ( & _Dest ) [ _Size ], const char * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _mbstowcs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
#line 532
extern "C" { __declspec(dllimport) size_t __cdecl _mbstowcs_l(__wchar_t * _Dest, const char * _Source, size_t _MaxCount, _locale_t _Locale); } 
#line 534
extern "C" { __declspec(dllimport) int __cdecl rand(); } 
#line 539 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _set_error_mode(int _Mode); } 
#line 541
extern "C" { __declspec(dllimport) void __cdecl srand(unsigned _Seed); } 
#line 542
extern "C" { __declspec(dllimport) double __cdecl strtod(const char * _Str, char ** _EndPtr); } 
#line 543
extern "C" { __declspec(dllimport) double __cdecl _strtod_l(const char * _Str, char ** _EndPtr, _locale_t _Locale); } 
#line 544
extern "C" { __declspec(dllimport) long __cdecl strtol(const char * _Str, char ** _EndPtr, int _Radix); } 
#line 545
extern "C" { __declspec(dllimport) long __cdecl _strtol_l(const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 546
extern "C" { __declspec(dllimport) __int64 __cdecl strtoll(const char * _Str, char ** _EndPtr, int _Radix); } 
#line 547
extern "C" { __declspec(dllimport) __int64 __cdecl _strtoll_l(const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 548
extern "C" { __declspec(dllimport) unsigned long __cdecl strtoul(const char * _Str, char ** _EndPtr, int _Radix); } 
#line 549
extern "C" { __declspec(dllimport) unsigned long __cdecl _strtoul_l(const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 550
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl strtoull(const char * _Str, char ** _EndPtr, int _Radix); } 
#line 551
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _strtoull_l(const char * _Str, char ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 552
extern "C" { __declspec(dllimport) long double __cdecl strtold(const char * _Str, char ** _EndPtr); } 
#line 553
extern "C" { __declspec(dllimport) long double __cdecl _strtold_l(const char * _Str, char ** _EndPtr, _locale_t _Locale); } 
#line 554
extern "C" { __declspec(dllimport) float __cdecl strtof(const char * _Str, char ** _EndPtr); } 
#line 555
extern "C" { __declspec(dllimport) float __cdecl _strtof_l(const char * _Str, char ** _EndPtr, _locale_t _Locale); } 
#line 560
extern "C" { __declspec(dllimport) int __cdecl system(const char * _Command); } 
#line 564 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long _Val, char * _DstBuf, size_t _Size, int _Radix); } 
#line 565
template < size_t _Size > inline errno_t __cdecl _ultoa_s ( unsigned long _Value, char ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultoa_s ( _Value, _Dest, _Size, _Radix ); }
#line 566
extern "C" { __declspec(dllimport) char *__cdecl _ultoa(unsigned long _Value, char * _Dest, int _Radix); } 
#line 567
extern "C" { __declspec(dllimport) int __cdecl wctomb(char * _MbCh, __wchar_t _WCh); } 
#line 568
extern "C" { __declspec(dllimport) int __cdecl _wctomb_l(char * _MbCh, __wchar_t _WCh, _locale_t _Locale); } 
#line 570
extern "C" { __declspec(dllimport) errno_t __cdecl wctomb_s(int * _SizeConverted, char * _MbCh, rsize_t _SizeInBytes, __wchar_t _WCh); } 
#line 572 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wctomb_s_l(int * _SizeConverted, char * _MbCh, size_t _SizeInBytes, __wchar_t _WCh, _locale_t _Locale); } 
#line 573
extern "C" { __declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes); } 
#line 574
template < size_t _Size > inline errno_t __cdecl wcstombs_s ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount ) throw ( ) { return wcstombs_s ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount ); }
#line 575
extern "C" { __declspec(dllimport) size_t __cdecl wcstombs(char * _Dest, const __wchar_t * _Source, size_t _MaxCount); } 
#line 576
extern "C" { __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char * _Dst, size_t _DstSizeInBytes, const __wchar_t * _Src, size_t _MaxCountInBytes, _locale_t _Locale); } 
#line 577
template < size_t _Size > inline errno_t __cdecl _wcstombs_s_l ( size_t * _PtNumOfCharConverted, char ( & _Dest ) [ _Size ], const wchar_t * _Source, size_t _MaxCount, _locale_t _Locale ) throw ( ) { return _wcstombs_s_l ( _PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale ); }
#line 578
extern "C" { __declspec(dllimport) size_t __cdecl _wcstombs_l(char * _Dest, const __wchar_t * _Source, size_t _MaxCount, _locale_t _Locale); } 
#line 640 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl calloc(size_t _Count, size_t _Size); } 
#line 641
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl free(void * _Memory); } 
#line 642
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl malloc(size_t _Size); } 
#line 644
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl realloc(void * _Memory, size_t _NewSize); } 
#line 646
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _recalloc(void * _Memory, size_t _Count, size_t _Size); } 
#line 647
extern "C" { __declspec(dllimport) __declspec(noalias) void __cdecl _aligned_free(void * _Memory); } 
#line 648
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_malloc(size_t _Size, size_t _Alignment); } 
#line 649
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_malloc(size_t _Size, size_t _Alignment, size_t _Offset); } 
#line 651
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_realloc(void * _Memory, size_t _NewSize, size_t _Alignment); } 
#line 653
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_recalloc(void * _Memory, size_t _Count, size_t _Size, size_t _Alignment); } 
#line 655
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_realloc(void * _Memory, size_t _NewSize, size_t _Alignment, size_t _Offset); } 
#line 657
extern "C" { __declspec(dllimport) __declspec(noalias) __declspec(restrict) void *__cdecl _aligned_offset_recalloc(void * _Memory, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset); } 
#line 658
extern "C" { __declspec(dllimport) size_t __cdecl _aligned_msize(void * _Memory, size_t _Alignment, size_t _Offset); } 
#line 685 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _itow_s(int _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
#line 686
template < size_t _Size > inline errno_t __cdecl _itow_s ( int _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _itow_s ( _Value, _Dest, _Size, _Radix ); }
#line 687
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _itow(int _Value, __wchar_t * _Dest, int _Radix); } 
#line 688
extern "C" { __declspec(dllimport) errno_t __cdecl _ltow_s(long _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
#line 689
template < size_t _Size > inline errno_t __cdecl _ltow_s ( long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ltow_s ( _Value, _Dest, _Size, _Radix ); }
#line 690
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ltow(long _Value, __wchar_t * _Dest, int _Radix); } 
#line 691
extern "C" { __declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
#line 692
template < size_t _Size > inline errno_t __cdecl _ultow_s ( unsigned long _Value, wchar_t ( & _Dest ) [ _Size ], int _Radix ) throw ( ) { return _ultow_s ( _Value, _Dest, _Size, _Radix ); }
#line 693
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ultow(unsigned long _Value, __wchar_t * _Dest, int _Radix); } 
#line 694
extern "C" { __declspec(dllimport) double __cdecl wcstod(const __wchar_t * _Str, __wchar_t ** _EndPtr); } 
#line 695
extern "C" { __declspec(dllimport) double __cdecl _wcstod_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, _locale_t _Locale); } 
#line 696
extern "C" { __declspec(dllimport) long __cdecl wcstol(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
#line 697
extern "C" { __declspec(dllimport) long __cdecl _wcstol_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 698
extern "C" { __declspec(dllimport) __int64 __cdecl wcstoll(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
#line 699
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoll_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 700
extern "C" { __declspec(dllimport) unsigned long __cdecl wcstoul(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
#line 701
extern "C" { __declspec(dllimport) unsigned long __cdecl _wcstoul_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 702
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl wcstoull(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
#line 703
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoull_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 704
extern "C" { __declspec(dllimport) long double __cdecl wcstold(const __wchar_t * _Str, __wchar_t ** _EndPtr); } 
#line 705
extern "C" { __declspec(dllimport) long double __cdecl _wcstold_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, _locale_t _Locale); } 
#line 706
extern "C" { __declspec(dllimport) float __cdecl wcstof(const __wchar_t * _Str, __wchar_t ** _EndPtr); } 
#line 707
extern "C" { __declspec(dllimport) float __cdecl _wcstof_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, _locale_t _Locale); } 
#line 711
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetenv(const __wchar_t * _VarName); } 
#line 712
extern "C" { __declspec(dllimport) errno_t __cdecl _wgetenv_s(size_t * _ReturnSize, __wchar_t * _DstBuf, size_t _DstSizeInWords, const __wchar_t * _VarName); } 
#line 713
template < size_t _Size > inline errno_t __cdecl _wgetenv_s ( size_t * _ReturnSize, wchar_t ( & _Dest ) [ _Size ], const wchar_t * _VarName ) throw ( ) { return _wgetenv_s ( _ReturnSize, _Dest, _Size, _VarName ); }
#line 720 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wdupenv_s(__wchar_t ** _Buffer, size_t * _BufferSizeInWords, const __wchar_t * _VarName); } 
#line 728 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _wsystem(const __wchar_t * _Command); } 
#line 733 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) double __cdecl _wtof(const __wchar_t * _Str); } 
#line 734
extern "C" { __declspec(dllimport) double __cdecl _wtof_l(const __wchar_t * _Str, _locale_t _Locale); } 
#line 735
extern "C" { __declspec(dllimport) int __cdecl _wtoi(const __wchar_t * _Str); } 
#line 736
extern "C" { __declspec(dllimport) int __cdecl _wtoi_l(const __wchar_t * _Str, _locale_t _Locale); } 
#line 737
extern "C" { __declspec(dllimport) long __cdecl _wtol(const __wchar_t * _Str); } 
#line 738
extern "C" { __declspec(dllimport) long __cdecl _wtol_l(const __wchar_t * _Str, _locale_t _Locale); } 
#line 739
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoll(const __wchar_t * _Str); } 
#line 740
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoll_l(const __wchar_t * _Str, _locale_t _Locale); } 
#line 742
extern "C" { __declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
#line 743
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _i64tow(__int64 _Val, __wchar_t * _DstBuf, int _Radix); } 
#line 744
extern "C" { __declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 _Val, __wchar_t * _DstBuf, size_t _SizeInWords, int _Radix); } 
#line 745
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _ui64tow(unsigned __int64 _Val, __wchar_t * _DstBuf, int _Radix); } 
#line 746
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64(const __wchar_t * _Str); } 
#line 747
extern "C" { __declspec(dllimport) __int64 __cdecl _wtoi64_l(const __wchar_t * _Str, _locale_t _Locale); } 
#line 748
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
#line 749
extern "C" { __declspec(dllimport) __int64 __cdecl _wcstoi64_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 750
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix); } 
#line 751
extern "C" { __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(const __wchar_t * _Str, __wchar_t ** _EndPtr, int _Radix, _locale_t _Locale); } 
#line 770 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) char *__cdecl _fullpath(char * _FullPath, const char * _Path, size_t _SizeInBytes); } 
#line 778 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _ecvt_s(char * _DstBuf, size_t _Size, double _Val, int _NumOfDights, int * _PtDec, int * _PtSign); } 
#line 779
template < size_t _Size > inline errno_t __cdecl _ecvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _ecvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
#line 780
extern "C" { __declspec(dllimport) char *__cdecl _ecvt(double _Val, int _NumOfDigits, int * _PtDec, int * _PtSign); } 
#line 781
extern "C" { __declspec(dllimport) errno_t __cdecl _fcvt_s(char * _DstBuf, size_t _Size, double _Val, int _NumOfDec, int * _PtDec, int * _PtSign); } 
#line 782
template < size_t _Size > inline errno_t __cdecl _fcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits, int * _PtDec, int * _PtSign ) throw ( ) { return _fcvt_s ( _Dest, _Size, _Value, _NumOfDigits, _PtDec, _PtSign ); }
#line 783
extern "C" { __declspec(dllimport) char *__cdecl _fcvt(double _Val, int _NumOfDec, int * _PtDec, int * _PtSign); } 
#line 784
extern "C" { __declspec(dllimport) errno_t __cdecl _gcvt_s(char * _DstBuf, size_t _Size, double _Val, int _NumOfDigits); } 
#line 785
template < size_t _Size > inline errno_t __cdecl _gcvt_s ( char ( & _Dest ) [ _Size ], double _Value, int _NumOfDigits ) throw ( ) { return _gcvt_s ( _Dest, _Size, _Value, _NumOfDigits ); }
#line 786
extern "C" { __declspec(dllimport) char *__cdecl _gcvt(double _Val, int _NumOfDigits, char * _DstBuf); } 
#line 788
extern "C" { __declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * _Result, char * _Str); } 
#line 789
extern "C" { __declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * _Result, char * _Str); } 
#line 790
extern "C" { __declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * _Result, const char * _Str); } 
#line 791
extern "C" { __declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char * _Str, _locale_t _Locale); } 
#line 792
extern "C" { __declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * _Result, char * _Str, _locale_t _Locale); } 
#line 793
extern "C" { __declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * _Result, const char * _Str, _locale_t _Locale); } 
#line 794
extern "C" { unsigned long __cdecl _lrotl(unsigned long _Val, int _Shift); } 
#line 795
extern "C" { unsigned long __cdecl _lrotr(unsigned long _Val, int _Shift); } 
#line 796
extern "C" { __declspec(dllimport) errno_t __cdecl _makepath_s(char * _PathResult, size_t _SizeInWords, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); } 
#line 798
template < size_t _Size > inline errno_t __cdecl _makepath_s ( char ( & _Path ) [ _Size ], const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext ) throw ( ) { return _makepath_s ( _Path, _Size, _Drive, _Dir, _Filename, _Ext ); }
#line 799
extern "C" { __declspec(dllimport) void __cdecl _makepath(char * _Path, const char * _Drive, const char * _Dir, const char * _Filename, const char * _Ext); } 
#line 826 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { _onexit_t __cdecl _onexit(_onexit_t _Func); } 
#line 831 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl perror(const char * _ErrMsg); } 
#line 834 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
#pragma warning (push)
#pragma warning (disable:6540)
#line 838
extern "C" { __declspec(dllimport) int __cdecl _putenv(const char * _EnvString); } 
#line 839
extern "C" { __declspec(dllimport) errno_t __cdecl _putenv_s(const char * _Name, const char * _Value); } 
#line 842 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { unsigned __cdecl _rotl(unsigned _Val, int _Shift); } 
#line 843
extern "C" { unsigned __int64 __cdecl _rotl64(unsigned __int64 _Val, int _Shift); } 
#line 844
extern "C" { unsigned __cdecl _rotr(unsigned _Val, int _Shift); } 
#line 845
extern "C" { unsigned __int64 __cdecl _rotr64(unsigned __int64 _Val, int _Shift); } 
#pragma warning (pop)
#line 849
extern "C" { __declspec(dllimport) errno_t __cdecl _searchenv_s(const char * _Filename, const char * _EnvVar, char * _ResultPath, size_t _SizeInBytes); } 
#line 850
template < size_t _Size > inline errno_t __cdecl _searchenv_s ( const char * _Filename, const char * _EnvVar, char ( & _ResultPath ) [ _Size ] ) throw ( ) { return _searchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
#line 851
extern "C" { __declspec(dllimport) void __cdecl _searchenv(const char * _Filename, const char * _EnvVar, char * _ResultPath); } 
#line 854 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl _splitpath(const char * _FullPath, char * _Drive, char * _Dir, char * _Filename, char * _Ext); } 
#line 855
extern "C" { __declspec(dllimport) errno_t __cdecl _splitpath_s(const char * _FullPath, char * _Drive, size_t _DriveSize, char * _Dir, size_t _DirSize, char * _Filename, size_t _FilenameSize, char * _Ext, size_t _ExtSize); } 
#line 860
template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _splitpath_s ( const char * _Dest, char ( & _Drive ) [ _DriveSize ], char ( & _Dir ) [ _DirSize ], char ( & _Name ) [ _NameSize ], char ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _splitpath_s ( _Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 862
extern "C" { __declspec(dllimport) void __cdecl _swab(char * _Buf1, char * _Buf2, int _SizeInBytes); } 
#line 873 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wfullpath(__wchar_t * _FullPath, const __wchar_t * _Path, size_t _SizeInWords); } 
#line 879 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _wmakepath_s(__wchar_t * _PathResult, size_t _SIZE, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); } 
#line 881
template < size_t _Size > inline errno_t __cdecl _wmakepath_s ( wchar_t ( & _ResultPath ) [ _Size ], const wchar_t * _Drive, const wchar_t * _Dir, const wchar_t * _Filename, const wchar_t * _Ext ) throw ( ) { return _wmakepath_s ( _ResultPath, _Size, _Drive, _Dir, _Filename, _Ext ); }
#line 882
extern "C" { __declspec(dllimport) void __cdecl _wmakepath(__wchar_t * _ResultPath, const __wchar_t * _Drive, const __wchar_t * _Dir, const __wchar_t * _Filename, const __wchar_t * _Ext); } 
#line 885
extern "C" { __declspec(dllimport) void __cdecl _wperror(const __wchar_t * _ErrMsg); } 
#line 889 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) int __cdecl _wputenv(const __wchar_t * _EnvString); } 
#line 890
extern "C" { __declspec(dllimport) errno_t __cdecl _wputenv_s(const __wchar_t * _Name, const __wchar_t * _Value); } 
#line 891
extern "C" { __declspec(dllimport) errno_t __cdecl _wsearchenv_s(const __wchar_t * _Filename, const __wchar_t * _EnvVar, __wchar_t * _ResultPath, size_t _SizeInWords); } 
#line 892
template < size_t _Size > inline errno_t __cdecl _wsearchenv_s ( const wchar_t * _Filename, const wchar_t * _EnvVar, wchar_t ( & _ResultPath ) [ _Size ] ) throw ( ) { return _wsearchenv_s ( _Filename, _EnvVar, _ResultPath, _Size ); }
#line 893
extern "C" { __declspec(dllimport) void __cdecl _wsearchenv(const __wchar_t * _Filename, const __wchar_t * _EnvVar, __wchar_t * _ResultPath); } 
#line 896 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl _wsplitpath(const __wchar_t * _FullPath, __wchar_t * _Drive, __wchar_t * _Dir, __wchar_t * _Filename, __wchar_t * _Ext); } 
#line 897
extern "C" { __declspec(dllimport) errno_t __cdecl _wsplitpath_s(const __wchar_t * _FullPath, __wchar_t * _Drive, size_t _DriveSize, __wchar_t * _Dir, size_t _DirSize, __wchar_t * _Filename, size_t _FilenameSize, __wchar_t * _Ext, size_t _ExtSize); } 
#line 902
template < size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize > inline errno_t __cdecl _wsplitpath_s ( const wchar_t * _Path, wchar_t ( & _Drive ) [ _DriveSize ], wchar_t ( & _Dir ) [ _DirSize ], wchar_t ( & _Name ) [ _NameSize ], wchar_t ( & _Ext ) [ _ExtSize ] ) throw ( ) { return _wsplitpath_s ( _Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize ); }
#line 909 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using SetErrorMode in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(int _Mode); } 
#line 910
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Beep instead. S" "ee online help for details.")) __declspec(dllimport) void __cdecl _beep(unsigned _Frequency, unsigned _Duration); } 
#line 911
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using Sleep instead. " "See online help for details.")) __declspec(dllimport) void __cdecl _sleep(unsigned long _Duration); } 
#line 932 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { __declspec(dllimport) char *__cdecl ecvt(double _Val, int _NumOfDigits, int * _PtDec, int * _PtSign); } 
#line 935
extern "C" { __declspec(dllimport) char *__cdecl fcvt(double _Val, int _NumOfDec, int * _PtDec, int * _PtSign); } 
#line 936
extern "C" { __declspec(dllimport) char *__cdecl gcvt(double _Val, int _NumOfDigits, char * _DstBuf); } 
#line 937
extern "C" { __declspec(dllimport) char *__cdecl itoa(int _Val, char * _DstBuf, int _Radix); } 
#line 938
extern "C" { __declspec(dllimport) char *__cdecl ltoa(long _Val, char * _DstBuf, int _Radix); } 
#line 941
extern "C" { __declspec(dllimport) int __cdecl putenv(const char * _EnvString); } 
#line 944 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
extern "C" { __declspec(dllimport) void __cdecl swab(char * _Buf1, char * _Buf2, int _SizeInBytes); } 
#line 945
extern "C" { __declspec(dllimport) char *__cdecl ultoa(unsigned long _Val, char * _Dstbuf, int _Radix); } 
#pragma warning(pop)
extern "C" { _onexit_t __cdecl onexit(_onexit_t _Func); } 
#line 205 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
#pragma detect_mismatch("_MSC_VER", "1800")
#line 209 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")
#line 218 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")
#line 57 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\use_ansi.h"
#pragma comment(lib, "msvcprt")
#line 957 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdlib.h"
#pragma pack ( pop )
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
#pragma pack ( push, 8 )
#line 568 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
namespace std { 
#line 569
typedef bool _Bool; 
#line 570
}
#line 586 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
typedef __int64 _Longlong; 
#line 587
typedef unsigned __int64 _ULonglong; 
#line 605 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
typedef unsigned short char16_t; 
#line 606
typedef unsigned char32_t; 
#line 619 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
namespace std { 
#line 620
enum _Uninitialized { 
#line 622
_Noinit
#line 623
}; 
#line 627
#pragma warning(push)
#pragma warning(disable:4412)
class __declspec(dllimport) _Lockit { 
#line 652 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
public: __thiscall _Lockit(); 
#line 653
explicit __thiscall _Lockit(int); 
#line 654
__thiscall ~_Lockit() throw(); 
#line 657 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
static void __cdecl _Lockit_ctor(int); 
#line 658
static void __cdecl _Lockit_dtor(int); 
#line 661
private: static void __cdecl _Lockit_ctor(_Lockit *); 
#line 662
static void __cdecl _Lockit_ctor(_Lockit *, int); 
#line 663
static void __cdecl _Lockit_dtor(_Lockit *); 
#line 666
public: _Lockit(const _Lockit &) = delete;
#line 667
_Lockit &operator=(const _Lockit &) = delete;
#line 670
private: int _Locktype; 
#line 685 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
}; 
#line 772 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
class __declspec(dllimport) _Init_locks { 
#line 788 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
public: __thiscall _Init_locks(); 
#line 789
__thiscall ~_Init_locks() throw(); 
#line 793 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
private: static void __cdecl _Init_locks_ctor(_Init_locks *); 
#line 794
static void __cdecl _Init_locks_dtor(_Init_locks *); 
#line 805 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
}; 
#line 807
#pragma warning(pop)
}
#line 817 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
__declspec(dllimport) void __cdecl _Atexit(void (__cdecl *)(void)); 
#line 819
typedef int _Mbstatet; 
#line 820
typedef unsigned long _Uint32t; 
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtr1common"
#pragma warning(push,3)
#line 829 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\yvals.h"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtr1common"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
template< class _T1, class 
#line 16
_Ret> struct unary_function; 
#line 20
template< class _T1, class 
#line 21
_T2, class 
#line 22
_Ret> struct binary_function; 
#line 26
struct _Nil { 
#line 28
}; 
#line 29
static _Nil _Nil_obj; 
#line 32
template < class _Ty,
 _Ty _Val >
 struct integral_constant
 {
 static const _Ty value = _Val;

 typedef _Ty value_type;
 typedef integral_constant < _Ty, _Val > type;

 operator value_type ( ) const
  {
  return ( value );
  }
 };
#line 47
typedef integral_constant< bool, true>  true_type; 
#line 48
typedef integral_constant< bool, false>  false_type; 
#line 51
template< bool > 
#line 52
struct _Cat_base : public false_type { 
#line 55
}; 
#line 58
template<> struct _Cat_base< true>  : public true_type { 
#line 61
}; 
#line 64
template< bool _Test, class 
#line 65
_Ty = void> 
#line 66
struct enable_if { 
#line 68
}; 
#line 70
template< class _Ty> 
#line 71
struct enable_if< true, _Ty>  { 
#line 73
typedef _Ty type; 
#line 74
}; 
#line 77
template< bool _Test, class 
#line 78
_Ty1, class 
#line 79
_Ty2> 
#line 80
struct conditional { 
#line 82
typedef _Ty2 type; 
#line 83
}; 
#line 85
template< class _Ty1, class 
#line 86
_Ty2> 
#line 87
struct conditional< true, _Ty1, _Ty2>  { 
#line 89
typedef _Ty1 type; 
#line 90
}; 
#line 93
template< class _Ty1, class _Ty2> 
#line 94
struct is_same : public false_type { 
#line 97
}; 
#line 99
template< class _Ty1> 
#line 100
struct is_same< _Ty1, _Ty1>  : public true_type { 
#line 103
}; 
#line 106
template< class _Ty> 
#line 107
struct remove_const { 
#line 109
typedef _Ty type; 
#line 110
}; 
#line 112
template< class _Ty> 
#line 113
struct remove_const< const _Ty>  { 
#line 115
typedef _Ty type; 
#line 116
}; 
#line 118
template< class _Ty> 
#line 119
struct remove_const< const _Ty []>  { 
#line 121
typedef _Ty type[]; 
#line 122
}; 
#line 124
template< class _Ty, unsigned _Nx> 
#line 125
struct remove_const< const _Ty [_Nx]>  { 
#line 127
typedef _Ty type[_Nx]; 
#line 128
}; 
#line 131
template< class _Ty> 
#line 132
struct remove_volatile { 
#line 134
typedef _Ty type; 
#line 135
}; 
#line 137
template< class _Ty> 
#line 138
struct remove_volatile< volatile _Ty>  { 
#line 140
typedef _Ty type; 
#line 141
}; 
#line 143
template< class _Ty> 
#line 144
struct remove_volatile< volatile _Ty []>  { 
#line 146
typedef _Ty type[]; 
#line 147
}; 
#line 149
template< class _Ty, unsigned _Nx> 
#line 150
struct remove_volatile< volatile _Ty [_Nx]>  { 
#line 152
typedef _Ty type[_Nx]; 
#line 153
}; 
#line 156
template< class _Ty> 
#line 157
struct remove_cv { 
#line 160
typedef typename remove_const< typename remove_volatile< _Ty> ::type> ::type type; 
#line 161
}; 
#line 164
template< class _Ty> 
#line 165
struct _Is_integral : public false_type { 
#line 168
}; 
#line 171
template<> struct _Is_integral< bool>  : public true_type { 
#line 174
}; 
#line 177
template<> struct _Is_integral< char>  : public true_type { 
#line 180
}; 
#line 183
template<> struct _Is_integral< unsigned char>  : public true_type { 
#line 186
}; 
#line 189
template<> struct _Is_integral< signed char>  : public true_type { 
#line 192
}; 
#line 196
template<> struct _Is_integral< __wchar_t>  : public true_type { 
#line 199
}; 
#line 203 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtr1common"
template<> struct _Is_integral< unsigned short>  : public true_type { 
#line 206
}; 
#line 209
template<> struct _Is_integral< signed short>  : public true_type { 
#line 212
}; 
#line 215
template<> struct _Is_integral< unsigned>  : public true_type { 
#line 218
}; 
#line 221
template<> struct _Is_integral< signed int>  : public true_type { 
#line 224
}; 
#line 227
template<> struct _Is_integral< unsigned long>  : public true_type { 
#line 230
}; 
#line 233
template<> struct _Is_integral< signed long>  : public true_type { 
#line 236
}; 
#line 254 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtr1common"
template<> struct _Is_integral< __int64>  : public true_type { 
#line 257
}; 
#line 260
template<> struct _Is_integral< unsigned __int64>  : public true_type { 
#line 263
}; 
#line 267 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtr1common"
template< class _Ty> 
#line 268
struct is_integral : public _Is_integral< typename remove_cv< _Ty> ::type>  { 
#line 271
}; 
#line 274
template< class _Ty> 
#line 275
struct _Is_floating_point : public false_type { 
#line 278
}; 
#line 281
template<> struct _Is_floating_point< float>  : public true_type { 
#line 284
}; 
#line 287
template<> struct _Is_floating_point< double>  : public true_type { 
#line 290
}; 
#line 293
template<> struct _Is_floating_point< long double>  : public true_type { 
#line 296
}; 
#line 299
template< class _Ty> 
#line 300
struct is_floating_point : public _Is_floating_point< typename remove_cv< _Ty> ::type>  { 
#line 303
}; 
#line 305
template< class _Ty> 
#line 306
struct _Is_numeric : public _Cat_base< is_integral< _Ty> ::value || is_floating_point< _Ty> ::value>  { 
#line 310
}; 
#line 313
template< class _Ty> 
#line 314
struct remove_reference { 
#line 316
typedef _Ty type; 
#line 317
}; 
#line 319
template< class _Ty> 
#line 320
struct remove_reference< _Ty &>  { 
#line 322
typedef _Ty type; 
#line 323
}; 
#line 325
template< class _Ty> 
#line 326
struct remove_reference< _Ty &&>  { 
#line 328
typedef _Ty type; 
#line 329
}; 
#line 332
template< class _Tgt, class 
#line 333
_Src> 
#line 334
struct _Copy_cv { 
#line 336
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 337
typedef _Tgtx &type; 
#line 338
}; 
#line 340
template< class _Tgt, class 
#line 341
_Src> 
#line 342
struct _Copy_cv< _Tgt, const _Src>  { 
#line 344
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 345
typedef const _Tgtx &type; 
#line 346
}; 
#line 348
template< class _Tgt, class 
#line 349
_Src> 
#line 350
struct _Copy_cv< _Tgt, volatile _Src>  { 
#line 352
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 353
typedef volatile _Tgtx &type; 
#line 354
}; 
#line 356
template< class _Tgt, class 
#line 357
_Src> 
#line 358
struct _Copy_cv< _Tgt, const volatile _Src>  { 
#line 360
typedef typename remove_reference< _Tgt> ::type _Tgtx; 
#line 361
typedef const volatile _Tgtx &type; 
#line 362
}; 
#line 364
template< class _Tgt, class 
#line 365
_Src> 
#line 366
struct _Copy_cv< _Tgt, _Src &>  { 
#line 368
typedef typename std::_Copy_cv< _Tgt, _Src> ::type type; 
#line 369
}; 
#line 372
struct _Wrap_int { 
#line 374
_Wrap_int(int) 
#line 375
{ 
#line 376
} 
#line 377
}; 
#line 379
template< class _Ty> 
#line 380
struct _Identity { 
#line 382
typedef _Ty type; 
#line 383
}; 
#line 419
template< class _Ty> 
#line 420
struct _Has_result_type { 
#line 421
template< class _Uty> static auto _Fn(int, _Identity< typename _Uty::result_type>  * = 0, _Identity< typename _Uty::result_type>  * = 0, _Identity< typename _Uty::result_type>  * = 0)->true_type; template< class _Uty> static auto _Fn(_Wrap_int)->false_type; typedef decltype((_Fn< _Ty> (0))) type; }; 
#line 422
}
#line 424
#pragma warning(pop)
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtgmath.h"
#pragma warning(push,3)
#line 425 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtr1common"
#pragma pack ( pop )
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtgmath.h"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 16
template< class _Ty> 
#line 17
struct _Promote_to_float { 
#line 20
typedef typename conditional< is_integral< _Ty> ::value, double, _Ty> ::type type; 
#line 21
}; 
#line 23
template< class _Ty1, class 
#line 24
_Ty2> 
#line 25
struct _Common_float_type { 
#line 27
typedef typename _Promote_to_float< _Ty1> ::type _Ty1f; 
#line 28
typedef typename _Promote_to_float< _Ty2> ::type _Ty2f; 
#line 33
typedef typename conditional< is_same< typename _Promote_to_float< _Ty1> ::type, long double> ::value || is_same< typename _Promote_to_float< _Ty2> ::type, long double> ::value, long double, typename conditional< is_same< typename _Promote_to_float< _Ty1> ::type, double> ::value || is_same< typename _Promote_to_float< _Ty2> ::type, double> ::value, double, float> ::type> ::type type; 
#line 34
}; 
#line 35
}
#line 75
extern "C" double __cdecl pow(double, double); 
#line 76
inline float __cdecl pow(float, float) throw(); 
#line 77
inline long double __cdecl pow(long double, long double) throw(); 
#line 79
template < class _Ty1,
 class _Ty2 > inline
 typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value
  && :: std :: _Is_numeric < _Ty2 > :: value,
  typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type
 pow ( const _Ty1 _Left, const _Ty2 _Right )
 {
 typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type;
 return ( :: pow ( type ( _Left ), type ( _Right ) ) );
 }
#line 91
extern "C" double __cdecl acos(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type acos ( _Ty _Left ) { return ( :: acos ( ( double ) _Left ) ); }
#line 92
extern "C" double __cdecl asin(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type asin ( _Ty _Left ) { return ( :: asin ( ( double ) _Left ) ); }
#line 93
extern "C" double __cdecl atan(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type atan ( _Ty _Left ) { return ( :: atan ( ( double ) _Left ) ); }
#line 94
extern "C" double __cdecl atan2(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type atan2 ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: atan2 ( ( type ) _Left, ( type ) _Right ) ); }
#line 95
extern "C" __declspec(dllimport) double __cdecl ceil(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type ceil ( _Ty _Left ) { return ( :: ceil ( ( double ) _Left ) ); }
#line 96
extern "C" double __cdecl cos(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cos ( _Ty _Left ) { return ( :: cos ( ( double ) _Left ) ); }
#line 97
extern "C" double __cdecl cosh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cosh ( _Ty _Left ) { return ( :: cosh ( ( double ) _Left ) ); }
#line 98
extern "C" double __cdecl exp(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type exp ( _Ty _Left ) { return ( :: exp ( ( double ) _Left ) ); }
#line 100
extern "C" __declspec(dllimport) double __cdecl floor(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type floor ( _Ty _Left ) { return ( :: floor ( ( double ) _Left ) ); }
#line 101
extern "C" double __cdecl fmod(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fmod ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmod ( ( type ) _Left, ( type ) _Right ) ); }
#line 102
extern "C" __declspec(dllimport) double __cdecl frexp(double, int *); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type frexp ( _Ty _Left, int * _Arg2 ) { return ( :: frexp ( ( double ) _Left, _Arg2 ) ); }
#line 103
extern "C" __declspec(dllimport) double __cdecl ldexp(double, int); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type ldexp ( _Ty _Left, int _Arg2 ) { return ( :: ldexp ( ( double ) _Left, _Arg2 ) ); }
#line 104
extern "C" double __cdecl log(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log ( _Ty _Left ) { return ( :: log ( ( double ) _Left ) ); }
#line 105
extern "C" double __cdecl log10(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log10 ( _Ty _Left ) { return ( :: log10 ( ( double ) _Left ) ); }
#line 108
extern "C" double __cdecl sin(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sin ( _Ty _Left ) { return ( :: sin ( ( double ) _Left ) ); }
#line 109
extern "C" double __cdecl sinh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sinh ( _Ty _Left ) { return ( :: sinh ( ( double ) _Left ) ); }
#line 110
extern "C" double __cdecl sqrt(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type sqrt ( _Ty _Left ) { return ( :: sqrt ( ( double ) _Left ) ); }
#line 111
extern "C" double __cdecl tan(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tan ( _Ty _Left ) { return ( :: tan ( ( double ) _Left ) ); }
#line 112
extern "C" double __cdecl tanh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tanh ( _Ty _Left ) { return ( :: tanh ( ( double ) _Left ) ); }
#line 124
inline float _Fma(float _Left, float _Middle, float _Right) 
#line 125
{ 
#line 126
return ::fmaf(_Left, _Middle, _Right); 
#line 127
} 
#line 129
inline double _Fma(double _Left, double _Middle, double _Right) 
#line 130
{ 
#line 131
return ::fma(_Left, _Middle, _Right); 
#line 132
} 
#line 134
inline long double _Fma(long double _Left, long double _Middle, long double _Right) 
#line 135
{ 
#line 136
return ::fmal(_Left, _Middle, _Right); 
#line 137
} 
#line 139
template < class _Ty1,
 class _Ty2,
 class _Ty3 > inline
 typename :: std :: _Common_float_type < _Ty1,
  typename :: std :: _Common_float_type < _Ty2, _Ty3 > :: type > :: type
 fma ( _Ty1 _Left, _Ty2 _Middle, _Ty3 _Right )
 {
 typedef typename :: std :: _Common_float_type < _Ty1,
  typename :: std :: _Common_float_type < _Ty2, _Ty3 > :: type > :: type type;
 return ( _Fma ( ( type ) _Left, ( type ) _Middle, ( type ) _Right ) );
 }
#line 152
inline float _Remquo(float _Left, float _Right, int *_Pquo) 
#line 153
{ 
#line 154
return ::remquof(_Left, _Right, _Pquo); 
#line 155
} 
#line 157
inline double _Remquo(double _Left, double _Right, int *_Pquo) 
#line 158
{ 
#line 159
return ::remquo(_Left, _Right, _Pquo); 
#line 160
} 
#line 162
inline long double _Remquo(long double _Left, long double _Right, int *_Pquo) 
#line 163
{ 
#line 164
return ::remquol(_Left, _Right, _Pquo); 
#line 165
} 
#line 167
template < class _Ty1,
 class _Ty2 > inline
 typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type
 remquo ( _Ty1 _Left, _Ty2 _Right, int * _Pquo )
 {
 typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type;
 return ( _Remquo ( ( type ) _Left, ( type ) _Right, _Pquo ) );
 }
#line 176
extern "C" __declspec(dllimport) double __cdecl acosh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type acosh ( _Ty _Left ) { return ( :: acosh ( ( double ) _Left ) ); }
#line 177
extern "C" __declspec(dllimport) double __cdecl asinh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type asinh ( _Ty _Left ) { return ( :: asinh ( ( double ) _Left ) ); }
#line 178
extern "C" __declspec(dllimport) double __cdecl atanh(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type atanh ( _Ty _Left ) { return ( :: atanh ( ( double ) _Left ) ); }
#line 179
extern "C" __declspec(dllimport) double __cdecl cbrt(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type cbrt ( _Ty _Left ) { return ( :: cbrt ( ( double ) _Left ) ); }
#line 180
extern "C" __declspec(dllimport) double __cdecl copysign(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type copysign ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: copysign ( ( type ) _Left, ( type ) _Right ) ); }
#line 181
extern "C" __declspec(dllimport) double __cdecl erf(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type erf ( _Ty _Left ) { return ( :: erf ( ( double ) _Left ) ); }
#line 182
extern "C" __declspec(dllimport) double __cdecl erfc(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type erfc ( _Ty _Left ) { return ( :: erfc ( ( double ) _Left ) ); }
#line 183
extern "C" __declspec(dllimport) double __cdecl expm1(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type expm1 ( _Ty _Left ) { return ( :: expm1 ( ( double ) _Left ) ); }
#line 184
extern "C" __declspec(dllimport) double __cdecl exp2(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type exp2 ( _Ty _Left ) { return ( :: exp2 ( ( double ) _Left ) ); }
#line 186
extern "C" __declspec(dllimport) double __cdecl fdim(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fdim ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fdim ( ( type ) _Left, ( type ) _Right ) ); }
#line 188
extern "C" __declspec(dllimport) double __cdecl fmax(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fmax ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmax ( ( type ) _Left, ( type ) _Right ) ); }
#line 189
extern "C" __declspec(dllimport) double __cdecl fmin(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type fmin ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: fmin ( ( type ) _Left, ( type ) _Right ) ); }
#line 190
extern "C" __inline double __cdecl hypot(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type hypot ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: hypot ( ( type ) _Left, ( type ) _Right ) ); }
#line 191
extern "C" __declspec(dllimport) int __cdecl ilogb(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, int > :: type ilogb ( _Ty _Left ) { return ( :: ilogb ( ( double ) _Left ) ); }
#line 192
extern "C" __declspec(dllimport) double __cdecl lgamma(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type lgamma ( _Ty _Left ) { return ( :: lgamma ( ( double ) _Left ) ); }
#line 193
extern "C" __declspec(dllimport) __int64 __cdecl llrint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long long > :: type llrint ( _Ty _Left ) { return ( :: llrint ( ( double ) _Left ) ); }
#line 194
extern "C" __declspec(dllimport) __int64 __cdecl llround(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long long > :: type llround ( _Ty _Left ) { return ( :: llround ( ( double ) _Left ) ); }
#line 195
extern "C" __declspec(dllimport) double __cdecl log1p(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log1p ( _Ty _Left ) { return ( :: log1p ( ( double ) _Left ) ); }
#line 196
extern "C" __declspec(dllimport) double __cdecl log2(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type log2 ( _Ty _Left ) { return ( :: log2 ( ( double ) _Left ) ); }
#line 197
extern "C" __declspec(dllimport) double __cdecl logb(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type logb ( _Ty _Left ) { return ( :: logb ( ( double ) _Left ) ); }
#line 198
extern "C" __declspec(dllimport) long __cdecl lrint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long > :: type lrint ( _Ty _Left ) { return ( :: lrint ( ( double ) _Left ) ); }
#line 199
extern "C" __declspec(dllimport) long __cdecl lround(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, long > :: type lround ( _Ty _Left ) { return ( :: lround ( ( double ) _Left ) ); }
#line 200
extern "C" __declspec(dllimport) double __cdecl nearbyint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type nearbyint ( _Ty _Left ) { return ( :: nearbyint ( ( double ) _Left ) ); }
#line 201
extern "C" __declspec(dllimport) double __cdecl nextafter(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type nextafter ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: nextafter ( ( type ) _Left, ( type ) _Right ) ); }
#line 202
extern "C" __declspec(dllimport) double __cdecl nexttoward(double, long double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type nexttoward ( _Ty _Left, long double _Arg2 ) { return ( :: nexttoward ( ( double ) _Left, _Arg2 ) ); }
#line 203
extern "C" __declspec(dllimport) double __cdecl remainder(double, double); template < class _Ty1, class _Ty2 > inline typename :: std :: enable_if < :: std :: _Is_numeric < _Ty1 > :: value && :: std :: _Is_numeric < _Ty2 > :: value, typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type > :: type remainder ( _Ty1 _Left, _Ty2 _Right ) { typedef typename :: std :: _Common_float_type < _Ty1, _Ty2 > :: type type; return ( :: remainder ( ( type ) _Left, ( type ) _Right ) ); }
#line 205
extern "C" __declspec(dllimport) double __cdecl rint(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type rint ( _Ty _Left ) { return ( :: rint ( ( double ) _Left ) ); }
#line 206
extern "C" __declspec(dllimport) double __cdecl round(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type round ( _Ty _Left ) { return ( :: round ( ( double ) _Left ) ); }
#line 207
extern "C" __declspec(dllimport) double __cdecl scalbln(double, long); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type scalbln ( _Ty _Left, long _Arg2 ) { return ( :: scalbln ( ( double ) _Left, _Arg2 ) ); }
#line 208
extern "C" __declspec(dllimport) double __cdecl scalbn(double, int); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type scalbn ( _Ty _Left, int _Arg2 ) { return ( :: scalbn ( ( double ) _Left, _Arg2 ) ); }
#line 209
extern "C" __declspec(dllimport) double __cdecl tgamma(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type tgamma ( _Ty _Left ) { return ( :: tgamma ( ( double ) _Left ) ); }
#line 210
extern "C" __declspec(dllimport) double __cdecl trunc(double); template < class _Ty > inline typename :: std :: enable_if < :: std :: is_integral < _Ty > :: value, double > :: type trunc ( _Ty _Left ) { return ( :: trunc ( ( double ) _Left ) ); }
#line 215 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xtgmath.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 22 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cmath"
namespace std { 
#line 23
using ::abs;using ::acos;using ::asin;
#line 24
using ::atan;using ::atan2;using ::ceil;
#line 25
using ::cos;using ::cosh;using ::exp;
#line 26
using ::fabs;using ::floor;using ::fmod;
#line 27
using ::frexp;using ::ldexp;using ::log;
#line 28
using ::log10;using ::modf;using ::pow;
#line 29
using ::sin;using ::sinh;using ::sqrt;
#line 30
using ::tan;using ::tanh;
#line 32
using ::acosf;using ::asinf;
#line 33
using ::atanf;using ::atan2f;using ::ceilf;
#line 34
using ::cosf;using ::coshf;using ::expf;
#line 35
using ::fabsf;using ::floorf;using ::fmodf;
#line 36
using ::frexpf;using ::ldexpf;using ::logf;
#line 37
using ::log10f;using ::modff;using ::powf;
#line 38
using ::sinf;using ::sinhf;using ::sqrtf;
#line 39
using ::tanf;using ::tanhf;
#line 41
using ::acosl;using ::asinl;
#line 42
using ::atanl;using ::atan2l;using ::ceill;
#line 43
using ::cosl;using ::coshl;using ::expl;
#line 44
using ::fabsl;using ::floorl;using ::fmodl;
#line 45
using ::frexpl;using ::ldexpl;using ::logl;
#line 46
using ::log10l;using ::modfl;using ::powl;
#line 47
using ::sinl;using ::sinhl;using ::sqrtl;
#line 48
using ::tanl;using ::tanhl;
#line 50
using ::float_t;using ::double_t;
#line 52
using ::acosh;using ::asinh;using ::atanh;
#line 53
using ::cbrt;using ::erf;using ::erfc;
#line 54
using ::expm1;using ::exp2;
#line 55
using ::hypot;using ::ilogb;using ::lgamma;
#line 56
using ::log1p;using ::log2;using ::logb;
#line 57
using ::llrint;using ::lrint;using ::nearbyint;
#line 58
using ::rint;using ::llround;using ::lround;
#line 59
using ::fdim;using ::fma;using ::fmax;using ::fmin;
#line 60
using ::round;using ::trunc;
#line 61
using ::remainder;using ::remquo;
#line 62
using ::copysign;using ::nan;using ::nextafter;
#line 63
using ::scalbn;using ::scalbln;
#line 64
using ::nexttoward;using ::tgamma;
#line 66
using ::acoshf;using ::asinhf;using ::atanhf;
#line 67
using ::cbrtf;using ::erff;using ::erfcf;
#line 68
using ::expm1f;using ::exp2f;
#line 69
using ::hypotf;using ::ilogbf;using ::lgammaf;
#line 70
using ::log1pf;using ::log2f;using ::logbf;
#line 71
using ::llrintf;using ::lrintf;using ::nearbyintf;
#line 72
using ::rintf;using ::llroundf;using ::lroundf;
#line 73
using ::fdimf;using ::fmaf;using ::fmaxf;using ::fminf;
#line 74
using ::roundf;using ::truncf;
#line 75
using ::remainderf;using ::remquof;
#line 76
using ::copysignf;using ::nanf;
#line 77
using ::nextafterf;using ::scalbnf;using ::scalblnf;
#line 78
using ::nexttowardf;using ::tgammaf;
#line 80
using ::acoshl;using ::asinhl;using ::atanhl;
#line 81
using ::cbrtl;using ::erfl;using ::erfcl;
#line 82
using ::expm1l;using ::exp2l;
#line 83
using ::hypotl;using ::ilogbl;using ::lgammal;
#line 84
using ::log1pl;using ::log2l;using ::logbl;
#line 85
using ::llrintl;using ::lrintl;using ::nearbyintl;
#line 86
using ::rintl;using ::llroundl;using ::lroundl;
#line 87
using ::fdiml;using ::fmal;using ::fmaxl;using ::fminl;
#line 88
using ::roundl;using ::truncl;
#line 89
using ::remainderl;using ::remquol;
#line 90
using ::copysignl;using ::nanl;
#line 91
using ::nextafterl;using ::scalbnl;using ::scalblnl;
#line 92
using ::nexttowardl;using ::tgammal;
#line 94
using ::fpclassify;using ::signbit;
#line 95
using ::isfinite;using ::isinf;
#line 96
using ::isnan;using ::isnormal;
#line 97
using ::isgreater;using ::isgreaterequal;
#line 98
using ::isless;using ::islessequal;
#line 99
using ::islessgreater;using ::isunordered;
#line 100
}
#line 17 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cstdlib"
namespace std { 
#line 18
using ::size_t;using ::div_t;using ::ldiv_t;
#line 19
using ::abort;using ::abs;using ::atexit;
#line 20
using ::atof;using ::atoi;using ::atol;
#line 21
using ::bsearch;using ::calloc;using ::div;
#line 22
using ::exit;using ::free;
#line 23
using ::labs;using ::ldiv;using ::malloc;
#line 24
using ::mblen;using ::mbstowcs;using ::mbtowc;
#line 25
using ::qsort;using ::rand;using ::realloc;
#line 26
using ::srand;using ::strtod;using ::strtol;
#line 27
using ::strtoul;
#line 28
using ::wcstombs;using ::wctomb;
#line 30
using ::lldiv_t;
#line 33
using ::getenv;
#line 34
using ::system;
#line 37 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cstdlib"
using ::atoll;using ::llabs;using ::lldiv;
#line 38
using ::strtof;using ::strtold;
#line 39
using ::strtoll;using ::strtoull;
#line 40
}
#line 8968 "e:\\cudatoolkit\\include\\math_functions.h"
extern "C" { __declspec(dllimport) extern double __cdecl _hypot(double x, double y); } 
#line 8969
extern "C" { __declspec(dllimport) extern float __cdecl _hypotf(float x, float y); } 
#line 8979 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline bool signbit(long double); 
#line 8980
extern "C" { __declspec(dllimport) extern int _ldsign(long double); } 
#line 9023 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline bool signbit(double); 
#line 9024
extern "C" { __declspec(dllimport) extern int _dsign(double); } 
#line 9068 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline bool signbit(float); 
#line 9069
extern "C" { __declspec(dllimport) extern int _fdsign(float); } 
#line 9077 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isinf(long double a); 
#line 9112 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isinf(double a); 
#line 9150 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isinf(float a); 
#line 9157 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isnan(long double a); 
#line 9190 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isnan(double a); 
#line 9226 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isnan(float a); 
#line 9233 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isfinite(long double a); 
#line 9270 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isfinite(double a); 
#line 9306 "e:\\cudatoolkit\\include\\math_functions.h"
static __inline bool isfinite(float a); 
#line 9314 "e:\\cudatoolkit\\include\\math_functions.h"
template< class T> extern inline T _Pow_int(T, int) throw(); 
#line 9315
extern inline __int64 abs(__int64) throw(); 
#line 9386 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline long __cdecl abs(long) throw(); 
#line 9390 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline float __cdecl abs(float) throw(); 
#line 9391
extern inline double __cdecl abs(double) throw(); 
#line 9392
extern inline float __cdecl fabs(float) throw(); 
#line 9393
extern inline float __cdecl ceil(float) throw(); 
#line 9394
extern inline float __cdecl floor(float) throw(); 
#line 9395
extern inline float __cdecl sqrt(float) throw(); 
#line 9396
extern inline float __cdecl pow(float, float) throw(); 
#line 9412 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline float __cdecl pow(float, int) throw(); 
#line 9413
extern inline double __cdecl pow(double, int) throw(); 
#line 9416 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline float __cdecl log(float) throw(); 
#line 9417
extern inline float __cdecl log10(float) throw(); 
#line 9418
extern inline float __cdecl fmod(float, float) throw(); 
#line 9419
extern inline float __cdecl modf(float, float *) throw(); 
#line 9420
extern inline float __cdecl exp(float) throw(); 
#line 9421
extern inline float __cdecl frexp(float, int *) throw(); 
#line 9422
extern inline float __cdecl ldexp(float, int) throw(); 
#line 9423
extern inline float __cdecl asin(float) throw(); 
#line 9424
extern inline float __cdecl sin(float) throw(); 
#line 9425
extern inline float __cdecl sinh(float) throw(); 
#line 9426
extern inline float __cdecl acos(float) throw(); 
#line 9427
extern inline float __cdecl cos(float) throw(); 
#line 9428
extern inline float __cdecl cosh(float) throw(); 
#line 9429
extern inline float __cdecl atan(float) throw(); 
#line 9430
extern inline float __cdecl atan2(float, float) throw(); 
#line 9431
extern inline float __cdecl tan(float) throw(); 
#line 9432
extern inline float __cdecl tanh(float) throw(); 
#line 9564 "e:\\cudatoolkit\\include\\math_functions.h"
extern inline float __cdecl logb(float) throw(); 
#line 9565
extern inline int __cdecl ilogb(float) throw(); 
#line 9566
extern float __cdecl scalbn(float, float) throw(); 
#line 9567
extern inline float __cdecl scalbln(float, long) throw(); 
#line 9568
extern inline float __cdecl exp2(float) throw(); 
#line 9569
extern inline float __cdecl expm1(float) throw(); 
#line 9570
extern inline float __cdecl log2(float) throw(); 
#line 9571
extern inline float __cdecl log1p(float) throw(); 
#line 9572
extern inline float __cdecl acosh(float) throw(); 
#line 9573
extern inline float __cdecl asinh(float) throw(); 
#line 9574
extern inline float __cdecl atanh(float) throw(); 
#line 9575
extern inline float __cdecl hypot(float, float) throw(); 
#line 9576
extern float __cdecl norm3d(float, float, float) throw(); 
#line 9577
extern float __cdecl norm4d(float, float, float, float) throw(); 
#line 9578
extern inline float __cdecl cbrt(float) throw(); 
#line 9579
extern inline float __cdecl erf(float) throw(); 
#line 9580
extern inline float __cdecl erfc(float) throw(); 
#line 9581
extern inline float __cdecl lgamma(float) throw(); 
#line 9582
extern inline float __cdecl tgamma(float) throw(); 
#line 9583
extern inline float __cdecl copysign(float, float) throw(); 
#line 9584
extern inline float __cdecl nextafter(float, float) throw(); 
#line 9585
extern inline float __cdecl remainder(float, float) throw(); 
#line 9586
extern inline float __cdecl remquo(float, float, int *) throw(); 
#line 9587
extern inline float __cdecl round(float) throw(); 
#line 9588
extern inline long __cdecl lround(float) throw(); 
#line 9589
extern inline __int64 __cdecl llround(float) throw(); 
#line 9590
extern inline float __cdecl trunc(float) throw(); 
#line 9591
extern inline float __cdecl rint(float) throw(); 
#line 9592
extern inline long __cdecl lrint(float) throw(); 
#line 9593
extern inline __int64 __cdecl llrint(float) throw(); 
#line 9594
extern inline float __cdecl nearbyint(float) throw(); 
#line 9595
extern inline float __cdecl fdim(float, float) throw(); 
#line 9596
extern inline float __cdecl fma(float, float, float) throw(); 
#line 9597
extern inline float __cdecl fmax(float, float) throw(); 
#line 9598
extern inline float __cdecl fmin(float, float) throw(); 
#line 9601 "e:\\cudatoolkit\\include\\math_functions.h"
static inline float exp10(float a); 
#line 9603
static inline float rsqrt(float a); 
#line 9605
static inline float rcbrt(float a); 
#line 9607
static inline float sinpi(float a); 
#line 9609
static inline float cospi(float a); 
#line 9611
static inline void sincospi(float a, float * sptr, float * cptr); 
#line 9613
static inline void sincos(float a, float * sptr, float * cptr); 
#line 9615
static inline float j0(float a); 
#line 9617
static inline float j1(float a); 
#line 9619
static inline float jn(int n, float a); 
#line 9621
static inline float y0(float a); 
#line 9623
static inline float y1(float a); 
#line 9625
static inline float yn(int n, float a); 
#line 9627
static inline float cyl_bessel_i0(float a); 
#line 9629
static inline float cyl_bessel_i1(float a); 
#line 9631
static inline float erfinv(float a); 
#line 9633
static inline float erfcinv(float a); 
#line 9635
static inline float normcdfinv(float a); 
#line 9637
static inline float normcdf(float a); 
#line 9639
static inline float erfcx(float a); 
#line 9641
static inline double copysign(double a, float b); 
#line 9643
static inline float copysign(float a, double b); 
#line 9645
static inline unsigned min(unsigned a, unsigned b); 
#line 9647
static inline unsigned min(int a, unsigned b); 
#line 9649
static inline unsigned min(unsigned a, int b); 
#line 9651
static inline long min(long a, long b); 
#line 9653
static inline unsigned long min(unsigned long a, unsigned long b); 
#line 9655
static inline unsigned long min(long a, unsigned long b); 
#line 9657
static inline unsigned long min(unsigned long a, long b); 
#line 9659
static inline __int64 min(__int64 a, __int64 b); 
#line 9661
static inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b); 
#line 9663
static inline unsigned __int64 min(__int64 a, unsigned __int64 b); 
#line 9665
static inline unsigned __int64 min(unsigned __int64 a, __int64 b); 
#line 9667
static inline float min(float a, float b); 
#line 9669
static inline double min(double a, double b); 
#line 9671
static inline double min(float a, double b); 
#line 9673
static inline double min(double a, float b); 
#line 9675
static inline unsigned max(unsigned a, unsigned b); 
#line 9677
static inline unsigned max(int a, unsigned b); 
#line 9679
static inline unsigned max(unsigned a, int b); 
#line 9681
static inline long max(long a, long b); 
#line 9683
static inline unsigned long max(unsigned long a, unsigned long b); 
#line 9685
static inline unsigned long max(long a, unsigned long b); 
#line 9687
static inline unsigned long max(unsigned long a, long b); 
#line 9689
static inline __int64 max(__int64 a, __int64 b); 
#line 9691
static inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b); 
#line 9693
static inline unsigned __int64 max(__int64 a, unsigned __int64 b); 
#line 9695
static inline unsigned __int64 max(unsigned __int64 a, __int64 b); 
#line 9697
static inline float max(float a, float b); 
#line 9699
static inline double max(double a, double b); 
#line 9701
static inline double max(float a, double b); 
#line 9703
static inline double max(double a, float b); 
#line 314 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isinf(long double a) 
#line 315
{ 
#line 319 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isinf< long double> (a); 
#line 321 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 330 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isinf(double a) 
#line 331
{ 
#line 335 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isinf< double> (a); 
#line 337 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 346 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isinf(float a) 
#line 347
{ 
#line 351 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isinf< float> (a); 
#line 353 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 362 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isnan(long double a) 
#line 363
{ 
#line 367 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isnan< long double> (a); 
#line 369 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 378 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isnan(double a) 
#line 379
{ 
#line 383 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isnan< double> (a); 
#line 385 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 394 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isnan(float a) 
#line 395
{ 
#line 399 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isnan< float> (a); 
#line 401 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 410 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isfinite(long double a) 
#line 411
{ 
#line 415 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isfinite< long double> (a); 
#line 417 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 426 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isfinite(double a) 
#line 427
{ 
#line 431 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isfinite< double> (a); 
#line 433 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 442 "e:\\cudatoolkit\\include\\math_functions.hpp"
static __inline bool isfinite(float a) 
#line 443
{ 
#line 447 "e:\\cudatoolkit\\include\\math_functions.hpp"
return isfinite< float> (a); 
#line 449 "e:\\cudatoolkit\\include\\math_functions.hpp"
} 
#line 639 "e:\\cudatoolkit\\include\\math_functions.hpp"
static inline float exp10(float a) 
#line 640
{ 
#line 641
return exp10f(a); 
#line 642
} 
#line 644
static inline float rsqrt(float a) 
#line 645
{ 
#line 646
return rsqrtf(a); 
#line 647
} 
#line 649
static inline float rcbrt(float a) 
#line 650
{ 
#line 651
return rcbrtf(a); 
#line 652
} 
#line 654
static inline float sinpi(float a) 
#line 655
{ 
#line 656
return sinpif(a); 
#line 657
} 
#line 659
static inline float cospi(float a) 
#line 660
{ 
#line 661
return cospif(a); 
#line 662
} 
#line 664
static inline void sincospi(float a, float *sptr, float *cptr) 
#line 665
{ 
#line 666
sincospif(a, sptr, cptr); 
#line 667
} 
#line 669
static inline void sincos(float a, float *sptr, float *cptr) 
#line 670
{ 
#line 671
sincosf(a, sptr, cptr); 
#line 672
} 
#line 674
static inline float j0(float a) 
#line 675
{ 
#line 676
return j0f(a); 
#line 677
} 
#line 679
static inline float j1(float a) 
#line 680
{ 
#line 681
return j1f(a); 
#line 682
} 
#line 684
static inline float jn(int n, float a) 
#line 685
{ 
#line 686
return jnf(n, a); 
#line 687
} 
#line 689
static inline float y0(float a) 
#line 690
{ 
#line 691
return y0f(a); 
#line 692
} 
#line 694
static inline float y1(float a) 
#line 695
{ 
#line 696
return y1f(a); 
#line 697
} 
#line 699
static inline float yn(int n, float a) 
#line 700
{ 
#line 701
return ynf(n, a); 
#line 702
} 
#line 704
static inline float cyl_bessel_i0(float a) 
#line 705
{ 
#line 706
return cyl_bessel_i0f(a); 
#line 707
} 
#line 709
static inline float cyl_bessel_i1(float a) 
#line 710
{ 
#line 711
return cyl_bessel_i1f(a); 
#line 712
} 
#line 714
static inline float erfinv(float a) 
#line 715
{ 
#line 716
return erfinvf(a); 
#line 717
} 
#line 719
static inline float erfcinv(float a) 
#line 720
{ 
#line 721
return erfcinvf(a); 
#line 722
} 
#line 724
static inline float normcdfinv(float a) 
#line 725
{ 
#line 726
return normcdfinvf(a); 
#line 727
} 
#line 729
static inline float normcdf(float a) 
#line 730
{ 
#line 731
return normcdff(a); 
#line 732
} 
#line 734
static inline float erfcx(float a) 
#line 735
{ 
#line 736
return erfcxf(a); 
#line 737
} 
#line 739
static inline double copysign(double a, float b) 
#line 740
{ 
#line 741
return copysign(a, (double)b); 
#line 742
} 
#line 744
static inline float copysign(float a, double b) 
#line 745
{ 
#line 746
return copysignf(a, (float)b); 
#line 747
} 
#line 749
static inline unsigned min(unsigned a, unsigned b) 
#line 750
{ 
#line 751
return umin(a, b); 
#line 752
} 
#line 754
static inline unsigned min(int a, unsigned b) 
#line 755
{ 
#line 756
return umin((unsigned)a, b); 
#line 757
} 
#line 759
static inline unsigned min(unsigned a, int b) 
#line 760
{ 
#line 761
return umin(a, (unsigned)b); 
#line 762
} 
#line 764
static inline long min(long a, long b) 
#line 765
{ 
#line 768
#pragma warning (disable: 4127)
#line 771 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 773
#pragma warning (default: 4127)
#line 775 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (long)min((int)a, (int)b); 
#line 776
} else { 
#line 777
return (long)llmin((__int64)a, (__int64)b); 
#line 778
}  
#line 779
} 
#line 781
static inline unsigned long min(unsigned long a, unsigned long b) 
#line 782
{ 
#line 784
#pragma warning (disable: 4127)
#line 786 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 788
#pragma warning (default: 4127)
#line 790 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 791
} else { 
#line 792
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 793
}  
#line 794
} 
#line 796
static inline unsigned long min(long a, unsigned long b) 
#line 797
{ 
#line 799
#pragma warning (disable: 4127)
#line 801 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 803
#pragma warning (default: 4127)
#line 805 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 806
} else { 
#line 807
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 808
}  
#line 809
} 
#line 811
static inline unsigned long min(unsigned long a, long b) 
#line 812
{ 
#line 814
#pragma warning (disable: 4127)
#line 816 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 818
#pragma warning (default: 4127)
#line 820 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (unsigned long)umin((unsigned)a, (unsigned)b); 
#line 821
} else { 
#line 822
return (unsigned long)ullmin((unsigned __int64)a, (unsigned __int64)b); 
#line 823
}  
#line 824
} 
#line 826
static inline __int64 min(__int64 a, __int64 b) 
#line 827
{ 
#line 828
return llmin(a, b); 
#line 829
} 
#line 831
static inline unsigned __int64 min(unsigned __int64 a, unsigned __int64 b) 
#line 832
{ 
#line 833
return ullmin(a, b); 
#line 834
} 
#line 836
static inline unsigned __int64 min(__int64 a, unsigned __int64 b) 
#line 837
{ 
#line 838
return ullmin((unsigned __int64)a, b); 
#line 839
} 
#line 841
static inline unsigned __int64 min(unsigned __int64 a, __int64 b) 
#line 842
{ 
#line 843
return ullmin(a, (unsigned __int64)b); 
#line 844
} 
#line 846
static inline float min(float a, float b) 
#line 847
{ 
#line 848
return fminf(a, b); 
#line 849
} 
#line 851
static inline double min(double a, double b) 
#line 852
{ 
#line 853
return fmin(a, b); 
#line 854
} 
#line 856
static inline double min(float a, double b) 
#line 857
{ 
#line 858
return fmin((double)a, b); 
#line 859
} 
#line 861
static inline double min(double a, float b) 
#line 862
{ 
#line 863
return fmin(a, (double)b); 
#line 864
} 
#line 866
static inline unsigned max(unsigned a, unsigned b) 
#line 867
{ 
#line 868
return umax(a, b); 
#line 869
} 
#line 871
static inline unsigned max(int a, unsigned b) 
#line 872
{ 
#line 873
return umax((unsigned)a, b); 
#line 874
} 
#line 876
static inline unsigned max(unsigned a, int b) 
#line 877
{ 
#line 878
return umax(a, (unsigned)b); 
#line 879
} 
#line 881
static inline long max(long a, long b) 
#line 882
{ 
#line 885
#pragma warning (disable: 4127)
#line 887 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(long) == sizeof(int)) { 
#line 889
#pragma warning (default: 4127)
#line 891 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (long)max((int)a, (int)b); 
#line 892
} else { 
#line 893
return (long)llmax((__int64)a, (__int64)b); 
#line 894
}  
#line 895
} 
#line 897
static inline unsigned long max(unsigned long a, unsigned long b) 
#line 898
{ 
#line 900
#pragma warning (disable: 4127)
#line 902 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 904
#pragma warning (default: 4127)
#line 906 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 907
} else { 
#line 908
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 909
}  
#line 910
} 
#line 912
static inline unsigned long max(long a, unsigned long b) 
#line 913
{ 
#line 915
#pragma warning (disable: 4127)
#line 917 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 919
#pragma warning (default: 4127)
#line 921 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 922
} else { 
#line 923
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 924
}  
#line 925
} 
#line 927
static inline unsigned long max(unsigned long a, long b) 
#line 928
{ 
#line 930
#pragma warning (disable: 4127)
#line 932 "e:\\cudatoolkit\\include\\math_functions.hpp"
if (sizeof(unsigned long) == sizeof(unsigned)) { 
#line 934
#pragma warning (default: 4127)
#line 936 "e:\\cudatoolkit\\include\\math_functions.hpp"
return (unsigned long)umax((unsigned)a, (unsigned)b); 
#line 937
} else { 
#line 938
return (unsigned long)ullmax((unsigned __int64)a, (unsigned __int64)b); 
#line 939
}  
#line 940
} 
#line 942
static inline __int64 max(__int64 a, __int64 b) 
#line 943
{ 
#line 944
return llmax(a, b); 
#line 945
} 
#line 947
static inline unsigned __int64 max(unsigned __int64 a, unsigned __int64 b) 
#line 948
{ 
#line 949
return ullmax(a, b); 
#line 950
} 
#line 952
static inline unsigned __int64 max(__int64 a, unsigned __int64 b) 
#line 953
{ 
#line 954
return ullmax((unsigned __int64)a, b); 
#line 955
} 
#line 957
static inline unsigned __int64 max(unsigned __int64 a, __int64 b) 
#line 958
{ 
#line 959
return ullmax(a, (unsigned __int64)b); 
#line 960
} 
#line 962
static inline float max(float a, float b) 
#line 963
{ 
#line 964
return fmaxf(a, b); 
#line 965
} 
#line 967
static inline double max(double a, double b) 
#line 968
{ 
#line 969
return fmax(a, b); 
#line 970
} 
#line 972
static inline double max(float a, double b) 
#line 973
{ 
#line 974
return fmax((double)a, b); 
#line 975
} 
#line 977
static inline double max(double a, float b) 
#line 978
{ 
#line 979
return fmax(a, (double)b); 
#line 980
} 
#line 986
#pragma warning(disable : 4211)
#line 991 "e:\\cudatoolkit\\include\\math_functions.hpp"
static inline int min(int a, int b) 
#line 992
{ 
#line 993
return (a < b) ? a : b; 
#line 994
} 
#line 996
static inline unsigned umin(unsigned a, unsigned b) 
#line 997
{ 
#line 998
return (a < b) ? a : b; 
#line 999
} 
#line 1001
static inline __int64 llmin(__int64 a, __int64 b) 
#line 1002
{ 
#line 1003
return (a < b) ? a : b; 
#line 1004
} 
#line 1006
static inline unsigned __int64 ullmin(unsigned __int64 a, unsigned __int64 
#line 1007
b) 
#line 1008
{ 
#line 1009
return (a < b) ? a : b; 
#line 1010
} 
#line 1012
static inline int max(int a, int b) 
#line 1013
{ 
#line 1014
return (a > b) ? a : b; 
#line 1015
} 
#line 1017
static inline unsigned umax(unsigned a, unsigned b) 
#line 1018
{ 
#line 1019
return (a > b) ? a : b; 
#line 1020
} 
#line 1022
static inline __int64 llmax(__int64 a, __int64 b) 
#line 1023
{ 
#line 1024
return (a > b) ? a : b; 
#line 1025
} 
#line 1027
static inline unsigned __int64 ullmax(unsigned __int64 a, unsigned __int64 
#line 1028
b) 
#line 1029
{ 
#line 1030
return (a > b) ? a : b; 
#line 1031
} 
#line 1034
#pragma warning(default: 4211)
#line 77 "e:\\cudatoolkit\\include\\cuda_surface_types.h"
template< class T, int dim = 1> 
#line 78
struct surface : public surfaceReference { 
#line 81
surface() 
#line 82
{ 
#line 83
(::surfaceReference::channelDesc) = cudaCreateChannelDesc< T> (); 
#line 84
} 
#line 86
surface(::cudaChannelFormatDesc desc) 
#line 87
{ 
#line 88
(::surfaceReference::channelDesc) = desc; 
#line 89
} 
#line 91 "e:\\cudatoolkit\\include\\cuda_surface_types.h"
}; 
#line 93
template< int dim> 
#line 94
struct surface< void, dim>  : public surfaceReference { 
#line 97
surface() 
#line 98
{ 
#line 99
(::surfaceReference::channelDesc) = cudaCreateChannelDesc< void> (); 
#line 100
} 
#line 102 "e:\\cudatoolkit\\include\\cuda_surface_types.h"
}; 
#line 77 "e:\\cudatoolkit\\include\\cuda_texture_types.h"
template< class T, int texType = 1, cudaTextureReadMode mode = cudaReadModeElementType> 
#line 78
struct texture : public textureReference { 
#line 81
texture(int norm = 0, ::cudaTextureFilterMode 
#line 82
fMode = cudaFilterModePoint, ::cudaTextureAddressMode 
#line 83
aMode = cudaAddressModeClamp) 
#line 84
{ 
#line 85
(::textureReference::normalized) = norm; 
#line 86
(::textureReference::filterMode) = fMode; 
#line 87
((::textureReference::addressMode)[0]) = aMode; 
#line 88
((::textureReference::addressMode)[1]) = aMode; 
#line 89
((::textureReference::addressMode)[2]) = aMode; 
#line 90
(::textureReference::channelDesc) = cudaCreateChannelDesc< T> (); 
#line 91
(::textureReference::sRGB) = 0; 
#line 92
} 
#line 94
texture(int norm, ::cudaTextureFilterMode 
#line 95
fMode, ::cudaTextureAddressMode 
#line 96
aMode, ::cudaChannelFormatDesc 
#line 97
desc) 
#line 98
{ 
#line 99
(::textureReference::normalized) = norm; 
#line 100
(::textureReference::filterMode) = fMode; 
#line 101
((::textureReference::addressMode)[0]) = aMode; 
#line 102
((::textureReference::addressMode)[1]) = aMode; 
#line 103
((::textureReference::addressMode)[2]) = aMode; 
#line 104
(::textureReference::channelDesc) = desc; 
#line 105
(::textureReference::sRGB) = 0; 
#line 106
} 
#line 108 "e:\\cudatoolkit\\include\\cuda_texture_types.h"
}; 
#line 3230 "e:\\cudatoolkit\\include\\device_functions.h"
static __inline int mulhi(int a, int b); 
#line 3232
static __inline unsigned mulhi(unsigned a, unsigned b); 
#line 3234
static __inline unsigned mulhi(int a, unsigned b); 
#line 3236
static __inline unsigned mulhi(unsigned a, int b); 
#line 3238
static __inline __int64 mul64hi(__int64 a, __int64 b); 
#line 3240
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b); 
#line 3242
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b); 
#line 3244
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b); 
#line 3246
static __inline int float_as_int(float a); 
#line 3248
static __inline float int_as_float(int a); 
#line 3250
static __inline unsigned float_as_uint(float a); 
#line 3252
static __inline float uint_as_float(unsigned a); 
#line 3254
static __inline float saturate(float a); 
#line 3256
static __inline int mul24(int a, int b); 
#line 3258
static __inline unsigned umul24(unsigned a, unsigned b); 
#line 3260
static __inline void trap(); 
#line 3263
static __inline void brkpt(int c = 0); 
#line 3265
static __inline void syncthreads(); 
#line 3267
static __inline void prof_trigger(int e); 
#line 3269
static __inline void threadfence(bool global = true); 
#line 3271
static __inline int float2int(float a, cudaRoundMode mode = cudaRoundZero); 
#line 3273
static __inline unsigned float2uint(float a, cudaRoundMode mode = cudaRoundZero); 
#line 3275
static __inline float int2float(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 3277
static __inline float uint2float(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 83 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline int mulhi(int a, int b) 
#line 84
{int volatile ___ = 1;(void)a;(void)b;
#line 86
::exit(___);}
#if 0
#line 84
{ 
#line 85
return __mulhi(a, b); 
#line 86
} 
#endif
#line 88 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned mulhi(unsigned a, unsigned b) 
#line 89
{int volatile ___ = 1;(void)a;(void)b;
#line 91
::exit(___);}
#if 0
#line 89
{ 
#line 90
return __umulhi(a, b); 
#line 91
} 
#endif
#line 93 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned mulhi(int a, unsigned b) 
#line 94
{int volatile ___ = 1;(void)a;(void)b;
#line 96
::exit(___);}
#if 0
#line 94
{ 
#line 95
return __umulhi((unsigned)a, b); 
#line 96
} 
#endif
#line 98 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned mulhi(unsigned a, int b) 
#line 99
{int volatile ___ = 1;(void)a;(void)b;
#line 101
::exit(___);}
#if 0
#line 99
{ 
#line 100
return __umulhi(a, (unsigned)b); 
#line 101
} 
#endif
#line 103 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline __int64 mul64hi(__int64 a, __int64 b) 
#line 104
{int volatile ___ = 1;(void)a;(void)b;
#line 106
::exit(___);}
#if 0
#line 104
{ 
#line 105
return __mul64hi(a, b); 
#line 106
} 
#endif
#line 108 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, unsigned __int64 b) 
#line 109
{int volatile ___ = 1;(void)a;(void)b;
#line 111
::exit(___);}
#if 0
#line 109
{ 
#line 110
return __umul64hi(a, b); 
#line 111
} 
#endif
#line 113 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(__int64 a, unsigned __int64 b) 
#line 114
{int volatile ___ = 1;(void)a;(void)b;
#line 116
::exit(___);}
#if 0
#line 114
{ 
#line 115
return __umul64hi((unsigned __int64)a, b); 
#line 116
} 
#endif
#line 118 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned __int64 mul64hi(unsigned __int64 a, __int64 b) 
#line 119
{int volatile ___ = 1;(void)a;(void)b;
#line 121
::exit(___);}
#if 0
#line 119
{ 
#line 120
return __umul64hi(a, (unsigned __int64)b); 
#line 121
} 
#endif
#line 123 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline int float_as_int(float a) 
#line 124
{int volatile ___ = 1;(void)a;
#line 126
::exit(___);}
#if 0
#line 124
{ 
#line 125
return __float_as_int(a); 
#line 126
} 
#endif
#line 128 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline float int_as_float(int a) 
#line 129
{int volatile ___ = 1;(void)a;
#line 131
::exit(___);}
#if 0
#line 129
{ 
#line 130
return __int_as_float(a); 
#line 131
} 
#endif
#line 133 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned float_as_uint(float a) 
#line 134
{int volatile ___ = 1;(void)a;
#line 136
::exit(___);}
#if 0
#line 134
{ 
#line 135
return __float_as_uint(a); 
#line 136
} 
#endif
#line 138 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline float uint_as_float(unsigned a) 
#line 139
{int volatile ___ = 1;(void)a;
#line 141
::exit(___);}
#if 0
#line 139
{ 
#line 140
return __uint_as_float(a); 
#line 141
} 
#endif
#line 142 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline float saturate(float a) 
#line 143
{int volatile ___ = 1;(void)a;
#line 145
::exit(___);}
#if 0
#line 143
{ 
#line 144
return __saturatef(a); 
#line 145
} 
#endif
#line 147 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline int mul24(int a, int b) 
#line 148
{int volatile ___ = 1;(void)a;(void)b;
#line 150
::exit(___);}
#if 0
#line 148
{ 
#line 149
return __mul24(a, b); 
#line 150
} 
#endif
#line 152 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned umul24(unsigned a, unsigned b) 
#line 153
{int volatile ___ = 1;(void)a;(void)b;
#line 155
::exit(___);}
#if 0
#line 153
{ 
#line 154
return __umul24(a, b); 
#line 155
} 
#endif
#line 157 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline void trap() 
#line 158
{int volatile ___ = 1;
#line 160
::exit(___);}
#if 0
#line 158
{ 
#line 159
__trap(); 
#line 160
} 
#endif
#line 163 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline void brkpt(int c) 
#line 164
{int volatile ___ = 1;(void)c;
#line 166
::exit(___);}
#if 0
#line 164
{ 
#line 165
__brkpt(c); 
#line 166
} 
#endif
#line 168 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline void syncthreads() 
#line 169
{int volatile ___ = 1;
#line 171
::exit(___);}
#if 0
#line 169
{ 
#line 170
__syncthreads(); 
#line 171
} 
#endif
#line 173 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline void prof_trigger(int e) 
#line 174
{int volatile ___ = 1;(void)e;
#line 191
::exit(___);}
#if 0
#line 174
{ 
#line 175
if (e == 0) { __prof_trigger(0); } else { 
#line 176
if (e == 1) { __prof_trigger(1); } else { 
#line 177
if (e == 2) { __prof_trigger(2); } else { 
#line 178
if (e == 3) { __prof_trigger(3); } else { 
#line 179
if (e == 4) { __prof_trigger(4); } else { 
#line 180
if (e == 5) { __prof_trigger(5); } else { 
#line 181
if (e == 6) { __prof_trigger(6); } else { 
#line 182
if (e == 7) { __prof_trigger(7); } else { 
#line 183
if (e == 8) { __prof_trigger(8); } else { 
#line 184
if (e == 9) { __prof_trigger(9); } else { 
#line 185
if (e == 10) { __prof_trigger(10); } else { 
#line 186
if (e == 11) { __prof_trigger(11); } else { 
#line 187
if (e == 12) { __prof_trigger(12); } else { 
#line 188
if (e == 13) { __prof_trigger(13); } else { 
#line 189
if (e == 14) { __prof_trigger(14); } else { 
#line 190
if (e == 15) { __prof_trigger(15); }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  }  
#line 191
} 
#endif
#line 193 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline void threadfence(bool global) 
#line 194
{int volatile ___ = 1;(void)global;
#line 196
::exit(___);}
#if 0
#line 194
{ 
#line 195
global ? __threadfence() : __threadfence_block(); 
#line 196
} 
#endif
#line 198 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline int float2int(float a, cudaRoundMode mode) 
#line 199
{int volatile ___ = 1;(void)a;(void)mode;
#line 204
::exit(___);}
#if 0
#line 199
{ 
#line 200
return (mode == (cudaRoundNearest)) ? __float2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2int_rd(a) : __float2int_rz(a))); 
#line 204
} 
#endif
#line 206 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline unsigned float2uint(float a, cudaRoundMode mode) 
#line 207
{int volatile ___ = 1;(void)a;(void)mode;
#line 212
::exit(___);}
#if 0
#line 207
{ 
#line 208
return (mode == (cudaRoundNearest)) ? __float2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __float2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __float2uint_rd(a) : __float2uint_rz(a))); 
#line 212
} 
#endif
#line 214 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline float int2float(int a, cudaRoundMode mode) 
#line 215
{int volatile ___ = 1;(void)a;(void)mode;
#line 220
::exit(___);}
#if 0
#line 215
{ 
#line 216
return (mode == (cudaRoundZero)) ? __int2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __int2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __int2float_rd(a) : __int2float_rn(a))); 
#line 220
} 
#endif
#line 222 "e:\\cudatoolkit\\include\\device_functions.hpp"
static __inline float uint2float(unsigned a, cudaRoundMode mode) 
#line 223
{int volatile ___ = 1;(void)a;(void)mode;
#line 228
::exit(___);}
#if 0
#line 223
{ 
#line 224
return (mode == (cudaRoundZero)) ? __uint2float_rz(a) : ((mode == (cudaRoundPosInf)) ? __uint2float_ru(a) : ((mode == (cudaRoundMinInf)) ? __uint2float_rd(a) : __uint2float_rn(a))); 
#line 228
} 
#endif
#line 105 "e:\\cudatoolkit\\include\\device_atomic_functions.h"
static __inline int atomicAdd(int * address, int val); 
#line 107
static __inline unsigned atomicAdd(unsigned * address, unsigned val); 
#line 109
static __inline int atomicSub(int * address, int val); 
#line 111
static __inline unsigned atomicSub(unsigned * address, unsigned val); 
#line 113
static __inline int atomicExch(int * address, int val); 
#line 115
static __inline unsigned atomicExch(unsigned * address, unsigned val); 
#line 117
static __inline float atomicExch(float * address, float val); 
#line 119
static __inline int atomicMin(int * address, int val); 
#line 121
static __inline unsigned atomicMin(unsigned * address, unsigned val); 
#line 123
static __inline int atomicMax(int * address, int val); 
#line 125
static __inline unsigned atomicMax(unsigned * address, unsigned val); 
#line 127
static __inline unsigned atomicInc(unsigned * address, unsigned val); 
#line 129
static __inline unsigned atomicDec(unsigned * address, unsigned val); 
#line 131
static __inline int atomicAnd(int * address, int val); 
#line 133
static __inline unsigned atomicAnd(unsigned * address, unsigned val); 
#line 135
static __inline int atomicOr(int * address, int val); 
#line 137
static __inline unsigned atomicOr(unsigned * address, unsigned val); 
#line 139
static __inline int atomicXor(int * address, int val); 
#line 141
static __inline unsigned atomicXor(unsigned * address, unsigned val); 
#line 143
static __inline int atomicCAS(int * address, int compare, int val); 
#line 145
static __inline unsigned atomicCAS(unsigned * address, unsigned compare, unsigned val); 
#line 178 "e:\\cudatoolkit\\include\\device_atomic_functions.h"
static __inline unsigned __int64 atomicAdd(unsigned __int64 * address, unsigned __int64 val); 
#line 180
static __inline unsigned __int64 atomicExch(unsigned __int64 * address, unsigned __int64 val); 
#line 182
static __inline unsigned __int64 atomicCAS(unsigned __int64 * address, unsigned __int64 compare, unsigned __int64 val); 
#line 184
static __inline bool any(bool cond); 
#line 186
static __inline bool all(bool cond); 
#line 78 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicAdd(int *address, int val) 
#line 79
{int volatile ___ = 1;(void)address;(void)val;
#line 81
::exit(___);}
#if 0
#line 79
{ 
#line 80
return __iAtomicAdd(address, val); 
#line 81
} 
#endif
#line 83 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicAdd(unsigned *address, unsigned val) 
#line 84
{int volatile ___ = 1;(void)address;(void)val;
#line 86
::exit(___);}
#if 0
#line 84
{ 
#line 85
return __uAtomicAdd(address, val); 
#line 86
} 
#endif
#line 88 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicSub(int *address, int val) 
#line 89
{int volatile ___ = 1;(void)address;(void)val;
#line 91
::exit(___);}
#if 0
#line 89
{ 
#line 90
return __iAtomicAdd(address, (unsigned)(-val)); 
#line 91
} 
#endif
#line 93 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicSub(unsigned *address, unsigned val) 
#line 94
{int volatile ___ = 1;(void)address;(void)val;
#line 96
::exit(___);}
#if 0
#line 94
{ 
#line 95
return __uAtomicAdd(address, (unsigned)(-((int)val))); 
#line 96
} 
#endif
#line 98 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicExch(int *address, int val) 
#line 99
{int volatile ___ = 1;(void)address;(void)val;
#line 101
::exit(___);}
#if 0
#line 99
{ 
#line 100
return __iAtomicExch(address, val); 
#line 101
} 
#endif
#line 103 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicExch(unsigned *address, unsigned val) 
#line 104
{int volatile ___ = 1;(void)address;(void)val;
#line 106
::exit(___);}
#if 0
#line 104
{ 
#line 105
return __uAtomicExch(address, val); 
#line 106
} 
#endif
#line 108 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline float atomicExch(float *address, float val) 
#line 109
{int volatile ___ = 1;(void)address;(void)val;
#line 111
::exit(___);}
#if 0
#line 109
{ 
#line 110
return __fAtomicExch(address, val); 
#line 111
} 
#endif
#line 113 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicMin(int *address, int val) 
#line 114
{int volatile ___ = 1;(void)address;(void)val;
#line 116
::exit(___);}
#if 0
#line 114
{ 
#line 115
return __iAtomicMin(address, val); 
#line 116
} 
#endif
#line 118 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicMin(unsigned *address, unsigned val) 
#line 119
{int volatile ___ = 1;(void)address;(void)val;
#line 121
::exit(___);}
#if 0
#line 119
{ 
#line 120
return __uAtomicMin(address, val); 
#line 121
} 
#endif
#line 123 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicMax(int *address, int val) 
#line 124
{int volatile ___ = 1;(void)address;(void)val;
#line 126
::exit(___);}
#if 0
#line 124
{ 
#line 125
return __iAtomicMax(address, val); 
#line 126
} 
#endif
#line 128 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicMax(unsigned *address, unsigned val) 
#line 129
{int volatile ___ = 1;(void)address;(void)val;
#line 131
::exit(___);}
#if 0
#line 129
{ 
#line 130
return __uAtomicMax(address, val); 
#line 131
} 
#endif
#line 133 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicInc(unsigned *address, unsigned val) 
#line 134
{int volatile ___ = 1;(void)address;(void)val;
#line 136
::exit(___);}
#if 0
#line 134
{ 
#line 135
return __uAtomicInc(address, val); 
#line 136
} 
#endif
#line 138 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicDec(unsigned *address, unsigned val) 
#line 139
{int volatile ___ = 1;(void)address;(void)val;
#line 141
::exit(___);}
#if 0
#line 139
{ 
#line 140
return __uAtomicDec(address, val); 
#line 141
} 
#endif
#line 143 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicAnd(int *address, int val) 
#line 144
{int volatile ___ = 1;(void)address;(void)val;
#line 146
::exit(___);}
#if 0
#line 144
{ 
#line 145
return __iAtomicAnd(address, val); 
#line 146
} 
#endif
#line 148 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicAnd(unsigned *address, unsigned val) 
#line 149
{int volatile ___ = 1;(void)address;(void)val;
#line 151
::exit(___);}
#if 0
#line 149
{ 
#line 150
return __uAtomicAnd(address, val); 
#line 151
} 
#endif
#line 153 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicOr(int *address, int val) 
#line 154
{int volatile ___ = 1;(void)address;(void)val;
#line 156
::exit(___);}
#if 0
#line 154
{ 
#line 155
return __iAtomicOr(address, val); 
#line 156
} 
#endif
#line 158 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicOr(unsigned *address, unsigned val) 
#line 159
{int volatile ___ = 1;(void)address;(void)val;
#line 161
::exit(___);}
#if 0
#line 159
{ 
#line 160
return __uAtomicOr(address, val); 
#line 161
} 
#endif
#line 163 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicXor(int *address, int val) 
#line 164
{int volatile ___ = 1;(void)address;(void)val;
#line 166
::exit(___);}
#if 0
#line 164
{ 
#line 165
return __iAtomicXor(address, val); 
#line 166
} 
#endif
#line 168 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicXor(unsigned *address, unsigned val) 
#line 169
{int volatile ___ = 1;(void)address;(void)val;
#line 171
::exit(___);}
#if 0
#line 169
{ 
#line 170
return __uAtomicXor(address, val); 
#line 171
} 
#endif
#line 173 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline int atomicCAS(int *address, int compare, int val) 
#line 174
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 176
::exit(___);}
#if 0
#line 174
{ 
#line 175
return __iAtomicCAS(address, compare, val); 
#line 176
} 
#endif
#line 178 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned atomicCAS(unsigned *address, unsigned compare, unsigned val) 
#line 179
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 181
::exit(___);}
#if 0
#line 179
{ 
#line 180
return __uAtomicCAS(address, compare, val); 
#line 181
} 
#endif
#line 201 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned __int64 atomicAdd(unsigned __int64 *address, unsigned __int64 val) 
#line 202
{int volatile ___ = 1;(void)address;(void)val;
#line 204
::exit(___);}
#if 0
#line 202
{ 
#line 203
return __ullAtomicAdd(address, val); 
#line 204
} 
#endif
#line 206 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned __int64 atomicExch(unsigned __int64 *address, unsigned __int64 val) 
#line 207
{int volatile ___ = 1;(void)address;(void)val;
#line 209
::exit(___);}
#if 0
#line 207
{ 
#line 208
return __ullAtomicExch(address, val); 
#line 209
} 
#endif
#line 211 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline unsigned __int64 atomicCAS(unsigned __int64 *address, unsigned __int64 compare, unsigned __int64 val) 
#line 212
{int volatile ___ = 1;(void)address;(void)compare;(void)val;
#line 214
::exit(___);}
#if 0
#line 212
{ 
#line 213
return __ullAtomicCAS(address, compare, val); 
#line 214
} 
#endif
#line 216 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline bool any(bool cond) 
#line 217
{int volatile ___ = 1;(void)cond;
#line 219
::exit(___);}
#if 0
#line 217
{ 
#line 218
return (bool)__any((int)cond); 
#line 219
} 
#endif
#line 221 "e:\\cudatoolkit\\include\\device_atomic_functions.hpp"
static __inline bool all(bool cond) 
#line 222
{int volatile ___ = 1;(void)cond;
#line 224
::exit(___);}
#if 0
#line 222
{ 
#line 223
return (bool)__all((int)cond); 
#line 224
} 
#endif
#line 1143 "e:\\cudatoolkit\\include\\device_double_functions.h"
static __inline double fma(double a, double b, double c, cudaRoundMode mode); 
#line 1145
static __inline double dmul(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1147
static __inline double dadd(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1149
static __inline double dsub(double a, double b, cudaRoundMode mode = cudaRoundNearest); 
#line 1151
static __inline int double2int(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1153
static __inline unsigned double2uint(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1155
static __inline __int64 double2ll(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1157
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode = cudaRoundZero); 
#line 1159
static __inline double ll2double(__int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1161
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode = cudaRoundNearest); 
#line 1163
static __inline double int2double(int a, cudaRoundMode mode = cudaRoundNearest); 
#line 1165
static __inline double uint2double(unsigned a, cudaRoundMode mode = cudaRoundNearest); 
#line 1167
static __inline double float2double(float a, cudaRoundMode mode = cudaRoundNearest); 
#line 85 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double fma(double a, double b, double c, cudaRoundMode mode) 
#line 86
{int volatile ___ = 1;(void)a;(void)b;(void)c;(void)mode;
#line 91
::exit(___);}
#if 0
#line 86
{ 
#line 87
return (mode == (cudaRoundZero)) ? __fma_rz(a, b, c) : ((mode == (cudaRoundPosInf)) ? __fma_ru(a, b, c) : ((mode == (cudaRoundMinInf)) ? __fma_rd(a, b, c) : __fma_rn(a, b, c))); 
#line 91
} 
#endif
#line 93 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double dmul(double a, double b, cudaRoundMode mode) 
#line 94
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 99
::exit(___);}
#if 0
#line 94
{ 
#line 95
return (mode == (cudaRoundZero)) ? __dmul_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dmul_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dmul_rd(a, b) : __dmul_rn(a, b))); 
#line 99
} 
#endif
#line 101 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double dadd(double a, double b, cudaRoundMode mode) 
#line 102
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 107
::exit(___);}
#if 0
#line 102
{ 
#line 103
return (mode == (cudaRoundZero)) ? __dadd_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dadd_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dadd_rd(a, b) : __dadd_rn(a, b))); 
#line 107
} 
#endif
#line 109 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double dsub(double a, double b, cudaRoundMode mode) 
#line 110
{int volatile ___ = 1;(void)a;(void)b;(void)mode;
#line 115
::exit(___);}
#if 0
#line 110
{ 
#line 111
return (mode == (cudaRoundZero)) ? __dsub_rz(a, b) : ((mode == (cudaRoundPosInf)) ? __dsub_ru(a, b) : ((mode == (cudaRoundMinInf)) ? __dsub_rd(a, b) : __dsub_rn(a, b))); 
#line 115
} 
#endif
#line 117 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline int double2int(double a, cudaRoundMode mode) 
#line 118
{int volatile ___ = 1;(void)a;(void)mode;
#line 123
::exit(___);}
#if 0
#line 118
{ 
#line 119
return (mode == (cudaRoundNearest)) ? __double2int_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2int_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2int_rd(a) : __double2int_rz(a))); 
#line 123
} 
#endif
#line 125 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline unsigned double2uint(double a, cudaRoundMode mode) 
#line 126
{int volatile ___ = 1;(void)a;(void)mode;
#line 131
::exit(___);}
#if 0
#line 126
{ 
#line 127
return (mode == (cudaRoundNearest)) ? __double2uint_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2uint_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2uint_rd(a) : __double2uint_rz(a))); 
#line 131
} 
#endif
#line 133 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline __int64 double2ll(double a, cudaRoundMode mode) 
#line 134
{int volatile ___ = 1;(void)a;(void)mode;
#line 139
::exit(___);}
#if 0
#line 134
{ 
#line 135
return (mode == (cudaRoundNearest)) ? __double2ll_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ll_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ll_rd(a) : __double2ll_rz(a))); 
#line 139
} 
#endif
#line 141 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline unsigned __int64 double2ull(double a, cudaRoundMode mode) 
#line 142
{int volatile ___ = 1;(void)a;(void)mode;
#line 147
::exit(___);}
#if 0
#line 142
{ 
#line 143
return (mode == (cudaRoundNearest)) ? __double2ull_rn(a) : ((mode == (cudaRoundPosInf)) ? __double2ull_ru(a) : ((mode == (cudaRoundMinInf)) ? __double2ull_rd(a) : __double2ull_rz(a))); 
#line 147
} 
#endif
#line 149 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double ll2double(__int64 a, cudaRoundMode mode) 
#line 150
{int volatile ___ = 1;(void)a;(void)mode;
#line 155
::exit(___);}
#if 0
#line 150
{ 
#line 151
return (mode == (cudaRoundZero)) ? __ll2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ll2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ll2double_rd(a) : __ll2double_rn(a))); 
#line 155
} 
#endif
#line 157 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double ull2double(unsigned __int64 a, cudaRoundMode mode) 
#line 158
{int volatile ___ = 1;(void)a;(void)mode;
#line 163
::exit(___);}
#if 0
#line 158
{ 
#line 159
return (mode == (cudaRoundZero)) ? __ull2double_rz(a) : ((mode == (cudaRoundPosInf)) ? __ull2double_ru(a) : ((mode == (cudaRoundMinInf)) ? __ull2double_rd(a) : __ull2double_rn(a))); 
#line 163
} 
#endif
#line 165 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double int2double(int a, cudaRoundMode mode) 
#line 166
{int volatile ___ = 1;(void)a;(void)mode;
#line 168
::exit(___);}
#if 0
#line 166
{ 
#line 167
return (double)a; 
#line 168
} 
#endif
#line 170 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double uint2double(unsigned a, cudaRoundMode mode) 
#line 171
{int volatile ___ = 1;(void)a;(void)mode;
#line 173
::exit(___);}
#if 0
#line 171
{ 
#line 172
return (double)a; 
#line 173
} 
#endif
#line 175 "e:\\cudatoolkit\\include\\device_double_functions.hpp"
static __inline double float2double(float a, cudaRoundMode mode) 
#line 176
{int volatile ___ = 1;(void)a;(void)mode;
#line 178
::exit(___);}
#if 0
#line 176
{ 
#line 177
return (double)a; 
#line 178
} 
#endif
#line 85 "e:\\cudatoolkit\\include\\sm_20_atomic_functions.h"
static __inline float atomicAdd(float * address, float val); 
#line 76 "e:\\cudatoolkit\\include\\sm_20_atomic_functions.hpp"
static __inline float atomicAdd(float *address, float val) 
#line 77
{int volatile ___ = 1;(void)address;(void)val;
#line 79
::exit(___);}
#if 0
#line 77
{ 
#line 78
return __fAtomicAdd(address, val); 
#line 79
} 
#endif
#line 93 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.h"
static __inline __int64 atomicMin(__int64 * address, __int64 val); 
#line 95
static __inline __int64 atomicMax(__int64 * address, __int64 val); 
#line 97
static __inline unsigned __int64 atomicMin(unsigned __int64 * address, unsigned __int64 val); 
#line 99
static __inline unsigned __int64 atomicMax(unsigned __int64 * address, unsigned __int64 val); 
#line 101
static __inline unsigned __int64 atomicAnd(unsigned __int64 * address, unsigned __int64 val); 
#line 103
static __inline unsigned __int64 atomicOr(unsigned __int64 * address, unsigned __int64 val); 
#line 105
static __inline unsigned __int64 atomicXor(unsigned __int64 * address, unsigned __int64 val); 
#line 78 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline __int64 atomicMin(__int64 *address, __int64 val) 
#line 79
{int volatile ___ = 1;(void)address;(void)val;
#line 81
::exit(___);}
#if 0
#line 79
{ 
#line 80
return __illAtomicMin(address, val); 
#line 81
} 
#endif
#line 83 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline __int64 atomicMax(__int64 *address, __int64 val) 
#line 84
{int volatile ___ = 1;(void)address;(void)val;
#line 86
::exit(___);}
#if 0
#line 84
{ 
#line 85
return __illAtomicMax(address, val); 
#line 86
} 
#endif
#line 88 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline unsigned __int64 atomicMin(unsigned __int64 *address, unsigned __int64 val) 
#line 89
{int volatile ___ = 1;(void)address;(void)val;
#line 91
::exit(___);}
#if 0
#line 89
{ 
#line 90
return __ullAtomicMin(address, val); 
#line 91
} 
#endif
#line 93 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline unsigned __int64 atomicMax(unsigned __int64 *address, unsigned __int64 val) 
#line 94
{int volatile ___ = 1;(void)address;(void)val;
#line 96
::exit(___);}
#if 0
#line 94
{ 
#line 95
return __ullAtomicMax(address, val); 
#line 96
} 
#endif
#line 98 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline unsigned __int64 atomicAnd(unsigned __int64 *address, unsigned __int64 val) 
#line 99
{int volatile ___ = 1;(void)address;(void)val;
#line 101
::exit(___);}
#if 0
#line 99
{ 
#line 100
return __ullAtomicAnd(address, val); 
#line 101
} 
#endif
#line 103 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline unsigned __int64 atomicOr(unsigned __int64 *address, unsigned __int64 val) 
#line 104
{int volatile ___ = 1;(void)address;(void)val;
#line 106
::exit(___);}
#if 0
#line 104
{ 
#line 105
return __ullAtomicOr(address, val); 
#line 106
} 
#endif
#line 108 "e:\\cudatoolkit\\include\\sm_32_atomic_functions.hpp"
static __inline unsigned __int64 atomicXor(unsigned __int64 *address, unsigned __int64 val) 
#line 109
{int volatile ___ = 1;(void)address;(void)val;
#line 111
::exit(___);}
#if 0
#line 109
{ 
#line 110
return __ullAtomicXor(address, val); 
#line 111
} 
#endif
#line 1468 "e:\\cudatoolkit\\include\\sm_20_intrinsics.h"
static __inline unsigned ballot(bool pred); 
#line 1470
static __inline int syncthreads_count(bool pred); 
#line 1472
static __inline bool syncthreads_and(bool pred); 
#line 1474
static __inline bool syncthreads_or(bool pred); 
#line 1479
static __inline unsigned __isGlobal(const void * ptr); 
#line 77 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
static __inline unsigned ballot(bool pred) 
#line 78
{int volatile ___ = 1;(void)pred;
#line 80
::exit(___);}
#if 0
#line 78
{ 
#line 79
return __ballot((int)pred); 
#line 80
} 
#endif
#line 82 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
static __inline int syncthreads_count(bool pred) 
#line 83
{int volatile ___ = 1;(void)pred;
#line 85
::exit(___);}
#if 0
#line 83
{ 
#line 84
return __syncthreads_count((int)pred); 
#line 85
} 
#endif
#line 87 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
static __inline bool syncthreads_and(bool pred) 
#line 88
{int volatile ___ = 1;(void)pred;
#line 90
::exit(___);}
#if 0
#line 88
{ 
#line 89
return (bool)__syncthreads_and((int)pred); 
#line 90
} 
#endif
#line 92 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
static __inline bool syncthreads_or(bool pred) 
#line 93
{int volatile ___ = 1;(void)pred;
#line 95
::exit(___);}
#if 0
#line 93
{ 
#line 94
return (bool)__syncthreads_or((int)pred); 
#line 95
} 
#endif
#line 100 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
static __inline unsigned __isGlobal(const void *ptr) 
#line 101
{int volatile ___ = 1;(void)ptr;
#line 114 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
::exit(___);}
#if 0
#line 101 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
{ 
#line 102
unsigned ret; 
#line 103
__asm { 
	    .reg .pred p; 
	    isspacep.global p, %1; 
	    selp.u32 %0, 1, 0, p;  
	} 
	
#line 113 "e:\\cudatoolkit\\include\\sm_20_intrinsics.hpp"
return ret; 
#line 114
} 
#endif
#line 91 "e:\\cudatoolkit\\include\\sm_30_intrinsics.h"
static __inline int __shfl(int var, int srcLane, int width = 32); 
#line 93
static __inline unsigned __shfl(unsigned var, int srcLane, int width = 32); 
#line 95
static __inline int __shfl_up(int var, unsigned delta, int width = 32); 
#line 96
static __inline unsigned __shfl_up(unsigned var, unsigned delta, int width = 32); 
#line 98
static __inline int __shfl_down(int var, unsigned delta, int width = 32); 
#line 100
static __inline unsigned __shfl_down(unsigned var, unsigned delta, int width = 32); 
#line 102
static __inline int __shfl_xor(int var, int laneMask, int width = 32); 
#line 104
static __inline unsigned __shfl_xor(unsigned var, int laneMask, int width = 32); 
#line 106
static __inline float __shfl(float var, int srcLane, int width = 32); 
#line 108
static __inline float __shfl_up(float var, unsigned delta, int width = 32); 
#line 110
static __inline float __shfl_down(float var, unsigned delta, int width = 32); 
#line 112
static __inline float __shfl_xor(float var, int laneMask, int width = 32); 
#line 115
static __inline __int64 __shfl(__int64 var, int srcLane, int width = 32); 
#line 117
static __inline unsigned __int64 __shfl(unsigned __int64 var, int srcLane, int width = 32); 
#line 119
static __inline __int64 __shfl_up(__int64 var, unsigned delta, int width = 32); 
#line 121
static __inline unsigned __int64 __shfl_up(unsigned __int64 var, unsigned delta, int width = 32); 
#line 123
static __inline __int64 __shfl_down(__int64 var, unsigned delta, int width = 32); 
#line 125
static __inline unsigned __int64 __shfl_down(unsigned __int64 var, unsigned delta, int width = 32); 
#line 127
static __inline __int64 __shfl_xor(__int64 var, int laneMask, int width = 32); 
#line 129
static __inline unsigned __int64 __shfl_xor(unsigned __int64 var, int laneMask, int width = 32); 
#line 131
static __inline double __shfl(double var, int srcLane, int width = 32); 
#line 133
static __inline double __shfl_up(double var, unsigned delta, int width = 32); 
#line 135
static __inline double __shfl_down(double var, unsigned delta, int width = 32); 
#line 137
static __inline double __shfl_xor(double var, int laneMask, int width = 32); 
#line 141
static __inline long __shfl(long var, int srcLane, int width = 32); 
#line 143
static __inline unsigned long __shfl(unsigned long var, int srcLane, int width = 32); 
#line 145
static __inline long __shfl_up(long var, unsigned delta, int width = 32); 
#line 147
static __inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width = 32); 
#line 149
static __inline long __shfl_down(long var, unsigned delta, int width = 32); 
#line 151
static __inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width = 32); 
#line 153
static __inline long __shfl_xor(long var, int laneMask, int width = 32); 
#line 155
static __inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width = 32); 
#line 99 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline int __shfl(int var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 104
::exit(___);}
#if 0
#line 99
{ 
#line 100
int ret; 
#line 101
int c = ((32 - width) << 8) | 31; 
#line 102
__asm shfl.idx.b32 %0, %1, %2, %3;
return ret; 
#line 104
} 
#endif
#line 106 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __shfl(unsigned var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 108
::exit(___);}
#if 0
#line 106
{ 
#line 107
return (unsigned)__shfl((int)var, srcLane, width); 
#line 108
} 
#endif
#line 110 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline int __shfl_up(int var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 115
::exit(___);}
#if 0
#line 110
{ 
#line 111
int ret; 
#line 112
int c = (32 - width) << 8; 
#line 113
__asm shfl.up.b32 %0, %1, %2, %3;
return ret; 
#line 115
} 
#endif
#line 116 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __shfl_up(unsigned var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 118
::exit(___);}
#if 0
#line 116
{ 
#line 117
return (unsigned)__shfl_up((int)var, delta, width); 
#line 118
} 
#endif
#line 120 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline int __shfl_down(int var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 125
::exit(___);}
#if 0
#line 120
{ 
#line 121
int ret; 
#line 122
int c = ((32 - width) << 8) | 31; 
#line 123
__asm shfl.down.b32 %0, %1, %2, %3;
return ret; 
#line 125
} 
#endif
#line 127 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __shfl_down(unsigned var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 129
::exit(___);}
#if 0
#line 127
{ 
#line 128
return (unsigned)__shfl_down((int)var, delta, width); 
#line 129
} 
#endif
#line 131 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline int __shfl_xor(int var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 136
::exit(___);}
#if 0
#line 131
{ 
#line 132
int ret; 
#line 133
int c = ((32 - width) << 8) | 31; 
#line 134
__asm shfl.bfly.b32 %0, %1, %2, %3;
return ret; 
#line 136
} 
#endif
#line 138 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __shfl_xor(unsigned var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 140
::exit(___);}
#if 0
#line 138
{ 
#line 139
return (unsigned)__shfl_xor((int)var, laneMask, width); 
#line 140
} 
#endif
#line 142 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline float __shfl(float var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 148
::exit(___);}
#if 0
#line 142
{ 
#line 143
float ret; 
#line 144
int c; 
#line 145
c = (((32 - width) << 8) | 31); 
#line 146
__asm shfl.idx.b32 %0, %1, %2, %3;
return ret; 
#line 148
} 
#endif
#line 150 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline float __shfl_up(float var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 156
::exit(___);}
#if 0
#line 150
{ 
#line 151
float ret; 
#line 152
int c; 
#line 153
c = ((32 - width) << 8); 
#line 154
__asm shfl.up.b32 %0, %1, %2, %3;
return ret; 
#line 156
} 
#endif
#line 158 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline float __shfl_down(float var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 164
::exit(___);}
#if 0
#line 158
{ 
#line 159
float ret; 
#line 160
int c; 
#line 161
c = (((32 - width) << 8) | 31); 
#line 162
__asm shfl.down.b32 %0, %1, %2, %3;
return ret; 
#line 164
} 
#endif
#line 166 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline float __shfl_xor(float var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 172
::exit(___);}
#if 0
#line 166
{ 
#line 167
float ret; 
#line 168
int c; 
#line 169
c = (((32 - width) << 8) | 31); 
#line 170
__asm shfl.bfly.b32 %0, %1, %2, %3;
return ret; 
#line 172
} 
#endif
#line 175 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline __int64 __shfl(__int64 var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 182
::exit(___);}
#if 0
#line 175
{ 
#line 176
int lo, hi; 
#line 177
__asm mov.b64 {%0,%1}, %2;
hi = __shfl(hi, srcLane, width); 
#line 179
lo = __shfl(lo, srcLane, width); 
#line 180
__asm mov.b64 %0, {%1,%2};
return var; 
#line 182
} 
#endif
#line 184 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __int64 __shfl(unsigned __int64 var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 186
::exit(___);}
#if 0
#line 184
{ 
#line 185
return (unsigned __int64)__shfl((__int64)var, srcLane, width); 
#line 186
} 
#endif
#line 188 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline __int64 __shfl_up(__int64 var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 195
::exit(___);}
#if 0
#line 188
{ 
#line 189
int lo, hi; 
#line 190
__asm mov.b64 {%0,%1}, %2;
hi = __shfl_up(hi, delta, width); 
#line 192
lo = __shfl_up(lo, delta, width); 
#line 193
__asm mov.b64 %0, {%1,%2};
return var; 
#line 195
} 
#endif
#line 197 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __int64 __shfl_up(unsigned __int64 var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 199
::exit(___);}
#if 0
#line 197
{ 
#line 198
return (unsigned __int64)__shfl_up((__int64)var, delta, width); 
#line 199
} 
#endif
#line 201 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline __int64 __shfl_down(__int64 var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 208
::exit(___);}
#if 0
#line 201
{ 
#line 202
int lo, hi; 
#line 203
__asm mov.b64 {%0,%1}, %2;
hi = __shfl_down(hi, delta, width); 
#line 205
lo = __shfl_down(lo, delta, width); 
#line 206
__asm mov.b64 %0, {%1,%2};
return var; 
#line 208
} 
#endif
#line 210 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __int64 __shfl_down(unsigned __int64 var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 212
::exit(___);}
#if 0
#line 210
{ 
#line 211
return (unsigned __int64)__shfl_down((__int64)var, delta, width); 
#line 212
} 
#endif
#line 214 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline __int64 __shfl_xor(__int64 var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 221
::exit(___);}
#if 0
#line 214
{ 
#line 215
int lo, hi; 
#line 216
__asm mov.b64 {%0,%1}, %2;
hi = __shfl_xor(hi, laneMask, width); 
#line 218
lo = __shfl_xor(lo, laneMask, width); 
#line 219
__asm mov.b64 %0, {%1,%2};
return var; 
#line 221
} 
#endif
#line 223 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned __int64 __shfl_xor(unsigned __int64 var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 225
::exit(___);}
#if 0
#line 223
{ 
#line 224
return (unsigned __int64)__shfl_xor((__int64)var, laneMask, width); 
#line 225
} 
#endif
#line 227 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline double __shfl(double var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 234
::exit(___);}
#if 0
#line 227
{ 
#line 228
float lo, hi; 
#line 229
__asm mov.b64 {%0,%1}, %2;
hi = __shfl(hi, srcLane, width); 
#line 231
lo = __shfl(lo, srcLane, width); 
#line 232
__asm mov.b64 %0, {%1,%2};
return var; 
#line 234
} 
#endif
#line 236 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline double __shfl_up(double var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 243
::exit(___);}
#if 0
#line 236
{ 
#line 237
float lo, hi; 
#line 238
__asm mov.b64 {%0,%1}, %2;
hi = __shfl_up(hi, delta, width); 
#line 240
lo = __shfl_up(lo, delta, width); 
#line 241
__asm mov.b64 %0, {%1,%2};
return var; 
#line 243
} 
#endif
#line 245 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline double __shfl_down(double var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 252
::exit(___);}
#if 0
#line 245
{ 
#line 246
float lo, hi; 
#line 247
__asm mov.b64 {%0,%1}, %2;
hi = __shfl_down(hi, delta, width); 
#line 249
lo = __shfl_down(lo, delta, width); 
#line 250
__asm mov.b64 %0, {%1,%2};
return var; 
#line 252
} 
#endif
#line 254 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline double __shfl_xor(double var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 261
::exit(___);}
#if 0
#line 254
{ 
#line 255
float lo, hi; 
#line 256
__asm mov.b64 {%0,%1}, %2;
hi = __shfl_xor(hi, laneMask, width); 
#line 258
lo = __shfl_xor(lo, laneMask, width); 
#line 259
__asm mov.b64 %0, {%1,%2};
return var; 
#line 261
} 
#endif
#line 265 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline long __shfl(long var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 269
::exit(___);}
#if 0
#line 265
{ 
#line 266
return (sizeof(long) == sizeof(__int64)) ? __shfl((__int64)var, srcLane, width) : (__shfl((int)var, srcLane, width)); 
#line 269
} 
#endif
#line 271 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned long __shfl(unsigned long var, int srcLane, int width) {int volatile ___ = 1;(void)var;(void)srcLane;(void)width;
#line 275
::exit(___);}
#if 0
#line 271
{ 
#line 272
return (sizeof(long) == sizeof(__int64)) ? __shfl((unsigned __int64)var, srcLane, width) : (__shfl((unsigned)var, srcLane, width)); 
#line 275
} 
#endif
#line 277 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline long __shfl_up(long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 281
::exit(___);}
#if 0
#line 277
{ 
#line 278
return (sizeof(long) == sizeof(__int64)) ? __shfl_up((__int64)var, delta, width) : (__shfl_up((int)var, delta, width)); 
#line 281
} 
#endif
#line 283 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned long __shfl_up(unsigned long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 287
::exit(___);}
#if 0
#line 283
{ 
#line 284
return (sizeof(long) == sizeof(__int64)) ? __shfl_up((unsigned __int64)var, delta, width) : (__shfl_up((unsigned)var, delta, width)); 
#line 287
} 
#endif
#line 289 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline long __shfl_down(long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 293
::exit(___);}
#if 0
#line 289
{ 
#line 290
return (sizeof(long) == sizeof(__int64)) ? __shfl_down((__int64)var, delta, width) : (__shfl_down((int)var, delta, width)); 
#line 293
} 
#endif
#line 295 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned long __shfl_down(unsigned long var, unsigned delta, int width) {int volatile ___ = 1;(void)var;(void)delta;(void)width;
#line 299
::exit(___);}
#if 0
#line 295
{ 
#line 296
return (sizeof(long) == sizeof(__int64)) ? __shfl_down((unsigned __int64)var, delta, width) : (__shfl_down((unsigned)var, delta, width)); 
#line 299
} 
#endif
#line 301 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline long __shfl_xor(long var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 305
::exit(___);}
#if 0
#line 301
{ 
#line 302
return (sizeof(long) == sizeof(__int64)) ? __shfl_xor((__int64)var, laneMask, width) : (__shfl_xor((int)var, laneMask, width)); 
#line 305
} 
#endif
#line 307 "e:\\cudatoolkit\\include\\sm_30_intrinsics.hpp"
static __inline unsigned long __shfl_xor(unsigned long var, int laneMask, int width) {int volatile ___ = 1;(void)var;(void)laneMask;(void)width;
#line 311
::exit(___);}
#if 0
#line 307
{ 
#line 308
return (sizeof(long) == sizeof(__int64)) ? __shfl_xor((unsigned __int64)var, laneMask, width) : (__shfl_xor((unsigned)var, laneMask, width)); 
#line 311
} 
#endif
#line 80 "e:\\cudatoolkit\\include\\sm_32_intrinsics.h"
static __inline long __ldg(const long * ptr); 
#line 81
static __inline unsigned long __ldg(const unsigned long * ptr); 
#line 84
static __inline char __ldg(const char * ptr); 
#line 85
static __inline signed char __ldg(const signed char * ptr); 
#line 86
static __inline short __ldg(const short * ptr); 
#line 87
static __inline int __ldg(const int * ptr); 
#line 88
static __inline __int64 __ldg(const __int64 * ptr); 
#line 89
static __inline char2 __ldg(const char2 * ptr); 
#line 90
static __inline char4 __ldg(const char4 * ptr); 
#line 91
static __inline short2 __ldg(const short2 * ptr); 
#line 92
static __inline short4 __ldg(const short4 * ptr); 
#line 93
static __inline int2 __ldg(const int2 * ptr); 
#line 94
static __inline int4 __ldg(const int4 * ptr); 
#line 95
static __inline longlong2 __ldg(const longlong2 * ptr); 
#line 97
static __inline unsigned char __ldg(const unsigned char * ptr); 
#line 98
static __inline unsigned short __ldg(const unsigned short * ptr); 
#line 99
static __inline unsigned __ldg(const unsigned * ptr); 
#line 100
static __inline unsigned __int64 __ldg(const unsigned __int64 * ptr); 
#line 101
static __inline uchar2 __ldg(const uchar2 * ptr); 
#line 102
static __inline uchar4 __ldg(const uchar4 * ptr); 
#line 103
static __inline ushort2 __ldg(const ushort2 * ptr); 
#line 104
static __inline ushort4 __ldg(const ushort4 * ptr); 
#line 105
static __inline uint2 __ldg(const uint2 * ptr); 
#line 106
static __inline uint4 __ldg(const uint4 * ptr); 
#line 107
static __inline ulonglong2 __ldg(const ulonglong2 * ptr); 
#line 109
static __inline float __ldg(const float * ptr); 
#line 110
static __inline double __ldg(const double * ptr); 
#line 111
static __inline float2 __ldg(const float2 * ptr); 
#line 112
static __inline float4 __ldg(const float4 * ptr); 
#line 113
static __inline double2 __ldg(const double2 * ptr); 
#line 120
static __inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift); 
#line 121
static __inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift); 
#line 124
static __inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift); 
#line 125
static __inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift); 
#line 102 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline long __ldg(const long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 102
{ unsigned long ret; __asm ld.global.nc.s32 %0, [%1];
#line 102
return (long)ret; } 
#endif
#line 103 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned long __ldg(const unsigned long *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 103
{ unsigned long ret; __asm ld.global.nc.u32 %0, [%1];
#line 103
return ret; } 
#endif
#line 107 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline char __ldg(const char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 107
{ unsigned ret; __asm ld.global.nc.s8 %0, [%1];
#line 107
return (char)ret; } 
#endif
#line 108 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline signed char __ldg(const signed char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 108
{ unsigned ret; __asm ld.global.nc.s8 %0, [%1];
#line 108
return (signed char)ret; } 
#endif
#line 109 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline short __ldg(const short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 109
{ unsigned short ret; __asm ld.global.nc.s16 %0, [%1];
#line 109
return (short)ret; } 
#endif
#line 110 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline int __ldg(const int *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 110
{ unsigned ret; __asm ld.global.nc.s32 %0, [%1];
#line 110
return (int)ret; } 
#endif
#line 111 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline __int64 __ldg(const __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 111
{ unsigned __int64 ret; __asm ld.global.nc.s64 %0, [%1];
#line 111
return (__int64)ret; } 
#endif
#line 112 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline char2 __ldg(const char2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 112
{ char2 ret; int2 tmp; __asm ld.global.nc.v2.s8 {%0,%1}, [%2];
#line 112
(ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); return ret; } 
#endif
#line 113 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline char4 __ldg(const char4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 113
{ char4 ret; int4 tmp; __asm ld.global.nc.v4.s8 {%0,%1,%2,%3}, [%4];
#line 113
(ret.x) = ((char)(tmp.x)); (ret.y) = ((char)(tmp.y)); (ret.z) = ((char)(tmp.z)); (ret.w) = ((char)(tmp.w)); return ret; } 
#endif
#line 114 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline short2 __ldg(const short2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 114
{ short2 ret; __asm ld.global.nc.v2.s16 {%0,%1}, [%2];
#line 114
return ret; } 
#endif
#line 115 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline short4 __ldg(const short4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 115
{ short4 ret; __asm ld.global.nc.v4.s16 {%0,%1,%2,%3}, [%4];
#line 115
return ret; } 
#endif
#line 116 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline int2 __ldg(const int2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 116
{ int2 ret; __asm ld.global.nc.v2.s32 {%0,%1}, [%2];
#line 116
return ret; } 
#endif
#line 117 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline int4 __ldg(const int4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 117
{ int4 ret; __asm ld.global.nc.v4.s32 {%0,%1,%2,%3}, [%4];
#line 117
return ret; } 
#endif
#line 118 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline longlong2 __ldg(const longlong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 118
{ longlong2 ret; __asm ld.global.nc.v2.s64 %0, [%1];
#line 118
return ret; } 
#endif
#line 120 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned char __ldg(const unsigned char *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 120
{ unsigned ret; __asm ld.global.nc.u8 %0, [%1];
#line 120
return (unsigned char)ret; } 
#endif
#line 121 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned short __ldg(const unsigned short *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 121
{ unsigned short ret; __asm ld.global.nc.u16 %0, [%1];
#line 121
return ret; } 
#endif
#line 122 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned __ldg(const unsigned *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 122
{ unsigned ret; __asm ld.global.nc.u32 %0, [%1];
#line 122
return ret; } 
#endif
#line 123 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned __int64 __ldg(const unsigned __int64 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 123
{ unsigned __int64 ret; __asm ld.global.nc.u64 %0, [%1];
#line 123
return ret; } 
#endif
#line 124 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline uchar2 __ldg(const uchar2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 124
{ uchar2 ret; uint2 tmp; __asm ld.global.nc.v2.u8 {%0,%1}, [%2];
#line 124
(ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); return ret; } 
#endif
#line 125 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline uchar4 __ldg(const uchar4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 125
{ uchar4 ret; uint4 tmp; __asm ld.global.nc.v4.u8 {%0,%1,%2,%3}, [%4];
#line 125
(ret.x) = ((unsigned char)(tmp.x)); (ret.y) = ((unsigned char)(tmp.y)); (ret.z) = ((unsigned char)(tmp.z)); (ret.w) = ((unsigned char)(tmp.w)); return ret; } 
#endif
#line 126 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline ushort2 __ldg(const ushort2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 126
{ ushort2 ret; __asm ld.global.nc.v2.u16 {%0,%1}, [%2];
#line 126
return ret; } 
#endif
#line 127 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline ushort4 __ldg(const ushort4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 127
{ ushort4 ret; __asm ld.global.nc.v4.u16 {%0,%1,%2,%3}, [%4];
#line 127
return ret; } 
#endif
#line 128 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline uint2 __ldg(const uint2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 128
{ uint2 ret; __asm ld.global.nc.v2.u32 {%0,%1}, [%2];
#line 128
return ret; } 
#endif
#line 129 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline uint4 __ldg(const uint4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 129
{ uint4 ret; __asm ld.global.nc.v4.u32 {%0,%1,%2,%3}, [%4];
#line 129
return ret; } 
#endif
#line 130 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline ulonglong2 __ldg(const ulonglong2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 130
{ ulonglong2 ret; __asm ld.global.nc.v2.u64 %0, [%1];
#line 130
return ret; } 
#endif
#line 132 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline float __ldg(const float *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 132
{ float ret; __asm ld.global.nc.f32 %0, [%1];
#line 132
return ret; } 
#endif
#line 133 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline double __ldg(const double *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 133
{ double ret; __asm ld.global.nc.f64 %0, [%1];
#line 133
return ret; } 
#endif
#line 134 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline float2 __ldg(const float2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 134
{ float2 ret; __asm ld.global.nc.v2.f32 {%0,%1}, [%2];
#line 134
return ret; } 
#endif
#line 135 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline float4 __ldg(const float4 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 135
{ float4 ret; __asm ld.global.nc.v4.f32 {%0,%1,%2,%3}, [%4];
#line 135
return ret; } 
#endif
#line 136 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline double2 __ldg(const double2 *ptr) {int volatile ___ = 1;(void)ptr;::exit(___);}
#if 0
#line 136
{ double2 ret; __asm ld.global.nc.v2.f64 {%0,%1}, [%2];
#line 136
return ret; } 
#endif
#line 145 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned __funnelshift_l(unsigned lo, unsigned hi, unsigned shift) 
#line 146
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 150
::exit(___);}
#if 0
#line 146
{ 
#line 147
unsigned ret; 
#line 148
__asm shf.l.wrap.b32 %0, %1, %2, %3;
return ret; 
#line 150
} 
#endif
#line 151 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned __funnelshift_lc(unsigned lo, unsigned hi, unsigned shift) 
#line 152
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 156
::exit(___);}
#if 0
#line 152
{ 
#line 153
unsigned ret; 
#line 154
__asm shf.l.clamp.b32 %0, %1, %2, %3;
return ret; 
#line 156
} 
#endif
#line 159 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned __funnelshift_r(unsigned lo, unsigned hi, unsigned shift) 
#line 160
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 164
::exit(___);}
#if 0
#line 160
{ 
#line 161
unsigned ret; 
#line 162
__asm shf.r.wrap.b32 %0, %1, %2, %3;
return ret; 
#line 164
} 
#endif
#line 165 "e:\\cudatoolkit\\include\\sm_32_intrinsics.hpp"
static __inline unsigned __funnelshift_rc(unsigned lo, unsigned hi, unsigned shift) 
#line 166
{int volatile ___ = 1;(void)lo;(void)hi;(void)shift;
#line 170
::exit(___);}
#if 0
#line 166
{ 
#line 167
unsigned ret; 
#line 168
__asm shf.r.clamp.b32 %0, %1, %2, %3;
return ret; 
#line 170
} 
#endif
#line 112 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 113
surf1Dread(T *res, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 114
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)s;(void)mode;
#line 121
::exit(___);}
#if 0
#line 114
{ 
#line 115
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf1Dreadc1(surf, x, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf1Dreads1(surf, x, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf1Dreadu1(surf, x, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 121
} 
#endif
#line 123 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 124
surf1Dread(::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 125
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 131
::exit(___);}
#if 0
#line 125
{ 
#line 126
T tmp; 
#line 128
surf1Dread(&tmp, surf, x, (int)sizeof(T), mode); 
#line 130
return tmp; 
#line 131
} 
#endif
#line 133 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 134
surf1Dread(T *res, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 135
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)mode;
#line 137
::exit(___);}
#if 0
#line 135
{ 
#line 136
(*res) = surf1Dread< T> (surf, x, mode); 
#line 137
} 
#endif
#line 140 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 141
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 143
::exit(___);}
#if 0
#line 141
{ 
#line 142
return (char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x); 
#line 143
} 
#endif
#line 146 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 147
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 149
::exit(___);}
#if 0
#line 147
{ 
#line 148
return (signed char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x); 
#line 149
} 
#endif
#line 152 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 153
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 155
::exit(___);}
#if 0
#line 153
{ 
#line 154
return (__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x; 
#line 155
} 
#endif
#line 158 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 159
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 161
::exit(___);}
#if 0
#line 159
{ 
#line 160
return make_char1((signed char)((__surf1Dreadc1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 161
} 
#endif
#line 164 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 165
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 167
::exit(___);}
#if 0
#line 165
{ 
#line 166
return __surf1Dreadc1(surf, x, cudaBoundaryModeTrap); 
#line 167
} 
#endif
#line 170 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 171
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 175
::exit(___);}
#if 0
#line 171
{ 
#line 172
uchar2 tmp = __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
#line 174
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 175
} 
#endif
#line 178 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 179
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 181
::exit(___);}
#if 0
#line 179
{ 
#line 180
return __surf1Dreadc2(surf, x, cudaBoundaryModeTrap); 
#line 181
} 
#endif
#line 184 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 185
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 189
::exit(___);}
#if 0
#line 185
{ 
#line 186
uchar4 tmp = __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
#line 188
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 189
} 
#endif
#line 192 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 193
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 195
::exit(___);}
#if 0
#line 193
{ 
#line 194
return __surf1Dreadc4(surf, x, cudaBoundaryModeTrap); 
#line 195
} 
#endif
#line 198 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 199
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 201
::exit(___);}
#if 0
#line 199
{ 
#line 200
return (short)((__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x); 
#line 201
} 
#endif
#line 204 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 205
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 207
::exit(___);}
#if 0
#line 205
{ 
#line 206
return (__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x; 
#line 207
} 
#endif
#line 210 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 211
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 213
::exit(___);}
#if 0
#line 211
{ 
#line 212
return make_short1((signed short)((__surf1Dreads1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 213
} 
#endif
#line 216 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 217
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 219
::exit(___);}
#if 0
#line 217
{ 
#line 218
return __surf1Dreads1(surf, x, cudaBoundaryModeTrap); 
#line 219
} 
#endif
#line 222 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 223
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 227
::exit(___);}
#if 0
#line 223
{ 
#line 224
ushort2 tmp = __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
#line 226
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 227
} 
#endif
#line 230 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 231
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 233
::exit(___);}
#if 0
#line 231
{ 
#line 232
return __surf1Dreads2(surf, x, cudaBoundaryModeTrap); 
#line 233
} 
#endif
#line 236 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 237
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 241
::exit(___);}
#if 0
#line 237
{ 
#line 238
ushort4 tmp = __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
#line 240
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 241
} 
#endif
#line 244 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 245
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 247
::exit(___);}
#if 0
#line 245
{ 
#line 246
return __surf1Dreads4(surf, x, cudaBoundaryModeTrap); 
#line 247
} 
#endif
#line 250 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 251
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 253
::exit(___);}
#if 0
#line 251
{ 
#line 252
return (int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 253
} 
#endif
#line 256 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 257
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 259
::exit(___);}
#if 0
#line 257
{ 
#line 258
return (__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x; 
#line 259
} 
#endif
#line 262 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 263
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 265
::exit(___);}
#if 0
#line 263
{ 
#line 264
return make_int1((signed int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 265
} 
#endif
#line 268 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 269
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 271
::exit(___);}
#if 0
#line 269
{ 
#line 270
return __surf1Dreadu1(surf, x, cudaBoundaryModeTrap); 
#line 271
} 
#endif
#line 274 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 275
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 279
::exit(___);}
#if 0
#line 275
{ 
#line 276
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 278
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 279
} 
#endif
#line 282 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 283
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 285
::exit(___);}
#if 0
#line 283
{ 
#line 284
return __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 285
} 
#endif
#line 288 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 289
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 293
::exit(___);}
#if 0
#line 289
{ 
#line 290
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 292
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 293
} 
#endif
#line 296 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 297
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 299
::exit(___);}
#if 0
#line 297
{ 
#line 298
return __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 299
} 
#endif
#line 302 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 303
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 305
::exit(___);}
#if 0
#line 303
{ 
#line 304
return (__int64)((__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x); 
#line 305
} 
#endif
#line 308 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 309
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 311
::exit(___);}
#if 0
#line 309
{ 
#line 310
return (__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x; 
#line 311
} 
#endif
#line 314 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 315
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 317
::exit(___);}
#if 0
#line 315
{ 
#line 316
return make_longlong1((__int64)((__surf1Dreadl1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 317
} 
#endif
#line 320 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 321
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 323
::exit(___);}
#if 0
#line 321
{ 
#line 322
return __surf1Dreadl1(surf, x, cudaBoundaryModeTrap); 
#line 323
} 
#endif
#line 326 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 327
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 331
::exit(___);}
#if 0
#line 327
{ 
#line 328
ulonglong2 tmp = __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
#line 330
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 331
} 
#endif
#line 334 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 335
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 337
::exit(___);}
#if 0
#line 335
{ 
#line 336
return __surf1Dreadl2(surf, x, cudaBoundaryModeTrap); 
#line 337
} 
#endif
#line 342 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 343
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 345
::exit(___);}
#if 0
#line 343
{ 
#line 344
return (long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 345
} 
#endif
#line 348 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 349
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 351
::exit(___);}
#if 0
#line 349
{ 
#line 350
return (unsigned long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x); 
#line 351
} 
#endif
#line 354 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 355
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 357
::exit(___);}
#if 0
#line 355
{ 
#line 356
return make_long1((long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 357
} 
#endif
#line 360 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 361
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 363
::exit(___);}
#if 0
#line 361
{ 
#line 362
return make_ulong1((unsigned long)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 363
} 
#endif
#line 366 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 367
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 371
::exit(___);}
#if 0
#line 367
{ 
#line 368
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 370
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 371
} 
#endif
#line 374 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 375
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 379
::exit(___);}
#if 0
#line 375
{ 
#line 376
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 378
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 379
} 
#endif
#line 382 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 383
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 387
::exit(___);}
#if 0
#line 383
{ 
#line 384
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 386
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 387
} 
#endif
#line 390 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 391
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 395
::exit(___);}
#if 0
#line 391
{ 
#line 392
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 394
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 395
} 
#endif
#line 400 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 401
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 403
::exit(___);}
#if 0
#line 401
{ 
#line 402
return __int_as_float((int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x)); 
#line 403
} 
#endif
#line 406 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 407
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 409
::exit(___);}
#if 0
#line 407
{ 
#line 408
return make_float1(__int_as_float((int)((__surf1Dreadu1(surf, x, cudaBoundaryModeTrap)).x))); 
#line 409
} 
#endif
#line 412 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 413
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 417
::exit(___);}
#if 0
#line 413
{ 
#line 414
uint2 tmp = __surf1Dreadu2(surf, x, cudaBoundaryModeTrap); 
#line 416
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 417
} 
#endif
#line 420 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surf1Dread(surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 421
{int volatile ___ = 1;(void)surf;(void)x;(void)mode;
#line 425
::exit(___);}
#if 0
#line 421
{ 
#line 422
uint4 tmp = __surf1Dreadu4(surf, x, cudaBoundaryModeTrap); 
#line 424
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 425
} 
#endif
#line 460 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 461
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 462
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 469
::exit(___);}
#if 0
#line 462
{ 
#line 463
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 469
} 
#endif
#line 471 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 472
surf2Dread(::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 473
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 479
::exit(___);}
#if 0
#line 473
{ 
#line 474
T tmp; 
#line 476
surf2Dread(&tmp, surf, x, y, (int)sizeof(T), mode); 
#line 478
return tmp; 
#line 479
} 
#endif
#line 481 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 482
surf2Dread(T *res, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 483
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)mode;
#line 485
::exit(___);}
#if 0
#line 483
{ 
#line 484
(*res) = surf2Dread< T> (surf, x, y, mode); 
#line 485
} 
#endif
#line 488 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 491
::exit(___);}
#if 0
#line 489
{ 
#line 490
return (char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 491
} 
#endif
#line 494 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 495
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 497
::exit(___);}
#if 0
#line 495
{ 
#line 496
return (signed char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 497
} 
#endif
#line 500 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 501
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 503
::exit(___);}
#if 0
#line 501
{ 
#line 502
return (__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 503
} 
#endif
#line 506 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 507
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 509
::exit(___);}
#if 0
#line 507
{ 
#line 508
return make_char1((signed char)((__surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 509
} 
#endif
#line 512 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 513
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 515
::exit(___);}
#if 0
#line 513
{ 
#line 514
return __surf2Dreadc1(surf, x, y, cudaBoundaryModeTrap); 
#line 515
} 
#endif
#line 518 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 519
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 523
::exit(___);}
#if 0
#line 519
{ 
#line 520
uchar2 tmp = __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
#line 522
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 523
} 
#endif
#line 526 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 527
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 529
::exit(___);}
#if 0
#line 527
{ 
#line 528
return __surf2Dreadc2(surf, x, y, cudaBoundaryModeTrap); 
#line 529
} 
#endif
#line 532 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 533
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 537
::exit(___);}
#if 0
#line 533
{ 
#line 534
uchar4 tmp = __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
#line 536
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 537
} 
#endif
#line 540 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 541
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 543
::exit(___);}
#if 0
#line 541
{ 
#line 542
return __surf2Dreadc4(surf, x, y, cudaBoundaryModeTrap); 
#line 543
} 
#endif
#line 546 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 547
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 549
::exit(___);}
#if 0
#line 547
{ 
#line 548
return (short)((__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 549
} 
#endif
#line 552 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 553
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 555
::exit(___);}
#if 0
#line 553
{ 
#line 554
return (__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 555
} 
#endif
#line 558 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 559
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 561
::exit(___);}
#if 0
#line 559
{ 
#line 560
return make_short1((signed short)((__surf2Dreads1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 561
} 
#endif
#line 564 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 565
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 567
::exit(___);}
#if 0
#line 565
{ 
#line 566
return __surf2Dreads1(surf, x, y, cudaBoundaryModeTrap); 
#line 567
} 
#endif
#line 570 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 571
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 575
::exit(___);}
#if 0
#line 571
{ 
#line 572
ushort2 tmp = __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
#line 574
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 575
} 
#endif
#line 578 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 579
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 581
::exit(___);}
#if 0
#line 579
{ 
#line 580
return __surf2Dreads2(surf, x, y, cudaBoundaryModeTrap); 
#line 581
} 
#endif
#line 584 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 585
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 589
::exit(___);}
#if 0
#line 585
{ 
#line 586
ushort4 tmp = __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
#line 588
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 589
} 
#endif
#line 592 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 593
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 595
::exit(___);}
#if 0
#line 593
{ 
#line 594
return __surf2Dreads4(surf, x, y, cudaBoundaryModeTrap); 
#line 595
} 
#endif
#line 598 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 599
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 601
::exit(___);}
#if 0
#line 599
{ 
#line 600
return (int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 601
} 
#endif
#line 604 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 605
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 607
::exit(___);}
#if 0
#line 605
{ 
#line 606
return (__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 607
} 
#endif
#line 610 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 611
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 613
::exit(___);}
#if 0
#line 611
{ 
#line 612
return make_int1((signed int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 613
} 
#endif
#line 616 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 617
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 619
::exit(___);}
#if 0
#line 617
{ 
#line 618
return __surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap); 
#line 619
} 
#endif
#line 622 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 623
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 627
::exit(___);}
#if 0
#line 623
{ 
#line 624
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 626
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 627
} 
#endif
#line 630 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 631
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 633
::exit(___);}
#if 0
#line 631
{ 
#line 632
return __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 633
} 
#endif
#line 636 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 637
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 641
::exit(___);}
#if 0
#line 637
{ 
#line 638
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 640
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 641
} 
#endif
#line 644 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 645
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 647
::exit(___);}
#if 0
#line 645
{ 
#line 646
return __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 647
} 
#endif
#line 650 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 651
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 653
::exit(___);}
#if 0
#line 651
{ 
#line 652
return (__int64)((__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 653
} 
#endif
#line 656 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 657
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 659
::exit(___);}
#if 0
#line 657
{ 
#line 658
return (__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x; 
#line 659
} 
#endif
#line 662 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 663
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 665
::exit(___);}
#if 0
#line 663
{ 
#line 664
return make_longlong1((__int64)((__surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 665
} 
#endif
#line 668 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 669
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 671
::exit(___);}
#if 0
#line 669
{ 
#line 670
return __surf2Dreadl1(surf, x, y, cudaBoundaryModeTrap); 
#line 671
} 
#endif
#line 674 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 675
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 679
::exit(___);}
#if 0
#line 675
{ 
#line 676
ulonglong2 tmp = __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
#line 678
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 679
} 
#endif
#line 682 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 683
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 685
::exit(___);}
#if 0
#line 683
{ 
#line 684
return __surf2Dreadl2(surf, x, y, cudaBoundaryModeTrap); 
#line 685
} 
#endif
#line 690 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 691
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 693
::exit(___);}
#if 0
#line 691
{ 
#line 692
return (long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 693
} 
#endif
#line 696 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 697
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 699
::exit(___);}
#if 0
#line 697
{ 
#line 698
return (unsigned long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x); 
#line 699
} 
#endif
#line 702 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 703
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 705
::exit(___);}
#if 0
#line 703
{ 
#line 704
return make_long1((long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 705
} 
#endif
#line 708 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 709
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 711
::exit(___);}
#if 0
#line 709
{ 
#line 710
return make_ulong1((unsigned long)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 711
} 
#endif
#line 714 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 715
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 719
::exit(___);}
#if 0
#line 715
{ 
#line 716
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 718
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 719
} 
#endif
#line 722 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 723
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 727
::exit(___);}
#if 0
#line 723
{ 
#line 724
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 726
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 727
} 
#endif
#line 730 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 731
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 735
::exit(___);}
#if 0
#line 731
{ 
#line 732
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 734
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 735
} 
#endif
#line 738 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 739
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 743
::exit(___);}
#if 0
#line 739
{ 
#line 740
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 742
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 743
} 
#endif
#line 748 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 749
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 751
::exit(___);}
#if 0
#line 749
{ 
#line 750
return __int_as_float((int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x)); 
#line 751
} 
#endif
#line 754 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 755
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 757
::exit(___);}
#if 0
#line 755
{ 
#line 756
return make_float1(__int_as_float((int)((__surf2Dreadu1(surf, x, y, cudaBoundaryModeTrap)).x))); 
#line 757
} 
#endif
#line 760 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 761
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 765
::exit(___);}
#if 0
#line 761
{ 
#line 762
uint2 tmp = __surf2Dreadu2(surf, x, y, cudaBoundaryModeTrap); 
#line 764
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 765
} 
#endif
#line 768 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surf2Dread(surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 769
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)mode;
#line 773
::exit(___);}
#if 0
#line 769
{ 
#line 770
uint4 tmp = __surf2Dreadu4(surf, x, y, cudaBoundaryModeTrap); 
#line 772
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 773
} 
#endif
#line 808 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 809
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 810
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 817
::exit(___);}
#if 0
#line 810
{ 
#line 811
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 817
} 
#endif
#line 819 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 820
surf3Dread(::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 821
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 827
::exit(___);}
#if 0
#line 821
{ 
#line 822
T tmp; 
#line 824
surf3Dread(&tmp, surf, x, y, z, (int)sizeof(T), mode); 
#line 826
return tmp; 
#line 827
} 
#endif
#line 829 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 830
surf3Dread(T *res, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 831
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 833
::exit(___);}
#if 0
#line 831
{ 
#line 832
(*res) = surf3Dread< T> (surf, x, y, z, mode); 
#line 833
} 
#endif
#line 836 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 837
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 839
::exit(___);}
#if 0
#line 837
{ 
#line 838
return (char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 839
} 
#endif
#line 842 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 843
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 845
::exit(___);}
#if 0
#line 843
{ 
#line 844
return (signed char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 845
} 
#endif
#line 848 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 849
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 851
::exit(___);}
#if 0
#line 849
{ 
#line 850
return (__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 851
} 
#endif
#line 854 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 855
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 857
::exit(___);}
#if 0
#line 855
{ 
#line 856
return make_char1((signed char)((__surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 857
} 
#endif
#line 860 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 861
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 863
::exit(___);}
#if 0
#line 861
{ 
#line 862
return __surf3Dreadc1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 863
} 
#endif
#line 866 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 867
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 871
::exit(___);}
#if 0
#line 867
{ 
#line 868
uchar2 tmp = __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 870
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 871
} 
#endif
#line 874 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 875
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 877
::exit(___);}
#if 0
#line 875
{ 
#line 876
return __surf3Dreadc2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 877
} 
#endif
#line 880 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 881
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 885
::exit(___);}
#if 0
#line 881
{ 
#line 882
uchar4 tmp = __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 884
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 885
} 
#endif
#line 888 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 889
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 891
::exit(___);}
#if 0
#line 889
{ 
#line 890
return __surf3Dreadc4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 891
} 
#endif
#line 894 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 895
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 897
::exit(___);}
#if 0
#line 895
{ 
#line 896
return (short)((__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 897
} 
#endif
#line 900 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 901
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 903
::exit(___);}
#if 0
#line 901
{ 
#line 902
return (__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 903
} 
#endif
#line 906 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 907
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 909
::exit(___);}
#if 0
#line 907
{ 
#line 908
return make_short1((signed short)((__surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 909
} 
#endif
#line 912 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 913
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 915
::exit(___);}
#if 0
#line 913
{ 
#line 914
return __surf3Dreads1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 915
} 
#endif
#line 918 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 919
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 923
::exit(___);}
#if 0
#line 919
{ 
#line 920
ushort2 tmp = __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 922
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 923
} 
#endif
#line 926 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 927
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 929
::exit(___);}
#if 0
#line 927
{ 
#line 928
return __surf3Dreads2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 929
} 
#endif
#line 932 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 933
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 937
::exit(___);}
#if 0
#line 933
{ 
#line 934
ushort4 tmp = __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 936
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 937
} 
#endif
#line 940 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 941
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 943
::exit(___);}
#if 0
#line 941
{ 
#line 942
return __surf3Dreads4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 943
} 
#endif
#line 946 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 947
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 949
::exit(___);}
#if 0
#line 947
{ 
#line 948
return (int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 949
} 
#endif
#line 952 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 953
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 955
::exit(___);}
#if 0
#line 953
{ 
#line 954
return (__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 955
} 
#endif
#line 958 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 959
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 961
::exit(___);}
#if 0
#line 959
{ 
#line 960
return make_int1((signed int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 961
} 
#endif
#line 964 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 965
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 967
::exit(___);}
#if 0
#line 965
{ 
#line 966
return __surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 967
} 
#endif
#line 970 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 971
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 975
::exit(___);}
#if 0
#line 971
{ 
#line 972
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 974
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 975
} 
#endif
#line 978 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 979
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 981
::exit(___);}
#if 0
#line 979
{ 
#line 980
return __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 981
} 
#endif
#line 984 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 985
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 989
::exit(___);}
#if 0
#line 985
{ 
#line 986
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 988
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 989
} 
#endif
#line 992 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 993
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 995
::exit(___);}
#if 0
#line 993
{ 
#line 994
return __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 995
} 
#endif
#line 998 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 999
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1001
::exit(___);}
#if 0
#line 999
{ 
#line 1000
return (__int64)((__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1001
} 
#endif
#line 1004 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1005
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1007
::exit(___);}
#if 0
#line 1005
{ 
#line 1006
return (__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x; 
#line 1007
} 
#endif
#line 1010 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1011
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1013
::exit(___);}
#if 0
#line 1011
{ 
#line 1012
return make_longlong1((__int64)((__surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1013
} 
#endif
#line 1016 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1017
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1019
::exit(___);}
#if 0
#line 1017
{ 
#line 1018
return __surf3Dreadl1(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1019
} 
#endif
#line 1022 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1023
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1027
::exit(___);}
#if 0
#line 1023
{ 
#line 1024
ulonglong2 tmp = __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1026
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1027
} 
#endif
#line 1030 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1031
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1033
::exit(___);}
#if 0
#line 1031
{ 
#line 1032
return __surf3Dreadl2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1033
} 
#endif
#line 1038 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1039
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1041
::exit(___);}
#if 0
#line 1039
{ 
#line 1040
return (long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1041
} 
#endif
#line 1044 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1045
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1047
::exit(___);}
#if 0
#line 1045
{ 
#line 1046
return (unsigned long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x); 
#line 1047
} 
#endif
#line 1050 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1051
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1053
::exit(___);}
#if 0
#line 1051
{ 
#line 1052
return make_long1((long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1053
} 
#endif
#line 1056 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1057
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1059
::exit(___);}
#if 0
#line 1057
{ 
#line 1058
return make_ulong1((unsigned long)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1059
} 
#endif
#line 1062 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1063
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1067
::exit(___);}
#if 0
#line 1063
{ 
#line 1064
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1066
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1067
} 
#endif
#line 1070 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1071
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1075
::exit(___);}
#if 0
#line 1071
{ 
#line 1072
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1074
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1075
} 
#endif
#line 1078 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1079
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1083
::exit(___);}
#if 0
#line 1079
{ 
#line 1080
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1082
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1083
} 
#endif
#line 1086 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1087
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1091
::exit(___);}
#if 0
#line 1087
{ 
#line 1088
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1090
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1091
} 
#endif
#line 1096 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1097
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1099
::exit(___);}
#if 0
#line 1097
{ 
#line 1098
return __int_as_float((int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x)); 
#line 1099
} 
#endif
#line 1102 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1103
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1105
::exit(___);}
#if 0
#line 1103
{ 
#line 1104
return make_float1(__int_as_float((int)((__surf3Dreadu1(surf, x, y, z, cudaBoundaryModeTrap)).x))); 
#line 1105
} 
#endif
#line 1108 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1109
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1113
::exit(___);}
#if 0
#line 1109
{ 
#line 1110
uint2 tmp = __surf3Dreadu2(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1112
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1113
} 
#endif
#line 1116 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surf3Dread(surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 1117
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 1121
::exit(___);}
#if 0
#line 1117
{ 
#line 1118
uint4 tmp = __surf3Dreadu4(surf, x, y, z, cudaBoundaryModeTrap); 
#line 1120
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1121
} 
#endif
#line 1156 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1157
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1158
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 1165
::exit(___);}
#if 0
#line 1158
{ 
#line 1159
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 1165
} 
#endif
#line 1167 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1168
surf1DLayeredread(::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1169
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1175
::exit(___);}
#if 0
#line 1169
{ 
#line 1170
T tmp; 
#line 1172
surf1DLayeredread(&tmp, surf, x, layer, (int)sizeof(T), mode); 
#line 1174
return tmp; 
#line 1175
} 
#endif
#line 1177 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1178
surf1DLayeredread(T *res, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1179
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)layer;(void)mode;
#line 1181
::exit(___);}
#if 0
#line 1179
{ 
#line 1180
(*res) = surf1DLayeredread< T> (surf, x, layer, mode); 
#line 1181
} 
#endif
#line 1184 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1185
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1187
::exit(___);}
#if 0
#line 1185
{ 
#line 1186
return (char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1187
} 
#endif
#line 1190 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1191
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1193
::exit(___);}
#if 0
#line 1191
{ 
#line 1192
return (signed char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1193
} 
#endif
#line 1196 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1197
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1199
::exit(___);}
#if 0
#line 1197
{ 
#line 1198
return (__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1199
} 
#endif
#line 1202 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1203
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1205
::exit(___);}
#if 0
#line 1203
{ 
#line 1204
return make_char1((signed char)((__surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1205
} 
#endif
#line 1208 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1209
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1211
::exit(___);}
#if 0
#line 1209
{ 
#line 1210
return __surf1DLayeredreadc1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1211
} 
#endif
#line 1214 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1215
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1219
::exit(___);}
#if 0
#line 1215
{ 
#line 1216
uchar2 tmp = __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1218
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1219
} 
#endif
#line 1222 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1223
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1225
::exit(___);}
#if 0
#line 1223
{ 
#line 1224
return __surf1DLayeredreadc2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1225
} 
#endif
#line 1228 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1229
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1233
::exit(___);}
#if 0
#line 1229
{ 
#line 1230
uchar4 tmp = __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1232
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1233
} 
#endif
#line 1236 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1237
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1239
::exit(___);}
#if 0
#line 1237
{ 
#line 1238
return __surf1DLayeredreadc4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1239
} 
#endif
#line 1242 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1243
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1245
::exit(___);}
#if 0
#line 1243
{ 
#line 1244
return (short)((__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1245
} 
#endif
#line 1248 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1249
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1251
::exit(___);}
#if 0
#line 1249
{ 
#line 1250
return (__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1251
} 
#endif
#line 1254 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1255
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1257
::exit(___);}
#if 0
#line 1255
{ 
#line 1256
return make_short1((signed short)((__surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1257
} 
#endif
#line 1260 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1261
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1263
::exit(___);}
#if 0
#line 1261
{ 
#line 1262
return __surf1DLayeredreads1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1263
} 
#endif
#line 1266 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1267
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1271
::exit(___);}
#if 0
#line 1267
{ 
#line 1268
ushort2 tmp = __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1270
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1271
} 
#endif
#line 1274 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1275
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1277
::exit(___);}
#if 0
#line 1275
{ 
#line 1276
return __surf1DLayeredreads2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1277
} 
#endif
#line 1280 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1281
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1285
::exit(___);}
#if 0
#line 1281
{ 
#line 1282
ushort4 tmp = __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1284
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1285
} 
#endif
#line 1288 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1289
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1291
::exit(___);}
#if 0
#line 1289
{ 
#line 1290
return __surf1DLayeredreads4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1291
} 
#endif
#line 1294 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1295
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1297
::exit(___);}
#if 0
#line 1295
{ 
#line 1296
return (int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1297
} 
#endif
#line 1300 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1301
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1303
::exit(___);}
#if 0
#line 1301
{ 
#line 1302
return (__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1303
} 
#endif
#line 1306 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1307
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1309
::exit(___);}
#if 0
#line 1307
{ 
#line 1308
return make_int1((signed int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1309
} 
#endif
#line 1312 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1313
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1315
::exit(___);}
#if 0
#line 1313
{ 
#line 1314
return __surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1315
} 
#endif
#line 1318 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1319
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1323
::exit(___);}
#if 0
#line 1319
{ 
#line 1320
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1322
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 1323
} 
#endif
#line 1326 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1327
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1329
::exit(___);}
#if 0
#line 1327
{ 
#line 1328
return __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1329
} 
#endif
#line 1332 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1333
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1337
::exit(___);}
#if 0
#line 1333
{ 
#line 1334
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1336
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 1337
} 
#endif
#line 1340 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1341
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1343
::exit(___);}
#if 0
#line 1341
{ 
#line 1342
return __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1343
} 
#endif
#line 1346 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1347
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1349
::exit(___);}
#if 0
#line 1347
{ 
#line 1348
return (__int64)((__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1349
} 
#endif
#line 1352 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1353
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1355
::exit(___);}
#if 0
#line 1353
{ 
#line 1354
return (__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x; 
#line 1355
} 
#endif
#line 1358 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1359
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1361
::exit(___);}
#if 0
#line 1359
{ 
#line 1360
return make_longlong1((__int64)((__surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1361
} 
#endif
#line 1364 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1365
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1367
::exit(___);}
#if 0
#line 1365
{ 
#line 1366
return __surf1DLayeredreadl1(surf, x, layer, cudaBoundaryModeTrap); 
#line 1367
} 
#endif
#line 1370 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1371
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1375
::exit(___);}
#if 0
#line 1371
{ 
#line 1372
ulonglong2 tmp = __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1374
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1375
} 
#endif
#line 1378 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1379
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1381
::exit(___);}
#if 0
#line 1379
{ 
#line 1380
return __surf1DLayeredreadl2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1381
} 
#endif
#line 1386 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1387
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1389
::exit(___);}
#if 0
#line 1387
{ 
#line 1388
return (long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1389
} 
#endif
#line 1392 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1393
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1395
::exit(___);}
#if 0
#line 1393
{ 
#line 1394
return (unsigned long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x); 
#line 1395
} 
#endif
#line 1398 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1399
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1401
::exit(___);}
#if 0
#line 1399
{ 
#line 1400
return make_long1((long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1401
} 
#endif
#line 1404 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1405
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1407
::exit(___);}
#if 0
#line 1405
{ 
#line 1406
return make_ulong1((unsigned long)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1407
} 
#endif
#line 1410 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1411
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1415
::exit(___);}
#if 0
#line 1411
{ 
#line 1412
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1414
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1415
} 
#endif
#line 1418 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1419
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1423
::exit(___);}
#if 0
#line 1419
{ 
#line 1420
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1422
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1423
} 
#endif
#line 1426 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1427
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1431
::exit(___);}
#if 0
#line 1427
{ 
#line 1428
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1430
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1431
} 
#endif
#line 1434 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1435
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1439
::exit(___);}
#if 0
#line 1435
{ 
#line 1436
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1438
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1439
} 
#endif
#line 1444 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1445
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1447
::exit(___);}
#if 0
#line 1445
{ 
#line 1446
return __int_as_float((int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x)); 
#line 1447
} 
#endif
#line 1450 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1451
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1453
::exit(___);}
#if 0
#line 1451
{ 
#line 1452
return make_float1(__int_as_float((int)((__surf1DLayeredreadu1(surf, x, layer, cudaBoundaryModeTrap)).x))); 
#line 1453
} 
#endif
#line 1456 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1457
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1461
::exit(___);}
#if 0
#line 1457
{ 
#line 1458
uint2 tmp = __surf1DLayeredreadu2(surf, x, layer, cudaBoundaryModeTrap); 
#line 1460
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1461
} 
#endif
#line 1464 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surf1DLayeredread(surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1465
{int volatile ___ = 1;(void)surf;(void)x;(void)layer;(void)mode;
#line 1469
::exit(___);}
#if 0
#line 1465
{ 
#line 1466
uint4 tmp = __surf1DLayeredreadu4(surf, x, layer, cudaBoundaryModeTrap); 
#line 1468
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1469
} 
#endif
#line 1515 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1516
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1517
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 1524
::exit(___);}
#if 0
#line 1517
{ 
#line 1518
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 1524
} 
#endif
#line 1526 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1527
surf2DLayeredread(::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1528
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1534
::exit(___);}
#if 0
#line 1528
{ 
#line 1529
T tmp; 
#line 1531
surf2DLayeredread(&tmp, surf, x, y, layer, (int)sizeof(T), mode); 
#line 1533
return tmp; 
#line 1534
} 
#endif
#line 1536 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1537
surf2DLayeredread(T *res, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1538
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1540
::exit(___);}
#if 0
#line 1538
{ 
#line 1539
(*res) = surf2DLayeredread< T> (surf, x, y, layer, mode); 
#line 1540
} 
#endif
#line 1543 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1544
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1546
::exit(___);}
#if 0
#line 1544
{ 
#line 1545
return (char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1546
} 
#endif
#line 1549 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1550
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1552
::exit(___);}
#if 0
#line 1550
{ 
#line 1551
return (signed char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1552
} 
#endif
#line 1555 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1556
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1558
::exit(___);}
#if 0
#line 1556
{ 
#line 1557
return (__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1558
} 
#endif
#line 1561 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1562
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1564
::exit(___);}
#if 0
#line 1562
{ 
#line 1563
return make_char1((signed char)((__surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1564
} 
#endif
#line 1567 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1568
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1570
::exit(___);}
#if 0
#line 1568
{ 
#line 1569
return __surf2DLayeredreadc1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1570
} 
#endif
#line 1573 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1574
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1578
::exit(___);}
#if 0
#line 1574
{ 
#line 1575
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1577
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1578
} 
#endif
#line 1581 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1582
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1584
::exit(___);}
#if 0
#line 1582
{ 
#line 1583
return __surf2DLayeredreadc2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1584
} 
#endif
#line 1587 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1588
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1592
::exit(___);}
#if 0
#line 1588
{ 
#line 1589
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1591
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1592
} 
#endif
#line 1595 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1596
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1598
::exit(___);}
#if 0
#line 1596
{ 
#line 1597
return __surf2DLayeredreadc4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1598
} 
#endif
#line 1601 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1602
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1604
::exit(___);}
#if 0
#line 1602
{ 
#line 1603
return (short)((__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1604
} 
#endif
#line 1607 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1608
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1610
::exit(___);}
#if 0
#line 1608
{ 
#line 1609
return (__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1610
} 
#endif
#line 1613 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1614
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1616
::exit(___);}
#if 0
#line 1614
{ 
#line 1615
return make_short1((signed short)((__surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1616
} 
#endif
#line 1619 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1620
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1622
::exit(___);}
#if 0
#line 1620
{ 
#line 1621
return __surf2DLayeredreads1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1622
} 
#endif
#line 1625 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1626
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1630
::exit(___);}
#if 0
#line 1626
{ 
#line 1627
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1629
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1630
} 
#endif
#line 1633 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1634
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1636
::exit(___);}
#if 0
#line 1634
{ 
#line 1635
return __surf2DLayeredreads2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1636
} 
#endif
#line 1639 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1640
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1644
::exit(___);}
#if 0
#line 1640
{ 
#line 1641
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1643
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1644
} 
#endif
#line 1647 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1648
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1650
::exit(___);}
#if 0
#line 1648
{ 
#line 1649
return __surf2DLayeredreads4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1650
} 
#endif
#line 1653 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1654
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1656
::exit(___);}
#if 0
#line 1654
{ 
#line 1655
return (int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1656
} 
#endif
#line 1659 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1660
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1662
::exit(___);}
#if 0
#line 1660
{ 
#line 1661
return (__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1662
} 
#endif
#line 1665 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1666
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1668
::exit(___);}
#if 0
#line 1666
{ 
#line 1667
return make_int1((signed int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1668
} 
#endif
#line 1671 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1672
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1674
::exit(___);}
#if 0
#line 1672
{ 
#line 1673
return __surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1674
} 
#endif
#line 1677 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1678
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1682
::exit(___);}
#if 0
#line 1678
{ 
#line 1679
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1681
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 1682
} 
#endif
#line 1685 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1686
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1688
::exit(___);}
#if 0
#line 1686
{ 
#line 1687
return __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1688
} 
#endif
#line 1691 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1692
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1696
::exit(___);}
#if 0
#line 1692
{ 
#line 1693
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1695
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 1696
} 
#endif
#line 1699 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1700
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1702
::exit(___);}
#if 0
#line 1700
{ 
#line 1701
return __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1702
} 
#endif
#line 1705 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1706
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1708
::exit(___);}
#if 0
#line 1706
{ 
#line 1707
return (__int64)((__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1708
} 
#endif
#line 1711 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1712
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1714
::exit(___);}
#if 0
#line 1712
{ 
#line 1713
return (__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x; 
#line 1714
} 
#endif
#line 1717 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1718
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1720
::exit(___);}
#if 0
#line 1718
{ 
#line 1719
return make_longlong1((__int64)((__surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1720
} 
#endif
#line 1723 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1724
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1726
::exit(___);}
#if 0
#line 1724
{ 
#line 1725
return __surf2DLayeredreadl1(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1726
} 
#endif
#line 1729 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1730
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1734
::exit(___);}
#if 0
#line 1730
{ 
#line 1731
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1733
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 1734
} 
#endif
#line 1737 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1738
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1740
::exit(___);}
#if 0
#line 1738
{ 
#line 1739
return __surf2DLayeredreadl2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1740
} 
#endif
#line 1745 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1746
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1748
::exit(___);}
#if 0
#line 1746
{ 
#line 1747
return (long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1748
} 
#endif
#line 1751 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1752
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1754
::exit(___);}
#if 0
#line 1752
{ 
#line 1753
return (unsigned long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x); 
#line 1754
} 
#endif
#line 1757 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1758
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1760
::exit(___);}
#if 0
#line 1758
{ 
#line 1759
return make_long1((long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1760
} 
#endif
#line 1763 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1764
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1766
::exit(___);}
#if 0
#line 1764
{ 
#line 1765
return make_ulong1((unsigned long)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1766
} 
#endif
#line 1769 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1770
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1774
::exit(___);}
#if 0
#line 1770
{ 
#line 1771
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1773
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 1774
} 
#endif
#line 1777 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1778
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1782
::exit(___);}
#if 0
#line 1778
{ 
#line 1779
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1781
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 1782
} 
#endif
#line 1785 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1786
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1790
::exit(___);}
#if 0
#line 1786
{ 
#line 1787
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1789
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 1790
} 
#endif
#line 1793 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1794
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1798
::exit(___);}
#if 0
#line 1794
{ 
#line 1795
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1797
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 1798
} 
#endif
#line 1803 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1804
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1806
::exit(___);}
#if 0
#line 1804
{ 
#line 1805
return __int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x)); 
#line 1806
} 
#endif
#line 1809 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1810
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1812
::exit(___);}
#if 0
#line 1810
{ 
#line 1811
return make_float1(__int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layer, cudaBoundaryModeTrap)).x))); 
#line 1812
} 
#endif
#line 1815 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1816
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1820
::exit(___);}
#if 0
#line 1816
{ 
#line 1817
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1819
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 1820
} 
#endif
#line 1823 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surf2DLayeredread(surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1824
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1828
::exit(___);}
#if 0
#line 1824
{ 
#line 1825
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1827
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 1828
} 
#endif
#line 1851 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1852
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1853
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 1860
::exit(___);}
#if 0
#line 1853
{ 
#line 1854
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 1860
} 
#endif
#line 1862 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 1863
surfCubemapread(::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1864
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1870
::exit(___);}
#if 0
#line 1864
{ 
#line 1865
T tmp; 
#line 1867
surfCubemapread(&tmp, surf, x, y, face, (int)sizeof(T), mode); 
#line 1869
return tmp; 
#line 1870
} 
#endif
#line 1872 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 1873
surfCubemapread(T *res, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 1874
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1876
::exit(___);}
#if 0
#line 1874
{ 
#line 1875
(*res) = surfCubemapread< T> (surf, x, y, face, mode); 
#line 1876
} 
#endif
#line 1879 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1880
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1882
::exit(___);}
#if 0
#line 1880
{ 
#line 1881
return (char)((__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1882
} 
#endif
#line 1885 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1886
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1888
::exit(___);}
#if 0
#line 1886
{ 
#line 1887
return (signed char)((__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1888
} 
#endif
#line 1891 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1892
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1894
::exit(___);}
#if 0
#line 1892
{ 
#line 1893
return (__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1894
} 
#endif
#line 1897 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1898
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1900
::exit(___);}
#if 0
#line 1898
{ 
#line 1899
return make_char1((signed char)((__surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1900
} 
#endif
#line 1903 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1904
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1906
::exit(___);}
#if 0
#line 1904
{ 
#line 1905
return __surf2DLayeredreadc1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1906
} 
#endif
#line 1909 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1910
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1914
::exit(___);}
#if 0
#line 1910
{ 
#line 1911
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1913
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 1914
} 
#endif
#line 1917 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1918
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1920
::exit(___);}
#if 0
#line 1918
{ 
#line 1919
return __surf2DLayeredreadc2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1920
} 
#endif
#line 1923 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1924
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1928
::exit(___);}
#if 0
#line 1924
{ 
#line 1925
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1927
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 1928
} 
#endif
#line 1931 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1932
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1934
::exit(___);}
#if 0
#line 1932
{ 
#line 1933
return __surf2DLayeredreadc4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1934
} 
#endif
#line 1937 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1938
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1940
::exit(___);}
#if 0
#line 1938
{ 
#line 1939
return (short)((__surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1940
} 
#endif
#line 1943 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1944
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1946
::exit(___);}
#if 0
#line 1944
{ 
#line 1945
return (__surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1946
} 
#endif
#line 1949 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1950
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1952
::exit(___);}
#if 0
#line 1950
{ 
#line 1951
return make_short1((signed short)((__surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 1952
} 
#endif
#line 1955 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1956
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1958
::exit(___);}
#if 0
#line 1956
{ 
#line 1957
return __surf2DLayeredreads1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1958
} 
#endif
#line 1961 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1962
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1966
::exit(___);}
#if 0
#line 1962
{ 
#line 1963
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1965
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 1966
} 
#endif
#line 1969 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1970
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1972
::exit(___);}
#if 0
#line 1970
{ 
#line 1971
return __surf2DLayeredreads2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1972
} 
#endif
#line 1975 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1976
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1980
::exit(___);}
#if 0
#line 1976
{ 
#line 1977
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1979
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 1980
} 
#endif
#line 1983 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1984
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1986
::exit(___);}
#if 0
#line 1984
{ 
#line 1985
return __surf2DLayeredreads4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 1986
} 
#endif
#line 1989 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1990
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1992
::exit(___);}
#if 0
#line 1990
{ 
#line 1991
return (int)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 1992
} 
#endif
#line 1995 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1996
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1998
::exit(___);}
#if 0
#line 1996
{ 
#line 1997
return (__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 1998
} 
#endif
#line 2001 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2002
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2004
::exit(___);}
#if 0
#line 2002
{ 
#line 2003
return make_int1((signed int)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2004
} 
#endif
#line 2007 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2008
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2010
::exit(___);}
#if 0
#line 2008
{ 
#line 2009
return __surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2010
} 
#endif
#line 2013 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2014
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2018
::exit(___);}
#if 0
#line 2014
{ 
#line 2015
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2017
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 2018
} 
#endif
#line 2021 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2022
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2024
::exit(___);}
#if 0
#line 2022
{ 
#line 2023
return __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2024
} 
#endif
#line 2027 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2028
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2032
::exit(___);}
#if 0
#line 2028
{ 
#line 2029
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2031
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 2032
} 
#endif
#line 2035 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2036
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2038
::exit(___);}
#if 0
#line 2036
{ 
#line 2037
return __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2038
} 
#endif
#line 2041 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2042
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2044
::exit(___);}
#if 0
#line 2042
{ 
#line 2043
return (__int64)((__surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2044
} 
#endif
#line 2047 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2048
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2050
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
return (__surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x; 
#line 2050
} 
#endif
#line 2053 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2054
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2056
::exit(___);}
#if 0
#line 2054
{ 
#line 2055
return make_longlong1((__int64)((__surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2056
} 
#endif
#line 2059 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2060
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2062
::exit(___);}
#if 0
#line 2060
{ 
#line 2061
return __surf2DLayeredreadl1(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2062
} 
#endif
#line 2065 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2066
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2070
::exit(___);}
#if 0
#line 2066
{ 
#line 2067
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2069
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 2070
} 
#endif
#line 2073 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2074
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2076
::exit(___);}
#if 0
#line 2074
{ 
#line 2075
return __surf2DLayeredreadl2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2076
} 
#endif
#line 2081 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2082
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2084
::exit(___);}
#if 0
#line 2082
{ 
#line 2083
return (long)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2084
} 
#endif
#line 2087 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2088
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2090
::exit(___);}
#if 0
#line 2088
{ 
#line 2089
return (unsigned long)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x); 
#line 2090
} 
#endif
#line 2093 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2094
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2096
::exit(___);}
#if 0
#line 2094
{ 
#line 2095
return make_long1((long)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2096
} 
#endif
#line 2099 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2100
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2102
::exit(___);}
#if 0
#line 2100
{ 
#line 2101
return make_ulong1((unsigned long)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2102
} 
#endif
#line 2105 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2106
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2110
::exit(___);}
#if 0
#line 2106
{ 
#line 2107
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2109
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 2110
} 
#endif
#line 2113 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2114
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2118
::exit(___);}
#if 0
#line 2114
{ 
#line 2115
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2117
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 2118
} 
#endif
#line 2121 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2122
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2126
::exit(___);}
#if 0
#line 2122
{ 
#line 2123
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2125
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 2126
} 
#endif
#line 2129 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2130
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2134
::exit(___);}
#if 0
#line 2130
{ 
#line 2131
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2133
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 2134
} 
#endif
#line 2139 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2140
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2142
::exit(___);}
#if 0
#line 2140
{ 
#line 2141
return __int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x)); 
#line 2142
} 
#endif
#line 2145 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2146
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2148
::exit(___);}
#if 0
#line 2146
{ 
#line 2147
return make_float1(__int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, face, cudaBoundaryModeTrap)).x))); 
#line 2148
} 
#endif
#line 2151 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2152
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2156
::exit(___);}
#if 0
#line 2152
{ 
#line 2153
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2155
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 2156
} 
#endif
#line 2159 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surfCubemapread(surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 2160
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 2164
::exit(___);}
#if 0
#line 2160
{ 
#line 2161
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, face, cudaBoundaryModeTrap); 
#line 2163
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 2164
} 
#endif
#line 2188 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2189
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2190
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 2197
::exit(___);}
#if 0
#line 2190
{ 
#line 2191
(s == 1) ? (void)((*((::uchar1 *)res)) = __surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 2) ? (void)((*((::ushort1 *)res)) = __surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 4) ? (void)((*((::uint1 *)res)) = __surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 8) ? (void)((*((::uint2 *)res)) = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((s == 16) ? (void)((*((::uint4 *)res)) = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap)) : ((void)0))))); 
#line 2197
} 
#endif
#line 2199 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline T 
#line 2200
surfCubemapLayeredread(::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2201
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2207
::exit(___);}
#if 0
#line 2201
{ 
#line 2202
T tmp; 
#line 2204
surfCubemapLayeredread(&tmp, surf, x, y, layerFace, (int)sizeof(T), mode); 
#line 2206
return tmp; 
#line 2207
} 
#endif
#line 2209 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2210
surfCubemapLayeredread(T *res, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2211
{int volatile ___ = 1;(void)res;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2213
::exit(___);}
#if 0
#line 2211
{ 
#line 2212
(*res) = surfCubemapLayeredread< T> (surf, x, y, layerFace, mode); 
#line 2213
} 
#endif
#line 2216 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2217
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2219
::exit(___);}
#if 0
#line 2217
{ 
#line 2218
return (char)((__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2219
} 
#endif
#line 2222 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline signed char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2223
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2225
::exit(___);}
#if 0
#line 2223
{ 
#line 2224
return (signed char)((__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2225
} 
#endif
#line 2228 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned char surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2229
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2231
::exit(___);}
#if 0
#line 2229
{ 
#line 2230
return (__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2231
} 
#endif
#line 2234 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2235
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2237
::exit(___);}
#if 0
#line 2235
{ 
#line 2236
return make_char1((signed char)((__surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2237
} 
#endif
#line 2240 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2241
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2243
::exit(___);}
#if 0
#line 2241
{ 
#line 2242
return __surf2DLayeredreadc1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2243
} 
#endif
#line 2246 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2247
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2251
::exit(___);}
#if 0
#line 2247
{ 
#line 2248
uchar2 tmp = __surf2DLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2250
return make_char2((signed char)(tmp.x), (signed char)(tmp.y)); 
#line 2251
} 
#endif
#line 2254 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2255
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2257
::exit(___);}
#if 0
#line 2255
{ 
#line 2256
return __surf2DLayeredreadc2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2257
} 
#endif
#line 2260 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline char4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2261
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2265
::exit(___);}
#if 0
#line 2261
{ 
#line 2262
uchar4 tmp = __surf2DLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2264
return make_char4((signed char)(tmp.x), (signed char)(tmp.y), (signed char)(tmp.z), (signed char)(tmp.w)); 
#line 2265
} 
#endif
#line 2268 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uchar4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2269
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2271
::exit(___);}
#if 0
#line 2269
{ 
#line 2270
return __surf2DLayeredreadc4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2271
} 
#endif
#line 2274 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2275
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2277
::exit(___);}
#if 0
#line 2275
{ 
#line 2276
return (short)((__surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2277
} 
#endif
#line 2280 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned short surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2281
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2283
::exit(___);}
#if 0
#line 2281
{ 
#line 2282
return (__surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2283
} 
#endif
#line 2286 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2287
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2289
::exit(___);}
#if 0
#line 2287
{ 
#line 2288
return make_short1((signed short)((__surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2289
} 
#endif
#line 2292 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2293
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2295
::exit(___);}
#if 0
#line 2293
{ 
#line 2294
return __surf2DLayeredreads1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2295
} 
#endif
#line 2298 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2299
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2303
::exit(___);}
#if 0
#line 2299
{ 
#line 2300
ushort2 tmp = __surf2DLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2302
return make_short2((signed short)(tmp.x), (signed short)(tmp.y)); 
#line 2303
} 
#endif
#line 2306 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2307
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2309
::exit(___);}
#if 0
#line 2307
{ 
#line 2308
return __surf2DLayeredreads2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2309
} 
#endif
#line 2312 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline short4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2313
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2317
::exit(___);}
#if 0
#line 2313
{ 
#line 2314
ushort4 tmp = __surf2DLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2316
return make_short4((signed short)(tmp.x), (signed short)(tmp.y), (signed short)(tmp.z), (signed short)(tmp.w)); 
#line 2317
} 
#endif
#line 2320 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ushort4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2321
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2323
::exit(___);}
#if 0
#line 2321
{ 
#line 2322
return __surf2DLayeredreads4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2323
} 
#endif
#line 2326 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2327
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2329
::exit(___);}
#if 0
#line 2327
{ 
#line 2328
return (int)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2329
} 
#endif
#line 2332 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2333
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2335
::exit(___);}
#if 0
#line 2333
{ 
#line 2334
return (__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2335
} 
#endif
#line 2338 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2339
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2341
::exit(___);}
#if 0
#line 2339
{ 
#line 2340
return make_int1((signed int)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2341
} 
#endif
#line 2344 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2345
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2347
::exit(___);}
#if 0
#line 2345
{ 
#line 2346
return __surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2347
} 
#endif
#line 2350 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2351
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2355
::exit(___);}
#if 0
#line 2351
{ 
#line 2352
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2354
return make_int2((int)(tmp.x), (int)(tmp.y)); 
#line 2355
} 
#endif
#line 2358 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2359
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2361
::exit(___);}
#if 0
#line 2359
{ 
#line 2360
return __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2361
} 
#endif
#line 2364 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline int4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2365
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2369
::exit(___);}
#if 0
#line 2365
{ 
#line 2366
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2368
return make_int4((int)(tmp.x), (int)(tmp.y), (int)(tmp.z), (int)(tmp.w)); 
#line 2369
} 
#endif
#line 2372 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline uint4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2373
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2375
::exit(___);}
#if 0
#line 2373
{ 
#line 2374
return __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2375
} 
#endif
#line 2378 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline __int64 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2379
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2381
::exit(___);}
#if 0
#line 2379
{ 
#line 2380
return (__int64)((__surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2381
} 
#endif
#line 2384 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned __int64 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2385
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2387
::exit(___);}
#if 0
#line 2385
{ 
#line 2386
return (__surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x; 
#line 2387
} 
#endif
#line 2390 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2391
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2393
::exit(___);}
#if 0
#line 2391
{ 
#line 2392
return make_longlong1((__int64)((__surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2393
} 
#endif
#line 2396 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2397
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2399
::exit(___);}
#if 0
#line 2397
{ 
#line 2398
return __surf2DLayeredreadl1(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2399
} 
#endif
#line 2402 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline longlong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2403
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2407
::exit(___);}
#if 0
#line 2403
{ 
#line 2404
ulonglong2 tmp = __surf2DLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2406
return make_longlong2((__int64)(tmp.x), (__int64)(tmp.y)); 
#line 2407
} 
#endif
#line 2410 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulonglong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2411
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2413
::exit(___);}
#if 0
#line 2411
{ 
#line 2412
return __surf2DLayeredreadl2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2413
} 
#endif
#line 2418 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2419
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2421
::exit(___);}
#if 0
#line 2419
{ 
#line 2420
return (long)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2421
} 
#endif
#line 2424 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline unsigned long surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2425
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2427
::exit(___);}
#if 0
#line 2425
{ 
#line 2426
return (unsigned long)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x); 
#line 2427
} 
#endif
#line 2430 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2431
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2433
::exit(___);}
#if 0
#line 2431
{ 
#line 2432
return make_long1((long)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2433
} 
#endif
#line 2436 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2437
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2439
::exit(___);}
#if 0
#line 2437
{ 
#line 2438
return make_ulong1((unsigned long)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2439
} 
#endif
#line 2442 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2443
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2447
::exit(___);}
#if 0
#line 2443
{ 
#line 2444
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2446
return make_long2((long)(tmp.x), (long)(tmp.y)); 
#line 2447
} 
#endif
#line 2450 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2451
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2455
::exit(___);}
#if 0
#line 2451
{ 
#line 2452
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2454
return make_ulong2((unsigned long)(tmp.x), (unsigned long)(tmp.y)); 
#line 2455
} 
#endif
#line 2458 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline long4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2459
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2463
::exit(___);}
#if 0
#line 2459
{ 
#line 2460
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2462
return make_long4((long)(tmp.x), (long)(tmp.y), (long)(tmp.z), (long)(tmp.w)); 
#line 2463
} 
#endif
#line 2466 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline ulong4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2467
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2471
::exit(___);}
#if 0
#line 2467
{ 
#line 2468
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2470
return make_ulong4((unsigned long)(tmp.x), (unsigned long)(tmp.y), (unsigned long)(tmp.z), (unsigned long)(tmp.w)); 
#line 2471
} 
#endif
#line 2476 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2477
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2479
::exit(___);}
#if 0
#line 2477
{ 
#line 2478
return __int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x)); 
#line 2479
} 
#endif
#line 2482 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float1 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2483
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2485
::exit(___);}
#if 0
#line 2483
{ 
#line 2484
return make_float1(__int_as_float((int)((__surf2DLayeredreadu1(surf, x, y, layerFace, cudaBoundaryModeTrap)).x))); 
#line 2485
} 
#endif
#line 2488 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float2 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2489
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2493
::exit(___);}
#if 0
#line 2489
{ 
#line 2490
uint2 tmp = __surf2DLayeredreadu2(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2492
return make_float2(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y))); 
#line 2493
} 
#endif
#line 2496 "e:\\cudatoolkit\\include\\surface_functions.h"
template<> __forceinline float4 surfCubemapLayeredread(surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 2497
{int volatile ___ = 1;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 2501
::exit(___);}
#if 0
#line 2497
{ 
#line 2498
uint4 tmp = __surf2DLayeredreadu4(surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 2500
return make_float4(__int_as_float((int)(tmp.x)), __int_as_float((int)(tmp.y)), __int_as_float((int)(tmp.z)), __int_as_float((int)(tmp.w))); 
#line 2501
} 
#endif
#line 2537 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2538
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2539
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)s;(void)mode;
#line 2557
::exit(___);}
#if 0
#line 2539
{ 
#line 2540
union { 
#line 2541
T val; 
#line 2542
::uchar1 c1; 
#line 2543
::ushort1 s1; 
#line 2544
::uint1 u1; 
#line 2545
::uint2 u2; 
#line 2546
::uint4 u4; 
#line 2547
} tmp; 
#line 2549
(tmp.val) = val; 
#line 2551
(s == 1) ? (void)__surf1Dwritec1(tmp.c1, surf, x, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf1Dwrites1(tmp.s1, surf, x, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf1Dwriteu1(tmp.u1, surf, x, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf1Dwriteu2(tmp.u2, surf, x, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf1Dwriteu4(tmp.u4, surf, x, cudaBoundaryModeTrap) : ((void)0))))); 
#line 2557
} 
#endif
#line 2559 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2560
surf1Dwrite(T val, ::surface< void, 1>  surf, int x, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2561
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 2563
::exit(___);}
#if 0
#line 2561
{ ; 
#line 2562
surf1Dwrite(val, surf, x, (int)sizeof(T), mode); 
#line 2563
} 
#endif
#line 2566 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2568
static __forceinline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2570
static __forceinline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2572
static __forceinline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2574
static __forceinline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2576
static __forceinline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2578
static __forceinline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2580
static __forceinline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2582
static __forceinline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2584
static __forceinline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2586
static __forceinline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2588
static __forceinline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2590
static __forceinline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2592
static __forceinline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2594
static __forceinline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2596
static __forceinline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2598
static __forceinline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2600
static __forceinline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2602
static __forceinline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2604
static __forceinline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2606
static __forceinline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2608
static __forceinline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2610
static __forceinline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2612
static __forceinline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2614
static __forceinline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2616
static __forceinline void surf1Dwrite(__int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2618
static __forceinline void surf1Dwrite(unsigned __int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2620
static __forceinline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2622
static __forceinline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2624
static __forceinline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2626
static __forceinline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2630
static __forceinline void surf1Dwrite(long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2632
static __forceinline void surf1Dwrite(unsigned long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2634
static __forceinline void surf1Dwrite(long1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2636
static __forceinline void surf1Dwrite(ulong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2638
static __forceinline void surf1Dwrite(long2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2640
static __forceinline void surf1Dwrite(ulong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2642
static __forceinline void surf1Dwrite(long4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2644
static __forceinline void surf1Dwrite(ulong4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2648 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2650
static __forceinline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2652
static __forceinline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2654
static __forceinline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2690 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2691
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2692
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)s;(void)mode;
#line 2710
::exit(___);}
#if 0
#line 2692
{ 
#line 2693
union { 
#line 2694
T val; 
#line 2695
::uchar1 c1; 
#line 2696
::ushort1 s1; 
#line 2697
::uint1 u1; 
#line 2698
::uint2 u2; 
#line 2699
::uint4 u4; 
#line 2700
} tmp; 
#line 2702
(tmp.val) = val; 
#line 2704
(s == 1) ? (void)__surf2Dwritec1(tmp.c1, surf, x, y, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2Dwrites1(tmp.s1, surf, x, y, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2Dwriteu1(tmp.u1, surf, x, y, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2Dwriteu2(tmp.u2, surf, x, y, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2Dwriteu4(tmp.u4, surf, x, y, cudaBoundaryModeTrap) : ((void)0))))); 
#line 2710
} 
#endif
#line 2712 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2713
surf2Dwrite(T val, ::surface< void, 2>  surf, int x, int y, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2714
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 2716
::exit(___);}
#if 0
#line 2714
{ ; 
#line 2715
surf2Dwrite(val, surf, x, y, (int)sizeof(T), mode); 
#line 2716
} 
#endif
#line 2719 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2721
static __forceinline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2723
static __forceinline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2725
static __forceinline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2727
static __forceinline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2729
static __forceinline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2731
static __forceinline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2733
static __forceinline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2735
static __forceinline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2737
static __forceinline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2739
static __forceinline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2741
static __forceinline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2743
static __forceinline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2745
static __forceinline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2747
static __forceinline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2749
static __forceinline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2751
static __forceinline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2753
static __forceinline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2755
static __forceinline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2757
static __forceinline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2759
static __forceinline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2761
static __forceinline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2763
static __forceinline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2765
static __forceinline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2767
static __forceinline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2769
static __forceinline void surf2Dwrite(__int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2771
static __forceinline void surf2Dwrite(unsigned __int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2773
static __forceinline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2775
static __forceinline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2777
static __forceinline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2779
static __forceinline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2783
static __forceinline void surf2Dwrite(long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2785
static __forceinline void surf2Dwrite(unsigned long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2787
static __forceinline void surf2Dwrite(long1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2789
static __forceinline void surf2Dwrite(ulong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2791
static __forceinline void surf2Dwrite(long2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2793
static __forceinline void surf2Dwrite(ulong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2795
static __forceinline void surf2Dwrite(long4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2797
static __forceinline void surf2Dwrite(ulong4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2801 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2803
static __forceinline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2805
static __forceinline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2807
static __forceinline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2843 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2844
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2845
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)s;(void)mode;
#line 2863
::exit(___);}
#if 0
#line 2845
{ 
#line 2846
union { 
#line 2847
T val; 
#line 2848
::uchar1 c1; 
#line 2849
::ushort1 s1; 
#line 2850
::uint1 u1; 
#line 2851
::uint2 u2; 
#line 2852
::uint4 u4; 
#line 2853
} tmp; 
#line 2855
(tmp.val) = val; 
#line 2857
(s == 1) ? (void)__surf3Dwritec1(tmp.c1, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf3Dwrites1(tmp.s1, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf3Dwriteu1(tmp.u1, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf3Dwriteu2(tmp.u2, surf, x, y, z, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf3Dwriteu4(tmp.u4, surf, x, y, z, cudaBoundaryModeTrap) : ((void)0))))); 
#line 2863
} 
#endif
#line 2865 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2866
surf3Dwrite(T val, ::surface< void, 3>  surf, int x, int y, int z, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2867
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 2869
::exit(___);}
#if 0
#line 2867
{ ; 
#line 2868
surf3Dwrite(val, surf, x, y, z, (int)sizeof(T), mode); 
#line 2869
} 
#endif
#line 2872 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2874
static __forceinline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2876
static __forceinline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2878
static __forceinline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2880
static __forceinline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2882
static __forceinline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2884
static __forceinline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2886
static __forceinline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2888
static __forceinline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2890
static __forceinline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2892
static __forceinline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2894
static __forceinline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2896
static __forceinline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2898
static __forceinline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2900
static __forceinline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2902
static __forceinline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2904
static __forceinline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2906
static __forceinline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2908
static __forceinline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2910
static __forceinline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2912
static __forceinline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2914
static __forceinline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2916
static __forceinline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2918
static __forceinline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2920
static __forceinline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2922
static __forceinline void surf3Dwrite(__int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2924
static __forceinline void surf3Dwrite(unsigned __int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2926
static __forceinline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2928
static __forceinline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2930
static __forceinline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2932
static __forceinline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2936
static __forceinline void surf3Dwrite(long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2938
static __forceinline void surf3Dwrite(unsigned long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2940
static __forceinline void surf3Dwrite(long1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2942
static __forceinline void surf3Dwrite(ulong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2944
static __forceinline void surf3Dwrite(long2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2946
static __forceinline void surf3Dwrite(ulong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2948
static __forceinline void surf3Dwrite(long4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2950
static __forceinline void surf3Dwrite(ulong4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2954 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2956
static __forceinline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2958
static __forceinline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2960
static __forceinline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 2996 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 2997
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 2998
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)s;(void)mode;
#line 3016
::exit(___);}
#if 0
#line 2998
{ 
#line 2999
union { 
#line 3000
T val; 
#line 3001
::uchar1 c1; 
#line 3002
::ushort1 s1; 
#line 3003
::uint1 u1; 
#line 3004
::uint2 u2; 
#line 3005
::uint4 u4; 
#line 3006
} tmp; 
#line 3008
(tmp.val) = val; 
#line 3010
(s == 1) ? (void)__surf1DLayeredwritec1(tmp.c1, surf, x, layer, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf1DLayeredwrites1(tmp.s1, surf, x, layer, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf1DLayeredwriteu1(tmp.u1, surf, x, layer, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf1DLayeredwriteu2(tmp.u2, surf, x, layer, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf1DLayeredwriteu4(tmp.u4, surf, x, layer, cudaBoundaryModeTrap) : ((void)0))))); 
#line 3016
} 
#endif
#line 3018 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3019
surf1DLayeredwrite(T val, ::surface< void, 241>  surf, int x, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3020
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 3022
::exit(___);}
#if 0
#line 3020
{ ; 
#line 3021
surf1DLayeredwrite(val, surf, x, layer, (int)sizeof(T), mode); 
#line 3022
} 
#endif
#line 3025 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3027
static __forceinline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3029
static __forceinline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3031
static __forceinline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3033
static __forceinline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3035
static __forceinline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3037
static __forceinline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3039
static __forceinline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3041
static __forceinline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3043
static __forceinline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3045
static __forceinline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3047
static __forceinline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3049
static __forceinline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3051
static __forceinline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3053
static __forceinline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3055
static __forceinline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3057
static __forceinline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3059
static __forceinline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3061
static __forceinline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3063
static __forceinline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3065
static __forceinline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3067
static __forceinline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3069
static __forceinline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3071
static __forceinline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3073
static __forceinline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3075
static __forceinline void surf1DLayeredwrite(__int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3077
static __forceinline void surf1DLayeredwrite(unsigned __int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3079
static __forceinline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3081
static __forceinline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3083
static __forceinline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3085
static __forceinline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3089
static __forceinline void surf1DLayeredwrite(long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3091
static __forceinline void surf1DLayeredwrite(unsigned long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3093
static __forceinline void surf1DLayeredwrite(long1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3095
static __forceinline void surf1DLayeredwrite(ulong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3097
static __forceinline void surf1DLayeredwrite(long2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3099
static __forceinline void surf1DLayeredwrite(ulong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3101
static __forceinline void surf1DLayeredwrite(long4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3103
static __forceinline void surf1DLayeredwrite(ulong4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3107 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3109
static __forceinline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3111
static __forceinline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3113
static __forceinline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3160 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3161
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3162
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)s;(void)mode;
#line 3180
::exit(___);}
#if 0
#line 3162
{ 
#line 3163
union { 
#line 3164
T val; 
#line 3165
::uchar1 c1; 
#line 3166
::ushort1 s1; 
#line 3167
::uint1 u1; 
#line 3168
::uint2 u2; 
#line 3169
::uint4 u4; 
#line 3170
} tmp; 
#line 3172
(tmp.val) = val; 
#line 3174
(s == 1) ? (void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layer, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layer, cudaBoundaryModeTrap) : ((void)0))))); 
#line 3180
} 
#endif
#line 3182 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3183
surf2DLayeredwrite(T val, ::surface< void, 242>  surf, int x, int y, int layer, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3184
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 3186
::exit(___);}
#if 0
#line 3184
{ ; 
#line 3185
surf2DLayeredwrite(val, surf, x, y, layer, (int)sizeof(T), mode); 
#line 3186
} 
#endif
#line 3189 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3191
static __forceinline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3193
static __forceinline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3195
static __forceinline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3197
static __forceinline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3199
static __forceinline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3201
static __forceinline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3203
static __forceinline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3205
static __forceinline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3207
static __forceinline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3209
static __forceinline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3211
static __forceinline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3213
static __forceinline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3215
static __forceinline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3217
static __forceinline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3219
static __forceinline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3221
static __forceinline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3223
static __forceinline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3225
static __forceinline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3227
static __forceinline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3229
static __forceinline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3231
static __forceinline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3233
static __forceinline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3235
static __forceinline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3237
static __forceinline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3239
static __forceinline void surf2DLayeredwrite(__int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3241
static __forceinline void surf2DLayeredwrite(unsigned __int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3243
static __forceinline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3245
static __forceinline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3247
static __forceinline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3249
static __forceinline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3253
static __forceinline void surf2DLayeredwrite(long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3255
static __forceinline void surf2DLayeredwrite(unsigned long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3257
static __forceinline void surf2DLayeredwrite(long1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3259
static __forceinline void surf2DLayeredwrite(ulong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3261
static __forceinline void surf2DLayeredwrite(long2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3263
static __forceinline void surf2DLayeredwrite(ulong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3265
static __forceinline void surf2DLayeredwrite(long4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3267
static __forceinline void surf2DLayeredwrite(ulong4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3271 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3273
static __forceinline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3275
static __forceinline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3277
static __forceinline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3302 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3303
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)s;(void)mode;
#line 3322
::exit(___);}
#if 0
#line 3304
{ 
#line 3305
union { 
#line 3306
T val; 
#line 3307
::uchar1 c1; 
#line 3308
::ushort1 s1; 
#line 3309
::uint1 u1; 
#line 3310
::uint2 u2; 
#line 3311
::uint4 u4; 
#line 3312
} tmp; 
#line 3314
(tmp.val) = val; 
#line 3316
(s == 1) ? (void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, face, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, face, cudaBoundaryModeTrap) : ((void)0))))); 
#line 3322
} 
#endif
#line 3324 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3325
surfCubemapwrite(T val, ::surface< void, 12>  surf, int x, int y, int face, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3326
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 3328
::exit(___);}
#if 0
#line 3326
{ 
#line 3327
surfCubemapwrite(val, surf, x, y, face, (int)sizeof(T), mode); 
#line 3328
} 
#endif
#line 3331 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3333
static __forceinline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3335
static __forceinline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3337
static __forceinline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3339
static __forceinline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3341
static __forceinline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3343
static __forceinline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3345
static __forceinline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3347
static __forceinline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3349
static __forceinline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3351
static __forceinline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3353
static __forceinline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3355
static __forceinline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3357
static __forceinline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3359
static __forceinline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3361
static __forceinline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3363
static __forceinline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3365
static __forceinline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3367
static __forceinline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3369
static __forceinline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3371
static __forceinline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3373
static __forceinline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3375
static __forceinline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3377
static __forceinline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3379
static __forceinline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3381
static __forceinline void surfCubemapwrite(__int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3383
static __forceinline void surfCubemapwrite(unsigned __int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3385
static __forceinline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3387
static __forceinline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3389
static __forceinline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3391
static __forceinline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3395
static __forceinline void surfCubemapwrite(long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3397
static __forceinline void surfCubemapwrite(unsigned long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3399
static __forceinline void surfCubemapwrite(long1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3401
static __forceinline void surfCubemapwrite(ulong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3403
static __forceinline void surfCubemapwrite(long2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3405
static __forceinline void surfCubemapwrite(ulong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3407
static __forceinline void surfCubemapwrite(long4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3409
static __forceinline void surfCubemapwrite(ulong4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3413 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3415
static __forceinline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3417
static __forceinline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3419
static __forceinline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3444 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3445
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, int s, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3446
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)s;(void)mode;
#line 3464
::exit(___);}
#if 0
#line 3446
{ 
#line 3447
union { 
#line 3448
T val; 
#line 3449
::uchar1 c1; 
#line 3450
::ushort1 s1; 
#line 3451
::uint1 u1; 
#line 3452
::uint2 u2; 
#line 3453
::uint4 u4; 
#line 3454
} tmp; 
#line 3456
(tmp.val) = val; 
#line 3458
(s == 1) ? (void)__surf2DLayeredwritec1(tmp.c1, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 2) ? (void)__surf2DLayeredwrites1(tmp.s1, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 4) ? (void)__surf2DLayeredwriteu1(tmp.u1, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 8) ? (void)__surf2DLayeredwriteu2(tmp.u2, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((s == 16) ? (void)__surf2DLayeredwriteu4(tmp.u4, surf, x, y, layerFace, cudaBoundaryModeTrap) : ((void)0))))); 
#line 3464
} 
#endif
#line 3466 "e:\\cudatoolkit\\include\\surface_functions.h"
template< class T> static __forceinline void 
#line 3467
surfCubemapLayeredwrite(T val, ::surface< void, 252>  surf, int x, int y, int layerFace, ::cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap) 
#line 3468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 3470
::exit(___);}
#if 0
#line 3468
{ ; 
#line 3469
surfCubemapLayeredwrite(val, surf, x, y, layerFace, (int)sizeof(T), mode); 
#line 3470
} 
#endif
#line 3473 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3475
static __forceinline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3477
static __forceinline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3479
static __forceinline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3481
static __forceinline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3483
static __forceinline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3485
static __forceinline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3487
static __forceinline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3489
static __forceinline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3491
static __forceinline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3493
static __forceinline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3495
static __forceinline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3497
static __forceinline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3499
static __forceinline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3501
static __forceinline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3503
static __forceinline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3505
static __forceinline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3507
static __forceinline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3509
static __forceinline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3511
static __forceinline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3513
static __forceinline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3515
static __forceinline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3517
static __forceinline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3519
static __forceinline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3521
static __forceinline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3523
static __forceinline void surfCubemapLayeredwrite(__int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3525
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3527
static __forceinline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3529
static __forceinline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3531
static __forceinline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3533
static __forceinline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3537
static __forceinline void surfCubemapLayeredwrite(long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3539
static __forceinline void surfCubemapLayeredwrite(unsigned long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3541
static __forceinline void surfCubemapLayeredwrite(long1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3543
static __forceinline void surfCubemapLayeredwrite(ulong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3545
static __forceinline void surfCubemapLayeredwrite(long2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3547
static __forceinline void surfCubemapLayeredwrite(ulong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3549
static __forceinline void surfCubemapLayeredwrite(long4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3551
static __forceinline void surfCubemapLayeredwrite(ulong4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3555 "e:\\cudatoolkit\\include\\surface_functions.h"
static __forceinline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3557
static __forceinline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3559
static __forceinline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 3561
static __forceinline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode = cudaBoundaryModeTrap); 
#line 94 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 95
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 97
::exit(___);}
#if 0
#line 95
{ 
#line 96
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
#line 97
} 
#endif
#line 99 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(signed char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 100
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 102
::exit(___);}
#if 0
#line 100
{ 
#line 101
__surf1Dwritec1(make_uchar1((unsigned char)val), surf, x, cudaBoundaryModeTrap); 
#line 102
} 
#endif
#line 104 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(unsigned char val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 105
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 107
::exit(___);}
#if 0
#line 105
{ 
#line 106
__surf1Dwritec1(make_uchar1(val), surf, x, cudaBoundaryModeTrap); 
#line 107
} 
#endif
#line 109 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(char1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 110
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 112
::exit(___);}
#if 0
#line 110
{ 
#line 111
__surf1Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 112
} 
#endif
#line 114 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(uchar1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 115
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 117
::exit(___);}
#if 0
#line 115
{ 
#line 116
__surf1Dwritec1(val, surf, x, cudaBoundaryModeTrap); 
#line 117
} 
#endif
#line 119 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(char2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 120
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 122
::exit(___);}
#if 0
#line 120
{ 
#line 121
__surf1Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 122
} 
#endif
#line 124 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(uchar2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 125
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 127
::exit(___);}
#if 0
#line 125
{ 
#line 126
__surf1Dwritec2(val, surf, x, cudaBoundaryModeTrap); 
#line 127
} 
#endif
#line 129 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(char4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 130
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 132
::exit(___);}
#if 0
#line 130
{ 
#line 131
__surf1Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 132
} 
#endif
#line 134 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(uchar4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 135
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 137
::exit(___);}
#if 0
#line 135
{ 
#line 136
__surf1Dwritec4(val, surf, x, cudaBoundaryModeTrap); 
#line 137
} 
#endif
#line 139 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 140
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 142
::exit(___);}
#if 0
#line 140
{ 
#line 141
__surf1Dwrites1(make_ushort1((unsigned short)val), surf, x, cudaBoundaryModeTrap); 
#line 142
} 
#endif
#line 144 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(unsigned short val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 145
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 147
::exit(___);}
#if 0
#line 145
{ 
#line 146
__surf1Dwrites1(make_ushort1(val), surf, x, cudaBoundaryModeTrap); 
#line 147
} 
#endif
#line 149 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(short1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 150
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 152
::exit(___);}
#if 0
#line 150
{ 
#line 151
__surf1Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 152
} 
#endif
#line 154 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ushort1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 155
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 157
::exit(___);}
#if 0
#line 155
{ 
#line 156
__surf1Dwrites1(val, surf, x, cudaBoundaryModeTrap); 
#line 157
} 
#endif
#line 159 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(short2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 160
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 162
::exit(___);}
#if 0
#line 160
{ 
#line 161
__surf1Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 162
} 
#endif
#line 164 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ushort2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 165
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 167
::exit(___);}
#if 0
#line 165
{ 
#line 166
__surf1Dwrites2(val, surf, x, cudaBoundaryModeTrap); 
#line 167
} 
#endif
#line 169 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(short4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 170
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 172
::exit(___);}
#if 0
#line 170
{ 
#line 171
__surf1Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 172
} 
#endif
#line 174 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ushort4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 175
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 177
::exit(___);}
#if 0
#line 175
{ 
#line 176
__surf1Dwrites4(val, surf, x, cudaBoundaryModeTrap); 
#line 177
} 
#endif
#line 179 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(int val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 180
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 182
::exit(___);}
#if 0
#line 180
{ 
#line 181
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 182
} 
#endif
#line 184 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(unsigned val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 185
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 187
::exit(___);}
#if 0
#line 185
{ 
#line 186
__surf1Dwriteu1(make_uint1(val), surf, x, cudaBoundaryModeTrap); 
#line 187
} 
#endif
#line 189 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(int1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 190
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 192
::exit(___);}
#if 0
#line 190
{ 
#line 191
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 192
} 
#endif
#line 194 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(uint1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 195
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 197
::exit(___);}
#if 0
#line 195
{ 
#line 196
__surf1Dwriteu1(val, surf, x, cudaBoundaryModeTrap); 
#line 197
} 
#endif
#line 199 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(int2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 200
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 202
::exit(___);}
#if 0
#line 200
{ 
#line 201
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 202
} 
#endif
#line 204 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(uint2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 205
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 207
::exit(___);}
#if 0
#line 205
{ 
#line 206
__surf1Dwriteu2(val, surf, x, cudaBoundaryModeTrap); 
#line 207
} 
#endif
#line 209 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(int4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 210
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 212
::exit(___);}
#if 0
#line 210
{ 
#line 211
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 212
} 
#endif
#line 214 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(uint4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 215
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 217
::exit(___);}
#if 0
#line 215
{ 
#line 216
__surf1Dwriteu4(val, surf, x, cudaBoundaryModeTrap); 
#line 217
} 
#endif
#line 219 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(__int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 220
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 222
::exit(___);}
#if 0
#line 220
{ 
#line 221
__surf1Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, cudaBoundaryModeTrap); 
#line 222
} 
#endif
#line 224 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(unsigned __int64 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 225
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 227
::exit(___);}
#if 0
#line 225
{ 
#line 226
__surf1Dwritel1(make_ulonglong1(val), surf, x, cudaBoundaryModeTrap); 
#line 227
} 
#endif
#line 229 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(longlong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 230
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 232
::exit(___);}
#if 0
#line 230
{ 
#line 231
__surf1Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 232
} 
#endif
#line 234 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ulonglong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 235
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 237
::exit(___);}
#if 0
#line 235
{ 
#line 236
__surf1Dwritel1(val, surf, x, cudaBoundaryModeTrap); 
#line 237
} 
#endif
#line 239 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(longlong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 240
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 242
::exit(___);}
#if 0
#line 240
{ 
#line 241
__surf1Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 242
} 
#endif
#line 244 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ulonglong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 245
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 247
::exit(___);}
#if 0
#line 245
{ 
#line 246
__surf1Dwritel2(val, surf, x, cudaBoundaryModeTrap); 
#line 247
} 
#endif
#line 251 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 252
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 254
::exit(___);}
#if 0
#line 252
{ 
#line 253
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 254
} 
#endif
#line 256 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(unsigned long val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 257
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 259
::exit(___);}
#if 0
#line 257
{ 
#line 258
__surf1Dwriteu1(make_uint1((unsigned)val), surf, x, cudaBoundaryModeTrap); 
#line 259
} 
#endif
#line 261 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(long1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 262
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 264
::exit(___);}
#if 0
#line 262
{ 
#line 263
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 264
} 
#endif
#line 266 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ulong1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 267
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 269
::exit(___);}
#if 0
#line 267
{ 
#line 268
__surf1Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 269
} 
#endif
#line 271 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(long2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 272
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 274
::exit(___);}
#if 0
#line 272
{ 
#line 273
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 274
} 
#endif
#line 276 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ulong2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 277
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 279
::exit(___);}
#if 0
#line 277
{ 
#line 278
__surf1Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 279
} 
#endif
#line 281 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(long4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 282
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 284
::exit(___);}
#if 0
#line 282
{ 
#line 283
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 284
} 
#endif
#line 286 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(ulong4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 287
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 289
::exit(___);}
#if 0
#line 287
{ 
#line 288
__surf1Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 289
} 
#endif
#line 293 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(float val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 294
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 296
::exit(___);}
#if 0
#line 294
{ 
#line 295
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, cudaBoundaryModeTrap); 
#line 296
} 
#endif
#line 298 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(float1 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 299
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 301
::exit(___);}
#if 0
#line 299
{ 
#line 300
__surf1Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, cudaBoundaryModeTrap); 
#line 301
} 
#endif
#line 303 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(float2 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 304
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 306
::exit(___);}
#if 0
#line 304
{ 
#line 305
__surf1Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, cudaBoundaryModeTrap); 
#line 306
} 
#endif
#line 308 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1Dwrite(float4 val, surface< void, 1>  surf, int x, cudaSurfaceBoundaryMode mode) 
#line 309
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)mode;
#line 311
::exit(___);}
#if 0
#line 309
{ 
#line 310
__surf1Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, cudaBoundaryModeTrap); 
#line 311
} 
#endif
#line 336 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 337
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 339
::exit(___);}
#if 0
#line 337
{ 
#line 338
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
#line 339
} 
#endif
#line 341 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(signed char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 342
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 344
::exit(___);}
#if 0
#line 342
{ 
#line 343
__surf2Dwritec1(make_uchar1((unsigned char)val), surf, x, y, cudaBoundaryModeTrap); 
#line 344
} 
#endif
#line 346 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(unsigned char val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 347
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 349
::exit(___);}
#if 0
#line 347
{ 
#line 348
__surf2Dwritec1(make_uchar1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 349
} 
#endif
#line 351 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(char1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 352
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 354
::exit(___);}
#if 0
#line 352
{ 
#line 353
__surf2Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 354
} 
#endif
#line 356 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(uchar1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 357
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 359
::exit(___);}
#if 0
#line 357
{ 
#line 358
__surf2Dwritec1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 359
} 
#endif
#line 361 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(char2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 362
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 364
::exit(___);}
#if 0
#line 362
{ 
#line 363
__surf2Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 364
} 
#endif
#line 366 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(uchar2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 367
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 369
::exit(___);}
#if 0
#line 367
{ 
#line 368
__surf2Dwritec2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 369
} 
#endif
#line 371 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(char4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 372
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 374
::exit(___);}
#if 0
#line 372
{ 
#line 373
__surf2Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 374
} 
#endif
#line 376 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(uchar4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 377
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 379
::exit(___);}
#if 0
#line 377
{ 
#line 378
__surf2Dwritec4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 379
} 
#endif
#line 381 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 382
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 384
::exit(___);}
#if 0
#line 382
{ 
#line 383
__surf2Dwrites1(make_ushort1((unsigned short)val), surf, x, y, cudaBoundaryModeTrap); 
#line 384
} 
#endif
#line 386 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(unsigned short val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 387
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 389
::exit(___);}
#if 0
#line 387
{ 
#line 388
__surf2Dwrites1(make_ushort1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 389
} 
#endif
#line 391 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(short1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 392
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 394
::exit(___);}
#if 0
#line 392
{ 
#line 393
__surf2Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 394
} 
#endif
#line 396 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ushort1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 397
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 399
::exit(___);}
#if 0
#line 397
{ 
#line 398
__surf2Dwrites1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 399
} 
#endif
#line 401 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(short2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 402
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 404
::exit(___);}
#if 0
#line 402
{ 
#line 403
__surf2Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 404
} 
#endif
#line 406 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ushort2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 407
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 409
::exit(___);}
#if 0
#line 407
{ 
#line 408
__surf2Dwrites2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 409
} 
#endif
#line 411 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(short4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 412
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 414
::exit(___);}
#if 0
#line 412
{ 
#line 413
__surf2Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 414
} 
#endif
#line 416 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ushort4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 417
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 419
::exit(___);}
#if 0
#line 417
{ 
#line 418
__surf2Dwrites4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 419
} 
#endif
#line 421 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(int val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 422
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 424
::exit(___);}
#if 0
#line 422
{ 
#line 423
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 424
} 
#endif
#line 426 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(unsigned val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 427
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 429
::exit(___);}
#if 0
#line 427
{ 
#line 428
__surf2Dwriteu1(make_uint1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 429
} 
#endif
#line 431 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(int1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 432
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 434
::exit(___);}
#if 0
#line 432
{ 
#line 433
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 434
} 
#endif
#line 436 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(uint1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 437
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 439
::exit(___);}
#if 0
#line 437
{ 
#line 438
__surf2Dwriteu1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 439
} 
#endif
#line 441 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(int2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 442
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 444
::exit(___);}
#if 0
#line 442
{ 
#line 443
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 444
} 
#endif
#line 446 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(uint2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 447
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 449
::exit(___);}
#if 0
#line 447
{ 
#line 448
__surf2Dwriteu2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 449
} 
#endif
#line 451 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(int4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 452
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 454
::exit(___);}
#if 0
#line 452
{ 
#line 453
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 454
} 
#endif
#line 456 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(uint4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 457
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 459
::exit(___);}
#if 0
#line 457
{ 
#line 458
__surf2Dwriteu4(val, surf, x, y, cudaBoundaryModeTrap); 
#line 459
} 
#endif
#line 461 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(__int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 462
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 464
::exit(___);}
#if 0
#line 462
{ 
#line 463
__surf2Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, cudaBoundaryModeTrap); 
#line 464
} 
#endif
#line 466 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(unsigned __int64 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 467
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 469
::exit(___);}
#if 0
#line 467
{ 
#line 468
__surf2Dwritel1(make_ulonglong1(val), surf, x, y, cudaBoundaryModeTrap); 
#line 469
} 
#endif
#line 471 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(longlong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 472
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 474
::exit(___);}
#if 0
#line 472
{ 
#line 473
__surf2Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 474
} 
#endif
#line 476 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ulonglong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 477
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 479
::exit(___);}
#if 0
#line 477
{ 
#line 478
__surf2Dwritel1(val, surf, x, y, cudaBoundaryModeTrap); 
#line 479
} 
#endif
#line 481 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(longlong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 482
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 484
::exit(___);}
#if 0
#line 482
{ 
#line 483
__surf2Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 484
} 
#endif
#line 486 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ulonglong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 487
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 489
::exit(___);}
#if 0
#line 487
{ 
#line 488
__surf2Dwritel2(val, surf, x, y, cudaBoundaryModeTrap); 
#line 489
} 
#endif
#line 493 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 494
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 496
::exit(___);}
#if 0
#line 494
{ 
#line 495
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 496
} 
#endif
#line 498 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(unsigned long val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 499
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 501
::exit(___);}
#if 0
#line 499
{ 
#line 500
__surf2Dwriteu1(make_uint1((unsigned)val), surf, x, y, cudaBoundaryModeTrap); 
#line 501
} 
#endif
#line 503 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(long1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 504
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 506
::exit(___);}
#if 0
#line 504
{ 
#line 505
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 506
} 
#endif
#line 508 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ulong1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 509
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 511
::exit(___);}
#if 0
#line 509
{ 
#line 510
__surf2Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 511
} 
#endif
#line 513 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(long2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 514
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 516
::exit(___);}
#if 0
#line 514
{ 
#line 515
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 516
} 
#endif
#line 518 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ulong2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 519
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 521
::exit(___);}
#if 0
#line 519
{ 
#line 520
__surf2Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 521
} 
#endif
#line 523 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(long4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 524
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 526
::exit(___);}
#if 0
#line 524
{ 
#line 525
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 526
} 
#endif
#line 528 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(ulong4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 529
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 531
::exit(___);}
#if 0
#line 529
{ 
#line 530
__surf2Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 531
} 
#endif
#line 535 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(float val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 536
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 538
::exit(___);}
#if 0
#line 536
{ 
#line 537
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, cudaBoundaryModeTrap); 
#line 538
} 
#endif
#line 540 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(float1 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 541
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 543
::exit(___);}
#if 0
#line 541
{ 
#line 542
__surf2Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, cudaBoundaryModeTrap); 
#line 543
} 
#endif
#line 545 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(float2 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 546
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 548
::exit(___);}
#if 0
#line 546
{ 
#line 547
__surf2Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, cudaBoundaryModeTrap); 
#line 548
} 
#endif
#line 550 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2Dwrite(float4 val, surface< void, 2>  surf, int x, int y, cudaSurfaceBoundaryMode mode) 
#line 551
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)mode;
#line 553
::exit(___);}
#if 0
#line 551
{ 
#line 552
__surf2Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, cudaBoundaryModeTrap); 
#line 553
} 
#endif
#line 578 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 579
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 581
::exit(___);}
#if 0
#line 579
{ 
#line 580
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 581
} 
#endif
#line 583 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(signed char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 584
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 586
::exit(___);}
#if 0
#line 584
{ 
#line 585
__surf3Dwritec1(make_uchar1((unsigned char)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 586
} 
#endif
#line 588 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(unsigned char val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 589
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 591
::exit(___);}
#if 0
#line 589
{ 
#line 590
__surf3Dwritec1(make_uchar1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 591
} 
#endif
#line 593 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(char1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 594
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 596
::exit(___);}
#if 0
#line 594
{ 
#line 595
__surf3Dwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 596
} 
#endif
#line 598 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(uchar1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 599
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 601
::exit(___);}
#if 0
#line 599
{ 
#line 600
__surf3Dwritec1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 601
} 
#endif
#line 603 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(char2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 604
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 606
::exit(___);}
#if 0
#line 604
{ 
#line 605
__surf3Dwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 606
} 
#endif
#line 608 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(uchar2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 609
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 611
::exit(___);}
#if 0
#line 609
{ 
#line 610
__surf3Dwritec2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 611
} 
#endif
#line 613 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(char4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 614
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 616
::exit(___);}
#if 0
#line 614
{ 
#line 615
__surf3Dwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 616
} 
#endif
#line 618 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(uchar4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 619
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 621
::exit(___);}
#if 0
#line 619
{ 
#line 620
__surf3Dwritec4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 621
} 
#endif
#line 623 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 624
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 626
::exit(___);}
#if 0
#line 624
{ 
#line 625
__surf3Dwrites1(make_ushort1((unsigned short)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 626
} 
#endif
#line 628 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(unsigned short val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 629
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 631
::exit(___);}
#if 0
#line 629
{ 
#line 630
__surf3Dwrites1(make_ushort1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 631
} 
#endif
#line 633 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(short1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 634
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 636
::exit(___);}
#if 0
#line 634
{ 
#line 635
__surf3Dwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 636
} 
#endif
#line 638 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ushort1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 639
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 641
::exit(___);}
#if 0
#line 639
{ 
#line 640
__surf3Dwrites1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 641
} 
#endif
#line 643 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(short2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 644
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 646
::exit(___);}
#if 0
#line 644
{ 
#line 645
__surf3Dwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 646
} 
#endif
#line 648 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ushort2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 649
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 651
::exit(___);}
#if 0
#line 649
{ 
#line 650
__surf3Dwrites2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 651
} 
#endif
#line 653 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(short4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 654
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 656
::exit(___);}
#if 0
#line 654
{ 
#line 655
__surf3Dwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 656
} 
#endif
#line 658 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ushort4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 659
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 661
::exit(___);}
#if 0
#line 659
{ 
#line 660
__surf3Dwrites4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 661
} 
#endif
#line 663 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(int val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 664
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 666
::exit(___);}
#if 0
#line 664
{ 
#line 665
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 666
} 
#endif
#line 668 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(unsigned val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 669
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 671
::exit(___);}
#if 0
#line 669
{ 
#line 670
__surf3Dwriteu1(make_uint1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 671
} 
#endif
#line 673 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(int1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 674
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 676
::exit(___);}
#if 0
#line 674
{ 
#line 675
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 676
} 
#endif
#line 678 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(uint1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 679
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 681
::exit(___);}
#if 0
#line 679
{ 
#line 680
__surf3Dwriteu1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 681
} 
#endif
#line 683 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(int2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 684
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 686
::exit(___);}
#if 0
#line 684
{ 
#line 685
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 686
} 
#endif
#line 688 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(uint2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 691
::exit(___);}
#if 0
#line 689
{ 
#line 690
__surf3Dwriteu2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 691
} 
#endif
#line 693 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(int4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 694
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 696
::exit(___);}
#if 0
#line 694
{ 
#line 695
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 696
} 
#endif
#line 698 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(uint4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 699
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 701
::exit(___);}
#if 0
#line 699
{ 
#line 700
__surf3Dwriteu4(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 701
} 
#endif
#line 703 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(__int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 704
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 706
::exit(___);}
#if 0
#line 704
{ 
#line 705
__surf3Dwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 706
} 
#endif
#line 708 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(unsigned __int64 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 709
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 711
::exit(___);}
#if 0
#line 709
{ 
#line 710
__surf3Dwritel1(make_ulonglong1(val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 711
} 
#endif
#line 713 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(longlong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 714
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 716
::exit(___);}
#if 0
#line 714
{ 
#line 715
__surf3Dwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 716
} 
#endif
#line 718 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ulonglong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 719
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 721
::exit(___);}
#if 0
#line 719
{ 
#line 720
__surf3Dwritel1(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 721
} 
#endif
#line 723 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(longlong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 724
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 726
::exit(___);}
#if 0
#line 724
{ 
#line 725
__surf3Dwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 726
} 
#endif
#line 728 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ulonglong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 729
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 731
::exit(___);}
#if 0
#line 729
{ 
#line 730
__surf3Dwritel2(val, surf, x, y, z, cudaBoundaryModeTrap); 
#line 731
} 
#endif
#line 735 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 736
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 738
::exit(___);}
#if 0
#line 736
{ 
#line 737
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 738
} 
#endif
#line 740 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(unsigned long val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 741
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 743
::exit(___);}
#if 0
#line 741
{ 
#line 742
__surf3Dwriteu1(make_uint1((unsigned)val), surf, x, y, z, cudaBoundaryModeTrap); 
#line 743
} 
#endif
#line 745 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(long1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 746
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 748
::exit(___);}
#if 0
#line 746
{ 
#line 747
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 748
} 
#endif
#line 750 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ulong1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 751
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 753
::exit(___);}
#if 0
#line 751
{ 
#line 752
__surf3Dwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 753
} 
#endif
#line 755 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(long2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 756
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 758
::exit(___);}
#if 0
#line 756
{ 
#line 757
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 758
} 
#endif
#line 760 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ulong2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 761
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 763
::exit(___);}
#if 0
#line 761
{ 
#line 762
__surf3Dwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 763
} 
#endif
#line 765 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(long4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 766
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 768
::exit(___);}
#if 0
#line 766
{ 
#line 767
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 768
} 
#endif
#line 770 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(ulong4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 771
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 773
::exit(___);}
#if 0
#line 771
{ 
#line 772
__surf3Dwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 773
} 
#endif
#line 777 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(float val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 778
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 780
::exit(___);}
#if 0
#line 778
{ 
#line 779
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 780
} 
#endif
#line 782 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(float1 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 783
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 785
::exit(___);}
#if 0
#line 783
{ 
#line 784
__surf3Dwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 785
} 
#endif
#line 787 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(float2 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 788
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 790
::exit(___);}
#if 0
#line 788
{ 
#line 789
__surf3Dwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 790
} 
#endif
#line 792 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf3Dwrite(float4 val, surface< void, 3>  surf, int x, int y, int z, cudaSurfaceBoundaryMode mode) 
#line 793
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)z;(void)mode;
#line 795
::exit(___);}
#if 0
#line 793
{ 
#line 794
__surf3Dwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, z, cudaBoundaryModeTrap); 
#line 795
} 
#endif
#line 820 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 821
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 823
::exit(___);}
#if 0
#line 821
{ 
#line 822
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 823
} 
#endif
#line 825 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(signed char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 826
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 828
::exit(___);}
#if 0
#line 826
{ 
#line 827
__surf1DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 828
} 
#endif
#line 830 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned char val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 831
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 833
::exit(___);}
#if 0
#line 831
{ 
#line 832
__surf1DLayeredwritec1(make_uchar1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 833
} 
#endif
#line 835 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(char1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 836
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 838
::exit(___);}
#if 0
#line 836
{ 
#line 837
__surf1DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 838
} 
#endif
#line 840 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(uchar1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 841
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 843
::exit(___);}
#if 0
#line 841
{ 
#line 842
__surf1DLayeredwritec1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 843
} 
#endif
#line 845 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(char2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 846
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 848
::exit(___);}
#if 0
#line 846
{ 
#line 847
__surf1DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 848
} 
#endif
#line 850 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(uchar2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 851
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 853
::exit(___);}
#if 0
#line 851
{ 
#line 852
__surf1DLayeredwritec2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 853
} 
#endif
#line 855 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(char4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 856
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 858
::exit(___);}
#if 0
#line 856
{ 
#line 857
__surf1DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 858
} 
#endif
#line 860 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(uchar4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 861
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 863
::exit(___);}
#if 0
#line 861
{ 
#line 862
__surf1DLayeredwritec4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 863
} 
#endif
#line 865 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 866
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 868
::exit(___);}
#if 0
#line 866
{ 
#line 867
__surf1DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 868
} 
#endif
#line 870 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned short val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 871
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 873
::exit(___);}
#if 0
#line 871
{ 
#line 872
__surf1DLayeredwrites1(make_ushort1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 873
} 
#endif
#line 875 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(short1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 876
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 878
::exit(___);}
#if 0
#line 876
{ 
#line 877
__surf1DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 878
} 
#endif
#line 880 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ushort1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 881
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 883
::exit(___);}
#if 0
#line 881
{ 
#line 882
__surf1DLayeredwrites1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 883
} 
#endif
#line 885 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(short2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 886
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 888
::exit(___);}
#if 0
#line 886
{ 
#line 887
__surf1DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 888
} 
#endif
#line 890 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ushort2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 891
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 893
::exit(___);}
#if 0
#line 891
{ 
#line 892
__surf1DLayeredwrites2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 893
} 
#endif
#line 895 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(short4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 896
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 898
::exit(___);}
#if 0
#line 896
{ 
#line 897
__surf1DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 898
} 
#endif
#line 900 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ushort4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 901
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 903
::exit(___);}
#if 0
#line 901
{ 
#line 902
__surf1DLayeredwrites4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 903
} 
#endif
#line 905 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(int val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 906
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 908
::exit(___);}
#if 0
#line 906
{ 
#line 907
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 908
} 
#endif
#line 910 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 911
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 913
::exit(___);}
#if 0
#line 911
{ 
#line 912
__surf1DLayeredwriteu1(make_uint1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 913
} 
#endif
#line 915 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(int1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 916
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 918
::exit(___);}
#if 0
#line 916
{ 
#line 917
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 918
} 
#endif
#line 920 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(uint1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 921
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 923
::exit(___);}
#if 0
#line 921
{ 
#line 922
__surf1DLayeredwriteu1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 923
} 
#endif
#line 925 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(int2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 926
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 928
::exit(___);}
#if 0
#line 926
{ 
#line 927
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 928
} 
#endif
#line 930 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(uint2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 931
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 933
::exit(___);}
#if 0
#line 931
{ 
#line 932
__surf1DLayeredwriteu2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 933
} 
#endif
#line 935 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(int4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 936
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 938
::exit(___);}
#if 0
#line 936
{ 
#line 937
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 938
} 
#endif
#line 940 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(uint4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 941
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 943
::exit(___);}
#if 0
#line 941
{ 
#line 942
__surf1DLayeredwriteu4(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 943
} 
#endif
#line 945 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(__int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 946
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 948
::exit(___);}
#if 0
#line 946
{ 
#line 947
__surf1DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 948
} 
#endif
#line 950 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned __int64 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 951
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 953
::exit(___);}
#if 0
#line 951
{ 
#line 952
__surf1DLayeredwritel1(make_ulonglong1(val), surf, x, layer, cudaBoundaryModeTrap); 
#line 953
} 
#endif
#line 955 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(longlong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 956
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 958
::exit(___);}
#if 0
#line 956
{ 
#line 957
__surf1DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 958
} 
#endif
#line 960 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulonglong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 961
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 963
::exit(___);}
#if 0
#line 961
{ 
#line 962
__surf1DLayeredwritel1(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 963
} 
#endif
#line 965 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(longlong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 966
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 968
::exit(___);}
#if 0
#line 966
{ 
#line 967
__surf1DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 968
} 
#endif
#line 970 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulonglong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 971
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 973
::exit(___);}
#if 0
#line 971
{ 
#line 972
__surf1DLayeredwritel2(val, surf, x, layer, cudaBoundaryModeTrap); 
#line 973
} 
#endif
#line 977 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 978
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 980
::exit(___);}
#if 0
#line 978
{ 
#line 979
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 980
} 
#endif
#line 982 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned long val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 983
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 985
::exit(___);}
#if 0
#line 983
{ 
#line 984
__surf1DLayeredwriteu1(make_uint1((unsigned)val), surf, x, layer, cudaBoundaryModeTrap); 
#line 985
} 
#endif
#line 987 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(long1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 988
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 990
::exit(___);}
#if 0
#line 988
{ 
#line 989
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 990
} 
#endif
#line 992 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulong1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 993
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 995
::exit(___);}
#if 0
#line 993
{ 
#line 994
__surf1DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 995
} 
#endif
#line 997 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(long2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 998
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1000
::exit(___);}
#if 0
#line 998
{ 
#line 999
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1000
} 
#endif
#line 1002 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulong2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1003
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1005
::exit(___);}
#if 0
#line 1003
{ 
#line 1004
__surf1DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1005
} 
#endif
#line 1007 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(long4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1008
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1010
::exit(___);}
#if 0
#line 1008
{ 
#line 1009
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1010
} 
#endif
#line 1012 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulong4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1013
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1015
::exit(___);}
#if 0
#line 1013
{ 
#line 1014
__surf1DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1015
} 
#endif
#line 1019 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(float val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1020
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1022
::exit(___);}
#if 0
#line 1020
{ 
#line 1021
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1022
} 
#endif
#line 1024 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(float1 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1025
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1027
::exit(___);}
#if 0
#line 1025
{ 
#line 1026
__surf1DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1027
} 
#endif
#line 1029 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(float2 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1030
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1032
::exit(___);}
#if 0
#line 1030
{ 
#line 1031
__surf1DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1032
} 
#endif
#line 1034 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf1DLayeredwrite(float4 val, surface< void, 241>  surf, int x, int layer, cudaSurfaceBoundaryMode mode) 
#line 1035
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)layer;(void)mode;
#line 1037
::exit(___);}
#if 0
#line 1035
{ 
#line 1036
__surf1DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, layer, cudaBoundaryModeTrap); 
#line 1037
} 
#endif
#line 1062 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1063
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1065
::exit(___);}
#if 0
#line 1063
{ 
#line 1064
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1065
} 
#endif
#line 1067 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(signed char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1068
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1070
::exit(___);}
#if 0
#line 1068
{ 
#line 1069
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1070
} 
#endif
#line 1072 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned char val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1073
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1075
::exit(___);}
#if 0
#line 1073
{ 
#line 1074
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1075
} 
#endif
#line 1077 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(char1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1078
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1080
::exit(___);}
#if 0
#line 1078
{ 
#line 1079
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1080
} 
#endif
#line 1082 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(uchar1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1083
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1085
::exit(___);}
#if 0
#line 1083
{ 
#line 1084
__surf2DLayeredwritec1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1085
} 
#endif
#line 1087 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(char2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1088
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1090
::exit(___);}
#if 0
#line 1088
{ 
#line 1089
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1090
} 
#endif
#line 1092 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(uchar2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1093
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1095
::exit(___);}
#if 0
#line 1093
{ 
#line 1094
__surf2DLayeredwritec2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1095
} 
#endif
#line 1097 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(char4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1098
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1100
::exit(___);}
#if 0
#line 1098
{ 
#line 1099
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1100
} 
#endif
#line 1102 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(uchar4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1103
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1105
::exit(___);}
#if 0
#line 1103
{ 
#line 1104
__surf2DLayeredwritec4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1105
} 
#endif
#line 1107 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1108
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1110
::exit(___);}
#if 0
#line 1108
{ 
#line 1109
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1110
} 
#endif
#line 1112 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned short val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1113
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1115
::exit(___);}
#if 0
#line 1113
{ 
#line 1114
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1115
} 
#endif
#line 1117 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(short1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1118
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1120
::exit(___);}
#if 0
#line 1118
{ 
#line 1119
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1120
} 
#endif
#line 1122 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ushort1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1123
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1125
::exit(___);}
#if 0
#line 1123
{ 
#line 1124
__surf2DLayeredwrites1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1125
} 
#endif
#line 1127 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(short2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1128
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1130
::exit(___);}
#if 0
#line 1128
{ 
#line 1129
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1130
} 
#endif
#line 1132 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ushort2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1133
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1135
::exit(___);}
#if 0
#line 1133
{ 
#line 1134
__surf2DLayeredwrites2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1135
} 
#endif
#line 1137 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(short4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1138
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1140
::exit(___);}
#if 0
#line 1138
{ 
#line 1139
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1140
} 
#endif
#line 1142 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ushort4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1143
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1145
::exit(___);}
#if 0
#line 1143
{ 
#line 1144
__surf2DLayeredwrites4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1145
} 
#endif
#line 1147 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(int val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1148
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1150
::exit(___);}
#if 0
#line 1148
{ 
#line 1149
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1150
} 
#endif
#line 1152 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1153
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1155
::exit(___);}
#if 0
#line 1153
{ 
#line 1154
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1155
} 
#endif
#line 1157 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(int1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1158
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1160
::exit(___);}
#if 0
#line 1158
{ 
#line 1159
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1160
} 
#endif
#line 1162 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(uint1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1163
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1165
::exit(___);}
#if 0
#line 1163
{ 
#line 1164
__surf2DLayeredwriteu1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1165
} 
#endif
#line 1167 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(int2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1168
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1170
::exit(___);}
#if 0
#line 1168
{ 
#line 1169
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1170
} 
#endif
#line 1172 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(uint2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1173
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1175
::exit(___);}
#if 0
#line 1173
{ 
#line 1174
__surf2DLayeredwriteu2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1175
} 
#endif
#line 1177 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(int4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1178
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1180
::exit(___);}
#if 0
#line 1178
{ 
#line 1179
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1180
} 
#endif
#line 1182 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(uint4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1183
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1185
::exit(___);}
#if 0
#line 1183
{ 
#line 1184
__surf2DLayeredwriteu4(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1185
} 
#endif
#line 1187 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(__int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1188
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1190
::exit(___);}
#if 0
#line 1188
{ 
#line 1189
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1190
} 
#endif
#line 1192 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned __int64 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1193
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1195
::exit(___);}
#if 0
#line 1193
{ 
#line 1194
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1195
} 
#endif
#line 1197 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(longlong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1198
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1200
::exit(___);}
#if 0
#line 1198
{ 
#line 1199
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1200
} 
#endif
#line 1202 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulonglong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1203
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1205
::exit(___);}
#if 0
#line 1203
{ 
#line 1204
__surf2DLayeredwritel1(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1205
} 
#endif
#line 1207 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(longlong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1208
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1210
::exit(___);}
#if 0
#line 1208
{ 
#line 1209
__surf2DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1210
} 
#endif
#line 1212 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulonglong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1213
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1215
::exit(___);}
#if 0
#line 1213
{ 
#line 1214
__surf2DLayeredwritel2(val, surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1215
} 
#endif
#line 1219 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1220
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1222
::exit(___);}
#if 0
#line 1220
{ 
#line 1221
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1222
} 
#endif
#line 1224 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned long val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1225
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1227
::exit(___);}
#if 0
#line 1225
{ 
#line 1226
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1227
} 
#endif
#line 1229 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(long1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1230
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1232
::exit(___);}
#if 0
#line 1230
{ 
#line 1231
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1232
} 
#endif
#line 1234 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulong1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1235
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1237
::exit(___);}
#if 0
#line 1235
{ 
#line 1236
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1237
} 
#endif
#line 1239 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(long2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1240
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1242
::exit(___);}
#if 0
#line 1240
{ 
#line 1241
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1242
} 
#endif
#line 1244 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulong2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1245
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1247
::exit(___);}
#if 0
#line 1245
{ 
#line 1246
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1247
} 
#endif
#line 1249 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(long4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1250
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1252
::exit(___);}
#if 0
#line 1250
{ 
#line 1251
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1252
} 
#endif
#line 1254 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulong4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1255
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1257
::exit(___);}
#if 0
#line 1255
{ 
#line 1256
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1257
} 
#endif
#line 1261 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(float val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1262
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1264
::exit(___);}
#if 0
#line 1262
{ 
#line 1263
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1264
} 
#endif
#line 1266 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(float1 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1267
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1269
::exit(___);}
#if 0
#line 1267
{ 
#line 1268
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1269
} 
#endif
#line 1271 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(float2 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1272
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1274
::exit(___);}
#if 0
#line 1272
{ 
#line 1273
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1274
} 
#endif
#line 1276 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surf2DLayeredwrite(float4 val, surface< void, 242>  surf, int x, int y, int layer, cudaSurfaceBoundaryMode mode) 
#line 1277
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layer;(void)mode;
#line 1279
::exit(___);}
#if 0
#line 1277
{ 
#line 1278
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layer, cudaBoundaryModeTrap); 
#line 1279
} 
#endif
#line 1305 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1306
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1308
::exit(___);}
#if 0
#line 1306
{ 
#line 1307
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1308
} 
#endif
#line 1310 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(signed char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1311
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1313
::exit(___);}
#if 0
#line 1311
{ 
#line 1312
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1313
} 
#endif
#line 1315 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned char val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1316
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1318
::exit(___);}
#if 0
#line 1316
{ 
#line 1317
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1318
} 
#endif
#line 1320 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(char1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1321
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1323
::exit(___);}
#if 0
#line 1321
{ 
#line 1322
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1323
} 
#endif
#line 1325 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(uchar1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1326
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1328
::exit(___);}
#if 0
#line 1326
{ 
#line 1327
__surf2DLayeredwritec1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1328
} 
#endif
#line 1330 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(char2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1331
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1333
::exit(___);}
#if 0
#line 1331
{ 
#line 1332
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1333
} 
#endif
#line 1335 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(uchar2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1336
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1338
::exit(___);}
#if 0
#line 1336
{ 
#line 1337
__surf2DLayeredwritec2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1338
} 
#endif
#line 1340 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(char4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1341
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1343
::exit(___);}
#if 0
#line 1341
{ 
#line 1342
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1343
} 
#endif
#line 1345 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(uchar4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1346
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1348
::exit(___);}
#if 0
#line 1346
{ 
#line 1347
__surf2DLayeredwritec4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1348
} 
#endif
#line 1350 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1351
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1353
::exit(___);}
#if 0
#line 1351
{ 
#line 1352
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1353
} 
#endif
#line 1355 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned short val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1356
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1358
::exit(___);}
#if 0
#line 1356
{ 
#line 1357
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1358
} 
#endif
#line 1360 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(short1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1361
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1363
::exit(___);}
#if 0
#line 1361
{ 
#line 1362
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1363
} 
#endif
#line 1365 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ushort1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1366
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1368
::exit(___);}
#if 0
#line 1366
{ 
#line 1367
__surf2DLayeredwrites1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1368
} 
#endif
#line 1370 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(short2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1371
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1373
::exit(___);}
#if 0
#line 1371
{ 
#line 1372
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1373
} 
#endif
#line 1375 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ushort2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1376
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1378
::exit(___);}
#if 0
#line 1376
{ 
#line 1377
__surf2DLayeredwrites2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1378
} 
#endif
#line 1380 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(short4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1381
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1383
::exit(___);}
#if 0
#line 1381
{ 
#line 1382
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1383
} 
#endif
#line 1385 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ushort4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1386
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1388
::exit(___);}
#if 0
#line 1386
{ 
#line 1387
__surf2DLayeredwrites4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1388
} 
#endif
#line 1390 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(int val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1391
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1393
::exit(___);}
#if 0
#line 1391
{ 
#line 1392
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1393
} 
#endif
#line 1395 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1396
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1398
::exit(___);}
#if 0
#line 1396
{ 
#line 1397
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1398
} 
#endif
#line 1400 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(int1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1401
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1403
::exit(___);}
#if 0
#line 1401
{ 
#line 1402
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1403
} 
#endif
#line 1405 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(uint1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1406
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1408
::exit(___);}
#if 0
#line 1406
{ 
#line 1407
__surf2DLayeredwriteu1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1408
} 
#endif
#line 1410 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(int2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1411
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1413
::exit(___);}
#if 0
#line 1411
{ 
#line 1412
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1413
} 
#endif
#line 1415 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(uint2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1416
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1418
::exit(___);}
#if 0
#line 1416
{ 
#line 1417
__surf2DLayeredwriteu2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1418
} 
#endif
#line 1420 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(int4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1421
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1423
::exit(___);}
#if 0
#line 1421
{ 
#line 1422
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1423
} 
#endif
#line 1425 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(uint4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1426
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1428
::exit(___);}
#if 0
#line 1426
{ 
#line 1427
__surf2DLayeredwriteu4(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1428
} 
#endif
#line 1430 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(__int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1431
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1433
::exit(___);}
#if 0
#line 1431
{ 
#line 1432
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1433
} 
#endif
#line 1435 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned __int64 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1436
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1438
::exit(___);}
#if 0
#line 1436
{ 
#line 1437
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1438
} 
#endif
#line 1440 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(longlong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1441
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1443
::exit(___);}
#if 0
#line 1441
{ 
#line 1442
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1443
} 
#endif
#line 1445 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ulonglong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1446
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1448
::exit(___);}
#if 0
#line 1446
{ 
#line 1447
__surf2DLayeredwritel1(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1448
} 
#endif
#line 1450 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(longlong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1451
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1453
::exit(___);}
#if 0
#line 1451
{ 
#line 1452
__surf2DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1453
} 
#endif
#line 1455 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ulonglong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1456
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1458
::exit(___);}
#if 0
#line 1456
{ 
#line 1457
__surf2DLayeredwritel2(val, surf, x, y, face, cudaBoundaryModeTrap); 
#line 1458
} 
#endif
#line 1462 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1463
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1465
::exit(___);}
#if 0
#line 1463
{ 
#line 1464
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1465
} 
#endif
#line 1467 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned long val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1468
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1470
::exit(___);}
#if 0
#line 1468
{ 
#line 1469
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1470
} 
#endif
#line 1472 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(long1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1473
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1475
::exit(___);}
#if 0
#line 1473
{ 
#line 1474
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1475
} 
#endif
#line 1477 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ulong1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1478
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1480
::exit(___);}
#if 0
#line 1478
{ 
#line 1479
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1480
} 
#endif
#line 1482 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(long2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1483
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1485
::exit(___);}
#if 0
#line 1483
{ 
#line 1484
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1485
} 
#endif
#line 1487 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ulong2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1488
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1490
::exit(___);}
#if 0
#line 1488
{ 
#line 1489
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1490
} 
#endif
#line 1492 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(long4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1493
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1495
::exit(___);}
#if 0
#line 1493
{ 
#line 1494
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1495
} 
#endif
#line 1497 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(ulong4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1498
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1500
::exit(___);}
#if 0
#line 1498
{ 
#line 1499
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1500
} 
#endif
#line 1504 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(float val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1505
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1507
::exit(___);}
#if 0
#line 1505
{ 
#line 1506
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1507
} 
#endif
#line 1509 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(float1 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1510
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1512
::exit(___);}
#if 0
#line 1510
{ 
#line 1511
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1512
} 
#endif
#line 1514 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(float2 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1515
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1517
::exit(___);}
#if 0
#line 1515
{ 
#line 1516
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1517
} 
#endif
#line 1519 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapwrite(float4 val, surface< void, 12>  surf, int x, int y, int face, cudaSurfaceBoundaryMode mode) 
#line 1520
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)face;(void)mode;
#line 1522
::exit(___);}
#if 0
#line 1520
{ 
#line 1521
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, face, cudaBoundaryModeTrap); 
#line 1522
} 
#endif
#line 1548 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1549
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1551
::exit(___);}
#if 0
#line 1549
{ 
#line 1550
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1551
} 
#endif
#line 1553 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(signed char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1554
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1556
::exit(___);}
#if 0
#line 1554
{ 
#line 1555
__surf2DLayeredwritec1(make_uchar1((unsigned char)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1556
} 
#endif
#line 1558 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned char val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1559
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1561
::exit(___);}
#if 0
#line 1559
{ 
#line 1560
__surf2DLayeredwritec1(make_uchar1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1561
} 
#endif
#line 1563 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1564
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1566
::exit(___);}
#if 0
#line 1564
{ 
#line 1565
__surf2DLayeredwritec1(make_uchar1((unsigned char)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1566
} 
#endif
#line 1568 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uchar1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1569
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1571
::exit(___);}
#if 0
#line 1569
{ 
#line 1570
__surf2DLayeredwritec1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1571
} 
#endif
#line 1573 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1574
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1576
::exit(___);}
#if 0
#line 1574
{ 
#line 1575
__surf2DLayeredwritec2(make_uchar2((unsigned char)(val.x), (unsigned char)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1576
} 
#endif
#line 1578 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uchar2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1579
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1581
::exit(___);}
#if 0
#line 1579
{ 
#line 1580
__surf2DLayeredwritec2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1581
} 
#endif
#line 1583 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1584
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1586
::exit(___);}
#if 0
#line 1584
{ 
#line 1585
__surf2DLayeredwritec4(make_uchar4((unsigned char)(val.x), (unsigned char)(val.y), (unsigned char)(val.z), (unsigned char)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1586
} 
#endif
#line 1588 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uchar4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1589
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1591
::exit(___);}
#if 0
#line 1589
{ 
#line 1590
__surf2DLayeredwritec4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1591
} 
#endif
#line 1593 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1594
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1596
::exit(___);}
#if 0
#line 1594
{ 
#line 1595
__surf2DLayeredwrites1(make_ushort1((unsigned short)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1596
} 
#endif
#line 1598 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned short val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1599
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1601
::exit(___);}
#if 0
#line 1599
{ 
#line 1600
__surf2DLayeredwrites1(make_ushort1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1601
} 
#endif
#line 1603 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1604
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1606
::exit(___);}
#if 0
#line 1604
{ 
#line 1605
__surf2DLayeredwrites1(make_ushort1((unsigned short)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1606
} 
#endif
#line 1608 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ushort1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1609
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1611
::exit(___);}
#if 0
#line 1609
{ 
#line 1610
__surf2DLayeredwrites1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1611
} 
#endif
#line 1613 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1614
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1616
::exit(___);}
#if 0
#line 1614
{ 
#line 1615
__surf2DLayeredwrites2(make_ushort2((unsigned short)(val.x), (unsigned short)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1616
} 
#endif
#line 1618 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ushort2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1619
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1621
::exit(___);}
#if 0
#line 1619
{ 
#line 1620
__surf2DLayeredwrites2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1621
} 
#endif
#line 1623 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1624
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1626
::exit(___);}
#if 0
#line 1624
{ 
#line 1625
__surf2DLayeredwrites4(make_ushort4((unsigned short)(val.x), (unsigned short)(val.y), (unsigned short)(val.z), (unsigned short)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1626
} 
#endif
#line 1628 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ushort4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1629
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1631
::exit(___);}
#if 0
#line 1629
{ 
#line 1630
__surf2DLayeredwrites4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1631
} 
#endif
#line 1633 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1634
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1636
::exit(___);}
#if 0
#line 1634
{ 
#line 1635
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1636
} 
#endif
#line 1638 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1639
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1641
::exit(___);}
#if 0
#line 1639
{ 
#line 1640
__surf2DLayeredwriteu1(make_uint1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1641
} 
#endif
#line 1643 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1644
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1646
::exit(___);}
#if 0
#line 1644
{ 
#line 1645
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1646
} 
#endif
#line 1648 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uint1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1649
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1651
::exit(___);}
#if 0
#line 1649
{ 
#line 1650
__surf2DLayeredwriteu1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1651
} 
#endif
#line 1653 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1654
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1656
::exit(___);}
#if 0
#line 1654
{ 
#line 1655
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1656
} 
#endif
#line 1658 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uint2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1659
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1661
::exit(___);}
#if 0
#line 1659
{ 
#line 1660
__surf2DLayeredwriteu2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1661
} 
#endif
#line 1663 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1664
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1666
::exit(___);}
#if 0
#line 1664
{ 
#line 1665
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1666
} 
#endif
#line 1668 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uint4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1669
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1671
::exit(___);}
#if 0
#line 1669
{ 
#line 1670
__surf2DLayeredwriteu4(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1671
} 
#endif
#line 1673 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(__int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1674
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1676
::exit(___);}
#if 0
#line 1674
{ 
#line 1675
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1676
} 
#endif
#line 1678 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1679
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1681
::exit(___);}
#if 0
#line 1679
{ 
#line 1680
__surf2DLayeredwritel1(make_ulonglong1(val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1681
} 
#endif
#line 1683 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(longlong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1684
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1686
::exit(___);}
#if 0
#line 1684
{ 
#line 1685
__surf2DLayeredwritel1(make_ulonglong1((unsigned __int64)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1686
} 
#endif
#line 1688 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulonglong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1689
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1691
::exit(___);}
#if 0
#line 1689
{ 
#line 1690
__surf2DLayeredwritel1(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1691
} 
#endif
#line 1693 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(longlong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1694
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1696
::exit(___);}
#if 0
#line 1694
{ 
#line 1695
__surf2DLayeredwritel2(make_ulonglong2((unsigned __int64)(val.x), (unsigned __int64)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1696
} 
#endif
#line 1698 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulonglong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1699
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1701
::exit(___);}
#if 0
#line 1699
{ 
#line 1700
__surf2DLayeredwritel2(val, surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1701
} 
#endif
#line 1705 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1706
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1708
::exit(___);}
#if 0
#line 1706
{ 
#line 1707
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1708
} 
#endif
#line 1710 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned long val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1711
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1713
::exit(___);}
#if 0
#line 1711
{ 
#line 1712
__surf2DLayeredwriteu1(make_uint1((unsigned)val), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1713
} 
#endif
#line 1715 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(long1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1716
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1718
::exit(___);}
#if 0
#line 1716
{ 
#line 1717
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1718
} 
#endif
#line 1720 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulong1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1721
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1723
::exit(___);}
#if 0
#line 1721
{ 
#line 1722
__surf2DLayeredwriteu1(make_uint1((unsigned)(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1723
} 
#endif
#line 1725 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(long2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1726
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1728
::exit(___);}
#if 0
#line 1726
{ 
#line 1727
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1728
} 
#endif
#line 1730 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulong2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1731
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1733
::exit(___);}
#if 0
#line 1731
{ 
#line 1732
__surf2DLayeredwriteu2(make_uint2((unsigned)(val.x), (unsigned)(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1733
} 
#endif
#line 1735 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(long4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1736
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1738
::exit(___);}
#if 0
#line 1736
{ 
#line 1737
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1738
} 
#endif
#line 1740 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulong4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1741
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1743
::exit(___);}
#if 0
#line 1741
{ 
#line 1742
__surf2DLayeredwriteu4(make_uint4((unsigned)(val.x), (unsigned)(val.y), (unsigned)(val.z), (unsigned)(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1743
} 
#endif
#line 1747 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1748
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1750
::exit(___);}
#if 0
#line 1748
{ 
#line 1749
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1750
} 
#endif
#line 1752 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float1 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1753
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1755
::exit(___);}
#if 0
#line 1753
{ 
#line 1754
__surf2DLayeredwriteu1(make_uint1((unsigned)__float_as_int(val.x)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1755
} 
#endif
#line 1757 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float2 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1758
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1760
::exit(___);}
#if 0
#line 1758
{ 
#line 1759
__surf2DLayeredwriteu2(make_uint2((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1760
} 
#endif
#line 1762 "e:\\cudatoolkit\\include\\surface_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float4 val, surface< void, 252>  surf, int x, int y, int layerFace, cudaSurfaceBoundaryMode mode) 
#line 1763
{int volatile ___ = 1;(void)val;(void)surf;(void)x;(void)y;(void)layerFace;(void)mode;
#line 1765
::exit(___);}
#if 0
#line 1763
{ 
#line 1764
__surf2DLayeredwriteu4(make_uint4((unsigned)__float_as_int(val.x), (unsigned)__float_as_int(val.y), (unsigned)__float_as_int(val.z), (unsigned)__float_as_int(val.w)), surf, x, y, layerFace, cudaBoundaryModeTrap); 
#line 1765
} 
#endif
#line 146 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 148
__utexfetchi(texture< T, 1, readMode>  t, ::int4 i) 
#line 149
{int volatile ___ = 1;(void)t;(void)i;
#line 151
::exit(___);}
#if 0
#line 149
{ 
#line 150
return __utexfetchi1D(t, i); 
#line 151
} 
#endif
#line 153 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 155
__itexfetchi(texture< T, 1, readMode>  t, ::int4 i) 
#line 156
{int volatile ___ = 1;(void)t;(void)i;
#line 158
::exit(___);}
#if 0
#line 156
{ 
#line 157
return __itexfetchi1D(t, i); 
#line 158
} 
#endif
#line 160 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 162
__ftexfetchi(texture< T, 1, readMode>  t, ::int4 i) 
#line 163
{int volatile ___ = 1;(void)t;(void)i;
#line 165
::exit(___);}
#if 0
#line 163
{ 
#line 164
return __ftexfetchi1D(t, i); 
#line 165
} 
#endif
#line 167 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 169
__utexfetch(texture< T, texType, readMode>  t, ::float4 i, int d = texType) 
#line 170
{int volatile ___ = 1;(void)t;(void)i;(void)d;
#line 177
::exit(___);}
#if 0
#line 170
{ 
#line 171
switch (d) { 
#line 172
case 1:  return __utexfetch1D(t, i); 
#line 173
case 2:  return __utexfetch2D(t, i); 
#line 175
default:  return __utexfetch3D(t, i); 
#line 176
}  
#line 177
} 
#endif
#line 179 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 181
__itexfetch(texture< T, texType, readMode>  t, ::float4 i, int d = texType) 
#line 182
{int volatile ___ = 1;(void)t;(void)i;(void)d;
#line 189
::exit(___);}
#if 0
#line 182
{ 
#line 183
switch (d) { 
#line 184
case 1:  return __itexfetch1D(t, i); 
#line 185
case 2:  return __itexfetch2D(t, i); 
#line 187
default:  return __itexfetch3D(t, i); 
#line 188
}  
#line 189
} 
#endif
#line 191 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 193
__ftexfetch(texture< T, texType, readMode>  t, ::float4 i, int d = texType) 
#line 194
{int volatile ___ = 1;(void)t;(void)i;(void)d;
#line 201
::exit(___);}
#if 0
#line 194
{ 
#line 195
switch (d) { 
#line 196
case 1:  return __ftexfetch1D(t, i); 
#line 197
case 2:  return __ftexfetch2D(t, i); 
#line 199
default:  return __ftexfetch3D(t, i); 
#line 200
}  
#line 201
} 
#endif
#line 203 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 205
__utexfetchc(texture< T, texType, readMode>  t, ::float4 i) 
#line 206
{int volatile ___ = 1;(void)t;(void)i;
#line 208
::exit(___);}
#if 0
#line 206
{ 
#line 207
return __utexfetchcube(t, i); 
#line 208
} 
#endif
#line 210 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 212
__itexfetchc(texture< T, texType, readMode>  t, ::float4 i) 
#line 213
{int volatile ___ = 1;(void)t;(void)i;
#line 215
::exit(___);}
#if 0
#line 213
{ 
#line 214
return __itexfetchcube(t, i); 
#line 215
} 
#endif
#line 217 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 219
__ftexfetchc(texture< T, texType, readMode>  t, ::float4 i) 
#line 220
{int volatile ___ = 1;(void)t;(void)i;
#line 222
::exit(___);}
#if 0
#line 220
{ 
#line 221
return __ftexfetchcube(t, i); 
#line 222
} 
#endif
#line 224 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 226
__utexfetchl(texture< T, texType, readMode>  t, ::float4 i, int l, int d = texType & 15) 
#line 227
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)d;
#line 233
::exit(___);}
#if 0
#line 227
{ 
#line 228
switch (d) { 
#line 229
case 1:  return __utexfetchl1D(t, i, l); 
#line 231
default:  return __utexfetchl2D(t, i, l); 
#line 232
}  
#line 233
} 
#endif
#line 235 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 237
__itexfetchl(texture< T, texType, readMode>  t, ::float4 i, int l, int d = texType & 15) 
#line 238
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)d;
#line 244
::exit(___);}
#if 0
#line 238
{ 
#line 239
switch (d) { 
#line 240
case 1:  return __itexfetchl1D(t, i, l); 
#line 242
default:  return __itexfetchl2D(t, i, l); 
#line 243
}  
#line 244
} 
#endif
#line 246 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 248
__ftexfetchl(texture< T, texType, readMode>  t, ::float4 i, int l, int d = texType & 15) 
#line 249
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)d;
#line 255
::exit(___);}
#if 0
#line 249
{ 
#line 250
switch (d) { 
#line 251
case 1:  return __ftexfetchl1D(t, i, l); 
#line 253
default:  return __ftexfetchl2D(t, i, l); 
#line 254
}  
#line 255
} 
#endif
#line 257 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 259
__utexfetchlc(texture< T, texType, readMode>  t, ::float4 i, int l) 
#line 260
{int volatile ___ = 1;(void)t;(void)i;(void)l;
#line 262
::exit(___);}
#if 0
#line 260
{ 
#line 261
return __utexfetchlcube(t, i, l); 
#line 262
} 
#endif
#line 264 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 266
__itexfetchlc(texture< T, texType, readMode>  t, ::float4 i, int l) 
#line 267
{int volatile ___ = 1;(void)t;(void)i;(void)l;
#line 269
::exit(___);}
#if 0
#line 267
{ 
#line 268
return __itexfetchlcube(t, i, l); 
#line 269
} 
#endif
#line 271 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 273
__ftexfetchlc(texture< T, texType, readMode>  t, ::float4 i, int l) 
#line 274
{int volatile ___ = 1;(void)t;(void)i;(void)l;
#line 276
::exit(___);}
#if 0
#line 274
{ 
#line 275
return __ftexfetchlcube(t, i, l); 
#line 276
} 
#endif
#line 285 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x); 
#line 287
static __forceinline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x); 
#line 289
static __forceinline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x); 
#line 291
static __forceinline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x); 
#line 293
static __forceinline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x); 
#line 295
static __forceinline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x); 
#line 297
static __forceinline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x); 
#line 299
static __forceinline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x); 
#line 301
static __forceinline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x); 
#line 309
static __forceinline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x); 
#line 311
static __forceinline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x); 
#line 313
static __forceinline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x); 
#line 315
static __forceinline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x); 
#line 317
static __forceinline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x); 
#line 319
static __forceinline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x); 
#line 321
static __forceinline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x); 
#line 323
static __forceinline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x); 
#line 331
static __forceinline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x); 
#line 333
static __forceinline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x); 
#line 335
static __forceinline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x); 
#line 337
static __forceinline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x); 
#line 339
static __forceinline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x); 
#line 341
static __forceinline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x); 
#line 343
static __forceinline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x); 
#line 345
static __forceinline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x); 
#line 355
static __forceinline long tex1Dfetch(texture< long, 1, cudaReadModeElementType>  t, int x); 
#line 357
static __forceinline unsigned long tex1Dfetch(texture< unsigned long, 1, cudaReadModeElementType>  t, int x); 
#line 359
static __forceinline long1 tex1Dfetch(texture< long1, 1, cudaReadModeElementType>  t, int x); 
#line 361
static __forceinline ulong1 tex1Dfetch(texture< ulong1, 1, cudaReadModeElementType>  t, int x); 
#line 363
static __forceinline long2 tex1Dfetch(texture< long2, 1, cudaReadModeElementType>  t, int x); 
#line 365
static __forceinline ulong2 tex1Dfetch(texture< ulong2, 1, cudaReadModeElementType>  t, int x); 
#line 367
static __forceinline long4 tex1Dfetch(texture< long4, 1, cudaReadModeElementType>  t, int x); 
#line 369
static __forceinline ulong4 tex1Dfetch(texture< ulong4, 1, cudaReadModeElementType>  t, int x); 
#line 379 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x); 
#line 381
static __forceinline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x); 
#line 383
static __forceinline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x); 
#line 385
static __forceinline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x); 
#line 393
static __forceinline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 395
static __forceinline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 397
static __forceinline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 399
static __forceinline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 401
static __forceinline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 403
static __forceinline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 405
static __forceinline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 407
static __forceinline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 409
static __forceinline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 417
static __forceinline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 419
static __forceinline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 421
static __forceinline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 423
static __forceinline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 425
static __forceinline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 427
static __forceinline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 429
static __forceinline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 431
static __forceinline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x); 
#line 439
static __forceinline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x); 
#line 441
static __forceinline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x); 
#line 443
static __forceinline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x); 
#line 445
static __forceinline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x); 
#line 447
static __forceinline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x); 
#line 449
static __forceinline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x); 
#line 451
static __forceinline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x); 
#line 453
static __forceinline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x); 
#line 455
static __forceinline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x); 
#line 463
static __forceinline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x); 
#line 465
static __forceinline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x); 
#line 467
static __forceinline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x); 
#line 469
static __forceinline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x); 
#line 471
static __forceinline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x); 
#line 473
static __forceinline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x); 
#line 475
static __forceinline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x); 
#line 477
static __forceinline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x); 
#line 485
static __forceinline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x); 
#line 487
static __forceinline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x); 
#line 489
static __forceinline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x); 
#line 491
static __forceinline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x); 
#line 493
static __forceinline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x); 
#line 495
static __forceinline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x); 
#line 497
static __forceinline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x); 
#line 499
static __forceinline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x); 
#line 515
static __forceinline long tex1D(texture< long, 1, cudaReadModeElementType>  t, float x); 
#line 517
static __forceinline unsigned long tex1D(texture< unsigned long, 1, cudaReadModeElementType>  t, float x); 
#line 519
static __forceinline long1 tex1D(texture< long1, 1, cudaReadModeElementType>  t, float x); 
#line 521
static __forceinline ulong1 tex1D(texture< ulong1, 1, cudaReadModeElementType>  t, float x); 
#line 523
static __forceinline long2 tex1D(texture< long2, 1, cudaReadModeElementType>  t, float x); 
#line 525
static __forceinline ulong2 tex1D(texture< ulong2, 1, cudaReadModeElementType>  t, float x); 
#line 527
static __forceinline long4 tex1D(texture< long4, 1, cudaReadModeElementType>  t, float x); 
#line 529
static __forceinline ulong4 tex1D(texture< ulong4, 1, cudaReadModeElementType>  t, float x); 
#line 539 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x); 
#line 541
static __forceinline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x); 
#line 543
static __forceinline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x); 
#line 545
static __forceinline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x); 
#line 553
static __forceinline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 555
static __forceinline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 557
static __forceinline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 559
static __forceinline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 561
static __forceinline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 563
static __forceinline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 565
static __forceinline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 567
static __forceinline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 569
static __forceinline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 577
static __forceinline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 579
static __forceinline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 581
static __forceinline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 583
static __forceinline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 585
static __forceinline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 587
static __forceinline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 589
static __forceinline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 591
static __forceinline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x); 
#line 599
static __forceinline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y); 
#line 601
static __forceinline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y); 
#line 603
static __forceinline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y); 
#line 605
static __forceinline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 607
static __forceinline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 609
static __forceinline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 611
static __forceinline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 613
static __forceinline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 615
static __forceinline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 623
static __forceinline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y); 
#line 625
static __forceinline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y); 
#line 627
static __forceinline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 629
static __forceinline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 631
static __forceinline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 633
static __forceinline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 635
static __forceinline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 637
static __forceinline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 645
static __forceinline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y); 
#line 647
static __forceinline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y); 
#line 649
static __forceinline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 651
static __forceinline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 653
static __forceinline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 655
static __forceinline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 657
static __forceinline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 659
static __forceinline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 669
static __forceinline long tex2D(texture< long, 2, cudaReadModeElementType>  t, float x, float y); 
#line 671
static __forceinline unsigned long tex2D(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y); 
#line 673
static __forceinline long1 tex2D(texture< long1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 675
static __forceinline ulong1 tex2D(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 677
static __forceinline long2 tex2D(texture< long2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 679
static __forceinline ulong2 tex2D(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 681
static __forceinline long4 tex2D(texture< long4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 683
static __forceinline ulong4 tex2D(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 693 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y); 
#line 695
static __forceinline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y); 
#line 697
static __forceinline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y); 
#line 699
static __forceinline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y); 
#line 707
static __forceinline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 709
static __forceinline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 711
static __forceinline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 713
static __forceinline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 715
static __forceinline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 717
static __forceinline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 719
static __forceinline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 721
static __forceinline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 723
static __forceinline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 731
static __forceinline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 733
static __forceinline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 735
static __forceinline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 737
static __forceinline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 739
static __forceinline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 741
static __forceinline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 743
static __forceinline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 745
static __forceinline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y); 
#line 753
static __forceinline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 755
static __forceinline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 757
static __forceinline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 759
static __forceinline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 761
static __forceinline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 763
static __forceinline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 765
static __forceinline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 767
static __forceinline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 769
static __forceinline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 777
static __forceinline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 779
static __forceinline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 781
static __forceinline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 783
static __forceinline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 785
static __forceinline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 787
static __forceinline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 789
static __forceinline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 791
static __forceinline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 799
static __forceinline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 801
static __forceinline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 803
static __forceinline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 805
static __forceinline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 807
static __forceinline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 809
static __forceinline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 811
static __forceinline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 813
static __forceinline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 823
static __forceinline long tex1DLayered(texture< long, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 825
static __forceinline unsigned long tex1DLayered(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 827
static __forceinline long1 tex1DLayered(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 829
static __forceinline ulong1 tex1DLayered(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 831
static __forceinline long2 tex1DLayered(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 833
static __forceinline ulong2 tex1DLayered(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 835
static __forceinline long4 tex1DLayered(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 837
static __forceinline ulong4 tex1DLayered(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 847 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 849
static __forceinline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 851
static __forceinline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 853
static __forceinline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer); 
#line 861
static __forceinline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 863
static __forceinline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 865
static __forceinline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 867
static __forceinline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 869
static __forceinline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 871
static __forceinline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 873
static __forceinline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 875
static __forceinline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 877
static __forceinline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 885
static __forceinline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 887
static __forceinline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 889
static __forceinline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 891
static __forceinline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 893
static __forceinline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 895
static __forceinline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 897
static __forceinline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 899
static __forceinline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer); 
#line 907
static __forceinline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 909
static __forceinline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 911
static __forceinline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 913
static __forceinline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 915
static __forceinline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 917
static __forceinline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 919
static __forceinline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 921
static __forceinline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 923
static __forceinline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 931
static __forceinline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 933
static __forceinline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 935
static __forceinline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 937
static __forceinline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 939
static __forceinline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 941
static __forceinline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 943
static __forceinline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 945
static __forceinline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 953
static __forceinline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 955
static __forceinline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 957
static __forceinline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 959
static __forceinline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 961
static __forceinline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 963
static __forceinline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 965
static __forceinline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 967
static __forceinline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 977
static __forceinline long tex2DLayered(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 979
static __forceinline unsigned long tex2DLayered(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 981
static __forceinline long1 tex2DLayered(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 983
static __forceinline ulong1 tex2DLayered(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 985
static __forceinline long2 tex2DLayered(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 987
static __forceinline ulong2 tex2DLayered(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 989
static __forceinline long4 tex2DLayered(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 991
static __forceinline ulong4 tex2DLayered(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 1001 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 1003
static __forceinline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 1005
static __forceinline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 1007
static __forceinline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer); 
#line 1015
static __forceinline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1017
static __forceinline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1019
static __forceinline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1021
static __forceinline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1023
static __forceinline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1025
static __forceinline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1027
static __forceinline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1029
static __forceinline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1031
static __forceinline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1039
static __forceinline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1041
static __forceinline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1043
static __forceinline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1045
static __forceinline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1047
static __forceinline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1049
static __forceinline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1051
static __forceinline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1053
static __forceinline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer); 
#line 1061
static __forceinline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1063
static __forceinline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1065
static __forceinline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1067
static __forceinline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1069
static __forceinline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1071
static __forceinline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1073
static __forceinline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1075
static __forceinline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1077
static __forceinline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1085
static __forceinline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1087
static __forceinline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1089
static __forceinline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1091
static __forceinline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1093
static __forceinline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1095
static __forceinline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1097
static __forceinline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1099
static __forceinline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1107
static __forceinline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1109
static __forceinline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1111
static __forceinline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1113
static __forceinline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1115
static __forceinline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1117
static __forceinline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1119
static __forceinline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1121
static __forceinline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1131
static __forceinline long tex3D(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1133
static __forceinline unsigned long tex3D(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1135
static __forceinline long1 tex3D(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1137
static __forceinline ulong1 tex3D(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1139
static __forceinline long2 tex3D(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1141
static __forceinline ulong2 tex3D(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1143
static __forceinline long4 tex3D(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1145
static __forceinline ulong4 tex3D(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1155 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1157
static __forceinline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1159
static __forceinline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1161
static __forceinline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1169
static __forceinline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1171
static __forceinline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1173
static __forceinline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1175
static __forceinline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1177
static __forceinline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1179
static __forceinline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1181
static __forceinline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1183
static __forceinline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1185
static __forceinline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1193
static __forceinline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1195
static __forceinline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1197
static __forceinline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1199
static __forceinline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1201
static __forceinline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1203
static __forceinline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1205
static __forceinline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1207
static __forceinline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1215
static __forceinline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1217
static __forceinline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1219
static __forceinline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1221
static __forceinline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1223
static __forceinline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1225
static __forceinline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1227
static __forceinline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1229
static __forceinline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1231
static __forceinline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1239
static __forceinline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1241
static __forceinline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1243
static __forceinline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1245
static __forceinline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1247
static __forceinline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1249
static __forceinline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1251
static __forceinline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1253
static __forceinline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1261
static __forceinline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1263
static __forceinline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1265
static __forceinline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1267
static __forceinline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1269
static __forceinline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1271
static __forceinline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1273
static __forceinline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1275
static __forceinline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1285
static __forceinline long texCubemap(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1287
static __forceinline unsigned long texCubemap(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1289
static __forceinline long1 texCubemap(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1291
static __forceinline ulong1 texCubemap(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1293
static __forceinline long2 texCubemap(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1295
static __forceinline ulong2 texCubemap(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1297
static __forceinline long4 texCubemap(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1299
static __forceinline ulong4 texCubemap(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1309 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1311
static __forceinline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1313
static __forceinline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1315
static __forceinline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z); 
#line 1323
static __forceinline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1325
static __forceinline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1327
static __forceinline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1329
static __forceinline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1331
static __forceinline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1333
static __forceinline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1335
static __forceinline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1337
static __forceinline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1339
static __forceinline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1347
static __forceinline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1349
static __forceinline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1351
static __forceinline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1353
static __forceinline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1355
static __forceinline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1357
static __forceinline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1359
static __forceinline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1361
static __forceinline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z); 
#line 1369
static __forceinline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1371
static __forceinline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1373
static __forceinline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1375
static __forceinline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1377
static __forceinline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1379
static __forceinline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1381
static __forceinline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1383
static __forceinline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1385
static __forceinline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1393
static __forceinline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1395
static __forceinline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1397
static __forceinline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1399
static __forceinline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1401
static __forceinline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1403
static __forceinline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1405
static __forceinline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1407
static __forceinline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1415
static __forceinline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1417
static __forceinline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1419
static __forceinline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1421
static __forceinline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1423
static __forceinline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1425
static __forceinline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1427
static __forceinline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1429
static __forceinline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1439
static __forceinline long texCubemapLayered(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1441
static __forceinline unsigned long texCubemapLayered(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1443
static __forceinline long1 texCubemapLayered(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1445
static __forceinline ulong1 texCubemapLayered(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1447
static __forceinline long2 texCubemapLayered(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1449
static __forceinline ulong2 texCubemapLayered(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1451
static __forceinline long4 texCubemapLayered(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1453
static __forceinline ulong4 texCubemapLayered(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1463 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1465
static __forceinline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1467
static __forceinline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1469
static __forceinline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer); 
#line 1477
static __forceinline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1479
static __forceinline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1481
static __forceinline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1483
static __forceinline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1485
static __forceinline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1487
static __forceinline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1489
static __forceinline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1491
static __forceinline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1493
static __forceinline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1501
static __forceinline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1503
static __forceinline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1505
static __forceinline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1507
static __forceinline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1509
static __forceinline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1511
static __forceinline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1513
static __forceinline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1515
static __forceinline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer); 
#line 1586 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< int comp, class T, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 1588
__itex2Dgather(texture< T, 2, readMode>  t, ::float2 i, int 
#line 1589
c = comp) 
#line 1590
{int volatile ___ = 1;(void)t;(void)i;(void)c;
#line 1598
::exit(___);}
#if 0
#line 1590
{ 
#line 1591
switch (c) { 
#line 1592
case 0:  return __itex2Dgather0(t, i); 
#line 1593
case 1:  return __itex2Dgather1(t, i); 
#line 1594
case 2:  return __itex2Dgather2(t, i); 
#line 1596
default:  return __itex2Dgather3(t, i); 
#line 1597
}  
#line 1598
} 
#endif
#line 1600 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< int comp, class T, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 1602
__utex2Dgather(texture< T, 2, readMode>  t, ::float2 i, int 
#line 1603
c = comp) 
#line 1604
{int volatile ___ = 1;(void)t;(void)i;(void)c;
#line 1612
::exit(___);}
#if 0
#line 1604
{ 
#line 1605
switch (c) { 
#line 1606
case 0:  return __utex2Dgather0(t, i); 
#line 1607
case 1:  return __utex2Dgather1(t, i); 
#line 1608
case 2:  return __utex2Dgather2(t, i); 
#line 1610
default:  return __utex2Dgather3(t, i); 
#line 1611
}  
#line 1612
} 
#endif
#line 1614 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< int comp, class T, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 1616
__ftex2Dgather(texture< T, 2, readMode>  t, ::float2 i, int 
#line 1617
c = comp) 
#line 1618
{int volatile ___ = 1;(void)t;(void)i;(void)c;
#line 1626
::exit(___);}
#if 0
#line 1618
{ 
#line 1619
switch (c) { 
#line 1620
case 0:  return __ftex2Dgather0(t, i); 
#line 1621
case 1:  return __ftex2Dgather1(t, i); 
#line 1622
case 2:  return __ftex2Dgather2(t, i); 
#line 1624
default:  return __ftex2Dgather3(t, i); 
#line 1625
}  
#line 1626
} 
#endif
#line 1628 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1630
static __forceinline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1632
static __forceinline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1634
static __forceinline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1636
static __forceinline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1638
static __forceinline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1640
static __forceinline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1642
static __forceinline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1644
static __forceinline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1646
static __forceinline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1648
static __forceinline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1650
static __forceinline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1652
static __forceinline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1654
static __forceinline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1656
static __forceinline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1658
static __forceinline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1660
static __forceinline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1662
static __forceinline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1664
static __forceinline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1666
static __forceinline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1668
static __forceinline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1670
static __forceinline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1672
static __forceinline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1674
static __forceinline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1676
static __forceinline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1678
static __forceinline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1680
static __forceinline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1682
static __forceinline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1684
static __forceinline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1686
static __forceinline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1688
static __forceinline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1690
static __forceinline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1692
static __forceinline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1694
static __forceinline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1696
static __forceinline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1698
static __forceinline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp = 0); 
#line 1707
static __forceinline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1709
static __forceinline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1711
static __forceinline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1713
static __forceinline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1715
static __forceinline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1717
static __forceinline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1719
static __forceinline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1721
static __forceinline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1723
static __forceinline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1725
static __forceinline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1727
static __forceinline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1729
static __forceinline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1731
static __forceinline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1733
static __forceinline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1735
static __forceinline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1737
static __forceinline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1739
static __forceinline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1741
static __forceinline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1743
static __forceinline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1745
static __forceinline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1747
static __forceinline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp = 0); 
#line 1839
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 1841
__utexfetchlod(texture< T, texType, readMode>  t, ::float4 i, float level, int 
#line 1842
d = texType) 
#line 1843
{int volatile ___ = 1;(void)t;(void)i;(void)level;(void)d;
#line 1850
::exit(___);}
#if 0
#line 1843
{ 
#line 1844
switch (d) { 
#line 1845
case 1:  return __utexfetchlod1D(t, i, level); 
#line 1846
case 2:  return __utexfetchlod2D(t, i, level); 
#line 1848
default:  return __utexfetchlod3D(t, i, level); 
#line 1849
}  
#line 1850
} 
#endif
#line 1852 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 1854
__itexfetchlod(texture< T, texType, readMode>  t, ::float4 i, float level, int 
#line 1855
d = texType) 
#line 1856
{int volatile ___ = 1;(void)t;(void)i;(void)level;(void)d;
#line 1863
::exit(___);}
#if 0
#line 1856
{ 
#line 1857
switch (d) { 
#line 1858
case 1:  return __itexfetchlod1D(t, i, level); 
#line 1859
case 2:  return __itexfetchlod2D(t, i, level); 
#line 1861
default:  return __itexfetchlod3D(t, i, level); 
#line 1862
}  
#line 1863
} 
#endif
#line 1865 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 1867
__ftexfetchlod(texture< T, texType, readMode>  t, ::float4 i, float level, int 
#line 1868
d = texType) 
#line 1869
{int volatile ___ = 1;(void)t;(void)i;(void)level;(void)d;
#line 1876
::exit(___);}
#if 0
#line 1869
{ 
#line 1870
switch (d) { 
#line 1871
case 1:  return __ftexfetchlod1D(t, i, level); 
#line 1872
case 2:  return __ftexfetchlod2D(t, i, level); 
#line 1874
default:  return __ftexfetchlod3D(t, i, level); 
#line 1875
}  
#line 1876
} 
#endif
#line 1879 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 1881
__utexfetchlodc(texture< T, texType, readMode>  t, ::float4 i, float level) 
#line 1882
{int volatile ___ = 1;(void)t;(void)i;(void)level;
#line 1884
::exit(___);}
#if 0
#line 1882
{ 
#line 1883
return __utexfetchlodcube(t, i, level); 
#line 1884
} 
#endif
#line 1886 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 1888
__itexfetchlodc(texture< T, texType, readMode>  t, ::float4 i, float level) 
#line 1889
{int volatile ___ = 1;(void)t;(void)i;(void)level;
#line 1891
::exit(___);}
#if 0
#line 1889
{ 
#line 1890
return __itexfetchlodcube(t, i, level); 
#line 1891
} 
#endif
#line 1893 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 1895
__ftexfetchlodc(texture< T, texType, readMode>  t, ::float4 i, float level) 
#line 1896
{int volatile ___ = 1;(void)t;(void)i;(void)level;
#line 1898
::exit(___);}
#if 0
#line 1896
{ 
#line 1897
return __ftexfetchlodcube(t, i, level); 
#line 1898
} 
#endif
#line 1900 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 1902
__utexfetchlodl(texture< T, texType, readMode>  t, ::float4 i, int l, float 
#line 1903
level, int d = texType & 15) 
#line 1904
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;(void)d;
#line 1910
::exit(___);}
#if 0
#line 1904
{ 
#line 1905
switch (d) { 
#line 1906
case 1:  return __utexfetchlodl1D(t, i, l, level); 
#line 1908
default:  return __utexfetchlodl2D(t, i, l, level); 
#line 1909
}  
#line 1910
} 
#endif
#line 1912 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 1914
__itexfetchlodl(texture< T, texType, readMode>  t, ::float4 i, int l, float 
#line 1915
level, int d = texType & 15) 
#line 1916
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;(void)d;
#line 1922
::exit(___);}
#if 0
#line 1916
{ 
#line 1917
switch (d) { 
#line 1918
case 1:  return __itexfetchlodl1D(t, i, l, level); 
#line 1920
default:  return __itexfetchlodl2D(t, i, l, level); 
#line 1921
}  
#line 1922
} 
#endif
#line 1924 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 1926
__ftexfetchlodl(texture< T, texType, readMode>  t, ::float4 i, int l, float 
#line 1927
level, int d = texType & 15) 
#line 1928
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;(void)d;
#line 1934
::exit(___);}
#if 0
#line 1928
{ 
#line 1929
switch (d) { 
#line 1930
case 1:  return __ftexfetchlodl1D(t, i, l, level); 
#line 1932
default:  return __ftexfetchlodl2D(t, i, l, level); 
#line 1933
}  
#line 1934
} 
#endif
#line 1937 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 1939
__utexfetchlodlc(texture< T, texType, readMode>  t, ::float4 i, int l, float 
#line 1940
level) 
#line 1941
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;
#line 1943
::exit(___);}
#if 0
#line 1941
{ 
#line 1942
return __utexfetchlodlcube(t, i, l, level); 
#line 1943
} 
#endif
#line 1945 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 1947
__itexfetchlodlc(texture< T, texType, readMode>  t, ::float4 i, int l, float 
#line 1948
level) 
#line 1949
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;
#line 1951
::exit(___);}
#if 0
#line 1949
{ 
#line 1950
return __itexfetchlodlcube(t, i, l, level); 
#line 1951
} 
#endif
#line 1953 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 1955
__ftexfetchlodlc(texture< T, texType, readMode>  t, ::float4 i, int l, float 
#line 1956
level) 
#line 1957
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)level;
#line 1959
::exit(___);}
#if 0
#line 1957
{ 
#line 1958
return __ftexfetchlodlcube(t, i, l, level); 
#line 1959
} 
#endif
#line 1968 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1970
static __forceinline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1972
static __forceinline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1974
static __forceinline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1976
static __forceinline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1978
static __forceinline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1980
static __forceinline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1982
static __forceinline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1984
static __forceinline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1992
static __forceinline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1994
static __forceinline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1996
static __forceinline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 1998
static __forceinline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2000
static __forceinline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2002
static __forceinline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2004
static __forceinline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2006
static __forceinline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2014
static __forceinline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2016
static __forceinline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2018
static __forceinline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2020
static __forceinline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2022
static __forceinline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2024
static __forceinline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2026
static __forceinline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2028
static __forceinline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2044
static __forceinline long tex1DLod(texture< long, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2046
static __forceinline unsigned long tex1DLod(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2048
static __forceinline long1 tex1DLod(texture< long1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2050
static __forceinline ulong1 tex1DLod(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2052
static __forceinline long2 tex1DLod(texture< long2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2054
static __forceinline ulong2 tex1DLod(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2056
static __forceinline long4 tex1DLod(texture< long4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2058
static __forceinline ulong4 tex1DLod(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2068 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2070
static __forceinline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2072
static __forceinline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2074
static __forceinline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level); 
#line 2082
static __forceinline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2084
static __forceinline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2086
static __forceinline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2088
static __forceinline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2090
static __forceinline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2092
static __forceinline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2094
static __forceinline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2096
static __forceinline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2098
static __forceinline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2106
static __forceinline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2108
static __forceinline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2110
static __forceinline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2112
static __forceinline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2114
static __forceinline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2116
static __forceinline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2118
static __forceinline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2120
static __forceinline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level); 
#line 2128
static __forceinline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2130
static __forceinline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2132
static __forceinline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2134
static __forceinline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2136
static __forceinline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2138
static __forceinline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2140
static __forceinline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2142
static __forceinline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2144
static __forceinline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2152
static __forceinline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2154
static __forceinline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2156
static __forceinline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2158
static __forceinline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2160
static __forceinline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2162
static __forceinline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2164
static __forceinline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2166
static __forceinline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2174
static __forceinline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2176
static __forceinline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2178
static __forceinline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2180
static __forceinline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2182
static __forceinline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2184
static __forceinline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2186
static __forceinline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2188
static __forceinline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2198
static __forceinline long tex2DLod(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2200
static __forceinline unsigned long tex2DLod(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2202
static __forceinline long1 tex2DLod(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2204
static __forceinline ulong1 tex2DLod(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2206
static __forceinline long2 tex2DLod(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2208
static __forceinline ulong2 tex2DLod(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2210
static __forceinline long4 tex2DLod(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2212
static __forceinline ulong4 tex2DLod(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2222 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2224
static __forceinline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2226
static __forceinline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2228
static __forceinline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level); 
#line 2236
static __forceinline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2238
static __forceinline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2240
static __forceinline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2242
static __forceinline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2244
static __forceinline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2246
static __forceinline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2248
static __forceinline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2250
static __forceinline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2252
static __forceinline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2260
static __forceinline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2262
static __forceinline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2264
static __forceinline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2266
static __forceinline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2268
static __forceinline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2270
static __forceinline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2272
static __forceinline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2274
static __forceinline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level); 
#line 2282
static __forceinline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2284
static __forceinline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2286
static __forceinline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2288
static __forceinline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2290
static __forceinline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2292
static __forceinline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2294
static __forceinline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2296
static __forceinline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2298
static __forceinline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2306
static __forceinline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2308
static __forceinline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2310
static __forceinline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2312
static __forceinline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2314
static __forceinline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2316
static __forceinline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2318
static __forceinline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2320
static __forceinline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2328
static __forceinline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2330
static __forceinline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2332
static __forceinline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2334
static __forceinline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2336
static __forceinline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2338
static __forceinline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2340
static __forceinline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2342
static __forceinline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2352
static __forceinline long tex1DLayeredLod(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2354
static __forceinline unsigned long tex1DLayeredLod(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2356
static __forceinline long1 tex1DLayeredLod(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2358
static __forceinline ulong1 tex1DLayeredLod(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2360
static __forceinline long2 tex1DLayeredLod(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2362
static __forceinline ulong2 tex1DLayeredLod(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2364
static __forceinline long4 tex1DLayeredLod(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2366
static __forceinline ulong4 tex1DLayeredLod(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2376 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2378
static __forceinline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2380
static __forceinline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2382
static __forceinline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level); 
#line 2390
static __forceinline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2392
static __forceinline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2394
static __forceinline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2396
static __forceinline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2398
static __forceinline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2400
static __forceinline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2402
static __forceinline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2404
static __forceinline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2406
static __forceinline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2414
static __forceinline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2416
static __forceinline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2418
static __forceinline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2420
static __forceinline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2422
static __forceinline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2424
static __forceinline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2426
static __forceinline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2428
static __forceinline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level); 
#line 2436
static __forceinline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2438
static __forceinline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2440
static __forceinline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2442
static __forceinline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2444
static __forceinline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2446
static __forceinline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2448
static __forceinline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2450
static __forceinline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2452
static __forceinline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2460
static __forceinline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2462
static __forceinline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2464
static __forceinline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2466
static __forceinline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2468
static __forceinline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2470
static __forceinline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2472
static __forceinline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2474
static __forceinline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2482
static __forceinline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2484
static __forceinline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2486
static __forceinline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2488
static __forceinline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2490
static __forceinline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2492
static __forceinline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2494
static __forceinline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2496
static __forceinline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2506
static __forceinline long tex2DLayeredLod(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2508
static __forceinline unsigned long tex2DLayeredLod(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2510
static __forceinline long1 tex2DLayeredLod(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2512
static __forceinline ulong1 tex2DLayeredLod(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2514
static __forceinline long2 tex2DLayeredLod(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2516
static __forceinline ulong2 tex2DLayeredLod(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2518
static __forceinline long4 tex2DLayeredLod(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2520
static __forceinline ulong4 tex2DLayeredLod(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2530 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2532
static __forceinline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2534
static __forceinline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2536
static __forceinline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level); 
#line 2544
static __forceinline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2546
static __forceinline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2548
static __forceinline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2550
static __forceinline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2552
static __forceinline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2554
static __forceinline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2556
static __forceinline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2558
static __forceinline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2560
static __forceinline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2568
static __forceinline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2570
static __forceinline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2572
static __forceinline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2574
static __forceinline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2576
static __forceinline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2578
static __forceinline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2580
static __forceinline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2582
static __forceinline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level); 
#line 2590
static __forceinline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2592
static __forceinline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2594
static __forceinline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2596
static __forceinline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2598
static __forceinline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2600
static __forceinline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2602
static __forceinline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2604
static __forceinline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2606
static __forceinline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2614
static __forceinline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2616
static __forceinline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2618
static __forceinline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2620
static __forceinline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2622
static __forceinline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2624
static __forceinline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2626
static __forceinline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2628
static __forceinline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2636
static __forceinline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2638
static __forceinline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2640
static __forceinline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2642
static __forceinline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2644
static __forceinline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2646
static __forceinline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2648
static __forceinline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2650
static __forceinline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2660
static __forceinline long tex3DLod(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2662
static __forceinline unsigned long tex3DLod(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2664
static __forceinline long1 tex3DLod(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2666
static __forceinline ulong1 tex3DLod(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2668
static __forceinline long2 tex3DLod(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2670
static __forceinline ulong2 tex3DLod(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2672
static __forceinline long4 tex3DLod(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2674
static __forceinline ulong4 tex3DLod(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2684 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2686
static __forceinline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2688
static __forceinline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2690
static __forceinline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2698
static __forceinline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2700
static __forceinline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2702
static __forceinline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2704
static __forceinline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2706
static __forceinline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2708
static __forceinline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2710
static __forceinline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2712
static __forceinline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2714
static __forceinline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2722
static __forceinline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2724
static __forceinline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2726
static __forceinline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2728
static __forceinline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2730
static __forceinline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2732
static __forceinline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2734
static __forceinline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2736
static __forceinline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2744
static __forceinline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2746
static __forceinline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2748
static __forceinline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2750
static __forceinline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2752
static __forceinline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2754
static __forceinline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2756
static __forceinline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2758
static __forceinline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2760
static __forceinline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2768
static __forceinline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2770
static __forceinline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2772
static __forceinline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2774
static __forceinline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2776
static __forceinline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2778
static __forceinline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2780
static __forceinline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2782
static __forceinline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2790
static __forceinline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2792
static __forceinline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2794
static __forceinline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2796
static __forceinline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2798
static __forceinline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2800
static __forceinline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2802
static __forceinline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2804
static __forceinline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2814
static __forceinline long texCubemapLod(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2816
static __forceinline unsigned long texCubemapLod(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2818
static __forceinline long1 texCubemapLod(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2820
static __forceinline ulong1 texCubemapLod(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2822
static __forceinline long2 texCubemapLod(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2824
static __forceinline ulong2 texCubemapLod(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2826
static __forceinline long4 texCubemapLod(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2828
static __forceinline ulong4 texCubemapLod(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2838 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2840
static __forceinline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2842
static __forceinline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2844
static __forceinline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level); 
#line 2852
static __forceinline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2854
static __forceinline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2856
static __forceinline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2858
static __forceinline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2860
static __forceinline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2862
static __forceinline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2864
static __forceinline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2866
static __forceinline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2868
static __forceinline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2876
static __forceinline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2878
static __forceinline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2880
static __forceinline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2882
static __forceinline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2884
static __forceinline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2886
static __forceinline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2888
static __forceinline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2890
static __forceinline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level); 
#line 2898
static __forceinline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2900
static __forceinline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2902
static __forceinline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2904
static __forceinline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2906
static __forceinline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2908
static __forceinline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2910
static __forceinline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2912
static __forceinline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2914
static __forceinline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2922
static __forceinline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2924
static __forceinline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2926
static __forceinline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2928
static __forceinline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2930
static __forceinline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2932
static __forceinline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2934
static __forceinline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2936
static __forceinline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2944
static __forceinline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2946
static __forceinline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2948
static __forceinline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2950
static __forceinline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2952
static __forceinline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2954
static __forceinline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2956
static __forceinline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2958
static __forceinline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2968
static __forceinline long texCubemapLayeredLod(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2970
static __forceinline unsigned long texCubemapLayeredLod(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2972
static __forceinline long1 texCubemapLayeredLod(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2974
static __forceinline ulong1 texCubemapLayeredLod(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2976
static __forceinline long2 texCubemapLayeredLod(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2978
static __forceinline ulong2 texCubemapLayeredLod(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2980
static __forceinline long4 texCubemapLayeredLod(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2982
static __forceinline ulong4 texCubemapLayeredLod(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2992 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2994
static __forceinline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2996
static __forceinline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 2998
static __forceinline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level); 
#line 3006
static __forceinline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3008
static __forceinline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3010
static __forceinline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3012
static __forceinline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3014
static __forceinline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3016
static __forceinline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3018
static __forceinline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3020
static __forceinline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3022
static __forceinline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3030
static __forceinline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3032
static __forceinline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3034
static __forceinline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3036
static __forceinline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3038
static __forceinline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3040
static __forceinline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3042
static __forceinline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3044
static __forceinline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level); 
#line 3047
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 3049
__utexfetchgrad(texture< T, texType, readMode>  t, ::float4 i, ::float4 dPdx, ::float4 dPdy, int d = texType) 
#line 3050
{int volatile ___ = 1;(void)t;(void)i;(void)dPdx;(void)dPdy;(void)d;
#line 3057
::exit(___);}
#if 0
#line 3050
{ 
#line 3051
switch (d) { 
#line 3052
case 1:  return __utexfetchgrad1D(t, i, dPdx, dPdy); 
#line 3053
case 2:  return __utexfetchgrad2D(t, i, dPdx, dPdy); 
#line 3055
default:  return __utexfetchgrad3D(t, i, dPdx, dPdy); 
#line 3056
}  
#line 3057
} 
#endif
#line 3059 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 3061
__itexfetchgrad(texture< T, texType, readMode>  t, ::float4 i, ::float4 dPdx, ::float4 dPdy, int d = texType) 
#line 3062
{int volatile ___ = 1;(void)t;(void)i;(void)dPdx;(void)dPdy;(void)d;
#line 3069
::exit(___);}
#if 0
#line 3062
{ 
#line 3063
switch (d) { 
#line 3064
case 1:  return __itexfetchgrad1D(t, i, dPdx, dPdy); 
#line 3065
case 2:  return __itexfetchgrad2D(t, i, dPdx, dPdy); 
#line 3067
default:  return __itexfetchgrad3D(t, i, dPdx, dPdy); 
#line 3068
}  
#line 3069
} 
#endif
#line 3071 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 3073
__ftexfetchgrad(texture< T, texType, readMode>  t, ::float4 i, ::float4 dPdx, ::float4 dPdy, int d = texType) 
#line 3074
{int volatile ___ = 1;(void)t;(void)i;(void)dPdx;(void)dPdy;(void)d;
#line 3081
::exit(___);}
#if 0
#line 3074
{ 
#line 3075
switch (d) { 
#line 3076
case 1:  return __ftexfetchgrad1D(t, i, dPdx, dPdy); 
#line 3077
case 2:  return __ftexfetchgrad2D(t, i, dPdx, dPdy); 
#line 3079
default:  return __ftexfetchgrad3D(t, i, dPdx, dPdy); 
#line 3080
}  
#line 3081
} 
#endif
#line 3083 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::uint4 
#line 3085
__utexfetchgradl(texture< T, texType, readMode>  t, ::float4 i, int l, ::float4 dPdx, ::float4 dPdy, int d = texType & 15) 
#line 3086
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)dPdx;(void)dPdy;(void)d;
#line 3092
::exit(___);}
#if 0
#line 3086
{ 
#line 3087
switch (d) { 
#line 3088
case 1:  return __utexfetchgradl1D(t, i, l, dPdx, dPdy); 
#line 3090
default:  return __utexfetchgradl2D(t, i, l, dPdx, dPdy); 
#line 3091
}  
#line 3092
} 
#endif
#line 3094 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::int4 
#line 3096
__itexfetchgradl(texture< T, texType, readMode>  t, ::float4 i, int l, ::float4 dPdx, ::float4 dPdy, int d = texType & 15) 
#line 3097
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)dPdx;(void)dPdy;(void)d;
#line 3103
::exit(___);}
#if 0
#line 3097
{ 
#line 3098
switch (d) { 
#line 3099
case 1:  return __itexfetchgradl1D(t, i, l, dPdx, dPdy); 
#line 3101
default:  return __itexfetchgradl2D(t, i, l, dPdx, dPdy); 
#line 3102
}  
#line 3103
} 
#endif
#line 3105 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
template< class T, int texType, cudaTextureReadMode readMode> static __forceinline ::float4 
#line 3107
__ftexfetchgradl(texture< T, texType, readMode>  t, ::float4 i, int l, ::float4 dPdx, ::float4 dPdy, int d = texType & 15) 
#line 3108
{int volatile ___ = 1;(void)t;(void)i;(void)l;(void)dPdx;(void)dPdy;(void)d;
#line 3114
::exit(___);}
#if 0
#line 3108
{ 
#line 3109
switch (d) { 
#line 3110
case 1:  return __ftexfetchgradl1D(t, i, l, dPdx, dPdy); 
#line 3112
default:  return __ftexfetchgradl2D(t, i, l, dPdx, dPdy); 
#line 3113
}  
#line 3114
} 
#endif
#line 3123 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3125
static __forceinline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3127
static __forceinline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3129
static __forceinline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3131
static __forceinline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3133
static __forceinline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3135
static __forceinline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3137
static __forceinline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3139
static __forceinline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3147
static __forceinline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3149
static __forceinline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3151
static __forceinline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3153
static __forceinline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3155
static __forceinline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3157
static __forceinline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3159
static __forceinline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3161
static __forceinline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3169
static __forceinline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3171
static __forceinline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3173
static __forceinline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3175
static __forceinline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3177
static __forceinline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3179
static __forceinline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3181
static __forceinline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3183
static __forceinline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3199
static __forceinline long tex1DGrad(texture< long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3201
static __forceinline unsigned long tex1DGrad(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3203
static __forceinline long1 tex1DGrad(texture< long1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3205
static __forceinline ulong1 tex1DGrad(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3207
static __forceinline long2 tex1DGrad(texture< long2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3209
static __forceinline ulong2 tex1DGrad(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3211
static __forceinline long4 tex1DGrad(texture< long4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3213
static __forceinline ulong4 tex1DGrad(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3223 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3225
static __forceinline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3227
static __forceinline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3229
static __forceinline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy); 
#line 3237
static __forceinline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3239
static __forceinline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3241
static __forceinline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3243
static __forceinline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3245
static __forceinline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3247
static __forceinline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3249
static __forceinline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3251
static __forceinline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3253
static __forceinline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3261
static __forceinline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3263
static __forceinline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3265
static __forceinline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3267
static __forceinline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3269
static __forceinline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3271
static __forceinline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3273
static __forceinline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3275
static __forceinline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy); 
#line 3283
static __forceinline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3285
static __forceinline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3287
static __forceinline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3289
static __forceinline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3291
static __forceinline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3293
static __forceinline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3295
static __forceinline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3297
static __forceinline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3299
static __forceinline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3307
static __forceinline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3309
static __forceinline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3311
static __forceinline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3313
static __forceinline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3315
static __forceinline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3317
static __forceinline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3319
static __forceinline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3321
static __forceinline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3329
static __forceinline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3331
static __forceinline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3333
static __forceinline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3335
static __forceinline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3337
static __forceinline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3339
static __forceinline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3341
static __forceinline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3343
static __forceinline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3353
static __forceinline long tex2DGrad(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3355
static __forceinline unsigned long tex2DGrad(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3357
static __forceinline long1 tex2DGrad(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3359
static __forceinline ulong1 tex2DGrad(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3361
static __forceinline long2 tex2DGrad(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3363
static __forceinline ulong2 tex2DGrad(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3365
static __forceinline long4 tex2DGrad(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3367
static __forceinline ulong4 tex2DGrad(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3377 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3379
static __forceinline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3381
static __forceinline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3383
static __forceinline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3391
static __forceinline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3393
static __forceinline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3395
static __forceinline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3397
static __forceinline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3399
static __forceinline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3401
static __forceinline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3403
static __forceinline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3405
static __forceinline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3407
static __forceinline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3415
static __forceinline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3417
static __forceinline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3419
static __forceinline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3421
static __forceinline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3423
static __forceinline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3425
static __forceinline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3427
static __forceinline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3429
static __forceinline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy); 
#line 3437
static __forceinline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3439
static __forceinline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3441
static __forceinline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3443
static __forceinline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3445
static __forceinline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3447
static __forceinline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3449
static __forceinline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3451
static __forceinline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3453
static __forceinline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3461
static __forceinline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3463
static __forceinline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3465
static __forceinline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3467
static __forceinline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3469
static __forceinline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3471
static __forceinline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3473
static __forceinline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3475
static __forceinline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3483
static __forceinline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3485
static __forceinline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3487
static __forceinline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3489
static __forceinline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3491
static __forceinline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3493
static __forceinline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3495
static __forceinline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3497
static __forceinline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3507
static __forceinline long tex1DLayeredGrad(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3509
static __forceinline unsigned long tex1DLayeredGrad(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3511
static __forceinline long1 tex1DLayeredGrad(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3513
static __forceinline ulong1 tex1DLayeredGrad(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3515
static __forceinline long2 tex1DLayeredGrad(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3517
static __forceinline ulong2 tex1DLayeredGrad(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3519
static __forceinline long4 tex1DLayeredGrad(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3521
static __forceinline ulong4 tex1DLayeredGrad(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3531 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3533
static __forceinline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3535
static __forceinline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3537
static __forceinline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy); 
#line 3545
static __forceinline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3547
static __forceinline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3549
static __forceinline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3551
static __forceinline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3553
static __forceinline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3555
static __forceinline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3557
static __forceinline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3559
static __forceinline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3561
static __forceinline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3569
static __forceinline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3571
static __forceinline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3573
static __forceinline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3575
static __forceinline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3577
static __forceinline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3579
static __forceinline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3581
static __forceinline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3583
static __forceinline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy); 
#line 3591
static __forceinline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3593
static __forceinline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3595
static __forceinline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3597
static __forceinline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3599
static __forceinline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3601
static __forceinline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3603
static __forceinline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3605
static __forceinline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3607
static __forceinline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3615
static __forceinline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3617
static __forceinline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3619
static __forceinline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3621
static __forceinline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3623
static __forceinline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3625
static __forceinline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3627
static __forceinline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3629
static __forceinline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3637
static __forceinline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3639
static __forceinline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3641
static __forceinline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3643
static __forceinline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3645
static __forceinline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3647
static __forceinline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3649
static __forceinline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3651
static __forceinline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3661
static __forceinline long tex2DLayeredGrad(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3663
static __forceinline unsigned long tex2DLayeredGrad(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3665
static __forceinline long1 tex2DLayeredGrad(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3667
static __forceinline ulong1 tex2DLayeredGrad(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3669
static __forceinline long2 tex2DLayeredGrad(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3671
static __forceinline ulong2 tex2DLayeredGrad(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3673
static __forceinline long4 tex2DLayeredGrad(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3675
static __forceinline ulong4 tex2DLayeredGrad(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3685 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3687
static __forceinline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3689
static __forceinline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3691
static __forceinline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3699
static __forceinline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3701
static __forceinline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3703
static __forceinline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3705
static __forceinline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3707
static __forceinline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3709
static __forceinline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3711
static __forceinline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3713
static __forceinline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3715
static __forceinline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3723
static __forceinline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3725
static __forceinline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3727
static __forceinline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3729
static __forceinline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3731
static __forceinline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3733
static __forceinline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3735
static __forceinline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3737
static __forceinline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 3745
static __forceinline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3747
static __forceinline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3749
static __forceinline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3751
static __forceinline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3753
static __forceinline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3755
static __forceinline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3757
static __forceinline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3759
static __forceinline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3761
static __forceinline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3769
static __forceinline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3771
static __forceinline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3773
static __forceinline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3775
static __forceinline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3777
static __forceinline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3779
static __forceinline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3781
static __forceinline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3783
static __forceinline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3791
static __forceinline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3793
static __forceinline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3795
static __forceinline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3797
static __forceinline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3799
static __forceinline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3801
static __forceinline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3803
static __forceinline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3805
static __forceinline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3815
static __forceinline long tex3DGrad(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3817
static __forceinline unsigned long tex3DGrad(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3819
static __forceinline long1 tex3DGrad(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3821
static __forceinline ulong1 tex3DGrad(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3823
static __forceinline long2 tex3DGrad(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3825
static __forceinline ulong2 tex3DGrad(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3827
static __forceinline long4 tex3DGrad(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3829
static __forceinline ulong4 tex3DGrad(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3839 "e:\\cudatoolkit\\include\\texture_fetch_functions.h"
static __forceinline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3841
static __forceinline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3843
static __forceinline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3845
static __forceinline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3853
static __forceinline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3855
static __forceinline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3857
static __forceinline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3859
static __forceinline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3861
static __forceinline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3863
static __forceinline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3865
static __forceinline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3867
static __forceinline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3869
static __forceinline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3877
static __forceinline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3879
static __forceinline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3881
static __forceinline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3883
static __forceinline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3885
static __forceinline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3887
static __forceinline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3889
static __forceinline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 3891
static __forceinline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 80 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1Dfetch(texture< char, 1, cudaReadModeElementType>  t, int x) 
#line 81
{int volatile ___ = 1;(void)t;(void)x;
#line 89 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 81 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 85 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 88 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 89
} 
#endif
#line 91 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1Dfetch(texture< signed char, 1, cudaReadModeElementType>  t, int x) 
#line 92
{int volatile ___ = 1;(void)t;(void)x;
#line 96
::exit(___);}
#if 0
#line 92
{ 
#line 93
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 95
return (signed char)(v.x); 
#line 96
} 
#endif
#line 98 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1Dfetch(texture< unsigned char, 1, cudaReadModeElementType>  t, int x) 
#line 99
{int volatile ___ = 1;(void)t;(void)x;
#line 103
::exit(___);}
#if 0
#line 99
{ 
#line 100
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 102
return (unsigned char)(v.x); 
#line 103
} 
#endif
#line 105 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1Dfetch(texture< char1, 1, cudaReadModeElementType>  t, int x) 
#line 106
{int volatile ___ = 1;(void)t;(void)x;
#line 110
::exit(___);}
#if 0
#line 106
{ 
#line 107
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 109
return make_char1(v.x); 
#line 110
} 
#endif
#line 112 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1Dfetch(texture< uchar1, 1, cudaReadModeElementType>  t, int x) 
#line 113
{int volatile ___ = 1;(void)t;(void)x;
#line 117
::exit(___);}
#if 0
#line 113
{ 
#line 114
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 116
return make_uchar1(v.x); 
#line 117
} 
#endif
#line 119 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1Dfetch(texture< char2, 1, cudaReadModeElementType>  t, int x) 
#line 120
{int volatile ___ = 1;(void)t;(void)x;
#line 124
::exit(___);}
#if 0
#line 120
{ 
#line 121
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 123
return make_char2(v.x, v.y); 
#line 124
} 
#endif
#line 126 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1Dfetch(texture< uchar2, 1, cudaReadModeElementType>  t, int x) 
#line 127
{int volatile ___ = 1;(void)t;(void)x;
#line 131
::exit(___);}
#if 0
#line 127
{ 
#line 128
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 130
return make_uchar2(v.x, v.y); 
#line 131
} 
#endif
#line 133 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1Dfetch(texture< char4, 1, cudaReadModeElementType>  t, int x) 
#line 134
{int volatile ___ = 1;(void)t;(void)x;
#line 138
::exit(___);}
#if 0
#line 134
{ 
#line 135
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 137
return make_char4(v.x, v.y, v.z, v.w); 
#line 138
} 
#endif
#line 140 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1Dfetch(texture< uchar4, 1, cudaReadModeElementType>  t, int x) 
#line 141
{int volatile ___ = 1;(void)t;(void)x;
#line 145
::exit(___);}
#if 0
#line 141
{ 
#line 142
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 144
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 145
} 
#endif
#line 153 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1Dfetch(texture< short, 1, cudaReadModeElementType>  t, int x) 
#line 154
{int volatile ___ = 1;(void)t;(void)x;
#line 158
::exit(___);}
#if 0
#line 154
{ 
#line 155
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 157
return (short)(v.x); 
#line 158
} 
#endif
#line 160 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1Dfetch(texture< unsigned short, 1, cudaReadModeElementType>  t, int x) 
#line 161
{int volatile ___ = 1;(void)t;(void)x;
#line 165
::exit(___);}
#if 0
#line 161
{ 
#line 162
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 164
return (unsigned short)(v.x); 
#line 165
} 
#endif
#line 167 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1Dfetch(texture< short1, 1, cudaReadModeElementType>  t, int x) 
#line 168
{int volatile ___ = 1;(void)t;(void)x;
#line 172
::exit(___);}
#if 0
#line 168
{ 
#line 169
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 171
return make_short1(v.x); 
#line 172
} 
#endif
#line 174 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1Dfetch(texture< ushort1, 1, cudaReadModeElementType>  t, int x) 
#line 175
{int volatile ___ = 1;(void)t;(void)x;
#line 179
::exit(___);}
#if 0
#line 175
{ 
#line 176
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 178
return make_ushort1(v.x); 
#line 179
} 
#endif
#line 181 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1Dfetch(texture< short2, 1, cudaReadModeElementType>  t, int x) 
#line 182
{int volatile ___ = 1;(void)t;(void)x;
#line 186
::exit(___);}
#if 0
#line 182
{ 
#line 183
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 185
return make_short2(v.x, v.y); 
#line 186
} 
#endif
#line 188 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1Dfetch(texture< ushort2, 1, cudaReadModeElementType>  t, int x) 
#line 189
{int volatile ___ = 1;(void)t;(void)x;
#line 193
::exit(___);}
#if 0
#line 189
{ 
#line 190
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 192
return make_ushort2(v.x, v.y); 
#line 193
} 
#endif
#line 195 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1Dfetch(texture< short4, 1, cudaReadModeElementType>  t, int x) 
#line 196
{int volatile ___ = 1;(void)t;(void)x;
#line 200
::exit(___);}
#if 0
#line 196
{ 
#line 197
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 199
return make_short4(v.x, v.y, v.z, v.w); 
#line 200
} 
#endif
#line 202 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1Dfetch(texture< ushort4, 1, cudaReadModeElementType>  t, int x) 
#line 203
{int volatile ___ = 1;(void)t;(void)x;
#line 207
::exit(___);}
#if 0
#line 203
{ 
#line 204
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 206
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 207
} 
#endif
#line 215 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1Dfetch(texture< int, 1, cudaReadModeElementType>  t, int x) 
#line 216
{int volatile ___ = 1;(void)t;(void)x;
#line 220
::exit(___);}
#if 0
#line 216
{ 
#line 217
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 219
return v.x; 
#line 220
} 
#endif
#line 222 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1Dfetch(texture< unsigned, 1, cudaReadModeElementType>  t, int x) 
#line 223
{int volatile ___ = 1;(void)t;(void)x;
#line 227
::exit(___);}
#if 0
#line 223
{ 
#line 224
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 226
return v.x; 
#line 227
} 
#endif
#line 229 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1Dfetch(texture< int1, 1, cudaReadModeElementType>  t, int x) 
#line 230
{int volatile ___ = 1;(void)t;(void)x;
#line 234
::exit(___);}
#if 0
#line 230
{ 
#line 231
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 233
return make_int1(v.x); 
#line 234
} 
#endif
#line 236 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1Dfetch(texture< uint1, 1, cudaReadModeElementType>  t, int x) 
#line 237
{int volatile ___ = 1;(void)t;(void)x;
#line 241
::exit(___);}
#if 0
#line 237
{ 
#line 238
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 240
return make_uint1(v.x); 
#line 241
} 
#endif
#line 243 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1Dfetch(texture< int2, 1, cudaReadModeElementType>  t, int x) 
#line 244
{int volatile ___ = 1;(void)t;(void)x;
#line 248
::exit(___);}
#if 0
#line 244
{ 
#line 245
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 247
return make_int2(v.x, v.y); 
#line 248
} 
#endif
#line 250 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1Dfetch(texture< uint2, 1, cudaReadModeElementType>  t, int x) 
#line 251
{int volatile ___ = 1;(void)t;(void)x;
#line 255
::exit(___);}
#if 0
#line 251
{ 
#line 252
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 254
return make_uint2(v.x, v.y); 
#line 255
} 
#endif
#line 257 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1Dfetch(texture< int4, 1, cudaReadModeElementType>  t, int x) 
#line 258
{int volatile ___ = 1;(void)t;(void)x;
#line 262
::exit(___);}
#if 0
#line 258
{ 
#line 259
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 261
return make_int4(v.x, v.y, v.z, v.w); 
#line 262
} 
#endif
#line 264 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1Dfetch(texture< uint4, 1, cudaReadModeElementType>  t, int x) 
#line 265
{int volatile ___ = 1;(void)t;(void)x;
#line 269
::exit(___);}
#if 0
#line 265
{ 
#line 266
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 268
return make_uint4(v.x, v.y, v.z, v.w); 
#line 269
} 
#endif
#line 279 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1Dfetch(texture< long, 1, cudaReadModeElementType>  t, int x) 
#line 280
{int volatile ___ = 1;(void)t;(void)x;
#line 284
::exit(___);}
#if 0
#line 280
{ 
#line 281
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 283
return (long)(v.x); 
#line 284
} 
#endif
#line 286 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1Dfetch(texture< unsigned long, 1, cudaReadModeElementType>  t, int x) 
#line 287
{int volatile ___ = 1;(void)t;(void)x;
#line 291
::exit(___);}
#if 0
#line 287
{ 
#line 288
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 290
return (unsigned long)(v.x); 
#line 291
} 
#endif
#line 293 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1Dfetch(texture< long1, 1, cudaReadModeElementType>  t, int x) 
#line 294
{int volatile ___ = 1;(void)t;(void)x;
#line 298
::exit(___);}
#if 0
#line 294
{ 
#line 295
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 297
return make_long1(v.x); 
#line 298
} 
#endif
#line 300 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1Dfetch(texture< ulong1, 1, cudaReadModeElementType>  t, int x) 
#line 301
{int volatile ___ = 1;(void)t;(void)x;
#line 305
::exit(___);}
#if 0
#line 301
{ 
#line 302
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 304
return make_ulong1(v.x); 
#line 305
} 
#endif
#line 307 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1Dfetch(texture< long2, 1, cudaReadModeElementType>  t, int x) 
#line 308
{int volatile ___ = 1;(void)t;(void)x;
#line 312
::exit(___);}
#if 0
#line 308
{ 
#line 309
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 311
return make_long2(v.x, v.y); 
#line 312
} 
#endif
#line 314 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1Dfetch(texture< ulong2, 1, cudaReadModeElementType>  t, int x) 
#line 315
{int volatile ___ = 1;(void)t;(void)x;
#line 319
::exit(___);}
#if 0
#line 315
{ 
#line 316
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 318
return make_ulong2(v.x, v.y); 
#line 319
} 
#endif
#line 321 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1Dfetch(texture< long4, 1, cudaReadModeElementType>  t, int x) 
#line 322
{int volatile ___ = 1;(void)t;(void)x;
#line 326
::exit(___);}
#if 0
#line 322
{ 
#line 323
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 325
return make_long4(v.x, v.y, v.z, v.w); 
#line 326
} 
#endif
#line 328 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1Dfetch(texture< ulong4, 1, cudaReadModeElementType>  t, int x) 
#line 329
{int volatile ___ = 1;(void)t;(void)x;
#line 333
::exit(___);}
#if 0
#line 329
{ 
#line 330
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 332
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 333
} 
#endif
#line 343 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1Dfetch(texture< float, 1, cudaReadModeElementType>  t, int x) 
#line 344
{int volatile ___ = 1;(void)t;(void)x;
#line 348
::exit(___);}
#if 0
#line 344
{ 
#line 345
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 347
return v.x; 
#line 348
} 
#endif
#line 350 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1Dfetch(texture< float1, 1, cudaReadModeElementType>  t, int x) 
#line 351
{int volatile ___ = 1;(void)t;(void)x;
#line 355
::exit(___);}
#if 0
#line 351
{ 
#line 352
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 354
return make_float1(v.x); 
#line 355
} 
#endif
#line 357 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1Dfetch(texture< float2, 1, cudaReadModeElementType>  t, int x) 
#line 358
{int volatile ___ = 1;(void)t;(void)x;
#line 362
::exit(___);}
#if 0
#line 358
{ 
#line 359
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 361
return make_float2(v.x, v.y); 
#line 362
} 
#endif
#line 364 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1Dfetch(texture< float4, 1, cudaReadModeElementType>  t, int x) 
#line 365
{int volatile ___ = 1;(void)t;(void)x;
#line 369
::exit(___);}
#if 0
#line 365
{ 
#line 366
float4 v = __ftexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 368
return make_float4(v.x, v.y, v.z, v.w); 
#line 369
} 
#endif
#line 377 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1Dfetch(texture< char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 378
{int volatile ___ = 1;(void)t;(void)x;
#line 387 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 378 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 382 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 384 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 386
return w.x; 
#line 387
} 
#endif
#line 389 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1Dfetch(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 390
{int volatile ___ = 1;(void)t;(void)x;
#line 395
::exit(___);}
#if 0
#line 390
{ 
#line 391
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 392
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 394
return w.x; 
#line 395
} 
#endif
#line 397 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1Dfetch(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 398
{int volatile ___ = 1;(void)t;(void)x;
#line 403
::exit(___);}
#if 0
#line 398
{ 
#line 399
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 400
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 402
return w.x; 
#line 403
} 
#endif
#line 405 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1Dfetch(texture< char1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 406
{int volatile ___ = 1;(void)t;(void)x;
#line 411
::exit(___);}
#if 0
#line 406
{ 
#line 407
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 408
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 410
return make_float1(w.x); 
#line 411
} 
#endif
#line 413 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1Dfetch(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 414
{int volatile ___ = 1;(void)t;(void)x;
#line 419
::exit(___);}
#if 0
#line 414
{ 
#line 415
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 416
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 418
return make_float1(w.x); 
#line 419
} 
#endif
#line 421 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1Dfetch(texture< char2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 422
{int volatile ___ = 1;(void)t;(void)x;
#line 427
::exit(___);}
#if 0
#line 422
{ 
#line 423
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 424
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 426
return make_float2(w.x, w.y); 
#line 427
} 
#endif
#line 429 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1Dfetch(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 430
{int volatile ___ = 1;(void)t;(void)x;
#line 435
::exit(___);}
#if 0
#line 430
{ 
#line 431
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 432
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 434
return make_float2(w.x, w.y); 
#line 435
} 
#endif
#line 437 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1Dfetch(texture< char4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 438
{int volatile ___ = 1;(void)t;(void)x;
#line 443
::exit(___);}
#if 0
#line 438
{ 
#line 439
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 440
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 442
return make_float4(w.x, w.y, w.z, w.w); 
#line 443
} 
#endif
#line 445 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1Dfetch(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 446
{int volatile ___ = 1;(void)t;(void)x;
#line 451
::exit(___);}
#if 0
#line 446
{ 
#line 447
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 448
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 450
return make_float4(w.x, w.y, w.z, w.w); 
#line 451
} 
#endif
#line 459 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1Dfetch(texture< short, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 460
{int volatile ___ = 1;(void)t;(void)x;
#line 465
::exit(___);}
#if 0
#line 460
{ 
#line 461
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 462
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 464
return w.x; 
#line 465
} 
#endif
#line 467 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1Dfetch(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 468
{int volatile ___ = 1;(void)t;(void)x;
#line 473
::exit(___);}
#if 0
#line 468
{ 
#line 469
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 470
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 472
return w.x; 
#line 473
} 
#endif
#line 475 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1Dfetch(texture< short1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 476
{int volatile ___ = 1;(void)t;(void)x;
#line 481
::exit(___);}
#if 0
#line 476
{ 
#line 477
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 478
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 480
return make_float1(w.x); 
#line 481
} 
#endif
#line 483 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1Dfetch(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 484
{int volatile ___ = 1;(void)t;(void)x;
#line 489
::exit(___);}
#if 0
#line 484
{ 
#line 485
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 486
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 488
return make_float1(w.x); 
#line 489
} 
#endif
#line 491 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1Dfetch(texture< short2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 492
{int volatile ___ = 1;(void)t;(void)x;
#line 497
::exit(___);}
#if 0
#line 492
{ 
#line 493
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 494
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 496
return make_float2(w.x, w.y); 
#line 497
} 
#endif
#line 499 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1Dfetch(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 500
{int volatile ___ = 1;(void)t;(void)x;
#line 505
::exit(___);}
#if 0
#line 500
{ 
#line 501
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 502
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 504
return make_float2(w.x, w.y); 
#line 505
} 
#endif
#line 507 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1Dfetch(texture< short4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 508
{int volatile ___ = 1;(void)t;(void)x;
#line 513
::exit(___);}
#if 0
#line 508
{ 
#line 509
int4 v = __itexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 510
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 512
return make_float4(w.x, w.y, w.z, w.w); 
#line 513
} 
#endif
#line 515 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1Dfetch(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, int x) 
#line 516
{int volatile ___ = 1;(void)t;(void)x;
#line 521
::exit(___);}
#if 0
#line 516
{ 
#line 517
uint4 v = __utexfetchi(t, make_int4(x, 0, 0, 0)); 
#line 518
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 520
return make_float4(w.x, w.y, w.z, w.w); 
#line 521
} 
#endif
#line 529 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1D(texture< char, 1, cudaReadModeElementType>  t, float x) 
#line 530
{int volatile ___ = 1;(void)t;(void)x;
#line 538 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 530 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 534 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 537 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 538
} 
#endif
#line 540 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1D(texture< signed char, 1, cudaReadModeElementType>  t, float x) 
#line 541
{int volatile ___ = 1;(void)t;(void)x;
#line 545
::exit(___);}
#if 0
#line 541
{ 
#line 542
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 544
return (signed char)(v.x); 
#line 545
} 
#endif
#line 547 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1D(texture< unsigned char, 1, cudaReadModeElementType>  t, float x) 
#line 548
{int volatile ___ = 1;(void)t;(void)x;
#line 552
::exit(___);}
#if 0
#line 548
{ 
#line 549
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 551
return (unsigned char)(v.x); 
#line 552
} 
#endif
#line 554 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1D(texture< char1, 1, cudaReadModeElementType>  t, float x) 
#line 555
{int volatile ___ = 1;(void)t;(void)x;
#line 559
::exit(___);}
#if 0
#line 555
{ 
#line 556
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 558
return make_char1(v.x); 
#line 559
} 
#endif
#line 561 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1D(texture< uchar1, 1, cudaReadModeElementType>  t, float x) 
#line 562
{int volatile ___ = 1;(void)t;(void)x;
#line 566
::exit(___);}
#if 0
#line 562
{ 
#line 563
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 565
return make_uchar1(v.x); 
#line 566
} 
#endif
#line 568 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1D(texture< char2, 1, cudaReadModeElementType>  t, float x) 
#line 569
{int volatile ___ = 1;(void)t;(void)x;
#line 573
::exit(___);}
#if 0
#line 569
{ 
#line 570
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 572
return make_char2(v.x, v.y); 
#line 573
} 
#endif
#line 575 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1D(texture< uchar2, 1, cudaReadModeElementType>  t, float x) 
#line 576
{int volatile ___ = 1;(void)t;(void)x;
#line 580
::exit(___);}
#if 0
#line 576
{ 
#line 577
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 579
return make_uchar2(v.x, v.y); 
#line 580
} 
#endif
#line 582 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1D(texture< char4, 1, cudaReadModeElementType>  t, float x) 
#line 583
{int volatile ___ = 1;(void)t;(void)x;
#line 587
::exit(___);}
#if 0
#line 583
{ 
#line 584
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 586
return make_char4(v.x, v.y, v.z, v.w); 
#line 587
} 
#endif
#line 589 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1D(texture< uchar4, 1, cudaReadModeElementType>  t, float x) 
#line 590
{int volatile ___ = 1;(void)t;(void)x;
#line 594
::exit(___);}
#if 0
#line 590
{ 
#line 591
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 593
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 594
} 
#endif
#line 602 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1D(texture< short, 1, cudaReadModeElementType>  t, float x) 
#line 603
{int volatile ___ = 1;(void)t;(void)x;
#line 607
::exit(___);}
#if 0
#line 603
{ 
#line 604
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 606
return (short)(v.x); 
#line 607
} 
#endif
#line 609 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1D(texture< unsigned short, 1, cudaReadModeElementType>  t, float x) 
#line 610
{int volatile ___ = 1;(void)t;(void)x;
#line 614
::exit(___);}
#if 0
#line 610
{ 
#line 611
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 613
return (unsigned short)(v.x); 
#line 614
} 
#endif
#line 616 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1D(texture< short1, 1, cudaReadModeElementType>  t, float x) 
#line 617
{int volatile ___ = 1;(void)t;(void)x;
#line 621
::exit(___);}
#if 0
#line 617
{ 
#line 618
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 620
return make_short1(v.x); 
#line 621
} 
#endif
#line 623 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1D(texture< ushort1, 1, cudaReadModeElementType>  t, float x) 
#line 624
{int volatile ___ = 1;(void)t;(void)x;
#line 628
::exit(___);}
#if 0
#line 624
{ 
#line 625
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 627
return make_ushort1(v.x); 
#line 628
} 
#endif
#line 630 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1D(texture< short2, 1, cudaReadModeElementType>  t, float x) 
#line 631
{int volatile ___ = 1;(void)t;(void)x;
#line 635
::exit(___);}
#if 0
#line 631
{ 
#line 632
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 634
return make_short2(v.x, v.y); 
#line 635
} 
#endif
#line 637 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1D(texture< ushort2, 1, cudaReadModeElementType>  t, float x) 
#line 638
{int volatile ___ = 1;(void)t;(void)x;
#line 642
::exit(___);}
#if 0
#line 638
{ 
#line 639
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 641
return make_ushort2(v.x, v.y); 
#line 642
} 
#endif
#line 644 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1D(texture< short4, 1, cudaReadModeElementType>  t, float x) 
#line 645
{int volatile ___ = 1;(void)t;(void)x;
#line 649
::exit(___);}
#if 0
#line 645
{ 
#line 646
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 648
return make_short4(v.x, v.y, v.z, v.w); 
#line 649
} 
#endif
#line 651 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1D(texture< ushort4, 1, cudaReadModeElementType>  t, float x) 
#line 652
{int volatile ___ = 1;(void)t;(void)x;
#line 656
::exit(___);}
#if 0
#line 652
{ 
#line 653
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 655
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 656
} 
#endif
#line 664 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1D(texture< int, 1, cudaReadModeElementType>  t, float x) 
#line 665
{int volatile ___ = 1;(void)t;(void)x;
#line 669
::exit(___);}
#if 0
#line 665
{ 
#line 666
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 668
return v.x; 
#line 669
} 
#endif
#line 671 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1D(texture< unsigned, 1, cudaReadModeElementType>  t, float x) 
#line 672
{int volatile ___ = 1;(void)t;(void)x;
#line 676
::exit(___);}
#if 0
#line 672
{ 
#line 673
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 675
return v.x; 
#line 676
} 
#endif
#line 678 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1D(texture< int1, 1, cudaReadModeElementType>  t, float x) 
#line 679
{int volatile ___ = 1;(void)t;(void)x;
#line 683
::exit(___);}
#if 0
#line 679
{ 
#line 680
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 682
return make_int1(v.x); 
#line 683
} 
#endif
#line 685 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1D(texture< uint1, 1, cudaReadModeElementType>  t, float x) 
#line 686
{int volatile ___ = 1;(void)t;(void)x;
#line 690
::exit(___);}
#if 0
#line 686
{ 
#line 687
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 689
return make_uint1(v.x); 
#line 690
} 
#endif
#line 692 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1D(texture< int2, 1, cudaReadModeElementType>  t, float x) 
#line 693
{int volatile ___ = 1;(void)t;(void)x;
#line 697
::exit(___);}
#if 0
#line 693
{ 
#line 694
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 696
return make_int2(v.x, v.y); 
#line 697
} 
#endif
#line 699 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1D(texture< uint2, 1, cudaReadModeElementType>  t, float x) 
#line 700
{int volatile ___ = 1;(void)t;(void)x;
#line 704
::exit(___);}
#if 0
#line 700
{ 
#line 701
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 703
return make_uint2(v.x, v.y); 
#line 704
} 
#endif
#line 706 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1D(texture< int4, 1, cudaReadModeElementType>  t, float x) 
#line 707
{int volatile ___ = 1;(void)t;(void)x;
#line 711
::exit(___);}
#if 0
#line 707
{ 
#line 708
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 710
return make_int4(v.x, v.y, v.z, v.w); 
#line 711
} 
#endif
#line 713 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1D(texture< uint4, 1, cudaReadModeElementType>  t, float x) 
#line 714
{int volatile ___ = 1;(void)t;(void)x;
#line 718
::exit(___);}
#if 0
#line 714
{ 
#line 715
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 717
return make_uint4(v.x, v.y, v.z, v.w); 
#line 718
} 
#endif
#line 734 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1D(texture< long, 1, cudaReadModeElementType>  t, float x) 
#line 735
{int volatile ___ = 1;(void)t;(void)x;
#line 739
::exit(___);}
#if 0
#line 735
{ 
#line 736
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 738
return (long)(v.x); 
#line 739
} 
#endif
#line 741 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1D(texture< unsigned long, 1, cudaReadModeElementType>  t, float x) 
#line 742
{int volatile ___ = 1;(void)t;(void)x;
#line 746
::exit(___);}
#if 0
#line 742
{ 
#line 743
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 745
return (unsigned long)(v.x); 
#line 746
} 
#endif
#line 748 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1D(texture< long1, 1, cudaReadModeElementType>  t, float x) 
#line 749
{int volatile ___ = 1;(void)t;(void)x;
#line 753
::exit(___);}
#if 0
#line 749
{ 
#line 750
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 752
return make_long1(v.x); 
#line 753
} 
#endif
#line 755 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1D(texture< ulong1, 1, cudaReadModeElementType>  t, float x) 
#line 756
{int volatile ___ = 1;(void)t;(void)x;
#line 760
::exit(___);}
#if 0
#line 756
{ 
#line 757
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 759
return make_ulong1(v.x); 
#line 760
} 
#endif
#line 762 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1D(texture< long2, 1, cudaReadModeElementType>  t, float x) 
#line 763
{int volatile ___ = 1;(void)t;(void)x;
#line 767
::exit(___);}
#if 0
#line 763
{ 
#line 764
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 766
return make_long2(v.x, v.y); 
#line 767
} 
#endif
#line 769 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1D(texture< ulong2, 1, cudaReadModeElementType>  t, float x) 
#line 770
{int volatile ___ = 1;(void)t;(void)x;
#line 774
::exit(___);}
#if 0
#line 770
{ 
#line 771
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 773
return make_ulong2(v.x, v.y); 
#line 774
} 
#endif
#line 776 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1D(texture< long4, 1, cudaReadModeElementType>  t, float x) 
#line 777
{int volatile ___ = 1;(void)t;(void)x;
#line 781
::exit(___);}
#if 0
#line 777
{ 
#line 778
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 780
return make_long4(v.x, v.y, v.z, v.w); 
#line 781
} 
#endif
#line 783 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1D(texture< ulong4, 1, cudaReadModeElementType>  t, float x) 
#line 784
{int volatile ___ = 1;(void)t;(void)x;
#line 788
::exit(___);}
#if 0
#line 784
{ 
#line 785
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 787
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 788
} 
#endif
#line 798 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1D(texture< float, 1, cudaReadModeElementType>  t, float x) 
#line 799
{int volatile ___ = 1;(void)t;(void)x;
#line 803
::exit(___);}
#if 0
#line 799
{ 
#line 800
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 802
return v.x; 
#line 803
} 
#endif
#line 805 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1D(texture< float1, 1, cudaReadModeElementType>  t, float x) 
#line 806
{int volatile ___ = 1;(void)t;(void)x;
#line 810
::exit(___);}
#if 0
#line 806
{ 
#line 807
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 809
return make_float1(v.x); 
#line 810
} 
#endif
#line 812 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1D(texture< float2, 1, cudaReadModeElementType>  t, float x) 
#line 813
{int volatile ___ = 1;(void)t;(void)x;
#line 817
::exit(___);}
#if 0
#line 813
{ 
#line 814
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 816
return make_float2(v.x, v.y); 
#line 817
} 
#endif
#line 819 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1D(texture< float4, 1, cudaReadModeElementType>  t, float x) 
#line 820
{int volatile ___ = 1;(void)t;(void)x;
#line 824
::exit(___);}
#if 0
#line 820
{ 
#line 821
float4 v = __ftexfetch(t, make_float4(x, 0, 0, 0)); 
#line 823
return make_float4(v.x, v.y, v.z, v.w); 
#line 824
} 
#endif
#line 832 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1D(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 833
{int volatile ___ = 1;(void)t;(void)x;
#line 842 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 833 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 837 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 839 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 841
return w.x; 
#line 842
} 
#endif
#line 844 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1D(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 845
{int volatile ___ = 1;(void)t;(void)x;
#line 850
::exit(___);}
#if 0
#line 845
{ 
#line 846
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 849
return w.x; 
#line 850
} 
#endif
#line 852 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1D(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 853
{int volatile ___ = 1;(void)t;(void)x;
#line 858
::exit(___);}
#if 0
#line 853
{ 
#line 854
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 857
return w.x; 
#line 858
} 
#endif
#line 860 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1D(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 861
{int volatile ___ = 1;(void)t;(void)x;
#line 866
::exit(___);}
#if 0
#line 861
{ 
#line 862
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 865
return make_float1(w.x); 
#line 866
} 
#endif
#line 868 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1D(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 869
{int volatile ___ = 1;(void)t;(void)x;
#line 874
::exit(___);}
#if 0
#line 869
{ 
#line 870
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 873
return make_float1(w.x); 
#line 874
} 
#endif
#line 876 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1D(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 877
{int volatile ___ = 1;(void)t;(void)x;
#line 882
::exit(___);}
#if 0
#line 877
{ 
#line 878
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 879
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 881
return make_float2(w.x, w.y); 
#line 882
} 
#endif
#line 884 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1D(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 885
{int volatile ___ = 1;(void)t;(void)x;
#line 890
::exit(___);}
#if 0
#line 885
{ 
#line 886
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 887
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 889
return make_float2(w.x, w.y); 
#line 890
} 
#endif
#line 892 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1D(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 893
{int volatile ___ = 1;(void)t;(void)x;
#line 898
::exit(___);}
#if 0
#line 893
{ 
#line 894
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 895
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 897
return make_float4(w.x, w.y, w.z, w.w); 
#line 898
} 
#endif
#line 900 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1D(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 901
{int volatile ___ = 1;(void)t;(void)x;
#line 906
::exit(___);}
#if 0
#line 901
{ 
#line 902
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 903
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 905
return make_float4(w.x, w.y, w.z, w.w); 
#line 906
} 
#endif
#line 914 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1D(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 915
{int volatile ___ = 1;(void)t;(void)x;
#line 920
::exit(___);}
#if 0
#line 915
{ 
#line 916
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 917
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 919
return w.x; 
#line 920
} 
#endif
#line 922 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1D(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 923
{int volatile ___ = 1;(void)t;(void)x;
#line 928
::exit(___);}
#if 0
#line 923
{ 
#line 924
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 925
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 927
return w.x; 
#line 928
} 
#endif
#line 930 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1D(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 931
{int volatile ___ = 1;(void)t;(void)x;
#line 936
::exit(___);}
#if 0
#line 931
{ 
#line 932
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 933
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 935
return make_float1(w.x); 
#line 936
} 
#endif
#line 938 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1D(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 939
{int volatile ___ = 1;(void)t;(void)x;
#line 944
::exit(___);}
#if 0
#line 939
{ 
#line 940
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 941
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 943
return make_float1(w.x); 
#line 944
} 
#endif
#line 946 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1D(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 947
{int volatile ___ = 1;(void)t;(void)x;
#line 952
::exit(___);}
#if 0
#line 947
{ 
#line 948
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 949
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 951
return make_float2(w.x, w.y); 
#line 952
} 
#endif
#line 954 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1D(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 955
{int volatile ___ = 1;(void)t;(void)x;
#line 960
::exit(___);}
#if 0
#line 955
{ 
#line 956
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 957
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 959
return make_float2(w.x, w.y); 
#line 960
} 
#endif
#line 962 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1D(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 963
{int volatile ___ = 1;(void)t;(void)x;
#line 968
::exit(___);}
#if 0
#line 963
{ 
#line 964
int4 v = __itexfetch(t, make_float4(x, 0, 0, 0)); 
#line 965
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 967
return make_float4(w.x, w.y, w.z, w.w); 
#line 968
} 
#endif
#line 970 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1D(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x) 
#line 971
{int volatile ___ = 1;(void)t;(void)x;
#line 976
::exit(___);}
#if 0
#line 971
{ 
#line 972
uint4 v = __utexfetch(t, make_float4(x, 0, 0, 0)); 
#line 973
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 975
return make_float4(w.x, w.y, w.z, w.w); 
#line 976
} 
#endif
#line 984 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex2D(texture< char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 985
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 993 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 985 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 989 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 992 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 993
} 
#endif
#line 995 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex2D(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 996
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1000
::exit(___);}
#if 0
#line 996
{ 
#line 997
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 999
return (signed char)(v.x); 
#line 1000
} 
#endif
#line 1002 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex2D(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1003
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1007
::exit(___);}
#if 0
#line 1003
{ 
#line 1004
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1006
return (unsigned char)(v.x); 
#line 1007
} 
#endif
#line 1009 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex2D(texture< char1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1010
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1014
::exit(___);}
#if 0
#line 1010
{ 
#line 1011
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1013
return make_char1(v.x); 
#line 1014
} 
#endif
#line 1016 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex2D(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1017
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1021
::exit(___);}
#if 0
#line 1017
{ 
#line 1018
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1020
return make_uchar1(v.x); 
#line 1021
} 
#endif
#line 1023 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex2D(texture< char2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1024
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1028
::exit(___);}
#if 0
#line 1024
{ 
#line 1025
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1027
return make_char2(v.x, v.y); 
#line 1028
} 
#endif
#line 1030 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex2D(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1031
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1035
::exit(___);}
#if 0
#line 1031
{ 
#line 1032
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1034
return make_uchar2(v.x, v.y); 
#line 1035
} 
#endif
#line 1037 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2D(texture< char4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1038
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1042
::exit(___);}
#if 0
#line 1038
{ 
#line 1039
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1041
return make_char4(v.x, v.y, v.z, v.w); 
#line 1042
} 
#endif
#line 1044 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2D(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1045
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1049
::exit(___);}
#if 0
#line 1045
{ 
#line 1046
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1048
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1049
} 
#endif
#line 1057 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex2D(texture< short, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1058
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1062
::exit(___);}
#if 0
#line 1058
{ 
#line 1059
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1061
return (short)(v.x); 
#line 1062
} 
#endif
#line 1064 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex2D(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1065
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1069
::exit(___);}
#if 0
#line 1065
{ 
#line 1066
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1068
return (unsigned short)(v.x); 
#line 1069
} 
#endif
#line 1071 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex2D(texture< short1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1072
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1076
::exit(___);}
#if 0
#line 1072
{ 
#line 1073
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1075
return make_short1(v.x); 
#line 1076
} 
#endif
#line 1078 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex2D(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1079
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1083
::exit(___);}
#if 0
#line 1079
{ 
#line 1080
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1082
return make_ushort1(v.x); 
#line 1083
} 
#endif
#line 1085 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex2D(texture< short2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1086
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1090
::exit(___);}
#if 0
#line 1086
{ 
#line 1087
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1089
return make_short2(v.x, v.y); 
#line 1090
} 
#endif
#line 1092 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex2D(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1093
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1097
::exit(___);}
#if 0
#line 1093
{ 
#line 1094
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1096
return make_ushort2(v.x, v.y); 
#line 1097
} 
#endif
#line 1099 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2D(texture< short4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1100
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1104
::exit(___);}
#if 0
#line 1100
{ 
#line 1101
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1103
return make_short4(v.x, v.y, v.z, v.w); 
#line 1104
} 
#endif
#line 1106 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2D(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1107
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1111
::exit(___);}
#if 0
#line 1107
{ 
#line 1108
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1110
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 1111
} 
#endif
#line 1119 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex2D(texture< int, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1120
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1124
::exit(___);}
#if 0
#line 1120
{ 
#line 1121
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1123
return v.x; 
#line 1124
} 
#endif
#line 1126 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex2D(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1127
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1131
::exit(___);}
#if 0
#line 1127
{ 
#line 1128
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1130
return v.x; 
#line 1131
} 
#endif
#line 1133 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex2D(texture< int1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1134
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1138
::exit(___);}
#if 0
#line 1134
{ 
#line 1135
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1137
return make_int1(v.x); 
#line 1138
} 
#endif
#line 1140 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex2D(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1141
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1145
::exit(___);}
#if 0
#line 1141
{ 
#line 1142
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1144
return make_uint1(v.x); 
#line 1145
} 
#endif
#line 1147 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex2D(texture< int2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1148
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1152
::exit(___);}
#if 0
#line 1148
{ 
#line 1149
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1151
return make_int2(v.x, v.y); 
#line 1152
} 
#endif
#line 1154 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex2D(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1155
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1159
::exit(___);}
#if 0
#line 1155
{ 
#line 1156
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1158
return make_uint2(v.x, v.y); 
#line 1159
} 
#endif
#line 1161 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2D(texture< int4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1162
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1166
::exit(___);}
#if 0
#line 1162
{ 
#line 1163
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1165
return make_int4(v.x, v.y, v.z, v.w); 
#line 1166
} 
#endif
#line 1168 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2D(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1169
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1173
::exit(___);}
#if 0
#line 1169
{ 
#line 1170
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1172
return make_uint4(v.x, v.y, v.z, v.w); 
#line 1173
} 
#endif
#line 1183 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex2D(texture< long, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1184
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1188
::exit(___);}
#if 0
#line 1184
{ 
#line 1185
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1187
return (long)(v.x); 
#line 1188
} 
#endif
#line 1190 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex2D(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1191
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1195
::exit(___);}
#if 0
#line 1191
{ 
#line 1192
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1194
return (unsigned long)(v.x); 
#line 1195
} 
#endif
#line 1197 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex2D(texture< long1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1198
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1202
::exit(___);}
#if 0
#line 1198
{ 
#line 1199
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1201
return make_long1(v.x); 
#line 1202
} 
#endif
#line 1204 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex2D(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1205
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1209
::exit(___);}
#if 0
#line 1205
{ 
#line 1206
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1208
return make_ulong1(v.x); 
#line 1209
} 
#endif
#line 1211 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex2D(texture< long2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1212
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1216
::exit(___);}
#if 0
#line 1212
{ 
#line 1213
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1215
return make_long2(v.x, v.y); 
#line 1216
} 
#endif
#line 1218 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex2D(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1219
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1223
::exit(___);}
#if 0
#line 1219
{ 
#line 1220
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1222
return make_ulong2(v.x, v.y); 
#line 1223
} 
#endif
#line 1225 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex2D(texture< long4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1226
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1230
::exit(___);}
#if 0
#line 1226
{ 
#line 1227
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1229
return make_long4(v.x, v.y, v.z, v.w); 
#line 1230
} 
#endif
#line 1232 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex2D(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1233
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1237
::exit(___);}
#if 0
#line 1233
{ 
#line 1234
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1236
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 1237
} 
#endif
#line 1247 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2D(texture< float, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1248
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1252
::exit(___);}
#if 0
#line 1248
{ 
#line 1249
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1251
return v.x; 
#line 1252
} 
#endif
#line 1254 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2D(texture< float1, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1255
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1259
::exit(___);}
#if 0
#line 1255
{ 
#line 1256
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1258
return make_float1(v.x); 
#line 1259
} 
#endif
#line 1261 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2D(texture< float2, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1262
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1266
::exit(___);}
#if 0
#line 1262
{ 
#line 1263
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1265
return make_float2(v.x, v.y); 
#line 1266
} 
#endif
#line 1268 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2D(texture< float4, 2, cudaReadModeElementType>  t, float x, float y) 
#line 1269
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1273
::exit(___);}
#if 0
#line 1269
{ 
#line 1270
float4 v = __ftexfetch(t, make_float4(x, y, 0, 0)); 
#line 1272
return make_float4(v.x, v.y, v.z, v.w); 
#line 1273
} 
#endif
#line 1281 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2D(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1282
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1291 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 1282 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 1286 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1288 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1290
return w.x; 
#line 1291
} 
#endif
#line 1293 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2D(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1294
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1299
::exit(___);}
#if 0
#line 1294
{ 
#line 1295
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1298
return w.x; 
#line 1299
} 
#endif
#line 1301 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2D(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1302
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1307
::exit(___);}
#if 0
#line 1302
{ 
#line 1303
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1306
return w.x; 
#line 1307
} 
#endif
#line 1309 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2D(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1310
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1315
::exit(___);}
#if 0
#line 1310
{ 
#line 1311
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1314
return make_float1(w.x); 
#line 1315
} 
#endif
#line 1317 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2D(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1318
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1323
::exit(___);}
#if 0
#line 1318
{ 
#line 1319
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1322
return make_float1(w.x); 
#line 1323
} 
#endif
#line 1325 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2D(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1326
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1331
::exit(___);}
#if 0
#line 1326
{ 
#line 1327
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1328
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1330
return make_float2(w.x, w.y); 
#line 1331
} 
#endif
#line 1333 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2D(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1334
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1339
::exit(___);}
#if 0
#line 1334
{ 
#line 1335
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1336
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1338
return make_float2(w.x, w.y); 
#line 1339
} 
#endif
#line 1341 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2D(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1342
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1347
::exit(___);}
#if 0
#line 1342
{ 
#line 1343
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1344
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1346
return make_float4(w.x, w.y, w.z, w.w); 
#line 1347
} 
#endif
#line 1349 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2D(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1350
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1355
::exit(___);}
#if 0
#line 1350
{ 
#line 1351
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1352
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1354
return make_float4(w.x, w.y, w.z, w.w); 
#line 1355
} 
#endif
#line 1363 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2D(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1364
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1369
::exit(___);}
#if 0
#line 1364
{ 
#line 1365
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1366
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1368
return w.x; 
#line 1369
} 
#endif
#line 1371 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2D(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1372
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1377
::exit(___);}
#if 0
#line 1372
{ 
#line 1373
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1374
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1376
return w.x; 
#line 1377
} 
#endif
#line 1379 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2D(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1380
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1385
::exit(___);}
#if 0
#line 1380
{ 
#line 1381
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1382
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1384
return make_float1(w.x); 
#line 1385
} 
#endif
#line 1387 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2D(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1388
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1393
::exit(___);}
#if 0
#line 1388
{ 
#line 1389
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1390
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1392
return make_float1(w.x); 
#line 1393
} 
#endif
#line 1395 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2D(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1396
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1401
::exit(___);}
#if 0
#line 1396
{ 
#line 1397
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1398
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1400
return make_float2(w.x, w.y); 
#line 1401
} 
#endif
#line 1403 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2D(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1404
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1409
::exit(___);}
#if 0
#line 1404
{ 
#line 1405
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1406
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1408
return make_float2(w.x, w.y); 
#line 1409
} 
#endif
#line 1411 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2D(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1412
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1417
::exit(___);}
#if 0
#line 1412
{ 
#line 1413
int4 v = __itexfetch(t, make_float4(x, y, 0, 0)); 
#line 1414
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1416
return make_float4(w.x, w.y, w.z, w.w); 
#line 1417
} 
#endif
#line 1419 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2D(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y) 
#line 1420
{int volatile ___ = 1;(void)t;(void)x;(void)y;
#line 1425
::exit(___);}
#if 0
#line 1420
{ 
#line 1421
uint4 v = __utexfetch(t, make_float4(x, y, 0, 0)); 
#line 1422
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1424
return make_float4(w.x, w.y, w.z, w.w); 
#line 1425
} 
#endif
#line 1433 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1DLayered(texture< char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1434
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1442 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 1434 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 1438 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1441 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 1442
} 
#endif
#line 1444 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1DLayered(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1445
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1449
::exit(___);}
#if 0
#line 1445
{ 
#line 1446
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1448
return (signed char)(v.x); 
#line 1449
} 
#endif
#line 1451 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1DLayered(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1452
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1456
::exit(___);}
#if 0
#line 1452
{ 
#line 1453
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1455
return (unsigned char)(v.x); 
#line 1456
} 
#endif
#line 1458 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1DLayered(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1459
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1463
::exit(___);}
#if 0
#line 1459
{ 
#line 1460
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1462
return make_char1(v.x); 
#line 1463
} 
#endif
#line 1465 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1DLayered(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1466
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1470
::exit(___);}
#if 0
#line 1466
{ 
#line 1467
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1469
return make_uchar1(v.x); 
#line 1470
} 
#endif
#line 1472 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1DLayered(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1473
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1477
::exit(___);}
#if 0
#line 1473
{ 
#line 1474
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1476
return make_char2(v.x, v.y); 
#line 1477
} 
#endif
#line 1479 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1DLayered(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1480
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1484
::exit(___);}
#if 0
#line 1480
{ 
#line 1481
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1483
return make_uchar2(v.x, v.y); 
#line 1484
} 
#endif
#line 1486 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1DLayered(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1487
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1491
::exit(___);}
#if 0
#line 1487
{ 
#line 1488
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1490
return make_char4(v.x, v.y, v.z, v.w); 
#line 1491
} 
#endif
#line 1493 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1DLayered(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1494
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1498
::exit(___);}
#if 0
#line 1494
{ 
#line 1495
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1497
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1498
} 
#endif
#line 1506 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1DLayered(texture< short, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1507
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1511
::exit(___);}
#if 0
#line 1507
{ 
#line 1508
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1510
return (short)(v.x); 
#line 1511
} 
#endif
#line 1513 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1DLayered(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1514
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1518
::exit(___);}
#if 0
#line 1514
{ 
#line 1515
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1517
return (unsigned short)(v.x); 
#line 1518
} 
#endif
#line 1520 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1DLayered(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1521
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1525
::exit(___);}
#if 0
#line 1521
{ 
#line 1522
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1524
return make_short1(v.x); 
#line 1525
} 
#endif
#line 1527 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1DLayered(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1528
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1532
::exit(___);}
#if 0
#line 1528
{ 
#line 1529
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1531
return make_ushort1(v.x); 
#line 1532
} 
#endif
#line 1534 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1DLayered(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1535
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1539
::exit(___);}
#if 0
#line 1535
{ 
#line 1536
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1538
return make_short2(v.x, v.y); 
#line 1539
} 
#endif
#line 1541 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1DLayered(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1542
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1546
::exit(___);}
#if 0
#line 1542
{ 
#line 1543
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1545
return make_ushort2(v.x, v.y); 
#line 1546
} 
#endif
#line 1548 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1DLayered(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1549
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1553
::exit(___);}
#if 0
#line 1549
{ 
#line 1550
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1552
return make_short4(v.x, v.y, v.z, v.w); 
#line 1553
} 
#endif
#line 1555 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1DLayered(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1556
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1560
::exit(___);}
#if 0
#line 1556
{ 
#line 1557
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1559
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 1560
} 
#endif
#line 1568 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1DLayered(texture< int, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1569
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1573
::exit(___);}
#if 0
#line 1569
{ 
#line 1570
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1572
return v.x; 
#line 1573
} 
#endif
#line 1575 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1DLayered(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1576
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1580
::exit(___);}
#if 0
#line 1576
{ 
#line 1577
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1579
return v.x; 
#line 1580
} 
#endif
#line 1582 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1DLayered(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1583
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1587
::exit(___);}
#if 0
#line 1583
{ 
#line 1584
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1586
return make_int1(v.x); 
#line 1587
} 
#endif
#line 1589 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1DLayered(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1590
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1594
::exit(___);}
#if 0
#line 1590
{ 
#line 1591
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1593
return make_uint1(v.x); 
#line 1594
} 
#endif
#line 1596 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1DLayered(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1597
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1601
::exit(___);}
#if 0
#line 1597
{ 
#line 1598
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1600
return make_int2(v.x, v.y); 
#line 1601
} 
#endif
#line 1603 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1DLayered(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1604
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1608
::exit(___);}
#if 0
#line 1604
{ 
#line 1605
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1607
return make_uint2(v.x, v.y); 
#line 1608
} 
#endif
#line 1610 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1DLayered(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1611
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1615
::exit(___);}
#if 0
#line 1611
{ 
#line 1612
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1614
return make_int4(v.x, v.y, v.z, v.w); 
#line 1615
} 
#endif
#line 1617 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1DLayered(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1618
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1622
::exit(___);}
#if 0
#line 1618
{ 
#line 1619
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1621
return make_uint4(v.x, v.y, v.z, v.w); 
#line 1622
} 
#endif
#line 1632 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1DLayered(texture< long, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1633
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1637
::exit(___);}
#if 0
#line 1633
{ 
#line 1634
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1636
return (long)(v.x); 
#line 1637
} 
#endif
#line 1639 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1DLayered(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1640
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1644
::exit(___);}
#if 0
#line 1640
{ 
#line 1641
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1643
return (unsigned long)(v.x); 
#line 1644
} 
#endif
#line 1646 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1DLayered(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1647
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1651
::exit(___);}
#if 0
#line 1647
{ 
#line 1648
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1650
return make_long1(v.x); 
#line 1651
} 
#endif
#line 1653 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1DLayered(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1654
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1658
::exit(___);}
#if 0
#line 1654
{ 
#line 1655
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1657
return make_ulong1(v.x); 
#line 1658
} 
#endif
#line 1660 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1DLayered(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1661
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1665
::exit(___);}
#if 0
#line 1661
{ 
#line 1662
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1664
return make_long2(v.x, v.y); 
#line 1665
} 
#endif
#line 1667 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1DLayered(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1668
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1672
::exit(___);}
#if 0
#line 1668
{ 
#line 1669
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1671
return make_ulong2(v.x, v.y); 
#line 1672
} 
#endif
#line 1674 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1DLayered(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1675
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1679
::exit(___);}
#if 0
#line 1675
{ 
#line 1676
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1678
return make_long4(v.x, v.y, v.z, v.w); 
#line 1679
} 
#endif
#line 1681 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1DLayered(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1682
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1686
::exit(___);}
#if 0
#line 1682
{ 
#line 1683
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1685
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 1686
} 
#endif
#line 1696 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayered(texture< float, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1697
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1701
::exit(___);}
#if 0
#line 1697
{ 
#line 1698
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1700
return v.x; 
#line 1701
} 
#endif
#line 1703 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayered(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1704
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1708
::exit(___);}
#if 0
#line 1704
{ 
#line 1705
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1707
return make_float1(v.x); 
#line 1708
} 
#endif
#line 1710 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayered(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1711
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1715
::exit(___);}
#if 0
#line 1711
{ 
#line 1712
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1714
return make_float2(v.x, v.y); 
#line 1715
} 
#endif
#line 1717 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayered(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer) 
#line 1718
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1722
::exit(___);}
#if 0
#line 1718
{ 
#line 1719
float4 v = __ftexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1721
return make_float4(v.x, v.y, v.z, v.w); 
#line 1722
} 
#endif
#line 1730 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayered(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1731
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1740 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 1731 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 1735 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1737 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1739
return w.x; 
#line 1740
} 
#endif
#line 1742 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayered(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1743
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1748
::exit(___);}
#if 0
#line 1743
{ 
#line 1744
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1747
return w.x; 
#line 1748
} 
#endif
#line 1750 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayered(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1751
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1756
::exit(___);}
#if 0
#line 1751
{ 
#line 1752
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1755
return w.x; 
#line 1756
} 
#endif
#line 1758 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayered(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1759
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1764
::exit(___);}
#if 0
#line 1759
{ 
#line 1760
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1763
return make_float1(w.x); 
#line 1764
} 
#endif
#line 1766 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayered(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1767
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1772
::exit(___);}
#if 0
#line 1767
{ 
#line 1768
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1771
return make_float1(w.x); 
#line 1772
} 
#endif
#line 1774 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayered(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1775
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1780
::exit(___);}
#if 0
#line 1775
{ 
#line 1776
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1777
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1779
return make_float2(w.x, w.y); 
#line 1780
} 
#endif
#line 1782 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayered(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1783
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1788
::exit(___);}
#if 0
#line 1783
{ 
#line 1784
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1785
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1787
return make_float2(w.x, w.y); 
#line 1788
} 
#endif
#line 1790 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayered(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1791
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1796
::exit(___);}
#if 0
#line 1791
{ 
#line 1792
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1793
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1795
return make_float4(w.x, w.y, w.z, w.w); 
#line 1796
} 
#endif
#line 1798 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayered(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1799
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1804
::exit(___);}
#if 0
#line 1799
{ 
#line 1800
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1801
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1803
return make_float4(w.x, w.y, w.z, w.w); 
#line 1804
} 
#endif
#line 1812 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayered(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1813
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1818
::exit(___);}
#if 0
#line 1813
{ 
#line 1814
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1815
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1817
return w.x; 
#line 1818
} 
#endif
#line 1820 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayered(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1821
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1826
::exit(___);}
#if 0
#line 1821
{ 
#line 1822
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1823
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1825
return w.x; 
#line 1826
} 
#endif
#line 1828 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayered(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1829
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1834
::exit(___);}
#if 0
#line 1829
{ 
#line 1830
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1831
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1833
return make_float1(w.x); 
#line 1834
} 
#endif
#line 1836 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayered(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1837
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1842
::exit(___);}
#if 0
#line 1837
{ 
#line 1838
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1839
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1841
return make_float1(w.x); 
#line 1842
} 
#endif
#line 1844 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayered(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1845
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1850
::exit(___);}
#if 0
#line 1845
{ 
#line 1846
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1847
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1849
return make_float2(w.x, w.y); 
#line 1850
} 
#endif
#line 1852 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayered(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1853
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1858
::exit(___);}
#if 0
#line 1853
{ 
#line 1854
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1855
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1857
return make_float2(w.x, w.y); 
#line 1858
} 
#endif
#line 1860 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayered(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1861
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1866
::exit(___);}
#if 0
#line 1861
{ 
#line 1862
int4 v = __itexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1863
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1865
return make_float4(w.x, w.y, w.z, w.w); 
#line 1866
} 
#endif
#line 1868 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayered(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer) 
#line 1869
{int volatile ___ = 1;(void)t;(void)x;(void)layer;
#line 1874
::exit(___);}
#if 0
#line 1869
{ 
#line 1870
uint4 v = __utexfetchl(t, make_float4(x, 0, 0, 0), layer); 
#line 1871
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 1873
return make_float4(w.x, w.y, w.z, w.w); 
#line 1874
} 
#endif
#line 1882 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex2DLayered(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1891 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 1883 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 1887 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1890 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 1891
} 
#endif
#line 1893 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex2DLayered(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1894
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1898
::exit(___);}
#if 0
#line 1894
{ 
#line 1895
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1897
return (signed char)(v.x); 
#line 1898
} 
#endif
#line 1900 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex2DLayered(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1901
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1905
::exit(___);}
#if 0
#line 1901
{ 
#line 1902
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1904
return (unsigned char)(v.x); 
#line 1905
} 
#endif
#line 1907 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex2DLayered(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1908
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1912
::exit(___);}
#if 0
#line 1908
{ 
#line 1909
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1911
return make_char1(v.x); 
#line 1912
} 
#endif
#line 1914 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex2DLayered(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1915
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1919
::exit(___);}
#if 0
#line 1915
{ 
#line 1916
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1918
return make_uchar1(v.x); 
#line 1919
} 
#endif
#line 1921 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex2DLayered(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1922
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1926
::exit(___);}
#if 0
#line 1922
{ 
#line 1923
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1925
return make_char2(v.x, v.y); 
#line 1926
} 
#endif
#line 1928 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex2DLayered(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1929
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1933
::exit(___);}
#if 0
#line 1929
{ 
#line 1930
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1932
return make_uchar2(v.x, v.y); 
#line 1933
} 
#endif
#line 1935 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2DLayered(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1936
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1940
::exit(___);}
#if 0
#line 1936
{ 
#line 1937
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1939
return make_char4(v.x, v.y, v.z, v.w); 
#line 1940
} 
#endif
#line 1942 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2DLayered(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1943
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1947
::exit(___);}
#if 0
#line 1943
{ 
#line 1944
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1946
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 1947
} 
#endif
#line 1955 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex2DLayered(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1956
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1960
::exit(___);}
#if 0
#line 1956
{ 
#line 1957
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1959
return (short)(v.x); 
#line 1960
} 
#endif
#line 1962 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex2DLayered(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1963
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1967
::exit(___);}
#if 0
#line 1963
{ 
#line 1964
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1966
return (unsigned short)(v.x); 
#line 1967
} 
#endif
#line 1969 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex2DLayered(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1970
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1974
::exit(___);}
#if 0
#line 1970
{ 
#line 1971
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1973
return make_short1(v.x); 
#line 1974
} 
#endif
#line 1976 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex2DLayered(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1977
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1981
::exit(___);}
#if 0
#line 1977
{ 
#line 1978
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1980
return make_ushort1(v.x); 
#line 1981
} 
#endif
#line 1983 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex2DLayered(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1984
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1988
::exit(___);}
#if 0
#line 1984
{ 
#line 1985
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1987
return make_short2(v.x, v.y); 
#line 1988
} 
#endif
#line 1990 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex2DLayered(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 1995
::exit(___);}
#if 0
#line 1991
{ 
#line 1992
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 1994
return make_ushort2(v.x, v.y); 
#line 1995
} 
#endif
#line 1997 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2DLayered(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 1998
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2002
::exit(___);}
#if 0
#line 1998
{ 
#line 1999
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2001
return make_short4(v.x, v.y, v.z, v.w); 
#line 2002
} 
#endif
#line 2004 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2DLayered(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2009
::exit(___);}
#if 0
#line 2005
{ 
#line 2006
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2008
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2009
} 
#endif
#line 2017 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex2DLayered(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2018
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2022
::exit(___);}
#if 0
#line 2018
{ 
#line 2019
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2021
return v.x; 
#line 2022
} 
#endif
#line 2024 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex2DLayered(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2029
::exit(___);}
#if 0
#line 2025
{ 
#line 2026
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2028
return v.x; 
#line 2029
} 
#endif
#line 2031 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex2DLayered(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2032
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2036
::exit(___);}
#if 0
#line 2032
{ 
#line 2033
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2035
return make_int1(v.x); 
#line 2036
} 
#endif
#line 2038 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex2DLayered(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2039
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2043
::exit(___);}
#if 0
#line 2039
{ 
#line 2040
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2042
return make_uint1(v.x); 
#line 2043
} 
#endif
#line 2045 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex2DLayered(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2046
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2050
::exit(___);}
#if 0
#line 2046
{ 
#line 2047
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2049
return make_int2(v.x, v.y); 
#line 2050
} 
#endif
#line 2052 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex2DLayered(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2053
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2057
::exit(___);}
#if 0
#line 2053
{ 
#line 2054
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2056
return make_uint2(v.x, v.y); 
#line 2057
} 
#endif
#line 2059 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2DLayered(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2060
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2064
::exit(___);}
#if 0
#line 2060
{ 
#line 2061
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2063
return make_int4(v.x, v.y, v.z, v.w); 
#line 2064
} 
#endif
#line 2066 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2DLayered(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2067
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2071
::exit(___);}
#if 0
#line 2067
{ 
#line 2068
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2070
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2071
} 
#endif
#line 2081 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex2DLayered(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2082
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2086
::exit(___);}
#if 0
#line 2082
{ 
#line 2083
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2085
return (long)(v.x); 
#line 2086
} 
#endif
#line 2088 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex2DLayered(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2089
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2093
::exit(___);}
#if 0
#line 2089
{ 
#line 2090
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2092
return (unsigned long)(v.x); 
#line 2093
} 
#endif
#line 2095 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex2DLayered(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2096
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2100
::exit(___);}
#if 0
#line 2096
{ 
#line 2097
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2099
return make_long1(v.x); 
#line 2100
} 
#endif
#line 2102 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex2DLayered(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2103
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2107
::exit(___);}
#if 0
#line 2103
{ 
#line 2104
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2106
return make_ulong1(v.x); 
#line 2107
} 
#endif
#line 2109 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex2DLayered(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2110
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2114
::exit(___);}
#if 0
#line 2110
{ 
#line 2111
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2113
return make_long2(v.x, v.y); 
#line 2114
} 
#endif
#line 2116 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex2DLayered(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2117
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2121
::exit(___);}
#if 0
#line 2117
{ 
#line 2118
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2120
return make_ulong2(v.x, v.y); 
#line 2121
} 
#endif
#line 2123 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex2DLayered(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2124
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2128
::exit(___);}
#if 0
#line 2124
{ 
#line 2125
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2127
return make_long4(v.x, v.y, v.z, v.w); 
#line 2128
} 
#endif
#line 2130 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex2DLayered(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2131
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2135
::exit(___);}
#if 0
#line 2131
{ 
#line 2132
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2134
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 2135
} 
#endif
#line 2145 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayered(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2150
::exit(___);}
#if 0
#line 2146
{ 
#line 2147
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2149
return v.x; 
#line 2150
} 
#endif
#line 2152 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayered(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2153
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2157
::exit(___);}
#if 0
#line 2153
{ 
#line 2154
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2156
return make_float1(v.x); 
#line 2157
} 
#endif
#line 2159 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayered(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2160
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2164
::exit(___);}
#if 0
#line 2160
{ 
#line 2161
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2163
return make_float2(v.x, v.y); 
#line 2164
} 
#endif
#line 2166 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayered(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer) 
#line 2167
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2171
::exit(___);}
#if 0
#line 2167
{ 
#line 2168
float4 v = __ftexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2170
return make_float4(v.x, v.y, v.z, v.w); 
#line 2171
} 
#endif
#line 2179 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayered(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2180
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2189 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 2180 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 2184 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2186 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2188
return w.x; 
#line 2189
} 
#endif
#line 2191 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayered(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2197
::exit(___);}
#if 0
#line 2192
{ 
#line 2193
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2196
return w.x; 
#line 2197
} 
#endif
#line 2199 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayered(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2205
::exit(___);}
#if 0
#line 2200
{ 
#line 2201
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2204
return w.x; 
#line 2205
} 
#endif
#line 2207 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayered(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2213
::exit(___);}
#if 0
#line 2208
{ 
#line 2209
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2212
return make_float1(w.x); 
#line 2213
} 
#endif
#line 2215 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayered(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2221
::exit(___);}
#if 0
#line 2216
{ 
#line 2217
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2220
return make_float1(w.x); 
#line 2221
} 
#endif
#line 2223 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayered(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2224
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2229
::exit(___);}
#if 0
#line 2224
{ 
#line 2225
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2226
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2228
return make_float2(w.x, w.y); 
#line 2229
} 
#endif
#line 2231 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayered(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2232
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2237
::exit(___);}
#if 0
#line 2232
{ 
#line 2233
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2234
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2236
return make_float2(w.x, w.y); 
#line 2237
} 
#endif
#line 2239 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayered(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2240
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2245
::exit(___);}
#if 0
#line 2240
{ 
#line 2241
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2242
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2244
return make_float4(w.x, w.y, w.z, w.w); 
#line 2245
} 
#endif
#line 2247 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayered(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2253
::exit(___);}
#if 0
#line 2248
{ 
#line 2249
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2250
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2252
return make_float4(w.x, w.y, w.z, w.w); 
#line 2253
} 
#endif
#line 2261 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayered(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2262
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2267
::exit(___);}
#if 0
#line 2262
{ 
#line 2263
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2264
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2266
return w.x; 
#line 2267
} 
#endif
#line 2269 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayered(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2270
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2275
::exit(___);}
#if 0
#line 2270
{ 
#line 2271
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2272
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2274
return w.x; 
#line 2275
} 
#endif
#line 2277 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayered(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2278
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2283
::exit(___);}
#if 0
#line 2278
{ 
#line 2279
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2280
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2282
return make_float1(w.x); 
#line 2283
} 
#endif
#line 2285 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayered(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2286
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2291
::exit(___);}
#if 0
#line 2286
{ 
#line 2287
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2288
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2290
return make_float1(w.x); 
#line 2291
} 
#endif
#line 2293 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayered(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2294
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2299
::exit(___);}
#if 0
#line 2294
{ 
#line 2295
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2296
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2298
return make_float2(w.x, w.y); 
#line 2299
} 
#endif
#line 2301 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayered(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2302
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2307
::exit(___);}
#if 0
#line 2302
{ 
#line 2303
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2304
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2306
return make_float2(w.x, w.y); 
#line 2307
} 
#endif
#line 2309 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayered(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2315
::exit(___);}
#if 0
#line 2310
{ 
#line 2311
int4 v = __itexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2312
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2314
return make_float4(w.x, w.y, w.z, w.w); 
#line 2315
} 
#endif
#line 2317 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayered(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer) 
#line 2318
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;
#line 2323
::exit(___);}
#if 0
#line 2318
{ 
#line 2319
uint4 v = __utexfetchl(t, make_float4(x, y, 0, 0), layer); 
#line 2320
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2322
return make_float4(w.x, w.y, w.z, w.w); 
#line 2323
} 
#endif
#line 2331 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex3D(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2332
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2340 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 2332 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 2336 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2339 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 2340
} 
#endif
#line 2342 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex3D(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2343
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2347
::exit(___);}
#if 0
#line 2343
{ 
#line 2344
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2346
return (signed char)(v.x); 
#line 2347
} 
#endif
#line 2349 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex3D(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2350
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2354
::exit(___);}
#if 0
#line 2350
{ 
#line 2351
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2353
return (unsigned char)(v.x); 
#line 2354
} 
#endif
#line 2356 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex3D(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2357
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2361
::exit(___);}
#if 0
#line 2357
{ 
#line 2358
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2360
return make_char1(v.x); 
#line 2361
} 
#endif
#line 2363 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex3D(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2364
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2368
::exit(___);}
#if 0
#line 2364
{ 
#line 2365
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2367
return make_uchar1(v.x); 
#line 2368
} 
#endif
#line 2370 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex3D(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2371
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2375
::exit(___);}
#if 0
#line 2371
{ 
#line 2372
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2374
return make_char2(v.x, v.y); 
#line 2375
} 
#endif
#line 2377 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex3D(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2378
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2382
::exit(___);}
#if 0
#line 2378
{ 
#line 2379
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2381
return make_uchar2(v.x, v.y); 
#line 2382
} 
#endif
#line 2384 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex3D(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2385
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2389
::exit(___);}
#if 0
#line 2385
{ 
#line 2386
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2388
return make_char4(v.x, v.y, v.z, v.w); 
#line 2389
} 
#endif
#line 2391 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex3D(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2392
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2396
::exit(___);}
#if 0
#line 2392
{ 
#line 2393
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2395
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 2396
} 
#endif
#line 2404 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex3D(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2405
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2409
::exit(___);}
#if 0
#line 2405
{ 
#line 2406
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2408
return (short)(v.x); 
#line 2409
} 
#endif
#line 2411 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex3D(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2412
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2416
::exit(___);}
#if 0
#line 2412
{ 
#line 2413
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2415
return (unsigned short)(v.x); 
#line 2416
} 
#endif
#line 2418 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex3D(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2419
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2423
::exit(___);}
#if 0
#line 2419
{ 
#line 2420
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2422
return make_short1(v.x); 
#line 2423
} 
#endif
#line 2425 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex3D(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2426
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2430
::exit(___);}
#if 0
#line 2426
{ 
#line 2427
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2429
return make_ushort1(v.x); 
#line 2430
} 
#endif
#line 2432 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex3D(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2433
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2437
::exit(___);}
#if 0
#line 2433
{ 
#line 2434
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2436
return make_short2(v.x, v.y); 
#line 2437
} 
#endif
#line 2439 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex3D(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2440
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2444
::exit(___);}
#if 0
#line 2440
{ 
#line 2441
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2443
return make_ushort2(v.x, v.y); 
#line 2444
} 
#endif
#line 2446 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex3D(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2447
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2451
::exit(___);}
#if 0
#line 2447
{ 
#line 2448
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2450
return make_short4(v.x, v.y, v.z, v.w); 
#line 2451
} 
#endif
#line 2453 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex3D(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2454
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2458
::exit(___);}
#if 0
#line 2454
{ 
#line 2455
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2457
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2458
} 
#endif
#line 2466 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex3D(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2467
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2471
::exit(___);}
#if 0
#line 2467
{ 
#line 2468
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2470
return v.x; 
#line 2471
} 
#endif
#line 2473 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex3D(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2474
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2478
::exit(___);}
#if 0
#line 2474
{ 
#line 2475
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2477
return v.x; 
#line 2478
} 
#endif
#line 2480 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex3D(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2481
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2485
::exit(___);}
#if 0
#line 2481
{ 
#line 2482
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2484
return make_int1(v.x); 
#line 2485
} 
#endif
#line 2487 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex3D(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2488
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2492
::exit(___);}
#if 0
#line 2488
{ 
#line 2489
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2491
return make_uint1(v.x); 
#line 2492
} 
#endif
#line 2494 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex3D(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2499
::exit(___);}
#if 0
#line 2495
{ 
#line 2496
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2498
return make_int2(v.x, v.y); 
#line 2499
} 
#endif
#line 2501 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex3D(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2502
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2506
::exit(___);}
#if 0
#line 2502
{ 
#line 2503
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2505
return make_uint2(v.x, v.y); 
#line 2506
} 
#endif
#line 2508 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex3D(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2513
::exit(___);}
#if 0
#line 2509
{ 
#line 2510
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2512
return make_int4(v.x, v.y, v.z, v.w); 
#line 2513
} 
#endif
#line 2515 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex3D(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2520
::exit(___);}
#if 0
#line 2516
{ 
#line 2517
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2519
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2520
} 
#endif
#line 2530 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex3D(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2535
::exit(___);}
#if 0
#line 2531
{ 
#line 2532
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2534
return (long)(v.x); 
#line 2535
} 
#endif
#line 2537 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex3D(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2538
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2542
::exit(___);}
#if 0
#line 2538
{ 
#line 2539
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2541
return (unsigned long)(v.x); 
#line 2542
} 
#endif
#line 2544 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex3D(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2545
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2549
::exit(___);}
#if 0
#line 2545
{ 
#line 2546
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2548
return make_long1(v.x); 
#line 2549
} 
#endif
#line 2551 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex3D(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2552
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2556
::exit(___);}
#if 0
#line 2552
{ 
#line 2553
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2555
return make_ulong1(v.x); 
#line 2556
} 
#endif
#line 2558 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex3D(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2559
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2563
::exit(___);}
#if 0
#line 2559
{ 
#line 2560
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2562
return make_long2(v.x, v.y); 
#line 2563
} 
#endif
#line 2565 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex3D(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2566
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2570
::exit(___);}
#if 0
#line 2566
{ 
#line 2567
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2569
return make_ulong2(v.x, v.y); 
#line 2570
} 
#endif
#line 2572 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex3D(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2573
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2577
::exit(___);}
#if 0
#line 2573
{ 
#line 2574
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2576
return make_long4(v.x, v.y, v.z, v.w); 
#line 2577
} 
#endif
#line 2579 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex3D(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2580
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2584
::exit(___);}
#if 0
#line 2580
{ 
#line 2581
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2583
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 2584
} 
#endif
#line 2594 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3D(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2599
::exit(___);}
#if 0
#line 2595
{ 
#line 2596
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2598
return v.x; 
#line 2599
} 
#endif
#line 2601 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3D(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2602
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2606
::exit(___);}
#if 0
#line 2602
{ 
#line 2603
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2605
return make_float1(v.x); 
#line 2606
} 
#endif
#line 2608 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3D(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2609
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2613
::exit(___);}
#if 0
#line 2609
{ 
#line 2610
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2612
return make_float2(v.x, v.y); 
#line 2613
} 
#endif
#line 2615 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3D(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2616
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2620
::exit(___);}
#if 0
#line 2616
{ 
#line 2617
float4 v = __ftexfetch(t, make_float4(x, y, z, 0)); 
#line 2619
return make_float4(v.x, v.y, v.z, v.w); 
#line 2620
} 
#endif
#line 2628 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3D(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2629
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2638 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 2629 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 2633 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2635 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2637
return w.x; 
#line 2638
} 
#endif
#line 2640 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3D(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2646
::exit(___);}
#if 0
#line 2641
{ 
#line 2642
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2645
return w.x; 
#line 2646
} 
#endif
#line 2648 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3D(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2654
::exit(___);}
#if 0
#line 2649
{ 
#line 2650
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2653
return w.x; 
#line 2654
} 
#endif
#line 2656 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3D(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2662
::exit(___);}
#if 0
#line 2657
{ 
#line 2658
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2661
return make_float1(w.x); 
#line 2662
} 
#endif
#line 2664 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3D(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2670
::exit(___);}
#if 0
#line 2665
{ 
#line 2666
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2669
return make_float1(w.x); 
#line 2670
} 
#endif
#line 2672 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3D(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2678
::exit(___);}
#if 0
#line 2673
{ 
#line 2674
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2675
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2677
return make_float2(w.x, w.y); 
#line 2678
} 
#endif
#line 2680 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3D(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2686
::exit(___);}
#if 0
#line 2681
{ 
#line 2682
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2683
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2685
return make_float2(w.x, w.y); 
#line 2686
} 
#endif
#line 2688 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3D(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2689
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2694
::exit(___);}
#if 0
#line 2689
{ 
#line 2690
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2691
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2693
return make_float4(w.x, w.y, w.z, w.w); 
#line 2694
} 
#endif
#line 2696 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3D(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2697
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2702
::exit(___);}
#if 0
#line 2697
{ 
#line 2698
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2699
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2701
return make_float4(w.x, w.y, w.z, w.w); 
#line 2702
} 
#endif
#line 2710 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3D(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2711
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2716
::exit(___);}
#if 0
#line 2711
{ 
#line 2712
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2713
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2715
return w.x; 
#line 2716
} 
#endif
#line 2718 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3D(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2724
::exit(___);}
#if 0
#line 2719
{ 
#line 2720
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2721
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2723
return w.x; 
#line 2724
} 
#endif
#line 2726 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3D(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2727
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2732
::exit(___);}
#if 0
#line 2727
{ 
#line 2728
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2729
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2731
return make_float1(w.x); 
#line 2732
} 
#endif
#line 2734 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3D(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2740
::exit(___);}
#if 0
#line 2735
{ 
#line 2736
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2737
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2739
return make_float1(w.x); 
#line 2740
} 
#endif
#line 2742 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3D(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2743
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2748
::exit(___);}
#if 0
#line 2743
{ 
#line 2744
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2745
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2747
return make_float2(w.x, w.y); 
#line 2748
} 
#endif
#line 2750 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3D(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2751
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2756
::exit(___);}
#if 0
#line 2751
{ 
#line 2752
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2753
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2755
return make_float2(w.x, w.y); 
#line 2756
} 
#endif
#line 2758 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3D(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2764
::exit(___);}
#if 0
#line 2759
{ 
#line 2760
int4 v = __itexfetch(t, make_float4(x, y, z, 0)); 
#line 2761
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2763
return make_float4(w.x, w.y, w.z, w.w); 
#line 2764
} 
#endif
#line 2766 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3D(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 2767
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2772
::exit(___);}
#if 0
#line 2767
{ 
#line 2768
uint4 v = __utexfetch(t, make_float4(x, y, z, 0)); 
#line 2769
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 2771
return make_float4(w.x, w.y, w.z, w.w); 
#line 2772
} 
#endif
#line 2780 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char texCubemap(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2781
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2789 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 2781 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 2785 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2788 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 2789
} 
#endif
#line 2791 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char texCubemap(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2792
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2796
::exit(___);}
#if 0
#line 2792
{ 
#line 2793
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2795
return (signed char)(v.x); 
#line 2796
} 
#endif
#line 2798 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char texCubemap(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2799
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2803
::exit(___);}
#if 0
#line 2799
{ 
#line 2800
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2802
return (unsigned char)(v.x); 
#line 2803
} 
#endif
#line 2805 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 texCubemap(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2806
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2810
::exit(___);}
#if 0
#line 2806
{ 
#line 2807
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2809
return make_char1(v.x); 
#line 2810
} 
#endif
#line 2812 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 texCubemap(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2813
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2817
::exit(___);}
#if 0
#line 2813
{ 
#line 2814
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2816
return make_uchar1(v.x); 
#line 2817
} 
#endif
#line 2819 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 texCubemap(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2820
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2824
::exit(___);}
#if 0
#line 2820
{ 
#line 2821
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2823
return make_char2(v.x, v.y); 
#line 2824
} 
#endif
#line 2826 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 texCubemap(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2827
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2831
::exit(___);}
#if 0
#line 2827
{ 
#line 2828
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2830
return make_uchar2(v.x, v.y); 
#line 2831
} 
#endif
#line 2833 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 texCubemap(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2834
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2838
::exit(___);}
#if 0
#line 2834
{ 
#line 2835
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2837
return make_char4(v.x, v.y, v.z, v.w); 
#line 2838
} 
#endif
#line 2840 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 texCubemap(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2841
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2845
::exit(___);}
#if 0
#line 2841
{ 
#line 2842
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2844
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 2845
} 
#endif
#line 2853 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short texCubemap(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2854
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2858
::exit(___);}
#if 0
#line 2854
{ 
#line 2855
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2857
return (short)(v.x); 
#line 2858
} 
#endif
#line 2860 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short texCubemap(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2861
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2865
::exit(___);}
#if 0
#line 2861
{ 
#line 2862
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2864
return (unsigned short)(v.x); 
#line 2865
} 
#endif
#line 2867 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 texCubemap(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2872
::exit(___);}
#if 0
#line 2868
{ 
#line 2869
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2871
return make_short1(v.x); 
#line 2872
} 
#endif
#line 2874 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 texCubemap(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2875
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2879
::exit(___);}
#if 0
#line 2875
{ 
#line 2876
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2878
return make_ushort1(v.x); 
#line 2879
} 
#endif
#line 2881 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 texCubemap(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2882
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2886
::exit(___);}
#if 0
#line 2882
{ 
#line 2883
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2885
return make_short2(v.x, v.y); 
#line 2886
} 
#endif
#line 2888 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 texCubemap(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2889
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2893
::exit(___);}
#if 0
#line 2889
{ 
#line 2890
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2892
return make_ushort2(v.x, v.y); 
#line 2893
} 
#endif
#line 2895 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 texCubemap(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2896
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2900
::exit(___);}
#if 0
#line 2896
{ 
#line 2897
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2899
return make_short4(v.x, v.y, v.z, v.w); 
#line 2900
} 
#endif
#line 2902 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 texCubemap(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2903
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2907
::exit(___);}
#if 0
#line 2903
{ 
#line 2904
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2906
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 2907
} 
#endif
#line 2915 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int texCubemap(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2916
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2920
::exit(___);}
#if 0
#line 2916
{ 
#line 2917
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2919
return v.x; 
#line 2920
} 
#endif
#line 2922 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned texCubemap(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2923
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2927
::exit(___);}
#if 0
#line 2923
{ 
#line 2924
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2926
return v.x; 
#line 2927
} 
#endif
#line 2929 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 texCubemap(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2930
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2934
::exit(___);}
#if 0
#line 2930
{ 
#line 2931
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2933
return make_int1(v.x); 
#line 2934
} 
#endif
#line 2936 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 texCubemap(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2937
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2941
::exit(___);}
#if 0
#line 2937
{ 
#line 2938
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2940
return make_uint1(v.x); 
#line 2941
} 
#endif
#line 2943 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 texCubemap(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2944
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2948
::exit(___);}
#if 0
#line 2944
{ 
#line 2945
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2947
return make_int2(v.x, v.y); 
#line 2948
} 
#endif
#line 2950 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 texCubemap(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2951
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2955
::exit(___);}
#if 0
#line 2951
{ 
#line 2952
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2954
return make_uint2(v.x, v.y); 
#line 2955
} 
#endif
#line 2957 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 texCubemap(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2958
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2962
::exit(___);}
#if 0
#line 2958
{ 
#line 2959
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2961
return make_int4(v.x, v.y, v.z, v.w); 
#line 2962
} 
#endif
#line 2964 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 texCubemap(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2965
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2969
::exit(___);}
#if 0
#line 2965
{ 
#line 2966
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2968
return make_uint4(v.x, v.y, v.z, v.w); 
#line 2969
} 
#endif
#line 2979 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long texCubemap(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2980
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2984
::exit(___);}
#if 0
#line 2980
{ 
#line 2981
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2983
return (long)(v.x); 
#line 2984
} 
#endif
#line 2986 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long texCubemap(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2987
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2991
::exit(___);}
#if 0
#line 2987
{ 
#line 2988
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 2990
return (unsigned long)(v.x); 
#line 2991
} 
#endif
#line 2993 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 texCubemap(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 2994
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 2998
::exit(___);}
#if 0
#line 2994
{ 
#line 2995
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 2997
return make_long1(v.x); 
#line 2998
} 
#endif
#line 3000 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 texCubemap(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3001
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3005
::exit(___);}
#if 0
#line 3001
{ 
#line 3002
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3004
return make_ulong1(v.x); 
#line 3005
} 
#endif
#line 3007 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 texCubemap(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3008
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3012
::exit(___);}
#if 0
#line 3008
{ 
#line 3009
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3011
return make_long2(v.x, v.y); 
#line 3012
} 
#endif
#line 3014 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 texCubemap(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3015
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3019
::exit(___);}
#if 0
#line 3015
{ 
#line 3016
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3018
return make_ulong2(v.x, v.y); 
#line 3019
} 
#endif
#line 3021 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 texCubemap(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3022
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3026
::exit(___);}
#if 0
#line 3022
{ 
#line 3023
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3025
return make_long4(v.x, v.y, v.z, v.w); 
#line 3026
} 
#endif
#line 3028 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 texCubemap(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3029
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3033
::exit(___);}
#if 0
#line 3029
{ 
#line 3030
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3032
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 3033
} 
#endif
#line 3043 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemap(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3044
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3048
::exit(___);}
#if 0
#line 3044
{ 
#line 3045
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3047
return v.x; 
#line 3048
} 
#endif
#line 3050 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemap(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3051
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3055
::exit(___);}
#if 0
#line 3051
{ 
#line 3052
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3054
return make_float1(v.x); 
#line 3055
} 
#endif
#line 3057 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemap(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3058
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3062
::exit(___);}
#if 0
#line 3058
{ 
#line 3059
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3061
return make_float2(v.x, v.y); 
#line 3062
} 
#endif
#line 3064 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemap(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z) 
#line 3065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3069
::exit(___);}
#if 0
#line 3065
{ 
#line 3066
float4 v = __ftexfetchc(t, make_float4(x, y, z, 0)); 
#line 3068
return make_float4(v.x, v.y, v.z, v.w); 
#line 3069
} 
#endif
#line 3077 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemap(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3078
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3087 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 3078 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 3082 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3084 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3086
return w.x; 
#line 3087
} 
#endif
#line 3089 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemap(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3090
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3095
::exit(___);}
#if 0
#line 3090
{ 
#line 3091
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3092
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3094
return w.x; 
#line 3095
} 
#endif
#line 3097 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemap(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3098
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3103
::exit(___);}
#if 0
#line 3098
{ 
#line 3099
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3100
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3102
return w.x; 
#line 3103
} 
#endif
#line 3105 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemap(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3106
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3111
::exit(___);}
#if 0
#line 3106
{ 
#line 3107
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3108
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3110
return make_float1(w.x); 
#line 3111
} 
#endif
#line 3113 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemap(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3114
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3119
::exit(___);}
#if 0
#line 3114
{ 
#line 3115
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3116
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3118
return make_float1(w.x); 
#line 3119
} 
#endif
#line 3121 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemap(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3122
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3127
::exit(___);}
#if 0
#line 3122
{ 
#line 3123
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3124
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3126
return make_float2(w.x, w.y); 
#line 3127
} 
#endif
#line 3129 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemap(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3135
::exit(___);}
#if 0
#line 3130
{ 
#line 3131
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3132
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3134
return make_float2(w.x, w.y); 
#line 3135
} 
#endif
#line 3137 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemap(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3138
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3143
::exit(___);}
#if 0
#line 3138
{ 
#line 3139
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3140
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3142
return make_float4(w.x, w.y, w.z, w.w); 
#line 3143
} 
#endif
#line 3145 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemap(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3146
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3151
::exit(___);}
#if 0
#line 3146
{ 
#line 3147
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3148
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3150
return make_float4(w.x, w.y, w.z, w.w); 
#line 3151
} 
#endif
#line 3159 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemap(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3160
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3165
::exit(___);}
#if 0
#line 3160
{ 
#line 3161
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3162
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3164
return w.x; 
#line 3165
} 
#endif
#line 3167 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemap(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3168
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3173
::exit(___);}
#if 0
#line 3168
{ 
#line 3169
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3170
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3172
return w.x; 
#line 3173
} 
#endif
#line 3175 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemap(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3176
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3181
::exit(___);}
#if 0
#line 3176
{ 
#line 3177
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3178
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3180
return make_float1(w.x); 
#line 3181
} 
#endif
#line 3183 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemap(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3184
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3189
::exit(___);}
#if 0
#line 3184
{ 
#line 3185
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3186
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3188
return make_float1(w.x); 
#line 3189
} 
#endif
#line 3191 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemap(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3192
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3197
::exit(___);}
#if 0
#line 3192
{ 
#line 3193
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3194
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3196
return make_float2(w.x, w.y); 
#line 3197
} 
#endif
#line 3199 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemap(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3200
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3205
::exit(___);}
#if 0
#line 3200
{ 
#line 3201
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3202
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3204
return make_float2(w.x, w.y); 
#line 3205
} 
#endif
#line 3207 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemap(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3213
::exit(___);}
#if 0
#line 3208
{ 
#line 3209
int4 v = __itexfetchc(t, make_float4(x, y, z, 0)); 
#line 3210
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3212
return make_float4(w.x, w.y, w.z, w.w); 
#line 3213
} 
#endif
#line 3215 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemap(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z) 
#line 3216
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;
#line 3221
::exit(___);}
#if 0
#line 3216
{ 
#line 3217
uint4 v = __utexfetchc(t, make_float4(x, y, z, 0)); 
#line 3218
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3220
return make_float4(w.x, w.y, w.z, w.w); 
#line 3221
} 
#endif
#line 3229 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char texCubemapLayered(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3230
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3238 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 3230 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 3234 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3237 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 3238
} 
#endif
#line 3240 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char texCubemapLayered(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3241
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3245
::exit(___);}
#if 0
#line 3241
{ 
#line 3242
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3244
return (signed char)(v.x); 
#line 3245
} 
#endif
#line 3247 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char texCubemapLayered(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3248
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3252
::exit(___);}
#if 0
#line 3248
{ 
#line 3249
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3251
return (unsigned char)(v.x); 
#line 3252
} 
#endif
#line 3254 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 texCubemapLayered(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3255
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3259
::exit(___);}
#if 0
#line 3255
{ 
#line 3256
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3258
return make_char1(v.x); 
#line 3259
} 
#endif
#line 3261 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 texCubemapLayered(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3262
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3266
::exit(___);}
#if 0
#line 3262
{ 
#line 3263
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3265
return make_uchar1(v.x); 
#line 3266
} 
#endif
#line 3268 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 texCubemapLayered(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3269
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3273
::exit(___);}
#if 0
#line 3269
{ 
#line 3270
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3272
return make_char2(v.x, v.y); 
#line 3273
} 
#endif
#line 3275 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 texCubemapLayered(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3276
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3280
::exit(___);}
#if 0
#line 3276
{ 
#line 3277
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3279
return make_uchar2(v.x, v.y); 
#line 3280
} 
#endif
#line 3282 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 texCubemapLayered(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3283
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3287
::exit(___);}
#if 0
#line 3283
{ 
#line 3284
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3286
return make_char4(v.x, v.y, v.z, v.w); 
#line 3287
} 
#endif
#line 3289 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 texCubemapLayered(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3290
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3294
::exit(___);}
#if 0
#line 3290
{ 
#line 3291
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3293
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 3294
} 
#endif
#line 3302 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short texCubemapLayered(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3303
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3307
::exit(___);}
#if 0
#line 3303
{ 
#line 3304
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3306
return (short)(v.x); 
#line 3307
} 
#endif
#line 3309 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short texCubemapLayered(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3310
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3314
::exit(___);}
#if 0
#line 3310
{ 
#line 3311
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3313
return (unsigned short)(v.x); 
#line 3314
} 
#endif
#line 3316 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 texCubemapLayered(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3317
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3321
::exit(___);}
#if 0
#line 3317
{ 
#line 3318
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3320
return make_short1(v.x); 
#line 3321
} 
#endif
#line 3323 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 texCubemapLayered(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3324
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3328
::exit(___);}
#if 0
#line 3324
{ 
#line 3325
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3327
return make_ushort1(v.x); 
#line 3328
} 
#endif
#line 3330 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 texCubemapLayered(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3331
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3335
::exit(___);}
#if 0
#line 3331
{ 
#line 3332
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3334
return make_short2(v.x, v.y); 
#line 3335
} 
#endif
#line 3337 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 texCubemapLayered(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3338
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3342
::exit(___);}
#if 0
#line 3338
{ 
#line 3339
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3341
return make_ushort2(v.x, v.y); 
#line 3342
} 
#endif
#line 3344 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 texCubemapLayered(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3345
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3349
::exit(___);}
#if 0
#line 3345
{ 
#line 3346
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3348
return make_short4(v.x, v.y, v.z, v.w); 
#line 3349
} 
#endif
#line 3351 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 texCubemapLayered(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3352
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3356
::exit(___);}
#if 0
#line 3352
{ 
#line 3353
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3355
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 3356
} 
#endif
#line 3364 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int texCubemapLayered(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3365
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3369
::exit(___);}
#if 0
#line 3365
{ 
#line 3366
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3368
return v.x; 
#line 3369
} 
#endif
#line 3371 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned texCubemapLayered(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3372
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3376
::exit(___);}
#if 0
#line 3372
{ 
#line 3373
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3375
return v.x; 
#line 3376
} 
#endif
#line 3378 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 texCubemapLayered(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3379
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3383
::exit(___);}
#if 0
#line 3379
{ 
#line 3380
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3382
return make_int1(v.x); 
#line 3383
} 
#endif
#line 3385 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 texCubemapLayered(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3386
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3390
::exit(___);}
#if 0
#line 3386
{ 
#line 3387
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3389
return make_uint1(v.x); 
#line 3390
} 
#endif
#line 3392 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 texCubemapLayered(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3397
::exit(___);}
#if 0
#line 3393
{ 
#line 3394
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3396
return make_int2(v.x, v.y); 
#line 3397
} 
#endif
#line 3399 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 texCubemapLayered(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3400
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3404
::exit(___);}
#if 0
#line 3400
{ 
#line 3401
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3403
return make_uint2(v.x, v.y); 
#line 3404
} 
#endif
#line 3406 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 texCubemapLayered(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3407
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3411
::exit(___);}
#if 0
#line 3407
{ 
#line 3408
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3410
return make_int4(v.x, v.y, v.z, v.w); 
#line 3411
} 
#endif
#line 3413 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 texCubemapLayered(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3414
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3418
::exit(___);}
#if 0
#line 3414
{ 
#line 3415
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3417
return make_uint4(v.x, v.y, v.z, v.w); 
#line 3418
} 
#endif
#line 3428 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long texCubemapLayered(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3429
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3433
::exit(___);}
#if 0
#line 3429
{ 
#line 3430
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3432
return (long)(v.x); 
#line 3433
} 
#endif
#line 3435 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long texCubemapLayered(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3436
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3440
::exit(___);}
#if 0
#line 3436
{ 
#line 3437
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3439
return (unsigned long)(v.x); 
#line 3440
} 
#endif
#line 3442 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 texCubemapLayered(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3443
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3447
::exit(___);}
#if 0
#line 3443
{ 
#line 3444
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3446
return make_long1(v.x); 
#line 3447
} 
#endif
#line 3449 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 texCubemapLayered(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3450
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3454
::exit(___);}
#if 0
#line 3450
{ 
#line 3451
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3453
return make_ulong1(v.x); 
#line 3454
} 
#endif
#line 3456 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 texCubemapLayered(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3457
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3461
::exit(___);}
#if 0
#line 3457
{ 
#line 3458
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3460
return make_long2(v.x, v.y); 
#line 3461
} 
#endif
#line 3463 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 texCubemapLayered(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3464
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3468
::exit(___);}
#if 0
#line 3464
{ 
#line 3465
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3467
return make_ulong2(v.x, v.y); 
#line 3468
} 
#endif
#line 3470 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 texCubemapLayered(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3471
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3475
::exit(___);}
#if 0
#line 3471
{ 
#line 3472
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3474
return make_long4(v.x, v.y, v.z, v.w); 
#line 3475
} 
#endif
#line 3477 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 texCubemapLayered(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3478
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3482
::exit(___);}
#if 0
#line 3478
{ 
#line 3479
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3481
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 3482
} 
#endif
#line 3492 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayered(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3493
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3497
::exit(___);}
#if 0
#line 3493
{ 
#line 3494
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3496
return v.x; 
#line 3497
} 
#endif
#line 3499 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayered(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3500
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3504
::exit(___);}
#if 0
#line 3500
{ 
#line 3501
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3503
return make_float1(v.x); 
#line 3504
} 
#endif
#line 3506 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayered(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3507
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3511
::exit(___);}
#if 0
#line 3507
{ 
#line 3508
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3510
return make_float2(v.x, v.y); 
#line 3511
} 
#endif
#line 3513 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayered(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer) 
#line 3514
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3518
::exit(___);}
#if 0
#line 3514
{ 
#line 3515
float4 v = __ftexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3517
return make_float4(v.x, v.y, v.z, v.w); 
#line 3518
} 
#endif
#line 3526 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayered(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3527
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3536 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 3527 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 3531 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3533 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3535
return w.x; 
#line 3536
} 
#endif
#line 3538 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayered(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3539
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3544
::exit(___);}
#if 0
#line 3539
{ 
#line 3540
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3541
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3543
return w.x; 
#line 3544
} 
#endif
#line 3546 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayered(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3547
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3552
::exit(___);}
#if 0
#line 3547
{ 
#line 3548
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3549
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3551
return w.x; 
#line 3552
} 
#endif
#line 3554 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayered(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3555
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3560
::exit(___);}
#if 0
#line 3555
{ 
#line 3556
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3557
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3559
return make_float1(w.x); 
#line 3560
} 
#endif
#line 3562 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayered(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3563
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3568
::exit(___);}
#if 0
#line 3563
{ 
#line 3564
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3565
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3567
return make_float1(w.x); 
#line 3568
} 
#endif
#line 3570 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayered(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3576
::exit(___);}
#if 0
#line 3571
{ 
#line 3572
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3573
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3575
return make_float2(w.x, w.y); 
#line 3576
} 
#endif
#line 3578 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayered(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3579
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3584
::exit(___);}
#if 0
#line 3579
{ 
#line 3580
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3581
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3583
return make_float2(w.x, w.y); 
#line 3584
} 
#endif
#line 3586 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayered(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3587
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3592
::exit(___);}
#if 0
#line 3587
{ 
#line 3588
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3589
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3591
return make_float4(w.x, w.y, w.z, w.w); 
#line 3592
} 
#endif
#line 3594 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayered(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3600
::exit(___);}
#if 0
#line 3595
{ 
#line 3596
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3597
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3599
return make_float4(w.x, w.y, w.z, w.w); 
#line 3600
} 
#endif
#line 3608 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayered(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3609
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3614
::exit(___);}
#if 0
#line 3609
{ 
#line 3610
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3611
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3613
return w.x; 
#line 3614
} 
#endif
#line 3616 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayered(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3617
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3622
::exit(___);}
#if 0
#line 3617
{ 
#line 3618
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3619
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3621
return w.x; 
#line 3622
} 
#endif
#line 3624 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayered(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3625
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3630
::exit(___);}
#if 0
#line 3625
{ 
#line 3626
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3627
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3629
return make_float1(w.x); 
#line 3630
} 
#endif
#line 3632 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayered(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3638
::exit(___);}
#if 0
#line 3633
{ 
#line 3634
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3635
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3637
return make_float1(w.x); 
#line 3638
} 
#endif
#line 3640 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayered(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3641
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3646
::exit(___);}
#if 0
#line 3641
{ 
#line 3642
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3643
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3645
return make_float2(w.x, w.y); 
#line 3646
} 
#endif
#line 3648 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayered(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3649
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3654
::exit(___);}
#if 0
#line 3649
{ 
#line 3650
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3651
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3653
return make_float2(w.x, w.y); 
#line 3654
} 
#endif
#line 3656 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayered(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3657
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3662
::exit(___);}
#if 0
#line 3657
{ 
#line 3658
int4 v = __itexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3659
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3661
return make_float4(w.x, w.y, w.z, w.w); 
#line 3662
} 
#endif
#line 3664 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayered(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer) 
#line 3665
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;
#line 3670
::exit(___);}
#if 0
#line 3665
{ 
#line 3666
uint4 v = __utexfetchlc(t, make_float4(x, y, z, 0), layer); 
#line 3667
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 3669
return make_float4(w.x, w.y, w.z, w.w); 
#line 3670
} 
#endif
#line 3703 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2Dgather(texture< char, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3704
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3706
::exit(___);}
#if 0
#line 3704
{ 
#line 3705
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3706
} 
#endif
#line 3708 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2Dgather(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3709
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3711
::exit(___);}
#if 0
#line 3709
{ 
#line 3710
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3711
} 
#endif
#line 3713 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2Dgather(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3714
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3716
::exit(___);}
#if 0
#line 3714
{ 
#line 3715
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
#line 3716
} 
#endif
#line 3718 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2Dgather(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3721
::exit(___);}
#if 0
#line 3719
{ 
#line 3720
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } ; 
#line 3721
} 
#endif
#line 3723 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2Dgather(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3724
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3726
::exit(___);}
#if 0
#line 3724
{ 
#line 3725
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } ; 
#line 3726
} 
#endif
#line 3728 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2Dgather(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3729
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3731
::exit(___);}
#if 0
#line 3729
{ 
#line 3730
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  ; 
#line 3731
} 
#endif
#line 3733 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2Dgather(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3734
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3736
::exit(___);}
#if 0
#line 3734
{ 
#line 3735
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  ; 
#line 3736
} 
#endif
#line 3738 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2Dgather(texture< char3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3739
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3741
::exit(___);}
#if 0
#line 3739
{ 
#line 3740
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3741
} 
#endif
#line 3743 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2Dgather(texture< uchar3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3744
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3746
::exit(___);}
#if 0
#line 3744
{ 
#line 3745
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3746
} 
#endif
#line 3748 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2Dgather(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3749
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3751
::exit(___);}
#if 0
#line 3749
{ 
#line 3750
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_char4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3751
} 
#endif
#line 3753 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2Dgather(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3754
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3756
::exit(___);}
#if 0
#line 3754
{ 
#line 3755
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_uchar4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3756
} 
#endif
#line 3758 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2Dgather(texture< short, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3761
::exit(___);}
#if 0
#line 3759
{ 
#line 3760
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
#line 3761
} 
#endif
#line 3763 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2Dgather(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3766
::exit(___);}
#if 0
#line 3764
{ 
#line 3765
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
#line 3766
} 
#endif
#line 3768 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2Dgather(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3771
::exit(___);}
#if 0
#line 3769
{ 
#line 3770
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } ; 
#line 3771
} 
#endif
#line 3773 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2Dgather(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3774
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3776
::exit(___);}
#if 0
#line 3774
{ 
#line 3775
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } ; 
#line 3776
} 
#endif
#line 3778 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2Dgather(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3779
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3781
::exit(___);}
#if 0
#line 3779
{ 
#line 3780
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  ; 
#line 3781
} 
#endif
#line 3783 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2Dgather(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3784
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3786
::exit(___);}
#if 0
#line 3784
{ 
#line 3785
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  ; 
#line 3786
} 
#endif
#line 3788 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2Dgather(texture< short3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3789
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3791
::exit(___);}
#if 0
#line 3789
{ 
#line 3790
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3791
} 
#endif
#line 3793 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2Dgather(texture< ushort3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3794
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3796
::exit(___);}
#if 0
#line 3794
{ 
#line 3795
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  ; 
#line 3796
} 
#endif
#line 3798 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2Dgather(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3799
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3801
::exit(___);}
#if 0
#line 3799
{ 
#line 3800
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_short4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3801
} 
#endif
#line 3803 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2Dgather(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3804
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3806
::exit(___);}
#if 0
#line 3804
{ 
#line 3805
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_ushort4(v.x, v.y, v.z, v.w); }  }  }  ; 
#line 3806
} 
#endif
#line 3808 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2Dgather(texture< int, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3809
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3811
::exit(___);}
#if 0
#line 3809
{ 
#line 3810
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3811
} 
#endif
#line 3813 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2Dgather(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3814
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3816
::exit(___);}
#if 0
#line 3814
{ 
#line 3815
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3816
} 
#endif
#line 3818 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2Dgather(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3821
::exit(___);}
#if 0
#line 3819
{ 
#line 3820
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3821
} 
#endif
#line 3823 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2Dgather(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3824
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3826
::exit(___);}
#if 0
#line 3824
{ 
#line 3825
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3826
} 
#endif
#line 3828 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2Dgather(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3829
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3831
::exit(___);}
#if 0
#line 3829
{ 
#line 3830
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3831
} 
#endif
#line 3833 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2Dgather(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3834
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3836
::exit(___);}
#if 0
#line 3834
{ 
#line 3835
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3836
} 
#endif
#line 3838 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2Dgather(texture< int3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3839
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3841
::exit(___);}
#if 0
#line 3839
{ 
#line 3840
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3841
} 
#endif
#line 3843 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2Dgather(texture< uint3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3844
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3846
::exit(___);}
#if 0
#line 3844
{ 
#line 3845
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3846
} 
#endif
#line 3848 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2Dgather(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3849
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3851
::exit(___);}
#if 0
#line 3849
{ 
#line 3850
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return v; } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3851
} 
#endif
#line 3853 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2Dgather(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3854
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3856
::exit(___);}
#if 0
#line 3854
{ 
#line 3855
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return v; } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3856
} 
#endif
#line 3858 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< float, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3859
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3861
::exit(___);}
#if 0
#line 3859
{ 
#line 3860
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3861
} 
#endif
#line 3863 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3866
::exit(___);}
#if 0
#line 3864
{ 
#line 3865
{ float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; } ; 
#line 3866
} 
#endif
#line 3868 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3869
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3871
::exit(___);}
#if 0
#line 3869
{ 
#line 3870
if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  ; 
#line 3871
} 
#endif
#line 3873 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< float3, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3874
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3876
::exit(___);}
#if 0
#line 3874
{ 
#line 3875
if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  ; 
#line 3876
} 
#endif
#line 3878 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, int comp) 
#line 3879
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3881
::exit(___);}
#if 0
#line 3879
{ 
#line 3880
if (comp == 3) { float4 v = __ftex2Dgather< 3> (t, make_float2(x, y)); return v; } else { if (comp == 2) { float4 v = __ftex2Dgather< 2> (t, make_float2(x, y)); return v; } else { if (comp == 1) { float4 v = __ftex2Dgather< 1> (t, make_float2(x, y)); return v; } else { float4 v = __ftex2Dgather< 0> (t, make_float2(x, y)); return v; }  }  }  ; 
#line 3881
} 
#endif
#line 3890 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3891
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3893
::exit(___);}
#if 0
#line 3891
{ 
#line 3892
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3893
} 
#endif
#line 3895 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3896
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3898
::exit(___);}
#if 0
#line 3896
{ 
#line 3897
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3898
} 
#endif
#line 3900 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3901
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3903
::exit(___);}
#if 0
#line 3901
{ 
#line 3902
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3903
} 
#endif
#line 3905 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3906
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3908
::exit(___);}
#if 0
#line 3906
{ 
#line 3907
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3908
} 
#endif
#line 3910 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3911
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3913
::exit(___);}
#if 0
#line 3911
{ 
#line 3912
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3913
} 
#endif
#line 3915 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3916
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3918
::exit(___);}
#if 0
#line 3916
{ 
#line 3917
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 3918
} 
#endif
#line 3920 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3923
::exit(___);}
#if 0
#line 3921
{ 
#line 3922
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 3923
} 
#endif
#line 3925 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< char3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3926
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3928
::exit(___);}
#if 0
#line 3926
{ 
#line 3927
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 3928
} 
#endif
#line 3930 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< uchar3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3931
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3933
::exit(___);}
#if 0
#line 3931
{ 
#line 3932
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 3933
} 
#endif
#line 3935 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3936
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3938
::exit(___);}
#if 0
#line 3936
{ 
#line 3937
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 3938
} 
#endif
#line 3940 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3941
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3943
::exit(___);}
#if 0
#line 3941
{ 
#line 3942
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 3943
} 
#endif
#line 3945 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3948
::exit(___);}
#if 0
#line 3946
{ 
#line 3947
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3948
} 
#endif
#line 3950 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3951
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3953
::exit(___);}
#if 0
#line 3951
{ 
#line 3952
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3953
} 
#endif
#line 3955 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3956
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3958
::exit(___);}
#if 0
#line 3956
{ 
#line 3957
{ int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3958
} 
#endif
#line 3960 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3961
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3963
::exit(___);}
#if 0
#line 3961
{ 
#line 3962
{ uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } ; 
#line 3963
} 
#endif
#line 3965 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3968
::exit(___);}
#if 0
#line 3966
{ 
#line 3967
if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 3968
} 
#endif
#line 3970 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3973
::exit(___);}
#if 0
#line 3971
{ 
#line 3972
if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  ; 
#line 3973
} 
#endif
#line 3975 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< short3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3976
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3978
::exit(___);}
#if 0
#line 3976
{ 
#line 3977
if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 3978
} 
#endif
#line 3980 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< ushort3, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3981
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3983
::exit(___);}
#if 0
#line 3981
{ 
#line 3982
if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  ; 
#line 3983
} 
#endif
#line 3985 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3986
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3988
::exit(___);}
#if 0
#line 3986
{ 
#line 3987
if (comp == 3) { int4 v = __itex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { int4 v = __itex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { int4 v = __itex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { int4 v = __itex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 3988
} 
#endif
#line 3990 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2Dgather(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, int comp) 
#line 3991
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)comp;
#line 3993
::exit(___);}
#if 0
#line 3991
{ 
#line 3992
if (comp == 3) { uint4 v = __utex2Dgather< 3> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 2) { uint4 v = __utex2Dgather< 2> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { if (comp == 1) { uint4 v = __utex2Dgather< 1> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); } else { uint4 v = __utex2Dgather< 0> (t, make_float2(x, y)); return make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); }  }  }  ; 
#line 3993
} 
#endif
#line 4007 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1DLod(texture< char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4008
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4016 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 4008 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 4012 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4015 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 4016
} 
#endif
#line 4018 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1DLod(texture< signed char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4019
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4023
::exit(___);}
#if 0
#line 4019
{ 
#line 4020
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4022
return (signed char)(v.x); 
#line 4023
} 
#endif
#line 4025 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1DLod(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4026
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4030
::exit(___);}
#if 0
#line 4026
{ 
#line 4027
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4029
return (unsigned char)(v.x); 
#line 4030
} 
#endif
#line 4032 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1DLod(texture< char1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4033
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4037
::exit(___);}
#if 0
#line 4033
{ 
#line 4034
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4036
return make_char1(v.x); 
#line 4037
} 
#endif
#line 4039 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1DLod(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4040
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4044
::exit(___);}
#if 0
#line 4040
{ 
#line 4041
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4043
return make_uchar1(v.x); 
#line 4044
} 
#endif
#line 4046 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1DLod(texture< char2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4047
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4051
::exit(___);}
#if 0
#line 4047
{ 
#line 4048
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4050
return make_char2(v.x, v.y); 
#line 4051
} 
#endif
#line 4053 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1DLod(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4054
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4058
::exit(___);}
#if 0
#line 4054
{ 
#line 4055
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4057
return make_uchar2(v.x, v.y); 
#line 4058
} 
#endif
#line 4060 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1DLod(texture< char4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4061
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4065
::exit(___);}
#if 0
#line 4061
{ 
#line 4062
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4064
return make_char4(v.x, v.y, v.z, v.w); 
#line 4065
} 
#endif
#line 4067 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1DLod(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4068
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4072
::exit(___);}
#if 0
#line 4068
{ 
#line 4069
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4071
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4072
} 
#endif
#line 4080 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1DLod(texture< short, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4081
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4085
::exit(___);}
#if 0
#line 4081
{ 
#line 4082
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4084
return (short)(v.x); 
#line 4085
} 
#endif
#line 4087 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1DLod(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4088
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4092
::exit(___);}
#if 0
#line 4088
{ 
#line 4089
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4091
return (unsigned short)(v.x); 
#line 4092
} 
#endif
#line 4094 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1DLod(texture< short1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4095
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4099
::exit(___);}
#if 0
#line 4095
{ 
#line 4096
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4098
return make_short1(v.x); 
#line 4099
} 
#endif
#line 4101 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1DLod(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4102
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4106
::exit(___);}
#if 0
#line 4102
{ 
#line 4103
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4105
return make_ushort1(v.x); 
#line 4106
} 
#endif
#line 4108 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1DLod(texture< short2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4109
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4113
::exit(___);}
#if 0
#line 4109
{ 
#line 4110
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4112
return make_short2(v.x, v.y); 
#line 4113
} 
#endif
#line 4115 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1DLod(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4116
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4120
::exit(___);}
#if 0
#line 4116
{ 
#line 4117
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4119
return make_ushort2(v.x, v.y); 
#line 4120
} 
#endif
#line 4122 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1DLod(texture< short4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4123
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4127
::exit(___);}
#if 0
#line 4123
{ 
#line 4124
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4126
return make_short4(v.x, v.y, v.z, v.w); 
#line 4127
} 
#endif
#line 4129 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1DLod(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4130
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4134
::exit(___);}
#if 0
#line 4130
{ 
#line 4131
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4133
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 4134
} 
#endif
#line 4142 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1DLod(texture< int, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4143
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4147
::exit(___);}
#if 0
#line 4143
{ 
#line 4144
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4146
return v.x; 
#line 4147
} 
#endif
#line 4149 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1DLod(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4150
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4154
::exit(___);}
#if 0
#line 4150
{ 
#line 4151
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4153
return v.x; 
#line 4154
} 
#endif
#line 4156 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1DLod(texture< int1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4157
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4161
::exit(___);}
#if 0
#line 4157
{ 
#line 4158
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4160
return make_int1(v.x); 
#line 4161
} 
#endif
#line 4163 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1DLod(texture< uint1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4164
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4168
::exit(___);}
#if 0
#line 4164
{ 
#line 4165
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4167
return make_uint1(v.x); 
#line 4168
} 
#endif
#line 4170 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1DLod(texture< int2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4171
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4175
::exit(___);}
#if 0
#line 4171
{ 
#line 4172
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4174
return make_int2(v.x, v.y); 
#line 4175
} 
#endif
#line 4177 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1DLod(texture< uint2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4178
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4182
::exit(___);}
#if 0
#line 4178
{ 
#line 4179
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4181
return make_uint2(v.x, v.y); 
#line 4182
} 
#endif
#line 4184 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1DLod(texture< int4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4185
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4189
::exit(___);}
#if 0
#line 4185
{ 
#line 4186
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4188
return make_int4(v.x, v.y, v.z, v.w); 
#line 4189
} 
#endif
#line 4191 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1DLod(texture< uint4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4192
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4196
::exit(___);}
#if 0
#line 4192
{ 
#line 4193
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4195
return make_uint4(v.x, v.y, v.z, v.w); 
#line 4196
} 
#endif
#line 4212 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1DLod(texture< long, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4213
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4217
::exit(___);}
#if 0
#line 4213
{ 
#line 4214
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4216
return (long)(v.x); 
#line 4217
} 
#endif
#line 4219 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1DLod(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4220
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4224
::exit(___);}
#if 0
#line 4220
{ 
#line 4221
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4223
return (unsigned long)(v.x); 
#line 4224
} 
#endif
#line 4226 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1DLod(texture< long1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4227
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4231
::exit(___);}
#if 0
#line 4227
{ 
#line 4228
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4230
return make_long1(v.x); 
#line 4231
} 
#endif
#line 4233 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1DLod(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4234
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4238
::exit(___);}
#if 0
#line 4234
{ 
#line 4235
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4237
return make_ulong1(v.x); 
#line 4238
} 
#endif
#line 4240 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1DLod(texture< long2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4241
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4245
::exit(___);}
#if 0
#line 4241
{ 
#line 4242
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4244
return make_long2(v.x, v.y); 
#line 4245
} 
#endif
#line 4247 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1DLod(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4248
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4252
::exit(___);}
#if 0
#line 4248
{ 
#line 4249
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4251
return make_ulong2(v.x, v.y); 
#line 4252
} 
#endif
#line 4254 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1DLod(texture< long4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4255
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4259
::exit(___);}
#if 0
#line 4255
{ 
#line 4256
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4258
return make_long4(v.x, v.y, v.z, v.w); 
#line 4259
} 
#endif
#line 4261 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1DLod(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4262
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4266
::exit(___);}
#if 0
#line 4262
{ 
#line 4263
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4265
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 4266
} 
#endif
#line 4276 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLod(texture< float, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4277
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4281
::exit(___);}
#if 0
#line 4277
{ 
#line 4278
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4280
return v.x; 
#line 4281
} 
#endif
#line 4283 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLod(texture< float1, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4284
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4288
::exit(___);}
#if 0
#line 4284
{ 
#line 4285
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4287
return make_float1(v.x); 
#line 4288
} 
#endif
#line 4290 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLod(texture< float2, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4291
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4295
::exit(___);}
#if 0
#line 4291
{ 
#line 4292
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4294
return make_float2(v.x, v.y); 
#line 4295
} 
#endif
#line 4297 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLod(texture< float4, 1, cudaReadModeElementType>  t, float x, float level) 
#line 4298
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4302
::exit(___);}
#if 0
#line 4298
{ 
#line 4299
float4 v = __ftexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4301
return make_float4(v.x, v.y, v.z, v.w); 
#line 4302
} 
#endif
#line 4310 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLod(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4311
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4320 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 4311 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 4315 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4317 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4319
return w.x; 
#line 4320
} 
#endif
#line 4322 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLod(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4323
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4328
::exit(___);}
#if 0
#line 4323
{ 
#line 4324
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4325
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4327
return w.x; 
#line 4328
} 
#endif
#line 4330 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLod(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4331
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4336
::exit(___);}
#if 0
#line 4331
{ 
#line 4332
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4333
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4335
return w.x; 
#line 4336
} 
#endif
#line 4338 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLod(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4339
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4344
::exit(___);}
#if 0
#line 4339
{ 
#line 4340
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4341
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4343
return make_float1(w.x); 
#line 4344
} 
#endif
#line 4346 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLod(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4347
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4352
::exit(___);}
#if 0
#line 4347
{ 
#line 4348
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4349
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4351
return make_float1(w.x); 
#line 4352
} 
#endif
#line 4354 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLod(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4355
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4360
::exit(___);}
#if 0
#line 4355
{ 
#line 4356
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4357
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4359
return make_float2(w.x, w.y); 
#line 4360
} 
#endif
#line 4362 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLod(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4363
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4368
::exit(___);}
#if 0
#line 4363
{ 
#line 4364
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4365
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4367
return make_float2(w.x, w.y); 
#line 4368
} 
#endif
#line 4370 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLod(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4371
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4376
::exit(___);}
#if 0
#line 4371
{ 
#line 4372
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4373
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4375
return make_float4(w.x, w.y, w.z, w.w); 
#line 4376
} 
#endif
#line 4378 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLod(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4379
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4384
::exit(___);}
#if 0
#line 4379
{ 
#line 4380
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4381
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4383
return make_float4(w.x, w.y, w.z, w.w); 
#line 4384
} 
#endif
#line 4392 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLod(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4393
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4398
::exit(___);}
#if 0
#line 4393
{ 
#line 4394
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4395
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4397
return w.x; 
#line 4398
} 
#endif
#line 4400 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLod(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4401
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4406
::exit(___);}
#if 0
#line 4401
{ 
#line 4402
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4403
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4405
return w.x; 
#line 4406
} 
#endif
#line 4408 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLod(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4409
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4414
::exit(___);}
#if 0
#line 4409
{ 
#line 4410
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4411
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4413
return make_float1(w.x); 
#line 4414
} 
#endif
#line 4416 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLod(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4417
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4422
::exit(___);}
#if 0
#line 4417
{ 
#line 4418
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4419
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4421
return make_float1(w.x); 
#line 4422
} 
#endif
#line 4424 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLod(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4425
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4430
::exit(___);}
#if 0
#line 4425
{ 
#line 4426
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4427
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4429
return make_float2(w.x, w.y); 
#line 4430
} 
#endif
#line 4432 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLod(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4433
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4438
::exit(___);}
#if 0
#line 4433
{ 
#line 4434
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4435
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4437
return make_float2(w.x, w.y); 
#line 4438
} 
#endif
#line 4440 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLod(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4441
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4446
::exit(___);}
#if 0
#line 4441
{ 
#line 4442
int4 v = __itexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4445
return make_float4(w.x, w.y, w.z, w.w); 
#line 4446
} 
#endif
#line 4448 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLod(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float level) 
#line 4449
{int volatile ___ = 1;(void)t;(void)x;(void)level;
#line 4454
::exit(___);}
#if 0
#line 4449
{ 
#line 4450
uint4 v = __utexfetchlod(t, make_float4(x, 0, 0, 0), level); 
#line 4451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4453
return make_float4(w.x, w.y, w.z, w.w); 
#line 4454
} 
#endif
#line 4462 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex2DLod(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4463
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4471 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 4463 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 4467 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4470 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 4471
} 
#endif
#line 4473 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex2DLod(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4474
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4478
::exit(___);}
#if 0
#line 4474
{ 
#line 4475
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4477
return (signed char)(v.x); 
#line 4478
} 
#endif
#line 4480 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex2DLod(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4481
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4485
::exit(___);}
#if 0
#line 4481
{ 
#line 4482
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4484
return (unsigned char)(v.x); 
#line 4485
} 
#endif
#line 4487 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex2DLod(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4488
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4492
::exit(___);}
#if 0
#line 4488
{ 
#line 4489
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4491
return make_char1(v.x); 
#line 4492
} 
#endif
#line 4494 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex2DLod(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4495
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4499
::exit(___);}
#if 0
#line 4495
{ 
#line 4496
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4498
return make_uchar1(v.x); 
#line 4499
} 
#endif
#line 4501 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex2DLod(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4502
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4506
::exit(___);}
#if 0
#line 4502
{ 
#line 4503
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4505
return make_char2(v.x, v.y); 
#line 4506
} 
#endif
#line 4508 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex2DLod(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4509
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4513
::exit(___);}
#if 0
#line 4509
{ 
#line 4510
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4512
return make_uchar2(v.x, v.y); 
#line 4513
} 
#endif
#line 4515 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2DLod(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4516
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4520
::exit(___);}
#if 0
#line 4516
{ 
#line 4517
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4519
return make_char4(v.x, v.y, v.z, v.w); 
#line 4520
} 
#endif
#line 4522 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2DLod(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4523
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4527
::exit(___);}
#if 0
#line 4523
{ 
#line 4524
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4526
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4527
} 
#endif
#line 4535 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex2DLod(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4536
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4540
::exit(___);}
#if 0
#line 4536
{ 
#line 4537
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4539
return (short)(v.x); 
#line 4540
} 
#endif
#line 4542 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex2DLod(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4547
::exit(___);}
#if 0
#line 4543
{ 
#line 4544
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4546
return (unsigned short)(v.x); 
#line 4547
} 
#endif
#line 4549 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex2DLod(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4550
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4554
::exit(___);}
#if 0
#line 4550
{ 
#line 4551
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4553
return make_short1(v.x); 
#line 4554
} 
#endif
#line 4556 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex2DLod(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4557
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4561
::exit(___);}
#if 0
#line 4557
{ 
#line 4558
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4560
return make_ushort1(v.x); 
#line 4561
} 
#endif
#line 4563 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex2DLod(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4564
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4568
::exit(___);}
#if 0
#line 4564
{ 
#line 4565
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4567
return make_short2(v.x, v.y); 
#line 4568
} 
#endif
#line 4570 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex2DLod(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4575
::exit(___);}
#if 0
#line 4571
{ 
#line 4572
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4574
return make_ushort2(v.x, v.y); 
#line 4575
} 
#endif
#line 4577 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2DLod(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4578
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4582
::exit(___);}
#if 0
#line 4578
{ 
#line 4579
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4581
return make_short4(v.x, v.y, v.z, v.w); 
#line 4582
} 
#endif
#line 4584 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2DLod(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4585
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4589
::exit(___);}
#if 0
#line 4585
{ 
#line 4586
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4588
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 4589
} 
#endif
#line 4597 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex2DLod(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4602
::exit(___);}
#if 0
#line 4598
{ 
#line 4599
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4601
return v.x; 
#line 4602
} 
#endif
#line 4604 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex2DLod(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4609
::exit(___);}
#if 0
#line 4605
{ 
#line 4606
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4608
return v.x; 
#line 4609
} 
#endif
#line 4611 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex2DLod(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4616
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4615
return make_int1(v.x); 
#line 4616
} 
#endif
#line 4618 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex2DLod(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4623
::exit(___);}
#if 0
#line 4619
{ 
#line 4620
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4622
return make_uint1(v.x); 
#line 4623
} 
#endif
#line 4625 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex2DLod(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4630
::exit(___);}
#if 0
#line 4626
{ 
#line 4627
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4629
return make_int2(v.x, v.y); 
#line 4630
} 
#endif
#line 4632 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex2DLod(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4637
::exit(___);}
#if 0
#line 4633
{ 
#line 4634
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4636
return make_uint2(v.x, v.y); 
#line 4637
} 
#endif
#line 4639 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2DLod(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4640
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4644
::exit(___);}
#if 0
#line 4640
{ 
#line 4641
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4643
return make_int4(v.x, v.y, v.z, v.w); 
#line 4644
} 
#endif
#line 4646 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2DLod(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4647
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4651
::exit(___);}
#if 0
#line 4647
{ 
#line 4648
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4650
return make_uint4(v.x, v.y, v.z, v.w); 
#line 4651
} 
#endif
#line 4661 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex2DLod(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4662
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4666
::exit(___);}
#if 0
#line 4662
{ 
#line 4663
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4665
return (long)(v.x); 
#line 4666
} 
#endif
#line 4668 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex2DLod(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4669
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4673
::exit(___);}
#if 0
#line 4669
{ 
#line 4670
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4672
return (unsigned long)(v.x); 
#line 4673
} 
#endif
#line 4675 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex2DLod(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4676
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4680
::exit(___);}
#if 0
#line 4676
{ 
#line 4677
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4679
return make_long1(v.x); 
#line 4680
} 
#endif
#line 4682 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex2DLod(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4683
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4687
::exit(___);}
#if 0
#line 4683
{ 
#line 4684
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4686
return make_ulong1(v.x); 
#line 4687
} 
#endif
#line 4689 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex2DLod(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4690
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4694
::exit(___);}
#if 0
#line 4690
{ 
#line 4691
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4693
return make_long2(v.x, v.y); 
#line 4694
} 
#endif
#line 4696 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex2DLod(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4697
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4701
::exit(___);}
#if 0
#line 4697
{ 
#line 4698
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4700
return make_ulong2(v.x, v.y); 
#line 4701
} 
#endif
#line 4703 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex2DLod(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4704
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4708
::exit(___);}
#if 0
#line 4704
{ 
#line 4705
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4707
return make_long4(v.x, v.y, v.z, v.w); 
#line 4708
} 
#endif
#line 4710 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex2DLod(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4711
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4715
::exit(___);}
#if 0
#line 4711
{ 
#line 4712
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4714
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 4715
} 
#endif
#line 4725 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLod(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4730
::exit(___);}
#if 0
#line 4726
{ 
#line 4727
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4729
return v.x; 
#line 4730
} 
#endif
#line 4732 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLod(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4737
::exit(___);}
#if 0
#line 4733
{ 
#line 4734
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4736
return make_float1(v.x); 
#line 4737
} 
#endif
#line 4739 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLod(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4740
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4744
::exit(___);}
#if 0
#line 4740
{ 
#line 4741
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4743
return make_float2(v.x, v.y); 
#line 4744
} 
#endif
#line 4746 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLod(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float level) 
#line 4747
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4751
::exit(___);}
#if 0
#line 4747
{ 
#line 4748
float4 v = __ftexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4750
return make_float4(v.x, v.y, v.z, v.w); 
#line 4751
} 
#endif
#line 4759 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLod(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4760
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4769 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 4760 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 4764 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4766 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4768
return w.x; 
#line 4769
} 
#endif
#line 4771 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLod(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4772
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4777
::exit(___);}
#if 0
#line 4772
{ 
#line 4773
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4774
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4776
return w.x; 
#line 4777
} 
#endif
#line 4779 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLod(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4780
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4785
::exit(___);}
#if 0
#line 4780
{ 
#line 4781
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4782
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4784
return w.x; 
#line 4785
} 
#endif
#line 4787 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLod(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4793
::exit(___);}
#if 0
#line 4788
{ 
#line 4789
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4790
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4792
return make_float1(w.x); 
#line 4793
} 
#endif
#line 4795 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLod(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4796
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4801
::exit(___);}
#if 0
#line 4796
{ 
#line 4797
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4798
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4800
return make_float1(w.x); 
#line 4801
} 
#endif
#line 4803 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLod(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4804
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4809
::exit(___);}
#if 0
#line 4804
{ 
#line 4805
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4806
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4808
return make_float2(w.x, w.y); 
#line 4809
} 
#endif
#line 4811 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLod(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4812
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4817
::exit(___);}
#if 0
#line 4812
{ 
#line 4813
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4814
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4816
return make_float2(w.x, w.y); 
#line 4817
} 
#endif
#line 4819 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLod(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4820
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4825
::exit(___);}
#if 0
#line 4820
{ 
#line 4821
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4822
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4824
return make_float4(w.x, w.y, w.z, w.w); 
#line 4825
} 
#endif
#line 4827 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLod(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4833
::exit(___);}
#if 0
#line 4828
{ 
#line 4829
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4830
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4832
return make_float4(w.x, w.y, w.z, w.w); 
#line 4833
} 
#endif
#line 4841 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLod(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4842
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4847
::exit(___);}
#if 0
#line 4842
{ 
#line 4843
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4844
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4846
return w.x; 
#line 4847
} 
#endif
#line 4849 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLod(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4855
::exit(___);}
#if 0
#line 4850
{ 
#line 4851
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4852
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4854
return w.x; 
#line 4855
} 
#endif
#line 4857 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLod(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4858
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4863
::exit(___);}
#if 0
#line 4858
{ 
#line 4859
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4860
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4862
return make_float1(w.x); 
#line 4863
} 
#endif
#line 4865 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLod(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4866
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4871
::exit(___);}
#if 0
#line 4866
{ 
#line 4867
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4868
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4870
return make_float1(w.x); 
#line 4871
} 
#endif
#line 4873 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLod(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4874
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4879
::exit(___);}
#if 0
#line 4874
{ 
#line 4875
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4876
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4878
return make_float2(w.x, w.y); 
#line 4879
} 
#endif
#line 4881 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLod(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4882
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4887
::exit(___);}
#if 0
#line 4882
{ 
#line 4883
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4884
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4886
return make_float2(w.x, w.y); 
#line 4887
} 
#endif
#line 4889 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLod(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4895
::exit(___);}
#if 0
#line 4890
{ 
#line 4891
int4 v = __itexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4892
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4894
return make_float4(w.x, w.y, w.z, w.w); 
#line 4895
} 
#endif
#line 4897 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLod(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float level) 
#line 4898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)level;
#line 4903
::exit(___);}
#if 0
#line 4898
{ 
#line 4899
uint4 v = __utexfetchlod(t, make_float4(x, y, 0, 0), level); 
#line 4900
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 4902
return make_float4(w.x, w.y, w.z, w.w); 
#line 4903
} 
#endif
#line 4911 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1DLayeredLod(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4912
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4920 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 4912 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 4916 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4919 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 4920
} 
#endif
#line 4922 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1DLayeredLod(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4923
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4927
::exit(___);}
#if 0
#line 4923
{ 
#line 4924
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4926
return (signed char)(v.x); 
#line 4927
} 
#endif
#line 4929 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4930
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4934
::exit(___);}
#if 0
#line 4930
{ 
#line 4931
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4933
return (unsigned char)(v.x); 
#line 4934
} 
#endif
#line 4936 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1DLayeredLod(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4937
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4941
::exit(___);}
#if 0
#line 4937
{ 
#line 4938
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4940
return make_char1(v.x); 
#line 4941
} 
#endif
#line 4943 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4944
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4948
::exit(___);}
#if 0
#line 4944
{ 
#line 4945
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4947
return make_uchar1(v.x); 
#line 4948
} 
#endif
#line 4950 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1DLayeredLod(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4951
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4955
::exit(___);}
#if 0
#line 4951
{ 
#line 4952
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4954
return make_char2(v.x, v.y); 
#line 4955
} 
#endif
#line 4957 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4958
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4962
::exit(___);}
#if 0
#line 4958
{ 
#line 4959
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4961
return make_uchar2(v.x, v.y); 
#line 4962
} 
#endif
#line 4964 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1DLayeredLod(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4965
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4969
::exit(___);}
#if 0
#line 4965
{ 
#line 4966
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4968
return make_char4(v.x, v.y, v.z, v.w); 
#line 4969
} 
#endif
#line 4971 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4972
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4976
::exit(___);}
#if 0
#line 4972
{ 
#line 4973
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4975
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 4976
} 
#endif
#line 4984 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1DLayeredLod(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4985
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4989
::exit(___);}
#if 0
#line 4985
{ 
#line 4986
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4988
return (short)(v.x); 
#line 4989
} 
#endif
#line 4991 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4992
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 4996
::exit(___);}
#if 0
#line 4992
{ 
#line 4993
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 4995
return (unsigned short)(v.x); 
#line 4996
} 
#endif
#line 4998 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1DLayeredLod(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 4999
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5003
::exit(___);}
#if 0
#line 4999
{ 
#line 5000
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5002
return make_short1(v.x); 
#line 5003
} 
#endif
#line 5005 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5006
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5010
::exit(___);}
#if 0
#line 5006
{ 
#line 5007
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5009
return make_ushort1(v.x); 
#line 5010
} 
#endif
#line 5012 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1DLayeredLod(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5013
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5017
::exit(___);}
#if 0
#line 5013
{ 
#line 5014
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5016
return make_short2(v.x, v.y); 
#line 5017
} 
#endif
#line 5019 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5020
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5024
::exit(___);}
#if 0
#line 5020
{ 
#line 5021
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5023
return make_ushort2(v.x, v.y); 
#line 5024
} 
#endif
#line 5026 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1DLayeredLod(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5027
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5031
::exit(___);}
#if 0
#line 5027
{ 
#line 5028
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5030
return make_short4(v.x, v.y, v.z, v.w); 
#line 5031
} 
#endif
#line 5033 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5034
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5038
::exit(___);}
#if 0
#line 5034
{ 
#line 5035
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5037
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5038
} 
#endif
#line 5046 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1DLayeredLod(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5047
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5051
::exit(___);}
#if 0
#line 5047
{ 
#line 5048
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5050
return v.x; 
#line 5051
} 
#endif
#line 5053 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1DLayeredLod(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5054
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5058
::exit(___);}
#if 0
#line 5054
{ 
#line 5055
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5057
return v.x; 
#line 5058
} 
#endif
#line 5060 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1DLayeredLod(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5061
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5065
::exit(___);}
#if 0
#line 5061
{ 
#line 5062
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5064
return make_int1(v.x); 
#line 5065
} 
#endif
#line 5067 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1DLayeredLod(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5068
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5072
::exit(___);}
#if 0
#line 5068
{ 
#line 5069
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5071
return make_uint1(v.x); 
#line 5072
} 
#endif
#line 5074 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1DLayeredLod(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5075
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5079
::exit(___);}
#if 0
#line 5075
{ 
#line 5076
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5078
return make_int2(v.x, v.y); 
#line 5079
} 
#endif
#line 5081 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1DLayeredLod(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5082
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5086
::exit(___);}
#if 0
#line 5082
{ 
#line 5083
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5085
return make_uint2(v.x, v.y); 
#line 5086
} 
#endif
#line 5088 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1DLayeredLod(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5089
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5093
::exit(___);}
#if 0
#line 5089
{ 
#line 5090
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5092
return make_int4(v.x, v.y, v.z, v.w); 
#line 5093
} 
#endif
#line 5095 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1DLayeredLod(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5096
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5100
::exit(___);}
#if 0
#line 5096
{ 
#line 5097
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5099
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5100
} 
#endif
#line 5110 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1DLayeredLod(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5111
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5115
::exit(___);}
#if 0
#line 5111
{ 
#line 5112
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5114
return (long)(v.x); 
#line 5115
} 
#endif
#line 5117 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1DLayeredLod(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5118
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5122
::exit(___);}
#if 0
#line 5118
{ 
#line 5119
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5121
return (unsigned long)(v.x); 
#line 5122
} 
#endif
#line 5124 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1DLayeredLod(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5125
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5129
::exit(___);}
#if 0
#line 5125
{ 
#line 5126
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5128
return make_long1(v.x); 
#line 5129
} 
#endif
#line 5131 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1DLayeredLod(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5132
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5136
::exit(___);}
#if 0
#line 5132
{ 
#line 5133
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5135
return make_ulong1(v.x); 
#line 5136
} 
#endif
#line 5138 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1DLayeredLod(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5139
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5143
::exit(___);}
#if 0
#line 5139
{ 
#line 5140
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5142
return make_long2(v.x, v.y); 
#line 5143
} 
#endif
#line 5145 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1DLayeredLod(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5146
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5150
::exit(___);}
#if 0
#line 5146
{ 
#line 5147
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5149
return make_ulong2(v.x, v.y); 
#line 5150
} 
#endif
#line 5152 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1DLayeredLod(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5153
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5157
::exit(___);}
#if 0
#line 5153
{ 
#line 5154
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5156
return make_long4(v.x, v.y, v.z, v.w); 
#line 5157
} 
#endif
#line 5159 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1DLayeredLod(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5160
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5164
::exit(___);}
#if 0
#line 5160
{ 
#line 5161
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5163
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 5164
} 
#endif
#line 5174 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredLod(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5175
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5179
::exit(___);}
#if 0
#line 5175
{ 
#line 5176
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5178
return v.x; 
#line 5179
} 
#endif
#line 5181 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredLod(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5182
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5186
::exit(___);}
#if 0
#line 5182
{ 
#line 5183
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5185
return make_float1(v.x); 
#line 5186
} 
#endif
#line 5188 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredLod(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5189
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5193
::exit(___);}
#if 0
#line 5189
{ 
#line 5190
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5192
return make_float2(v.x, v.y); 
#line 5193
} 
#endif
#line 5195 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredLod(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float level) 
#line 5196
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5200
::exit(___);}
#if 0
#line 5196
{ 
#line 5197
float4 v = __ftexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5199
return make_float4(v.x, v.y, v.z, v.w); 
#line 5200
} 
#endif
#line 5208 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredLod(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5209
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5218 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 5209 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 5213 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5215 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5217
return w.x; 
#line 5218
} 
#endif
#line 5220 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredLod(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5221
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5226
::exit(___);}
#if 0
#line 5221
{ 
#line 5222
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5223
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5225
return w.x; 
#line 5226
} 
#endif
#line 5228 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredLod(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5229
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5234
::exit(___);}
#if 0
#line 5229
{ 
#line 5230
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5231
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5233
return w.x; 
#line 5234
} 
#endif
#line 5236 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredLod(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5237
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5242
::exit(___);}
#if 0
#line 5237
{ 
#line 5238
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5239
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5241
return make_float1(w.x); 
#line 5242
} 
#endif
#line 5244 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredLod(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5245
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5250
::exit(___);}
#if 0
#line 5245
{ 
#line 5246
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5247
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5249
return make_float1(w.x); 
#line 5250
} 
#endif
#line 5252 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredLod(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5253
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5258
::exit(___);}
#if 0
#line 5253
{ 
#line 5254
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5255
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5257
return make_float2(w.x, w.y); 
#line 5258
} 
#endif
#line 5260 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredLod(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5261
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5266
::exit(___);}
#if 0
#line 5261
{ 
#line 5262
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5263
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5265
return make_float2(w.x, w.y); 
#line 5266
} 
#endif
#line 5268 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredLod(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5269
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5274
::exit(___);}
#if 0
#line 5269
{ 
#line 5270
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5271
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5273
return make_float4(w.x, w.y, w.z, w.w); 
#line 5274
} 
#endif
#line 5276 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredLod(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5277
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5282
::exit(___);}
#if 0
#line 5277
{ 
#line 5278
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5279
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5281
return make_float4(w.x, w.y, w.z, w.w); 
#line 5282
} 
#endif
#line 5290 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredLod(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5291
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5296
::exit(___);}
#if 0
#line 5291
{ 
#line 5292
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5293
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5295
return w.x; 
#line 5296
} 
#endif
#line 5298 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredLod(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5299
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5304
::exit(___);}
#if 0
#line 5299
{ 
#line 5300
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5301
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5303
return w.x; 
#line 5304
} 
#endif
#line 5306 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredLod(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5307
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5312
::exit(___);}
#if 0
#line 5307
{ 
#line 5308
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5309
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5311
return make_float1(w.x); 
#line 5312
} 
#endif
#line 5314 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredLod(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5315
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5320
::exit(___);}
#if 0
#line 5315
{ 
#line 5316
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5317
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5319
return make_float1(w.x); 
#line 5320
} 
#endif
#line 5322 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredLod(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5323
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5328
::exit(___);}
#if 0
#line 5323
{ 
#line 5324
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5325
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5327
return make_float2(w.x, w.y); 
#line 5328
} 
#endif
#line 5330 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredLod(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5331
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5336
::exit(___);}
#if 0
#line 5331
{ 
#line 5332
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5333
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5335
return make_float2(w.x, w.y); 
#line 5336
} 
#endif
#line 5338 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredLod(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5339
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5344
::exit(___);}
#if 0
#line 5339
{ 
#line 5340
int4 v = __itexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5341
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5343
return make_float4(w.x, w.y, w.z, w.w); 
#line 5344
} 
#endif
#line 5346 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredLod(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float level) 
#line 5347
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)level;
#line 5352
::exit(___);}
#if 0
#line 5347
{ 
#line 5348
uint4 v = __utexfetchlodl(t, make_float4(x, 0, 0, 0), layer, level); 
#line 5349
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5351
return make_float4(w.x, w.y, w.z, w.w); 
#line 5352
} 
#endif
#line 5360 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex2DLayeredLod(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5361
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5369 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 5361 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 5365 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5368 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 5369
} 
#endif
#line 5371 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex2DLayeredLod(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5372
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5376
::exit(___);}
#if 0
#line 5372
{ 
#line 5373
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5375
return (signed char)(v.x); 
#line 5376
} 
#endif
#line 5378 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5379
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5383
::exit(___);}
#if 0
#line 5379
{ 
#line 5380
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5382
return (unsigned char)(v.x); 
#line 5383
} 
#endif
#line 5385 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex2DLayeredLod(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5386
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5390
::exit(___);}
#if 0
#line 5386
{ 
#line 5387
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5389
return make_char1(v.x); 
#line 5390
} 
#endif
#line 5392 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5393
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5397
::exit(___);}
#if 0
#line 5393
{ 
#line 5394
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5396
return make_uchar1(v.x); 
#line 5397
} 
#endif
#line 5399 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex2DLayeredLod(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5400
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5404
::exit(___);}
#if 0
#line 5400
{ 
#line 5401
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5403
return make_char2(v.x, v.y); 
#line 5404
} 
#endif
#line 5406 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5407
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5411
::exit(___);}
#if 0
#line 5407
{ 
#line 5408
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5410
return make_uchar2(v.x, v.y); 
#line 5411
} 
#endif
#line 5413 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2DLayeredLod(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5414
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5418
::exit(___);}
#if 0
#line 5414
{ 
#line 5415
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5417
return make_char4(v.x, v.y, v.z, v.w); 
#line 5418
} 
#endif
#line 5420 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5421
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5425
::exit(___);}
#if 0
#line 5421
{ 
#line 5422
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5424
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5425
} 
#endif
#line 5433 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex2DLayeredLod(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5434
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5438
::exit(___);}
#if 0
#line 5434
{ 
#line 5435
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5437
return (short)(v.x); 
#line 5438
} 
#endif
#line 5440 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5441
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5445
::exit(___);}
#if 0
#line 5441
{ 
#line 5442
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5444
return (unsigned short)(v.x); 
#line 5445
} 
#endif
#line 5447 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex2DLayeredLod(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5448
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5452
::exit(___);}
#if 0
#line 5448
{ 
#line 5449
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5451
return make_short1(v.x); 
#line 5452
} 
#endif
#line 5454 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5455
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5459
::exit(___);}
#if 0
#line 5455
{ 
#line 5456
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5458
return make_ushort1(v.x); 
#line 5459
} 
#endif
#line 5461 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex2DLayeredLod(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5462
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5466
::exit(___);}
#if 0
#line 5462
{ 
#line 5463
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5465
return make_short2(v.x, v.y); 
#line 5466
} 
#endif
#line 5468 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5469
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5473
::exit(___);}
#if 0
#line 5469
{ 
#line 5470
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5472
return make_ushort2(v.x, v.y); 
#line 5473
} 
#endif
#line 5475 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2DLayeredLod(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5476
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5480
::exit(___);}
#if 0
#line 5476
{ 
#line 5477
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5479
return make_short4(v.x, v.y, v.z, v.w); 
#line 5480
} 
#endif
#line 5482 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5483
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5487
::exit(___);}
#if 0
#line 5483
{ 
#line 5484
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5486
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5487
} 
#endif
#line 5495 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex2DLayeredLod(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5496
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5500
::exit(___);}
#if 0
#line 5496
{ 
#line 5497
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5499
return v.x; 
#line 5500
} 
#endif
#line 5502 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex2DLayeredLod(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5503
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5507
::exit(___);}
#if 0
#line 5503
{ 
#line 5504
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5506
return v.x; 
#line 5507
} 
#endif
#line 5509 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex2DLayeredLod(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5510
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5514
::exit(___);}
#if 0
#line 5510
{ 
#line 5511
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5513
return make_int1(v.x); 
#line 5514
} 
#endif
#line 5516 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex2DLayeredLod(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5517
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5521
::exit(___);}
#if 0
#line 5517
{ 
#line 5518
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5520
return make_uint1(v.x); 
#line 5521
} 
#endif
#line 5523 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex2DLayeredLod(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5524
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5528
::exit(___);}
#if 0
#line 5524
{ 
#line 5525
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5527
return make_int2(v.x, v.y); 
#line 5528
} 
#endif
#line 5530 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex2DLayeredLod(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5531
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5535
::exit(___);}
#if 0
#line 5531
{ 
#line 5532
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5534
return make_uint2(v.x, v.y); 
#line 5535
} 
#endif
#line 5537 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2DLayeredLod(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5538
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5542
::exit(___);}
#if 0
#line 5538
{ 
#line 5539
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5541
return make_int4(v.x, v.y, v.z, v.w); 
#line 5542
} 
#endif
#line 5544 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2DLayeredLod(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5545
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5549
::exit(___);}
#if 0
#line 5545
{ 
#line 5546
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5548
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5549
} 
#endif
#line 5559 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex2DLayeredLod(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5560
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5564
::exit(___);}
#if 0
#line 5560
{ 
#line 5561
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5563
return (long)(v.x); 
#line 5564
} 
#endif
#line 5566 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex2DLayeredLod(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5567
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5571
::exit(___);}
#if 0
#line 5567
{ 
#line 5568
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5570
return (unsigned long)(v.x); 
#line 5571
} 
#endif
#line 5573 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex2DLayeredLod(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5574
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5578
::exit(___);}
#if 0
#line 5574
{ 
#line 5575
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5577
return make_long1(v.x); 
#line 5578
} 
#endif
#line 5580 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex2DLayeredLod(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5581
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5585
::exit(___);}
#if 0
#line 5581
{ 
#line 5582
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5584
return make_ulong1(v.x); 
#line 5585
} 
#endif
#line 5587 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex2DLayeredLod(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5588
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5592
::exit(___);}
#if 0
#line 5588
{ 
#line 5589
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5591
return make_long2(v.x, v.y); 
#line 5592
} 
#endif
#line 5594 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex2DLayeredLod(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5595
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5599
::exit(___);}
#if 0
#line 5595
{ 
#line 5596
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5598
return make_ulong2(v.x, v.y); 
#line 5599
} 
#endif
#line 5601 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex2DLayeredLod(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5602
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5606
::exit(___);}
#if 0
#line 5602
{ 
#line 5603
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5605
return make_long4(v.x, v.y, v.z, v.w); 
#line 5606
} 
#endif
#line 5608 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex2DLayeredLod(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5609
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5613
::exit(___);}
#if 0
#line 5609
{ 
#line 5610
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5612
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 5613
} 
#endif
#line 5623 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredLod(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5628
::exit(___);}
#if 0
#line 5624
{ 
#line 5625
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5627
return v.x; 
#line 5628
} 
#endif
#line 5630 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredLod(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5631
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5635
::exit(___);}
#if 0
#line 5631
{ 
#line 5632
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5634
return make_float1(v.x); 
#line 5635
} 
#endif
#line 5637 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredLod(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5638
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5642
::exit(___);}
#if 0
#line 5638
{ 
#line 5639
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5641
return make_float2(v.x, v.y); 
#line 5642
} 
#endif
#line 5644 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredLod(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float level) 
#line 5645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5649
::exit(___);}
#if 0
#line 5645
{ 
#line 5646
float4 v = __ftexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5648
return make_float4(v.x, v.y, v.z, v.w); 
#line 5649
} 
#endif
#line 5657 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredLod(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5658
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5667 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 5658 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 5662 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5664 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5666
return w.x; 
#line 5667
} 
#endif
#line 5669 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredLod(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5670
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5675
::exit(___);}
#if 0
#line 5670
{ 
#line 5671
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5672
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5674
return w.x; 
#line 5675
} 
#endif
#line 5677 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredLod(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5678
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5683
::exit(___);}
#if 0
#line 5678
{ 
#line 5679
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5680
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5682
return w.x; 
#line 5683
} 
#endif
#line 5685 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredLod(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5686
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5691
::exit(___);}
#if 0
#line 5686
{ 
#line 5687
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5688
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5690
return make_float1(w.x); 
#line 5691
} 
#endif
#line 5693 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredLod(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5694
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5699
::exit(___);}
#if 0
#line 5694
{ 
#line 5695
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5696
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5698
return make_float1(w.x); 
#line 5699
} 
#endif
#line 5701 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredLod(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5702
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5707
::exit(___);}
#if 0
#line 5702
{ 
#line 5703
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5704
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5706
return make_float2(w.x, w.y); 
#line 5707
} 
#endif
#line 5709 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredLod(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5710
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5715
::exit(___);}
#if 0
#line 5710
{ 
#line 5711
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5712
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5714
return make_float2(w.x, w.y); 
#line 5715
} 
#endif
#line 5717 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredLod(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5718
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5723
::exit(___);}
#if 0
#line 5718
{ 
#line 5719
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5720
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5722
return make_float4(w.x, w.y, w.z, w.w); 
#line 5723
} 
#endif
#line 5725 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredLod(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5731
::exit(___);}
#if 0
#line 5726
{ 
#line 5727
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5728
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5730
return make_float4(w.x, w.y, w.z, w.w); 
#line 5731
} 
#endif
#line 5739 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredLod(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5740
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5745
::exit(___);}
#if 0
#line 5740
{ 
#line 5741
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5742
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5744
return w.x; 
#line 5745
} 
#endif
#line 5747 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredLod(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5753
::exit(___);}
#if 0
#line 5748
{ 
#line 5749
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5750
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5752
return w.x; 
#line 5753
} 
#endif
#line 5755 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredLod(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5756
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5761
::exit(___);}
#if 0
#line 5756
{ 
#line 5757
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5758
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5760
return make_float1(w.x); 
#line 5761
} 
#endif
#line 5763 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredLod(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5764
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5769
::exit(___);}
#if 0
#line 5764
{ 
#line 5765
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5766
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5768
return make_float1(w.x); 
#line 5769
} 
#endif
#line 5771 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredLod(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5772
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5777
::exit(___);}
#if 0
#line 5772
{ 
#line 5773
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5774
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5776
return make_float2(w.x, w.y); 
#line 5777
} 
#endif
#line 5779 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredLod(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5780
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5785
::exit(___);}
#if 0
#line 5780
{ 
#line 5781
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5782
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5784
return make_float2(w.x, w.y); 
#line 5785
} 
#endif
#line 5787 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredLod(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5793
::exit(___);}
#if 0
#line 5788
{ 
#line 5789
int4 v = __itexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5790
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5792
return make_float4(w.x, w.y, w.z, w.w); 
#line 5793
} 
#endif
#line 5795 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredLod(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float level) 
#line 5796
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)level;
#line 5801
::exit(___);}
#if 0
#line 5796
{ 
#line 5797
uint4 v = __utexfetchlodl(t, make_float4(x, y, 0, 0), layer, level); 
#line 5798
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 5800
return make_float4(w.x, w.y, w.z, w.w); 
#line 5801
} 
#endif
#line 5809 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex3DLod(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5810
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5818 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 5810 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 5814 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5817 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 5818
} 
#endif
#line 5820 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex3DLod(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5821
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5825
::exit(___);}
#if 0
#line 5821
{ 
#line 5822
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5824
return (signed char)(v.x); 
#line 5825
} 
#endif
#line 5827 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex3DLod(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5832
::exit(___);}
#if 0
#line 5828
{ 
#line 5829
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5831
return (unsigned char)(v.x); 
#line 5832
} 
#endif
#line 5834 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex3DLod(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5835
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5839
::exit(___);}
#if 0
#line 5835
{ 
#line 5836
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5838
return make_char1(v.x); 
#line 5839
} 
#endif
#line 5841 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex3DLod(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5842
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5846
::exit(___);}
#if 0
#line 5842
{ 
#line 5843
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5845
return make_uchar1(v.x); 
#line 5846
} 
#endif
#line 5848 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex3DLod(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5849
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5853
::exit(___);}
#if 0
#line 5849
{ 
#line 5850
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5852
return make_char2(v.x, v.y); 
#line 5853
} 
#endif
#line 5855 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex3DLod(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5856
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5860
::exit(___);}
#if 0
#line 5856
{ 
#line 5857
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5859
return make_uchar2(v.x, v.y); 
#line 5860
} 
#endif
#line 5862 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex3DLod(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5863
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5867
::exit(___);}
#if 0
#line 5863
{ 
#line 5864
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5866
return make_char4(v.x, v.y, v.z, v.w); 
#line 5867
} 
#endif
#line 5869 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex3DLod(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5870
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5874
::exit(___);}
#if 0
#line 5870
{ 
#line 5871
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5873
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 5874
} 
#endif
#line 5882 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex3DLod(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5887
::exit(___);}
#if 0
#line 5883
{ 
#line 5884
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5886
return (short)(v.x); 
#line 5887
} 
#endif
#line 5889 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex3DLod(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5894
::exit(___);}
#if 0
#line 5890
{ 
#line 5891
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5893
return (unsigned short)(v.x); 
#line 5894
} 
#endif
#line 5896 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex3DLod(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5901
::exit(___);}
#if 0
#line 5897
{ 
#line 5898
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5900
return make_short1(v.x); 
#line 5901
} 
#endif
#line 5903 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex3DLod(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5904
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5908
::exit(___);}
#if 0
#line 5904
{ 
#line 5905
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5907
return make_ushort1(v.x); 
#line 5908
} 
#endif
#line 5910 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex3DLod(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5911
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5915
::exit(___);}
#if 0
#line 5911
{ 
#line 5912
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5914
return make_short2(v.x, v.y); 
#line 5915
} 
#endif
#line 5917 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex3DLod(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5918
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5922
::exit(___);}
#if 0
#line 5918
{ 
#line 5919
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5921
return make_ushort2(v.x, v.y); 
#line 5922
} 
#endif
#line 5924 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex3DLod(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5925
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5929
::exit(___);}
#if 0
#line 5925
{ 
#line 5926
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5928
return make_short4(v.x, v.y, v.z, v.w); 
#line 5929
} 
#endif
#line 5931 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex3DLod(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5932
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5936
::exit(___);}
#if 0
#line 5932
{ 
#line 5933
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5935
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 5936
} 
#endif
#line 5944 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex3DLod(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5945
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5949
::exit(___);}
#if 0
#line 5945
{ 
#line 5946
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5948
return v.x; 
#line 5949
} 
#endif
#line 5951 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex3DLod(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5952
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5956
::exit(___);}
#if 0
#line 5952
{ 
#line 5953
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5955
return v.x; 
#line 5956
} 
#endif
#line 5958 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex3DLod(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5959
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5963
::exit(___);}
#if 0
#line 5959
{ 
#line 5960
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5962
return make_int1(v.x); 
#line 5963
} 
#endif
#line 5965 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex3DLod(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5966
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5970
::exit(___);}
#if 0
#line 5966
{ 
#line 5967
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5969
return make_uint1(v.x); 
#line 5970
} 
#endif
#line 5972 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex3DLod(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5973
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5977
::exit(___);}
#if 0
#line 5973
{ 
#line 5974
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5976
return make_int2(v.x, v.y); 
#line 5977
} 
#endif
#line 5979 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex3DLod(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5980
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5984
::exit(___);}
#if 0
#line 5980
{ 
#line 5981
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5983
return make_uint2(v.x, v.y); 
#line 5984
} 
#endif
#line 5986 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex3DLod(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5987
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5991
::exit(___);}
#if 0
#line 5987
{ 
#line 5988
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5990
return make_int4(v.x, v.y, v.z, v.w); 
#line 5991
} 
#endif
#line 5993 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex3DLod(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 5994
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 5998
::exit(___);}
#if 0
#line 5994
{ 
#line 5995
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 5997
return make_uint4(v.x, v.y, v.z, v.w); 
#line 5998
} 
#endif
#line 6008 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex3DLod(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6009
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6013
::exit(___);}
#if 0
#line 6009
{ 
#line 6010
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6012
return (long)(v.x); 
#line 6013
} 
#endif
#line 6015 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex3DLod(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6016
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6020
::exit(___);}
#if 0
#line 6016
{ 
#line 6017
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6019
return (unsigned long)(v.x); 
#line 6020
} 
#endif
#line 6022 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex3DLod(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6023
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6027
::exit(___);}
#if 0
#line 6023
{ 
#line 6024
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6026
return make_long1(v.x); 
#line 6027
} 
#endif
#line 6029 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex3DLod(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6030
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6034
::exit(___);}
#if 0
#line 6030
{ 
#line 6031
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6033
return make_ulong1(v.x); 
#line 6034
} 
#endif
#line 6036 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex3DLod(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6037
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6041
::exit(___);}
#if 0
#line 6037
{ 
#line 6038
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6040
return make_long2(v.x, v.y); 
#line 6041
} 
#endif
#line 6043 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex3DLod(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6044
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6048
::exit(___);}
#if 0
#line 6044
{ 
#line 6045
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6047
return make_ulong2(v.x, v.y); 
#line 6048
} 
#endif
#line 6050 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex3DLod(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6051
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6055
::exit(___);}
#if 0
#line 6051
{ 
#line 6052
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6054
return make_long4(v.x, v.y, v.z, v.w); 
#line 6055
} 
#endif
#line 6057 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex3DLod(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6058
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6062
::exit(___);}
#if 0
#line 6058
{ 
#line 6059
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6061
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6062
} 
#endif
#line 6072 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DLod(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6073
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6077
::exit(___);}
#if 0
#line 6073
{ 
#line 6074
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6076
return v.x; 
#line 6077
} 
#endif
#line 6079 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DLod(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6080
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6084
::exit(___);}
#if 0
#line 6080
{ 
#line 6081
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6083
return make_float1(v.x); 
#line 6084
} 
#endif
#line 6086 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DLod(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6087
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6091
::exit(___);}
#if 0
#line 6087
{ 
#line 6088
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6090
return make_float2(v.x, v.y); 
#line 6091
} 
#endif
#line 6093 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DLod(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6094
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6098
::exit(___);}
#if 0
#line 6094
{ 
#line 6095
float4 v = __ftexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6097
return make_float4(v.x, v.y, v.z, v.w); 
#line 6098
} 
#endif
#line 6106 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DLod(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6107
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6116 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 6107 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 6111 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6113 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6115
return w.x; 
#line 6116
} 
#endif
#line 6118 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DLod(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6119
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6124
::exit(___);}
#if 0
#line 6119
{ 
#line 6120
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6121
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6123
return w.x; 
#line 6124
} 
#endif
#line 6126 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DLod(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6127
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6132
::exit(___);}
#if 0
#line 6127
{ 
#line 6128
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6129
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6131
return w.x; 
#line 6132
} 
#endif
#line 6134 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DLod(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6135
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6140
::exit(___);}
#if 0
#line 6135
{ 
#line 6136
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6137
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6139
return make_float1(w.x); 
#line 6140
} 
#endif
#line 6142 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DLod(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6143
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6148
::exit(___);}
#if 0
#line 6143
{ 
#line 6144
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6145
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6147
return make_float1(w.x); 
#line 6148
} 
#endif
#line 6150 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DLod(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6151
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6156
::exit(___);}
#if 0
#line 6151
{ 
#line 6152
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6153
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6155
return make_float2(w.x, w.y); 
#line 6156
} 
#endif
#line 6158 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DLod(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6159
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6164
::exit(___);}
#if 0
#line 6159
{ 
#line 6160
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6161
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6163
return make_float2(w.x, w.y); 
#line 6164
} 
#endif
#line 6166 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DLod(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6167
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6172
::exit(___);}
#if 0
#line 6167
{ 
#line 6168
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6169
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6171
return make_float4(w.x, w.y, w.z, w.w); 
#line 6172
} 
#endif
#line 6174 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DLod(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6175
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6180
::exit(___);}
#if 0
#line 6175
{ 
#line 6176
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6177
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6179
return make_float4(w.x, w.y, w.z, w.w); 
#line 6180
} 
#endif
#line 6188 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DLod(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6189
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6194
::exit(___);}
#if 0
#line 6189
{ 
#line 6190
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6191
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6193
return w.x; 
#line 6194
} 
#endif
#line 6196 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DLod(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6197
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6202
::exit(___);}
#if 0
#line 6197
{ 
#line 6198
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6199
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6201
return w.x; 
#line 6202
} 
#endif
#line 6204 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DLod(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6205
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6210
::exit(___);}
#if 0
#line 6205
{ 
#line 6206
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6207
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6209
return make_float1(w.x); 
#line 6210
} 
#endif
#line 6212 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DLod(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6213
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6218
::exit(___);}
#if 0
#line 6213
{ 
#line 6214
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6215
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6217
return make_float1(w.x); 
#line 6218
} 
#endif
#line 6220 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DLod(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6221
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6226
::exit(___);}
#if 0
#line 6221
{ 
#line 6222
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6223
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6225
return make_float2(w.x, w.y); 
#line 6226
} 
#endif
#line 6228 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DLod(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6229
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6234
::exit(___);}
#if 0
#line 6229
{ 
#line 6230
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6231
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6233
return make_float2(w.x, w.y); 
#line 6234
} 
#endif
#line 6236 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DLod(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6237
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6242
::exit(___);}
#if 0
#line 6237
{ 
#line 6238
int4 v = __itexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6239
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6241
return make_float4(w.x, w.y, w.z, w.w); 
#line 6242
} 
#endif
#line 6244 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DLod(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6245
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6250
::exit(___);}
#if 0
#line 6245
{ 
#line 6246
uint4 v = __utexfetchlod(t, make_float4(x, y, z, 0), level); 
#line 6247
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6249
return make_float4(w.x, w.y, w.z, w.w); 
#line 6250
} 
#endif
#line 6258 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char texCubemapLod(texture< char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6259
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6267 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 6259 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 6263 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6266 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 6267
} 
#endif
#line 6269 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char texCubemapLod(texture< signed char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6270
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6274
::exit(___);}
#if 0
#line 6270
{ 
#line 6271
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6273
return (signed char)(v.x); 
#line 6274
} 
#endif
#line 6276 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char texCubemapLod(texture< unsigned char, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6277
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6281
::exit(___);}
#if 0
#line 6277
{ 
#line 6278
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6280
return (unsigned char)(v.x); 
#line 6281
} 
#endif
#line 6283 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 texCubemapLod(texture< char1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6284
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6288
::exit(___);}
#if 0
#line 6284
{ 
#line 6285
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6287
return make_char1(v.x); 
#line 6288
} 
#endif
#line 6290 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 texCubemapLod(texture< uchar1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6291
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6295
::exit(___);}
#if 0
#line 6291
{ 
#line 6292
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6294
return make_uchar1(v.x); 
#line 6295
} 
#endif
#line 6297 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 texCubemapLod(texture< char2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6298
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6302
::exit(___);}
#if 0
#line 6298
{ 
#line 6299
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6301
return make_char2(v.x, v.y); 
#line 6302
} 
#endif
#line 6304 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 texCubemapLod(texture< uchar2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6305
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6309
::exit(___);}
#if 0
#line 6305
{ 
#line 6306
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6308
return make_uchar2(v.x, v.y); 
#line 6309
} 
#endif
#line 6311 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 texCubemapLod(texture< char4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6312
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6316
::exit(___);}
#if 0
#line 6312
{ 
#line 6313
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6315
return make_char4(v.x, v.y, v.z, v.w); 
#line 6316
} 
#endif
#line 6318 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 texCubemapLod(texture< uchar4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6319
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6323
::exit(___);}
#if 0
#line 6319
{ 
#line 6320
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6322
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 6323
} 
#endif
#line 6331 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short texCubemapLod(texture< short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6332
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6336
::exit(___);}
#if 0
#line 6332
{ 
#line 6333
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6335
return (short)(v.x); 
#line 6336
} 
#endif
#line 6338 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short texCubemapLod(texture< unsigned short, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6339
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6343
::exit(___);}
#if 0
#line 6339
{ 
#line 6340
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6342
return (unsigned short)(v.x); 
#line 6343
} 
#endif
#line 6345 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 texCubemapLod(texture< short1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6346
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6350
::exit(___);}
#if 0
#line 6346
{ 
#line 6347
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6349
return make_short1(v.x); 
#line 6350
} 
#endif
#line 6352 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 texCubemapLod(texture< ushort1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6353
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6357
::exit(___);}
#if 0
#line 6353
{ 
#line 6354
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6356
return make_ushort1(v.x); 
#line 6357
} 
#endif
#line 6359 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 texCubemapLod(texture< short2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6360
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6364
::exit(___);}
#if 0
#line 6360
{ 
#line 6361
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6363
return make_short2(v.x, v.y); 
#line 6364
} 
#endif
#line 6366 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 texCubemapLod(texture< ushort2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6367
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6371
::exit(___);}
#if 0
#line 6367
{ 
#line 6368
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6370
return make_ushort2(v.x, v.y); 
#line 6371
} 
#endif
#line 6373 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 texCubemapLod(texture< short4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6374
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6378
::exit(___);}
#if 0
#line 6374
{ 
#line 6375
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6377
return make_short4(v.x, v.y, v.z, v.w); 
#line 6378
} 
#endif
#line 6380 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 texCubemapLod(texture< ushort4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6381
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6385
::exit(___);}
#if 0
#line 6381
{ 
#line 6382
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6384
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6385
} 
#endif
#line 6393 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int texCubemapLod(texture< int, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6394
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6398
::exit(___);}
#if 0
#line 6394
{ 
#line 6395
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6397
return v.x; 
#line 6398
} 
#endif
#line 6400 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned texCubemapLod(texture< unsigned, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6401
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6405
::exit(___);}
#if 0
#line 6401
{ 
#line 6402
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6404
return v.x; 
#line 6405
} 
#endif
#line 6407 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 texCubemapLod(texture< int1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6408
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6412
::exit(___);}
#if 0
#line 6408
{ 
#line 6409
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6411
return make_int1(v.x); 
#line 6412
} 
#endif
#line 6414 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 texCubemapLod(texture< uint1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6415
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6419
::exit(___);}
#if 0
#line 6415
{ 
#line 6416
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6418
return make_uint1(v.x); 
#line 6419
} 
#endif
#line 6421 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 texCubemapLod(texture< int2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6422
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6426
::exit(___);}
#if 0
#line 6422
{ 
#line 6423
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6425
return make_int2(v.x, v.y); 
#line 6426
} 
#endif
#line 6428 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 texCubemapLod(texture< uint2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6429
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6433
::exit(___);}
#if 0
#line 6429
{ 
#line 6430
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6432
return make_uint2(v.x, v.y); 
#line 6433
} 
#endif
#line 6435 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 texCubemapLod(texture< int4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6436
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6440
::exit(___);}
#if 0
#line 6436
{ 
#line 6437
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6439
return make_int4(v.x, v.y, v.z, v.w); 
#line 6440
} 
#endif
#line 6442 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 texCubemapLod(texture< uint4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6443
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6447
::exit(___);}
#if 0
#line 6443
{ 
#line 6444
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6446
return make_uint4(v.x, v.y, v.z, v.w); 
#line 6447
} 
#endif
#line 6457 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long texCubemapLod(texture< long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6458
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6462
::exit(___);}
#if 0
#line 6458
{ 
#line 6459
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6461
return (long)(v.x); 
#line 6462
} 
#endif
#line 6464 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long texCubemapLod(texture< unsigned long, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6465
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6469
::exit(___);}
#if 0
#line 6465
{ 
#line 6466
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6468
return (unsigned long)(v.x); 
#line 6469
} 
#endif
#line 6471 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 texCubemapLod(texture< long1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6472
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6476
::exit(___);}
#if 0
#line 6472
{ 
#line 6473
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6475
return make_long1(v.x); 
#line 6476
} 
#endif
#line 6478 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 texCubemapLod(texture< ulong1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6479
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6483
::exit(___);}
#if 0
#line 6479
{ 
#line 6480
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6482
return make_ulong1(v.x); 
#line 6483
} 
#endif
#line 6485 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 texCubemapLod(texture< long2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6486
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6490
::exit(___);}
#if 0
#line 6486
{ 
#line 6487
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6489
return make_long2(v.x, v.y); 
#line 6490
} 
#endif
#line 6492 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 texCubemapLod(texture< ulong2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6493
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6497
::exit(___);}
#if 0
#line 6493
{ 
#line 6494
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6496
return make_ulong2(v.x, v.y); 
#line 6497
} 
#endif
#line 6499 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 texCubemapLod(texture< long4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6500
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6504
::exit(___);}
#if 0
#line 6500
{ 
#line 6501
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6503
return make_long4(v.x, v.y, v.z, v.w); 
#line 6504
} 
#endif
#line 6506 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 texCubemapLod(texture< ulong4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6507
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6511
::exit(___);}
#if 0
#line 6507
{ 
#line 6508
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6510
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6511
} 
#endif
#line 6521 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLod(texture< float, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6522
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6526
::exit(___);}
#if 0
#line 6522
{ 
#line 6523
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6525
return v.x; 
#line 6526
} 
#endif
#line 6528 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLod(texture< float1, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6529
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6533
::exit(___);}
#if 0
#line 6529
{ 
#line 6530
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6532
return make_float1(v.x); 
#line 6533
} 
#endif
#line 6535 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLod(texture< float2, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6536
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6540
::exit(___);}
#if 0
#line 6536
{ 
#line 6537
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6539
return make_float2(v.x, v.y); 
#line 6540
} 
#endif
#line 6542 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLod(texture< float4, 12, cudaReadModeElementType>  t, float x, float y, float z, float level) 
#line 6543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6547
::exit(___);}
#if 0
#line 6543
{ 
#line 6544
float4 v = __ftexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6546
return make_float4(v.x, v.y, v.z, v.w); 
#line 6547
} 
#endif
#line 6555 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLod(texture< char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6556
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6565 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 6556 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 6560 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6562 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6564
return w.x; 
#line 6565
} 
#endif
#line 6567 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLod(texture< signed char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6568
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6573
::exit(___);}
#if 0
#line 6568
{ 
#line 6569
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6570
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6572
return w.x; 
#line 6573
} 
#endif
#line 6575 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLod(texture< unsigned char, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6576
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6581
::exit(___);}
#if 0
#line 6576
{ 
#line 6577
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6578
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6580
return w.x; 
#line 6581
} 
#endif
#line 6583 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLod(texture< char1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6584
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6589
::exit(___);}
#if 0
#line 6584
{ 
#line 6585
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6586
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6588
return make_float1(w.x); 
#line 6589
} 
#endif
#line 6591 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLod(texture< uchar1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6592
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6597
::exit(___);}
#if 0
#line 6592
{ 
#line 6593
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6594
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6596
return make_float1(w.x); 
#line 6597
} 
#endif
#line 6599 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLod(texture< char2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6600
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6605
::exit(___);}
#if 0
#line 6600
{ 
#line 6601
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6602
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6604
return make_float2(w.x, w.y); 
#line 6605
} 
#endif
#line 6607 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLod(texture< uchar2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6608
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6613
::exit(___);}
#if 0
#line 6608
{ 
#line 6609
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6610
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6612
return make_float2(w.x, w.y); 
#line 6613
} 
#endif
#line 6615 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLod(texture< char4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6616
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6621
::exit(___);}
#if 0
#line 6616
{ 
#line 6617
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6618
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6620
return make_float4(w.x, w.y, w.z, w.w); 
#line 6621
} 
#endif
#line 6623 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLod(texture< uchar4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6629
::exit(___);}
#if 0
#line 6624
{ 
#line 6625
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6626
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6628
return make_float4(w.x, w.y, w.z, w.w); 
#line 6629
} 
#endif
#line 6637 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLod(texture< short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6638
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6643
::exit(___);}
#if 0
#line 6638
{ 
#line 6639
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6640
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6642
return w.x; 
#line 6643
} 
#endif
#line 6645 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLod(texture< unsigned short, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6651
::exit(___);}
#if 0
#line 6646
{ 
#line 6647
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6648
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6650
return w.x; 
#line 6651
} 
#endif
#line 6653 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLod(texture< short1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6654
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6659
::exit(___);}
#if 0
#line 6654
{ 
#line 6655
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6656
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6658
return make_float1(w.x); 
#line 6659
} 
#endif
#line 6661 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLod(texture< ushort1, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6662
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6667
::exit(___);}
#if 0
#line 6662
{ 
#line 6663
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6664
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6666
return make_float1(w.x); 
#line 6667
} 
#endif
#line 6669 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLod(texture< short2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6670
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6675
::exit(___);}
#if 0
#line 6670
{ 
#line 6671
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6672
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6674
return make_float2(w.x, w.y); 
#line 6675
} 
#endif
#line 6677 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLod(texture< ushort2, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6678
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6683
::exit(___);}
#if 0
#line 6678
{ 
#line 6679
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6680
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6682
return make_float2(w.x, w.y); 
#line 6683
} 
#endif
#line 6685 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLod(texture< short4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6686
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6691
::exit(___);}
#if 0
#line 6686
{ 
#line 6687
int4 v = __itexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6688
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6690
return make_float4(w.x, w.y, w.z, w.w); 
#line 6691
} 
#endif
#line 6693 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLod(texture< ushort4, 12, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float level) 
#line 6694
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)level;
#line 6699
::exit(___);}
#if 0
#line 6694
{ 
#line 6695
uint4 v = __utexfetchlodc(t, make_float4(x, y, z, 0), level); 
#line 6696
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 6698
return make_float4(w.x, w.y, w.z, w.w); 
#line 6699
} 
#endif
#line 6707 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char texCubemapLayeredLod(texture< char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6708
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6716 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 6708 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 6712 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6715 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 6716
} 
#endif
#line 6718 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char texCubemapLayeredLod(texture< signed char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6719
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6723
::exit(___);}
#if 0
#line 6719
{ 
#line 6720
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6722
return (signed char)(v.x); 
#line 6723
} 
#endif
#line 6725 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6726
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6730
::exit(___);}
#if 0
#line 6726
{ 
#line 6727
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6729
return (unsigned char)(v.x); 
#line 6730
} 
#endif
#line 6732 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6733
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6737
::exit(___);}
#if 0
#line 6733
{ 
#line 6734
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6736
return make_char1(v.x); 
#line 6737
} 
#endif
#line 6739 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6740
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6744
::exit(___);}
#if 0
#line 6740
{ 
#line 6741
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6743
return make_uchar1(v.x); 
#line 6744
} 
#endif
#line 6746 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6747
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6751
::exit(___);}
#if 0
#line 6747
{ 
#line 6748
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6750
return make_char2(v.x, v.y); 
#line 6751
} 
#endif
#line 6753 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6754
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6758
::exit(___);}
#if 0
#line 6754
{ 
#line 6755
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6757
return make_uchar2(v.x, v.y); 
#line 6758
} 
#endif
#line 6760 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6761
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6765
::exit(___);}
#if 0
#line 6761
{ 
#line 6762
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6764
return make_char4(v.x, v.y, v.z, v.w); 
#line 6765
} 
#endif
#line 6767 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6768
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6772
::exit(___);}
#if 0
#line 6768
{ 
#line 6769
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6771
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 6772
} 
#endif
#line 6780 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short texCubemapLayeredLod(texture< short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6781
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6785
::exit(___);}
#if 0
#line 6781
{ 
#line 6782
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6784
return (short)(v.x); 
#line 6785
} 
#endif
#line 6787 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6792
::exit(___);}
#if 0
#line 6788
{ 
#line 6789
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6791
return (unsigned short)(v.x); 
#line 6792
} 
#endif
#line 6794 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6799
::exit(___);}
#if 0
#line 6795
{ 
#line 6796
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6798
return make_short1(v.x); 
#line 6799
} 
#endif
#line 6801 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6802
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6806
::exit(___);}
#if 0
#line 6802
{ 
#line 6803
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6805
return make_ushort1(v.x); 
#line 6806
} 
#endif
#line 6808 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6809
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6813
::exit(___);}
#if 0
#line 6809
{ 
#line 6810
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6812
return make_short2(v.x, v.y); 
#line 6813
} 
#endif
#line 6815 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6816
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6820
::exit(___);}
#if 0
#line 6816
{ 
#line 6817
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6819
return make_ushort2(v.x, v.y); 
#line 6820
} 
#endif
#line 6822 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6823
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6827
::exit(___);}
#if 0
#line 6823
{ 
#line 6824
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6826
return make_short4(v.x, v.y, v.z, v.w); 
#line 6827
} 
#endif
#line 6829 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6830
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6834
::exit(___);}
#if 0
#line 6830
{ 
#line 6831
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6833
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 6834
} 
#endif
#line 6842 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int texCubemapLayeredLod(texture< int, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6843
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6847
::exit(___);}
#if 0
#line 6843
{ 
#line 6844
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6846
return v.x; 
#line 6847
} 
#endif
#line 6849 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned texCubemapLayeredLod(texture< unsigned, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6850
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6854
::exit(___);}
#if 0
#line 6850
{ 
#line 6851
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6853
return v.x; 
#line 6854
} 
#endif
#line 6856 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 texCubemapLayeredLod(texture< int1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6857
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6861
::exit(___);}
#if 0
#line 6857
{ 
#line 6858
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6860
return make_int1(v.x); 
#line 6861
} 
#endif
#line 6863 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 texCubemapLayeredLod(texture< uint1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6864
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6868
::exit(___);}
#if 0
#line 6864
{ 
#line 6865
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6867
return make_uint1(v.x); 
#line 6868
} 
#endif
#line 6870 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 texCubemapLayeredLod(texture< int2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6871
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6875
::exit(___);}
#if 0
#line 6871
{ 
#line 6872
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6874
return make_int2(v.x, v.y); 
#line 6875
} 
#endif
#line 6877 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 texCubemapLayeredLod(texture< uint2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6878
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6882
::exit(___);}
#if 0
#line 6878
{ 
#line 6879
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6881
return make_uint2(v.x, v.y); 
#line 6882
} 
#endif
#line 6884 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 texCubemapLayeredLod(texture< int4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6885
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6889
::exit(___);}
#if 0
#line 6885
{ 
#line 6886
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6888
return make_int4(v.x, v.y, v.z, v.w); 
#line 6889
} 
#endif
#line 6891 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 texCubemapLayeredLod(texture< uint4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6892
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6896
::exit(___);}
#if 0
#line 6892
{ 
#line 6893
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6895
return make_uint4(v.x, v.y, v.z, v.w); 
#line 6896
} 
#endif
#line 6906 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long texCubemapLayeredLod(texture< long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6907
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6911
::exit(___);}
#if 0
#line 6907
{ 
#line 6908
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6910
return (long)(v.x); 
#line 6911
} 
#endif
#line 6913 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long texCubemapLayeredLod(texture< unsigned long, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6914
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6918
::exit(___);}
#if 0
#line 6914
{ 
#line 6915
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6917
return (unsigned long)(v.x); 
#line 6918
} 
#endif
#line 6920 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 texCubemapLayeredLod(texture< long1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6921
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6925
::exit(___);}
#if 0
#line 6921
{ 
#line 6922
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6924
return make_long1(v.x); 
#line 6925
} 
#endif
#line 6927 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 texCubemapLayeredLod(texture< ulong1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6928
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6932
::exit(___);}
#if 0
#line 6928
{ 
#line 6929
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6931
return make_ulong1(v.x); 
#line 6932
} 
#endif
#line 6934 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 texCubemapLayeredLod(texture< long2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6935
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6939
::exit(___);}
#if 0
#line 6935
{ 
#line 6936
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6938
return make_long2(v.x, v.y); 
#line 6939
} 
#endif
#line 6941 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 texCubemapLayeredLod(texture< ulong2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6942
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6946
::exit(___);}
#if 0
#line 6942
{ 
#line 6943
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6945
return make_ulong2(v.x, v.y); 
#line 6946
} 
#endif
#line 6948 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 texCubemapLayeredLod(texture< long4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6949
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6953
::exit(___);}
#if 0
#line 6949
{ 
#line 6950
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6952
return make_long4(v.x, v.y, v.z, v.w); 
#line 6953
} 
#endif
#line 6955 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 texCubemapLayeredLod(texture< ulong4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6956
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6960
::exit(___);}
#if 0
#line 6956
{ 
#line 6957
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6959
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 6960
} 
#endif
#line 6970 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayeredLod(texture< float, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6975
::exit(___);}
#if 0
#line 6971
{ 
#line 6972
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6974
return v.x; 
#line 6975
} 
#endif
#line 6977 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayeredLod(texture< float1, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6982
::exit(___);}
#if 0
#line 6978
{ 
#line 6979
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6981
return make_float1(v.x); 
#line 6982
} 
#endif
#line 6984 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayeredLod(texture< float2, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6985
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6989
::exit(___);}
#if 0
#line 6985
{ 
#line 6986
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6988
return make_float2(v.x, v.y); 
#line 6989
} 
#endif
#line 6991 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayeredLod(texture< float4, 252, cudaReadModeElementType>  t, float x, float y, float z, int layer, float level) 
#line 6992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 6996
::exit(___);}
#if 0
#line 6992
{ 
#line 6993
float4 v = __ftexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 6995
return make_float4(v.x, v.y, v.z, v.w); 
#line 6996
} 
#endif
#line 7004 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayeredLod(texture< char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7005
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7014 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 7005 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 7009 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7011 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7013
return w.x; 
#line 7014
} 
#endif
#line 7016 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayeredLod(texture< signed char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7017
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7022
::exit(___);}
#if 0
#line 7017
{ 
#line 7018
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7019
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7021
return w.x; 
#line 7022
} 
#endif
#line 7024 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayeredLod(texture< unsigned char, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7025
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7030
::exit(___);}
#if 0
#line 7025
{ 
#line 7026
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7027
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7029
return w.x; 
#line 7030
} 
#endif
#line 7032 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayeredLod(texture< char1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7033
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7038
::exit(___);}
#if 0
#line 7033
{ 
#line 7034
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7035
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7037
return make_float1(w.x); 
#line 7038
} 
#endif
#line 7040 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayeredLod(texture< uchar1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7041
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7046
::exit(___);}
#if 0
#line 7041
{ 
#line 7042
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7043
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7045
return make_float1(w.x); 
#line 7046
} 
#endif
#line 7048 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayeredLod(texture< char2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7049
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7054
::exit(___);}
#if 0
#line 7049
{ 
#line 7050
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7051
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7053
return make_float2(w.x, w.y); 
#line 7054
} 
#endif
#line 7056 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayeredLod(texture< uchar2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7057
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7062
::exit(___);}
#if 0
#line 7057
{ 
#line 7058
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7059
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7061
return make_float2(w.x, w.y); 
#line 7062
} 
#endif
#line 7064 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayeredLod(texture< char4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7065
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7070
::exit(___);}
#if 0
#line 7065
{ 
#line 7066
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7067
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7069
return make_float4(w.x, w.y, w.z, w.w); 
#line 7070
} 
#endif
#line 7072 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayeredLod(texture< uchar4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7073
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7078
::exit(___);}
#if 0
#line 7073
{ 
#line 7074
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7075
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7077
return make_float4(w.x, w.y, w.z, w.w); 
#line 7078
} 
#endif
#line 7086 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayeredLod(texture< short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7087
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7092
::exit(___);}
#if 0
#line 7087
{ 
#line 7088
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7089
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7091
return w.x; 
#line 7092
} 
#endif
#line 7094 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float texCubemapLayeredLod(texture< unsigned short, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7100
::exit(___);}
#if 0
#line 7095
{ 
#line 7096
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7097
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7099
return w.x; 
#line 7100
} 
#endif
#line 7102 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayeredLod(texture< short1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7103
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7108
::exit(___);}
#if 0
#line 7103
{ 
#line 7104
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7105
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7107
return make_float1(w.x); 
#line 7108
} 
#endif
#line 7110 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 texCubemapLayeredLod(texture< ushort1, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7111
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7116
::exit(___);}
#if 0
#line 7111
{ 
#line 7112
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7113
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7115
return make_float1(w.x); 
#line 7116
} 
#endif
#line 7118 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayeredLod(texture< short2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7119
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7124
::exit(___);}
#if 0
#line 7119
{ 
#line 7120
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7121
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7123
return make_float2(w.x, w.y); 
#line 7124
} 
#endif
#line 7126 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 texCubemapLayeredLod(texture< ushort2, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7127
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7132
::exit(___);}
#if 0
#line 7127
{ 
#line 7128
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7129
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7131
return make_float2(w.x, w.y); 
#line 7132
} 
#endif
#line 7134 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayeredLod(texture< short4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7135
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7140
::exit(___);}
#if 0
#line 7135
{ 
#line 7136
int4 v = __itexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7137
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7139
return make_float4(w.x, w.y, w.z, w.w); 
#line 7140
} 
#endif
#line 7142 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 texCubemapLayeredLod(texture< ushort4, 252, cudaReadModeNormalizedFloat>  t, float x, float y, float z, int layer, float level) 
#line 7143
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 7148
::exit(___);}
#if 0
#line 7143
{ 
#line 7144
uint4 v = __utexfetchlodlc(t, make_float4(x, y, z, 0), layer, level); 
#line 7145
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7147
return make_float4(w.x, w.y, w.z, w.w); 
#line 7148
} 
#endif
#line 7157 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1DGrad(texture< char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7158
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7166 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 7158 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 7162 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7165 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 7166
} 
#endif
#line 7168 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1DGrad(texture< signed char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7169
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7173
::exit(___);}
#if 0
#line 7169
{ 
#line 7170
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7172
return (signed char)(v.x); 
#line 7173
} 
#endif
#line 7175 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1DGrad(texture< unsigned char, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7176
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7180
::exit(___);}
#if 0
#line 7176
{ 
#line 7177
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7179
return (unsigned char)(v.x); 
#line 7180
} 
#endif
#line 7182 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1DGrad(texture< char1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7183
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7187
::exit(___);}
#if 0
#line 7183
{ 
#line 7184
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7186
return make_char1(v.x); 
#line 7187
} 
#endif
#line 7189 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1DGrad(texture< uchar1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7190
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7194
::exit(___);}
#if 0
#line 7190
{ 
#line 7191
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7193
return make_uchar1(v.x); 
#line 7194
} 
#endif
#line 7196 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1DGrad(texture< char2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7197
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7201
::exit(___);}
#if 0
#line 7197
{ 
#line 7198
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7200
return make_char2(v.x, v.y); 
#line 7201
} 
#endif
#line 7203 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1DGrad(texture< uchar2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7204
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7208
::exit(___);}
#if 0
#line 7204
{ 
#line 7205
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7207
return make_uchar2(v.x, v.y); 
#line 7208
} 
#endif
#line 7210 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1DGrad(texture< char4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7211
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7215
::exit(___);}
#if 0
#line 7211
{ 
#line 7212
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7214
return make_char4(v.x, v.y, v.z, v.w); 
#line 7215
} 
#endif
#line 7217 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1DGrad(texture< uchar4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7218
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7222
::exit(___);}
#if 0
#line 7218
{ 
#line 7219
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7221
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 7222
} 
#endif
#line 7230 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1DGrad(texture< short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7231
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7235
::exit(___);}
#if 0
#line 7231
{ 
#line 7232
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7234
return (short)(v.x); 
#line 7235
} 
#endif
#line 7237 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1DGrad(texture< unsigned short, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7238
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7242
::exit(___);}
#if 0
#line 7238
{ 
#line 7239
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7241
return (unsigned short)(v.x); 
#line 7242
} 
#endif
#line 7244 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1DGrad(texture< short1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7245
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7249
::exit(___);}
#if 0
#line 7245
{ 
#line 7246
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7248
return make_short1(v.x); 
#line 7249
} 
#endif
#line 7251 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1DGrad(texture< ushort1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7252
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7256
::exit(___);}
#if 0
#line 7252
{ 
#line 7253
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7255
return make_ushort1(v.x); 
#line 7256
} 
#endif
#line 7258 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1DGrad(texture< short2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7259
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7263
::exit(___);}
#if 0
#line 7259
{ 
#line 7260
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7262
return make_short2(v.x, v.y); 
#line 7263
} 
#endif
#line 7265 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1DGrad(texture< ushort2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7266
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7270
::exit(___);}
#if 0
#line 7266
{ 
#line 7267
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7269
return make_ushort2(v.x, v.y); 
#line 7270
} 
#endif
#line 7272 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1DGrad(texture< short4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7273
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7277
::exit(___);}
#if 0
#line 7273
{ 
#line 7274
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7276
return make_short4(v.x, v.y, v.z, v.w); 
#line 7277
} 
#endif
#line 7279 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1DGrad(texture< ushort4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7280
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7284
::exit(___);}
#if 0
#line 7280
{ 
#line 7281
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7283
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 7284
} 
#endif
#line 7292 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1DGrad(texture< int, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7293
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7297
::exit(___);}
#if 0
#line 7293
{ 
#line 7294
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7296
return v.x; 
#line 7297
} 
#endif
#line 7299 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1DGrad(texture< unsigned, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7300
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7304
::exit(___);}
#if 0
#line 7300
{ 
#line 7301
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7303
return v.x; 
#line 7304
} 
#endif
#line 7306 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1DGrad(texture< int1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7307
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7311
::exit(___);}
#if 0
#line 7307
{ 
#line 7308
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7310
return make_int1(v.x); 
#line 7311
} 
#endif
#line 7313 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1DGrad(texture< uint1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7314
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7318
::exit(___);}
#if 0
#line 7314
{ 
#line 7315
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7317
return make_uint1(v.x); 
#line 7318
} 
#endif
#line 7320 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1DGrad(texture< int2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7321
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7325
::exit(___);}
#if 0
#line 7321
{ 
#line 7322
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7324
return make_int2(v.x, v.y); 
#line 7325
} 
#endif
#line 7327 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1DGrad(texture< uint2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7328
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7332
::exit(___);}
#if 0
#line 7328
{ 
#line 7329
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7331
return make_uint2(v.x, v.y); 
#line 7332
} 
#endif
#line 7334 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1DGrad(texture< int4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7335
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7339
::exit(___);}
#if 0
#line 7335
{ 
#line 7336
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7338
return make_int4(v.x, v.y, v.z, v.w); 
#line 7339
} 
#endif
#line 7341 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1DGrad(texture< uint4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7342
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7346
::exit(___);}
#if 0
#line 7342
{ 
#line 7343
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7345
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7346
} 
#endif
#line 7362 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1DGrad(texture< long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7363
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7367
::exit(___);}
#if 0
#line 7363
{ 
#line 7364
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7366
return (long)(v.x); 
#line 7367
} 
#endif
#line 7369 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1DGrad(texture< unsigned long, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7370
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7374
::exit(___);}
#if 0
#line 7370
{ 
#line 7371
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7373
return (unsigned long)(v.x); 
#line 7374
} 
#endif
#line 7376 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1DGrad(texture< long1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7377
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7381
::exit(___);}
#if 0
#line 7377
{ 
#line 7378
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7380
return make_long1(v.x); 
#line 7381
} 
#endif
#line 7383 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1DGrad(texture< ulong1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7384
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7388
::exit(___);}
#if 0
#line 7384
{ 
#line 7385
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7387
return make_ulong1(v.x); 
#line 7388
} 
#endif
#line 7390 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1DGrad(texture< long2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7391
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7395
::exit(___);}
#if 0
#line 7391
{ 
#line 7392
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7394
return make_long2(v.x, v.y); 
#line 7395
} 
#endif
#line 7397 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1DGrad(texture< ulong2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7398
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7402
::exit(___);}
#if 0
#line 7398
{ 
#line 7399
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7401
return make_ulong2(v.x, v.y); 
#line 7402
} 
#endif
#line 7404 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1DGrad(texture< long4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7405
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7409
::exit(___);}
#if 0
#line 7405
{ 
#line 7406
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7408
return make_long4(v.x, v.y, v.z, v.w); 
#line 7409
} 
#endif
#line 7411 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1DGrad(texture< ulong4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7412
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7416
::exit(___);}
#if 0
#line 7412
{ 
#line 7413
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7415
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7416
} 
#endif
#line 7426 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DGrad(texture< float, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7427
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7431
::exit(___);}
#if 0
#line 7427
{ 
#line 7428
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7430
return v.x; 
#line 7431
} 
#endif
#line 7433 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DGrad(texture< float1, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7434
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7438
::exit(___);}
#if 0
#line 7434
{ 
#line 7435
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7437
return make_float1(v.x); 
#line 7438
} 
#endif
#line 7440 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DGrad(texture< float2, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7441
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7445
::exit(___);}
#if 0
#line 7441
{ 
#line 7442
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7444
return make_float2(v.x, v.y); 
#line 7445
} 
#endif
#line 7447 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DGrad(texture< float4, 1, cudaReadModeElementType>  t, float x, float dPdx, float dPdy) 
#line 7448
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7452
::exit(___);}
#if 0
#line 7448
{ 
#line 7449
float4 v = __ftexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7451
return make_float4(v.x, v.y, v.z, v.w); 
#line 7452
} 
#endif
#line 7460 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DGrad(texture< char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7461
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7470 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 7461 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 7465 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7467 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7469
return w.x; 
#line 7470
} 
#endif
#line 7472 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DGrad(texture< signed char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7473
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7478
::exit(___);}
#if 0
#line 7473
{ 
#line 7474
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7475
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7477
return w.x; 
#line 7478
} 
#endif
#line 7480 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DGrad(texture< unsigned char, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7481
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7486
::exit(___);}
#if 0
#line 7481
{ 
#line 7482
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7483
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7485
return w.x; 
#line 7486
} 
#endif
#line 7488 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DGrad(texture< char1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7489
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7494
::exit(___);}
#if 0
#line 7489
{ 
#line 7490
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7491
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7493
return make_float1(w.x); 
#line 7494
} 
#endif
#line 7496 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DGrad(texture< uchar1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7497
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7502
::exit(___);}
#if 0
#line 7497
{ 
#line 7498
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7499
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7501
return make_float1(w.x); 
#line 7502
} 
#endif
#line 7504 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DGrad(texture< char2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7505
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7510
::exit(___);}
#if 0
#line 7505
{ 
#line 7506
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7507
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7509
return make_float2(w.x, w.y); 
#line 7510
} 
#endif
#line 7512 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DGrad(texture< uchar2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7513
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7518
::exit(___);}
#if 0
#line 7513
{ 
#line 7514
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7515
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7517
return make_float2(w.x, w.y); 
#line 7518
} 
#endif
#line 7520 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DGrad(texture< char4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7521
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7526
::exit(___);}
#if 0
#line 7521
{ 
#line 7522
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7523
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7525
return make_float4(w.x, w.y, w.z, w.w); 
#line 7526
} 
#endif
#line 7528 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DGrad(texture< uchar4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7529
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7534
::exit(___);}
#if 0
#line 7529
{ 
#line 7530
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7531
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7533
return make_float4(w.x, w.y, w.z, w.w); 
#line 7534
} 
#endif
#line 7542 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DGrad(texture< short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7543
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7548
::exit(___);}
#if 0
#line 7543
{ 
#line 7544
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7545
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7547
return w.x; 
#line 7548
} 
#endif
#line 7550 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DGrad(texture< unsigned short, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7551
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7556
::exit(___);}
#if 0
#line 7551
{ 
#line 7552
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7553
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7555
return w.x; 
#line 7556
} 
#endif
#line 7558 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DGrad(texture< short1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7559
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7564
::exit(___);}
#if 0
#line 7559
{ 
#line 7560
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7561
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7563
return make_float1(w.x); 
#line 7564
} 
#endif
#line 7566 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DGrad(texture< ushort1, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7567
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7572
::exit(___);}
#if 0
#line 7567
{ 
#line 7568
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7569
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7571
return make_float1(w.x); 
#line 7572
} 
#endif
#line 7574 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DGrad(texture< short2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7575
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7580
::exit(___);}
#if 0
#line 7575
{ 
#line 7576
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7577
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7579
return make_float2(w.x, w.y); 
#line 7580
} 
#endif
#line 7582 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DGrad(texture< ushort2, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7583
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7588
::exit(___);}
#if 0
#line 7583
{ 
#line 7584
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7585
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7587
return make_float2(w.x, w.y); 
#line 7588
} 
#endif
#line 7590 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DGrad(texture< short4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7591
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7596
::exit(___);}
#if 0
#line 7591
{ 
#line 7592
int4 v = __itexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7593
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7595
return make_float4(w.x, w.y, w.z, w.w); 
#line 7596
} 
#endif
#line 7598 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DGrad(texture< ushort4, 1, cudaReadModeNormalizedFloat>  t, float x, float dPdx, float dPdy) 
#line 7599
{int volatile ___ = 1;(void)t;(void)x;(void)dPdx;(void)dPdy;
#line 7604
::exit(___);}
#if 0
#line 7599
{ 
#line 7600
uint4 v = __utexfetchgrad(t, make_float4(x, 0, 0, 0), make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 7601
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7603
return make_float4(w.x, w.y, w.z, w.w); 
#line 7604
} 
#endif
#line 7612 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex2DGrad(texture< char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7613
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7621 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 7613 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 7617 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7620 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 7621
} 
#endif
#line 7623 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex2DGrad(texture< signed char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7624
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7628
::exit(___);}
#if 0
#line 7624
{ 
#line 7625
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7627
return (signed char)(v.x); 
#line 7628
} 
#endif
#line 7630 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex2DGrad(texture< unsigned char, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7631
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7635
::exit(___);}
#if 0
#line 7631
{ 
#line 7632
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7634
return (unsigned char)(v.x); 
#line 7635
} 
#endif
#line 7637 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex2DGrad(texture< char1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7638
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7642
::exit(___);}
#if 0
#line 7638
{ 
#line 7639
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7641
return make_char1(v.x); 
#line 7642
} 
#endif
#line 7644 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex2DGrad(texture< uchar1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7645
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7649
::exit(___);}
#if 0
#line 7645
{ 
#line 7646
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7648
return make_uchar1(v.x); 
#line 7649
} 
#endif
#line 7651 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex2DGrad(texture< char2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7652
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7656
::exit(___);}
#if 0
#line 7652
{ 
#line 7653
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7655
return make_char2(v.x, v.y); 
#line 7656
} 
#endif
#line 7658 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex2DGrad(texture< uchar2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7659
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7663
::exit(___);}
#if 0
#line 7659
{ 
#line 7660
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7662
return make_uchar2(v.x, v.y); 
#line 7663
} 
#endif
#line 7665 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2DGrad(texture< char4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7666
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7670
::exit(___);}
#if 0
#line 7666
{ 
#line 7667
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7669
return make_char4(v.x, v.y, v.z, v.w); 
#line 7670
} 
#endif
#line 7672 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2DGrad(texture< uchar4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7673
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7677
::exit(___);}
#if 0
#line 7673
{ 
#line 7674
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7676
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 7677
} 
#endif
#line 7685 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex2DGrad(texture< short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7686
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7690
::exit(___);}
#if 0
#line 7686
{ 
#line 7687
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7689
return (short)(v.x); 
#line 7690
} 
#endif
#line 7692 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex2DGrad(texture< unsigned short, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7693
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7697
::exit(___);}
#if 0
#line 7693
{ 
#line 7694
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7696
return (unsigned short)(v.x); 
#line 7697
} 
#endif
#line 7699 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex2DGrad(texture< short1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7700
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7704
::exit(___);}
#if 0
#line 7700
{ 
#line 7701
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7703
return make_short1(v.x); 
#line 7704
} 
#endif
#line 7706 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex2DGrad(texture< ushort1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7707
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7711
::exit(___);}
#if 0
#line 7707
{ 
#line 7708
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7710
return make_ushort1(v.x); 
#line 7711
} 
#endif
#line 7713 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex2DGrad(texture< short2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7714
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7718
::exit(___);}
#if 0
#line 7714
{ 
#line 7715
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7717
return make_short2(v.x, v.y); 
#line 7718
} 
#endif
#line 7720 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex2DGrad(texture< ushort2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7721
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7725
::exit(___);}
#if 0
#line 7721
{ 
#line 7722
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7724
return make_ushort2(v.x, v.y); 
#line 7725
} 
#endif
#line 7727 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2DGrad(texture< short4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7728
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7732
::exit(___);}
#if 0
#line 7728
{ 
#line 7729
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7731
return make_short4(v.x, v.y, v.z, v.w); 
#line 7732
} 
#endif
#line 7734 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2DGrad(texture< ushort4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7735
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7739
::exit(___);}
#if 0
#line 7735
{ 
#line 7736
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7738
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 7739
} 
#endif
#line 7747 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex2DGrad(texture< int, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7748
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7752
::exit(___);}
#if 0
#line 7748
{ 
#line 7749
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7751
return v.x; 
#line 7752
} 
#endif
#line 7754 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex2DGrad(texture< unsigned, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7755
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7759
::exit(___);}
#if 0
#line 7755
{ 
#line 7756
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7758
return v.x; 
#line 7759
} 
#endif
#line 7761 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex2DGrad(texture< int1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7762
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7766
::exit(___);}
#if 0
#line 7762
{ 
#line 7763
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7765
return make_int1(v.x); 
#line 7766
} 
#endif
#line 7768 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex2DGrad(texture< uint1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7769
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7773
::exit(___);}
#if 0
#line 7769
{ 
#line 7770
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7772
return make_uint1(v.x); 
#line 7773
} 
#endif
#line 7775 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex2DGrad(texture< int2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7776
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7780
::exit(___);}
#if 0
#line 7776
{ 
#line 7777
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7779
return make_int2(v.x, v.y); 
#line 7780
} 
#endif
#line 7782 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex2DGrad(texture< uint2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7783
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7787
::exit(___);}
#if 0
#line 7783
{ 
#line 7784
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7786
return make_uint2(v.x, v.y); 
#line 7787
} 
#endif
#line 7789 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2DGrad(texture< int4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7790
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7794
::exit(___);}
#if 0
#line 7790
{ 
#line 7791
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7793
return make_int4(v.x, v.y, v.z, v.w); 
#line 7794
} 
#endif
#line 7796 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2DGrad(texture< uint4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7797
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7801
::exit(___);}
#if 0
#line 7797
{ 
#line 7798
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7800
return make_uint4(v.x, v.y, v.z, v.w); 
#line 7801
} 
#endif
#line 7811 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex2DGrad(texture< long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7812
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7816
::exit(___);}
#if 0
#line 7812
{ 
#line 7813
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7815
return (long)(v.x); 
#line 7816
} 
#endif
#line 7818 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex2DGrad(texture< unsigned long, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7819
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7823
::exit(___);}
#if 0
#line 7819
{ 
#line 7820
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7822
return (unsigned long)(v.x); 
#line 7823
} 
#endif
#line 7825 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex2DGrad(texture< long1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7826
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7830
::exit(___);}
#if 0
#line 7826
{ 
#line 7827
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7829
return make_long1(v.x); 
#line 7830
} 
#endif
#line 7832 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex2DGrad(texture< ulong1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7833
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7837
::exit(___);}
#if 0
#line 7833
{ 
#line 7834
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7836
return make_ulong1(v.x); 
#line 7837
} 
#endif
#line 7839 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex2DGrad(texture< long2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7840
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7844
::exit(___);}
#if 0
#line 7840
{ 
#line 7841
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7843
return make_long2(v.x, v.y); 
#line 7844
} 
#endif
#line 7846 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex2DGrad(texture< ulong2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7847
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7851
::exit(___);}
#if 0
#line 7847
{ 
#line 7848
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7850
return make_ulong2(v.x, v.y); 
#line 7851
} 
#endif
#line 7853 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex2DGrad(texture< long4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7854
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7858
::exit(___);}
#if 0
#line 7854
{ 
#line 7855
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7857
return make_long4(v.x, v.y, v.z, v.w); 
#line 7858
} 
#endif
#line 7860 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex2DGrad(texture< ulong4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7861
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7865
::exit(___);}
#if 0
#line 7861
{ 
#line 7862
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7864
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 7865
} 
#endif
#line 7875 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DGrad(texture< float, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7876
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7880
::exit(___);}
#if 0
#line 7876
{ 
#line 7877
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7879
return v.x; 
#line 7880
} 
#endif
#line 7882 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DGrad(texture< float1, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7883
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7887
::exit(___);}
#if 0
#line 7883
{ 
#line 7884
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7886
return make_float1(v.x); 
#line 7887
} 
#endif
#line 7889 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DGrad(texture< float2, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7894
::exit(___);}
#if 0
#line 7890
{ 
#line 7891
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7893
return make_float2(v.x, v.y); 
#line 7894
} 
#endif
#line 7896 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DGrad(texture< float4, 2, cudaReadModeElementType>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7897
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7901
::exit(___);}
#if 0
#line 7897
{ 
#line 7898
float4 v = __ftexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7900
return make_float4(v.x, v.y, v.z, v.w); 
#line 7901
} 
#endif
#line 7909 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DGrad(texture< char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7910
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7919 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 7910 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 7914 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7916 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7918
return w.x; 
#line 7919
} 
#endif
#line 7921 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DGrad(texture< signed char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7922
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7927
::exit(___);}
#if 0
#line 7922
{ 
#line 7923
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7924
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7926
return w.x; 
#line 7927
} 
#endif
#line 7929 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DGrad(texture< unsigned char, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7930
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7935
::exit(___);}
#if 0
#line 7930
{ 
#line 7931
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7932
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7934
return w.x; 
#line 7935
} 
#endif
#line 7937 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DGrad(texture< char1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7943
::exit(___);}
#if 0
#line 7938
{ 
#line 7939
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7940
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7942
return make_float1(w.x); 
#line 7943
} 
#endif
#line 7945 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DGrad(texture< uchar1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7951
::exit(___);}
#if 0
#line 7946
{ 
#line 7947
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7948
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7950
return make_float1(w.x); 
#line 7951
} 
#endif
#line 7953 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DGrad(texture< char2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7954
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7959
::exit(___);}
#if 0
#line 7954
{ 
#line 7955
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7956
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7958
return make_float2(w.x, w.y); 
#line 7959
} 
#endif
#line 7961 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DGrad(texture< uchar2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7962
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7967
::exit(___);}
#if 0
#line 7962
{ 
#line 7963
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7964
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7966
return make_float2(w.x, w.y); 
#line 7967
} 
#endif
#line 7969 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DGrad(texture< char4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7970
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7975
::exit(___);}
#if 0
#line 7970
{ 
#line 7971
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7972
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7974
return make_float4(w.x, w.y, w.z, w.w); 
#line 7975
} 
#endif
#line 7977 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DGrad(texture< uchar4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7983
::exit(___);}
#if 0
#line 7978
{ 
#line 7979
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7980
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7982
return make_float4(w.x, w.y, w.z, w.w); 
#line 7983
} 
#endif
#line 7991 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DGrad(texture< short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 7992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 7997
::exit(___);}
#if 0
#line 7992
{ 
#line 7993
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 7994
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 7996
return w.x; 
#line 7997
} 
#endif
#line 7999 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DGrad(texture< unsigned short, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8000
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8005
::exit(___);}
#if 0
#line 8000
{ 
#line 8001
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8002
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8004
return w.x; 
#line 8005
} 
#endif
#line 8007 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DGrad(texture< short1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8008
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8013
::exit(___);}
#if 0
#line 8008
{ 
#line 8009
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8010
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8012
return make_float1(w.x); 
#line 8013
} 
#endif
#line 8015 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DGrad(texture< ushort1, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8016
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8021
::exit(___);}
#if 0
#line 8016
{ 
#line 8017
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8018
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8020
return make_float1(w.x); 
#line 8021
} 
#endif
#line 8023 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DGrad(texture< short2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8024
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8029
::exit(___);}
#if 0
#line 8024
{ 
#line 8025
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8026
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8028
return make_float2(w.x, w.y); 
#line 8029
} 
#endif
#line 8031 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DGrad(texture< ushort2, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8032
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8037
::exit(___);}
#if 0
#line 8032
{ 
#line 8033
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8034
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8036
return make_float2(w.x, w.y); 
#line 8037
} 
#endif
#line 8039 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DGrad(texture< short4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8045
::exit(___);}
#if 0
#line 8040
{ 
#line 8041
int4 v = __itexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8042
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8044
return make_float4(w.x, w.y, w.z, w.w); 
#line 8045
} 
#endif
#line 8047 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DGrad(texture< ushort4, 2, cudaReadModeNormalizedFloat>  t, float x, float y, float2 dPdx, float2 dPdy) 
#line 8048
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 8053
::exit(___);}
#if 0
#line 8048
{ 
#line 8049
uint4 v = __utexfetchgrad(t, make_float4(x, y, 0, 0), make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8050
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8052
return make_float4(w.x, w.y, w.z, w.w); 
#line 8053
} 
#endif
#line 8061 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex1DLayeredGrad(texture< char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8062
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8070 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 8062 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 8066 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8069 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 8070
} 
#endif
#line 8072 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex1DLayeredGrad(texture< signed char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8073
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8077
::exit(___);}
#if 0
#line 8073
{ 
#line 8074
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8076
return (signed char)(v.x); 
#line 8077
} 
#endif
#line 8079 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8080
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8084
::exit(___);}
#if 0
#line 8080
{ 
#line 8081
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8083
return (unsigned char)(v.x); 
#line 8084
} 
#endif
#line 8086 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8087
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8091
::exit(___);}
#if 0
#line 8087
{ 
#line 8088
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8090
return make_char1(v.x); 
#line 8091
} 
#endif
#line 8093 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8094
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8098
::exit(___);}
#if 0
#line 8094
{ 
#line 8095
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8097
return make_uchar1(v.x); 
#line 8098
} 
#endif
#line 8100 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8101
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8105
::exit(___);}
#if 0
#line 8101
{ 
#line 8102
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8104
return make_char2(v.x, v.y); 
#line 8105
} 
#endif
#line 8107 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8108
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8112
::exit(___);}
#if 0
#line 8108
{ 
#line 8109
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8111
return make_uchar2(v.x, v.y); 
#line 8112
} 
#endif
#line 8114 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8115
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8119
::exit(___);}
#if 0
#line 8115
{ 
#line 8116
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8118
return make_char4(v.x, v.y, v.z, v.w); 
#line 8119
} 
#endif
#line 8121 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8122
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8126
::exit(___);}
#if 0
#line 8122
{ 
#line 8123
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8125
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 8126
} 
#endif
#line 8134 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex1DLayeredGrad(texture< short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8135
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8139
::exit(___);}
#if 0
#line 8135
{ 
#line 8136
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8138
return (short)(v.x); 
#line 8139
} 
#endif
#line 8141 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8142
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8146
::exit(___);}
#if 0
#line 8142
{ 
#line 8143
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8145
return (unsigned short)(v.x); 
#line 8146
} 
#endif
#line 8148 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8149
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8153
::exit(___);}
#if 0
#line 8149
{ 
#line 8150
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8152
return make_short1(v.x); 
#line 8153
} 
#endif
#line 8155 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8156
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8160
::exit(___);}
#if 0
#line 8156
{ 
#line 8157
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8159
return make_ushort1(v.x); 
#line 8160
} 
#endif
#line 8162 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8163
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8167
::exit(___);}
#if 0
#line 8163
{ 
#line 8164
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8166
return make_short2(v.x, v.y); 
#line 8167
} 
#endif
#line 8169 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8170
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8174
::exit(___);}
#if 0
#line 8170
{ 
#line 8171
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8173
return make_ushort2(v.x, v.y); 
#line 8174
} 
#endif
#line 8176 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8177
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8181
::exit(___);}
#if 0
#line 8177
{ 
#line 8178
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8180
return make_short4(v.x, v.y, v.z, v.w); 
#line 8181
} 
#endif
#line 8183 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8184
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8188
::exit(___);}
#if 0
#line 8184
{ 
#line 8185
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8187
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 8188
} 
#endif
#line 8196 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex1DLayeredGrad(texture< int, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8197
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8201
::exit(___);}
#if 0
#line 8197
{ 
#line 8198
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8200
return v.x; 
#line 8201
} 
#endif
#line 8203 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex1DLayeredGrad(texture< unsigned, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8204
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8208
::exit(___);}
#if 0
#line 8204
{ 
#line 8205
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8207
return v.x; 
#line 8208
} 
#endif
#line 8210 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex1DLayeredGrad(texture< int1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8211
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8215
::exit(___);}
#if 0
#line 8211
{ 
#line 8212
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8214
return make_int1(v.x); 
#line 8215
} 
#endif
#line 8217 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex1DLayeredGrad(texture< uint1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8218
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8222
::exit(___);}
#if 0
#line 8218
{ 
#line 8219
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8221
return make_uint1(v.x); 
#line 8222
} 
#endif
#line 8224 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex1DLayeredGrad(texture< int2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8225
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8229
::exit(___);}
#if 0
#line 8225
{ 
#line 8226
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8228
return make_int2(v.x, v.y); 
#line 8229
} 
#endif
#line 8231 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex1DLayeredGrad(texture< uint2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8232
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8236
::exit(___);}
#if 0
#line 8232
{ 
#line 8233
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8235
return make_uint2(v.x, v.y); 
#line 8236
} 
#endif
#line 8238 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex1DLayeredGrad(texture< int4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8239
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8243
::exit(___);}
#if 0
#line 8239
{ 
#line 8240
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8242
return make_int4(v.x, v.y, v.z, v.w); 
#line 8243
} 
#endif
#line 8245 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex1DLayeredGrad(texture< uint4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8246
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8250
::exit(___);}
#if 0
#line 8246
{ 
#line 8247
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8249
return make_uint4(v.x, v.y, v.z, v.w); 
#line 8250
} 
#endif
#line 8260 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex1DLayeredGrad(texture< long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8261
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8265
::exit(___);}
#if 0
#line 8261
{ 
#line 8262
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8264
return (long)(v.x); 
#line 8265
} 
#endif
#line 8267 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex1DLayeredGrad(texture< unsigned long, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8268
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8272
::exit(___);}
#if 0
#line 8268
{ 
#line 8269
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8271
return (unsigned long)(v.x); 
#line 8272
} 
#endif
#line 8274 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex1DLayeredGrad(texture< long1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8275
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8279
::exit(___);}
#if 0
#line 8275
{ 
#line 8276
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8278
return make_long1(v.x); 
#line 8279
} 
#endif
#line 8281 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex1DLayeredGrad(texture< ulong1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8282
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8286
::exit(___);}
#if 0
#line 8282
{ 
#line 8283
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8285
return make_ulong1(v.x); 
#line 8286
} 
#endif
#line 8288 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex1DLayeredGrad(texture< long2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8289
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8293
::exit(___);}
#if 0
#line 8289
{ 
#line 8290
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8292
return make_long2(v.x, v.y); 
#line 8293
} 
#endif
#line 8295 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex1DLayeredGrad(texture< ulong2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8296
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8300
::exit(___);}
#if 0
#line 8296
{ 
#line 8297
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8299
return make_ulong2(v.x, v.y); 
#line 8300
} 
#endif
#line 8302 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex1DLayeredGrad(texture< long4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8303
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8307
::exit(___);}
#if 0
#line 8303
{ 
#line 8304
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8306
return make_long4(v.x, v.y, v.z, v.w); 
#line 8307
} 
#endif
#line 8309 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex1DLayeredGrad(texture< ulong4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8310
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8314
::exit(___);}
#if 0
#line 8310
{ 
#line 8311
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8313
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 8314
} 
#endif
#line 8324 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredGrad(texture< float, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8325
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8329
::exit(___);}
#if 0
#line 8325
{ 
#line 8326
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8328
return v.x; 
#line 8329
} 
#endif
#line 8331 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredGrad(texture< float1, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8332
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8336
::exit(___);}
#if 0
#line 8332
{ 
#line 8333
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8335
return make_float1(v.x); 
#line 8336
} 
#endif
#line 8338 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredGrad(texture< float2, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8339
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8343
::exit(___);}
#if 0
#line 8339
{ 
#line 8340
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8342
return make_float2(v.x, v.y); 
#line 8343
} 
#endif
#line 8345 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredGrad(texture< float4, 241, cudaReadModeElementType>  t, float x, int layer, float dPdx, float dPdy) 
#line 8346
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8350
::exit(___);}
#if 0
#line 8346
{ 
#line 8347
float4 v = __ftexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8349
return make_float4(v.x, v.y, v.z, v.w); 
#line 8350
} 
#endif
#line 8358 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredGrad(texture< char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8359
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8368 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 8359 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 8363 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8365 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8367
return w.x; 
#line 8368
} 
#endif
#line 8370 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredGrad(texture< signed char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8371
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8376
::exit(___);}
#if 0
#line 8371
{ 
#line 8372
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8373
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8375
return w.x; 
#line 8376
} 
#endif
#line 8378 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredGrad(texture< unsigned char, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8379
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8384
::exit(___);}
#if 0
#line 8379
{ 
#line 8380
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8381
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8383
return w.x; 
#line 8384
} 
#endif
#line 8386 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredGrad(texture< char1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8387
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8392
::exit(___);}
#if 0
#line 8387
{ 
#line 8388
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8389
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8391
return make_float1(w.x); 
#line 8392
} 
#endif
#line 8394 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredGrad(texture< uchar1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8395
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8400
::exit(___);}
#if 0
#line 8395
{ 
#line 8396
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8397
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8399
return make_float1(w.x); 
#line 8400
} 
#endif
#line 8402 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredGrad(texture< char2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8403
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8408
::exit(___);}
#if 0
#line 8403
{ 
#line 8404
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8405
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8407
return make_float2(w.x, w.y); 
#line 8408
} 
#endif
#line 8410 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredGrad(texture< uchar2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8411
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8416
::exit(___);}
#if 0
#line 8411
{ 
#line 8412
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8413
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8415
return make_float2(w.x, w.y); 
#line 8416
} 
#endif
#line 8418 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredGrad(texture< char4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8419
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8424
::exit(___);}
#if 0
#line 8419
{ 
#line 8420
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8421
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8423
return make_float4(w.x, w.y, w.z, w.w); 
#line 8424
} 
#endif
#line 8426 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredGrad(texture< uchar4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8427
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8432
::exit(___);}
#if 0
#line 8427
{ 
#line 8428
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8429
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8431
return make_float4(w.x, w.y, w.z, w.w); 
#line 8432
} 
#endif
#line 8440 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredGrad(texture< short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8441
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8446
::exit(___);}
#if 0
#line 8441
{ 
#line 8442
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8443
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8445
return w.x; 
#line 8446
} 
#endif
#line 8448 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex1DLayeredGrad(texture< unsigned short, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8449
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8454
::exit(___);}
#if 0
#line 8449
{ 
#line 8450
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8451
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8453
return w.x; 
#line 8454
} 
#endif
#line 8456 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredGrad(texture< short1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8457
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8462
::exit(___);}
#if 0
#line 8457
{ 
#line 8458
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8459
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8461
return make_float1(w.x); 
#line 8462
} 
#endif
#line 8464 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex1DLayeredGrad(texture< ushort1, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8465
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8470
::exit(___);}
#if 0
#line 8465
{ 
#line 8466
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8467
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8469
return make_float1(w.x); 
#line 8470
} 
#endif
#line 8472 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredGrad(texture< short2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8473
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8478
::exit(___);}
#if 0
#line 8473
{ 
#line 8474
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8475
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8477
return make_float2(w.x, w.y); 
#line 8478
} 
#endif
#line 8480 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex1DLayeredGrad(texture< ushort2, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8481
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8486
::exit(___);}
#if 0
#line 8481
{ 
#line 8482
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8483
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8485
return make_float2(w.x, w.y); 
#line 8486
} 
#endif
#line 8488 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredGrad(texture< short4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8489
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8494
::exit(___);}
#if 0
#line 8489
{ 
#line 8490
int4 v = __itexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8491
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8493
return make_float4(w.x, w.y, w.z, w.w); 
#line 8494
} 
#endif
#line 8496 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex1DLayeredGrad(texture< ushort4, 241, cudaReadModeNormalizedFloat>  t, float x, int layer, float dPdx, float dPdy) 
#line 8497
{int volatile ___ = 1;(void)t;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 8502
::exit(___);}
#if 0
#line 8497
{ 
#line 8498
uint4 v = __utexfetchgradl(t, make_float4(x, 0, 0, 0), layer, make_float4(dPdx, 0, 0, 0), make_float4(dPdy, 0, 0, 0)); 
#line 8499
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8501
return make_float4(w.x, w.y, w.z, w.w); 
#line 8502
} 
#endif
#line 8510 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex2DLayeredGrad(texture< char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8511
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8519 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 8511 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 8515 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8518 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 8519
} 
#endif
#line 8521 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex2DLayeredGrad(texture< signed char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8522
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8526
::exit(___);}
#if 0
#line 8522
{ 
#line 8523
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8525
return (signed char)(v.x); 
#line 8526
} 
#endif
#line 8528 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8529
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8533
::exit(___);}
#if 0
#line 8529
{ 
#line 8530
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8532
return (unsigned char)(v.x); 
#line 8533
} 
#endif
#line 8535 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8536
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8540
::exit(___);}
#if 0
#line 8536
{ 
#line 8537
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8539
return make_char1(v.x); 
#line 8540
} 
#endif
#line 8542 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8543
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8547
::exit(___);}
#if 0
#line 8543
{ 
#line 8544
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8546
return make_uchar1(v.x); 
#line 8547
} 
#endif
#line 8549 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8550
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8554
::exit(___);}
#if 0
#line 8550
{ 
#line 8551
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8553
return make_char2(v.x, v.y); 
#line 8554
} 
#endif
#line 8556 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8557
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8561
::exit(___);}
#if 0
#line 8557
{ 
#line 8558
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8560
return make_uchar2(v.x, v.y); 
#line 8561
} 
#endif
#line 8563 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8564
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8568
::exit(___);}
#if 0
#line 8564
{ 
#line 8565
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8567
return make_char4(v.x, v.y, v.z, v.w); 
#line 8568
} 
#endif
#line 8570 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8571
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8575
::exit(___);}
#if 0
#line 8571
{ 
#line 8572
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8574
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 8575
} 
#endif
#line 8583 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex2DLayeredGrad(texture< short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8584
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8588
::exit(___);}
#if 0
#line 8584
{ 
#line 8585
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8587
return (short)(v.x); 
#line 8588
} 
#endif
#line 8590 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8591
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8595
::exit(___);}
#if 0
#line 8591
{ 
#line 8592
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8594
return (unsigned short)(v.x); 
#line 8595
} 
#endif
#line 8597 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8598
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8602
::exit(___);}
#if 0
#line 8598
{ 
#line 8599
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8601
return make_short1(v.x); 
#line 8602
} 
#endif
#line 8604 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8605
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8609
::exit(___);}
#if 0
#line 8605
{ 
#line 8606
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8608
return make_ushort1(v.x); 
#line 8609
} 
#endif
#line 8611 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8612
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8616
::exit(___);}
#if 0
#line 8612
{ 
#line 8613
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8615
return make_short2(v.x, v.y); 
#line 8616
} 
#endif
#line 8618 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8619
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8623
::exit(___);}
#if 0
#line 8619
{ 
#line 8620
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8622
return make_ushort2(v.x, v.y); 
#line 8623
} 
#endif
#line 8625 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8626
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8630
::exit(___);}
#if 0
#line 8626
{ 
#line 8627
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8629
return make_short4(v.x, v.y, v.z, v.w); 
#line 8630
} 
#endif
#line 8632 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8633
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8637
::exit(___);}
#if 0
#line 8633
{ 
#line 8634
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8636
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 8637
} 
#endif
#line 8645 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex2DLayeredGrad(texture< int, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8646
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8650
::exit(___);}
#if 0
#line 8646
{ 
#line 8647
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8649
return v.x; 
#line 8650
} 
#endif
#line 8652 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex2DLayeredGrad(texture< unsigned, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8653
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8657
::exit(___);}
#if 0
#line 8653
{ 
#line 8654
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8656
return v.x; 
#line 8657
} 
#endif
#line 8659 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex2DLayeredGrad(texture< int1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8660
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8664
::exit(___);}
#if 0
#line 8660
{ 
#line 8661
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8663
return make_int1(v.x); 
#line 8664
} 
#endif
#line 8666 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex2DLayeredGrad(texture< uint1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8667
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8671
::exit(___);}
#if 0
#line 8667
{ 
#line 8668
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8670
return make_uint1(v.x); 
#line 8671
} 
#endif
#line 8673 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex2DLayeredGrad(texture< int2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8674
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8678
::exit(___);}
#if 0
#line 8674
{ 
#line 8675
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8677
return make_int2(v.x, v.y); 
#line 8678
} 
#endif
#line 8680 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex2DLayeredGrad(texture< uint2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8681
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8685
::exit(___);}
#if 0
#line 8681
{ 
#line 8682
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8684
return make_uint2(v.x, v.y); 
#line 8685
} 
#endif
#line 8687 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex2DLayeredGrad(texture< int4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8688
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8692
::exit(___);}
#if 0
#line 8688
{ 
#line 8689
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8691
return make_int4(v.x, v.y, v.z, v.w); 
#line 8692
} 
#endif
#line 8694 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex2DLayeredGrad(texture< uint4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8695
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8699
::exit(___);}
#if 0
#line 8695
{ 
#line 8696
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8698
return make_uint4(v.x, v.y, v.z, v.w); 
#line 8699
} 
#endif
#line 8709 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex2DLayeredGrad(texture< long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8710
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8714
::exit(___);}
#if 0
#line 8710
{ 
#line 8711
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8713
return (long)(v.x); 
#line 8714
} 
#endif
#line 8716 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex2DLayeredGrad(texture< unsigned long, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8717
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8721
::exit(___);}
#if 0
#line 8717
{ 
#line 8718
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8720
return (unsigned long)(v.x); 
#line 8721
} 
#endif
#line 8723 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex2DLayeredGrad(texture< long1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8724
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8728
::exit(___);}
#if 0
#line 8724
{ 
#line 8725
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8727
return make_long1(v.x); 
#line 8728
} 
#endif
#line 8730 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex2DLayeredGrad(texture< ulong1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8731
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8735
::exit(___);}
#if 0
#line 8731
{ 
#line 8732
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8734
return make_ulong1(v.x); 
#line 8735
} 
#endif
#line 8737 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex2DLayeredGrad(texture< long2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8738
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8742
::exit(___);}
#if 0
#line 8738
{ 
#line 8739
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8741
return make_long2(v.x, v.y); 
#line 8742
} 
#endif
#line 8744 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex2DLayeredGrad(texture< ulong2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8745
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8749
::exit(___);}
#if 0
#line 8745
{ 
#line 8746
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8748
return make_ulong2(v.x, v.y); 
#line 8749
} 
#endif
#line 8751 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex2DLayeredGrad(texture< long4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8752
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8756
::exit(___);}
#if 0
#line 8752
{ 
#line 8753
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8755
return make_long4(v.x, v.y, v.z, v.w); 
#line 8756
} 
#endif
#line 8758 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex2DLayeredGrad(texture< ulong4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8759
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8763
::exit(___);}
#if 0
#line 8759
{ 
#line 8760
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8762
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 8763
} 
#endif
#line 8773 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredGrad(texture< float, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8774
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8778
::exit(___);}
#if 0
#line 8774
{ 
#line 8775
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8777
return v.x; 
#line 8778
} 
#endif
#line 8780 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredGrad(texture< float1, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8781
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8785
::exit(___);}
#if 0
#line 8781
{ 
#line 8782
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8784
return make_float1(v.x); 
#line 8785
} 
#endif
#line 8787 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredGrad(texture< float2, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8788
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8792
::exit(___);}
#if 0
#line 8788
{ 
#line 8789
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8791
return make_float2(v.x, v.y); 
#line 8792
} 
#endif
#line 8794 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredGrad(texture< float4, 242, cudaReadModeElementType>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8795
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8799
::exit(___);}
#if 0
#line 8795
{ 
#line 8796
float4 v = __ftexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8798
return make_float4(v.x, v.y, v.z, v.w); 
#line 8799
} 
#endif
#line 8807 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredGrad(texture< char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8808
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8817 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 8808 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 8812 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8814 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8816
return w.x; 
#line 8817
} 
#endif
#line 8819 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredGrad(texture< signed char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8820
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8825
::exit(___);}
#if 0
#line 8820
{ 
#line 8821
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8822
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8824
return w.x; 
#line 8825
} 
#endif
#line 8827 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredGrad(texture< unsigned char, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8828
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8833
::exit(___);}
#if 0
#line 8828
{ 
#line 8829
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8830
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8832
return w.x; 
#line 8833
} 
#endif
#line 8835 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredGrad(texture< char1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8836
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8841
::exit(___);}
#if 0
#line 8836
{ 
#line 8837
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8838
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8840
return make_float1(w.x); 
#line 8841
} 
#endif
#line 8843 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredGrad(texture< uchar1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8844
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8849
::exit(___);}
#if 0
#line 8844
{ 
#line 8845
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8846
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8848
return make_float1(w.x); 
#line 8849
} 
#endif
#line 8851 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredGrad(texture< char2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8852
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8857
::exit(___);}
#if 0
#line 8852
{ 
#line 8853
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8854
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8856
return make_float2(w.x, w.y); 
#line 8857
} 
#endif
#line 8859 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredGrad(texture< uchar2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8860
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8865
::exit(___);}
#if 0
#line 8860
{ 
#line 8861
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8862
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8864
return make_float2(w.x, w.y); 
#line 8865
} 
#endif
#line 8867 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredGrad(texture< char4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8868
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8873
::exit(___);}
#if 0
#line 8868
{ 
#line 8869
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8870
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8872
return make_float4(w.x, w.y, w.z, w.w); 
#line 8873
} 
#endif
#line 8875 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredGrad(texture< uchar4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8876
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8881
::exit(___);}
#if 0
#line 8876
{ 
#line 8877
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8878
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8880
return make_float4(w.x, w.y, w.z, w.w); 
#line 8881
} 
#endif
#line 8889 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredGrad(texture< short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8890
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8895
::exit(___);}
#if 0
#line 8890
{ 
#line 8891
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8892
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8894
return w.x; 
#line 8895
} 
#endif
#line 8897 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex2DLayeredGrad(texture< unsigned short, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8898
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8903
::exit(___);}
#if 0
#line 8898
{ 
#line 8899
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8900
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8902
return w.x; 
#line 8903
} 
#endif
#line 8905 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredGrad(texture< short1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8906
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8911
::exit(___);}
#if 0
#line 8906
{ 
#line 8907
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8908
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8910
return make_float1(w.x); 
#line 8911
} 
#endif
#line 8913 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex2DLayeredGrad(texture< ushort1, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8914
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8919
::exit(___);}
#if 0
#line 8914
{ 
#line 8915
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8916
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8918
return make_float1(w.x); 
#line 8919
} 
#endif
#line 8921 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredGrad(texture< short2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8922
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8927
::exit(___);}
#if 0
#line 8922
{ 
#line 8923
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8924
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8926
return make_float2(w.x, w.y); 
#line 8927
} 
#endif
#line 8929 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex2DLayeredGrad(texture< ushort2, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8930
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8935
::exit(___);}
#if 0
#line 8930
{ 
#line 8931
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8932
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8934
return make_float2(w.x, w.y); 
#line 8935
} 
#endif
#line 8937 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredGrad(texture< short4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8938
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8943
::exit(___);}
#if 0
#line 8938
{ 
#line 8939
int4 v = __itexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8940
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8942
return make_float4(w.x, w.y, w.z, w.w); 
#line 8943
} 
#endif
#line 8945 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex2DLayeredGrad(texture< ushort4, 242, cudaReadModeNormalizedFloat>  t, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 8946
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 8951
::exit(___);}
#if 0
#line 8946
{ 
#line 8947
uint4 v = __utexfetchgradl(t, make_float4(x, y, 0, 0), layer, make_float4(dPdx.x, dPdx.y, 0, 0), make_float4(dPdy.x, dPdy.y, 0, 0)); 
#line 8948
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 8950
return make_float4(w.x, w.y, w.z, w.w); 
#line 8951
} 
#endif
#line 8959 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char tex3DGrad(texture< char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 8960
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 8968 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 8960 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 8964 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 8967 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
return (char)(v.x); 
#line 8968
} 
#endif
#line 8970 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline signed char tex3DGrad(texture< signed char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 8971
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 8975
::exit(___);}
#if 0
#line 8971
{ 
#line 8972
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 8974
return (signed char)(v.x); 
#line 8975
} 
#endif
#line 8977 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned char tex3DGrad(texture< unsigned char, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 8978
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 8982
::exit(___);}
#if 0
#line 8978
{ 
#line 8979
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 8981
return (unsigned char)(v.x); 
#line 8982
} 
#endif
#line 8984 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char1 tex3DGrad(texture< char1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 8985
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 8989
::exit(___);}
#if 0
#line 8985
{ 
#line 8986
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 8988
return make_char1(v.x); 
#line 8989
} 
#endif
#line 8991 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar1 tex3DGrad(texture< uchar1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 8992
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 8996
::exit(___);}
#if 0
#line 8992
{ 
#line 8993
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 8995
return make_uchar1(v.x); 
#line 8996
} 
#endif
#line 8998 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char2 tex3DGrad(texture< char2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 8999
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9003
::exit(___);}
#if 0
#line 8999
{ 
#line 9000
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9002
return make_char2(v.x, v.y); 
#line 9003
} 
#endif
#line 9005 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar2 tex3DGrad(texture< uchar2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9006
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9010
::exit(___);}
#if 0
#line 9006
{ 
#line 9007
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9009
return make_uchar2(v.x, v.y); 
#line 9010
} 
#endif
#line 9012 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline char4 tex3DGrad(texture< char4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9013
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9017
::exit(___);}
#if 0
#line 9013
{ 
#line 9014
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9016
return make_char4(v.x, v.y, v.z, v.w); 
#line 9017
} 
#endif
#line 9019 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uchar4 tex3DGrad(texture< uchar4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9020
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9024
::exit(___);}
#if 0
#line 9020
{ 
#line 9021
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9023
return make_uchar4(v.x, v.y, v.z, v.w); 
#line 9024
} 
#endif
#line 9032 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short tex3DGrad(texture< short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9033
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9037
::exit(___);}
#if 0
#line 9033
{ 
#line 9034
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9036
return (short)(v.x); 
#line 9037
} 
#endif
#line 9039 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned short tex3DGrad(texture< unsigned short, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9040
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9044
::exit(___);}
#if 0
#line 9040
{ 
#line 9041
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9043
return (unsigned short)(v.x); 
#line 9044
} 
#endif
#line 9046 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short1 tex3DGrad(texture< short1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9047
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9051
::exit(___);}
#if 0
#line 9047
{ 
#line 9048
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9050
return make_short1(v.x); 
#line 9051
} 
#endif
#line 9053 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort1 tex3DGrad(texture< ushort1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9054
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9058
::exit(___);}
#if 0
#line 9054
{ 
#line 9055
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9057
return make_ushort1(v.x); 
#line 9058
} 
#endif
#line 9060 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short2 tex3DGrad(texture< short2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9061
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9065
::exit(___);}
#if 0
#line 9061
{ 
#line 9062
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9064
return make_short2(v.x, v.y); 
#line 9065
} 
#endif
#line 9067 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort2 tex3DGrad(texture< ushort2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9068
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9072
::exit(___);}
#if 0
#line 9068
{ 
#line 9069
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9071
return make_ushort2(v.x, v.y); 
#line 9072
} 
#endif
#line 9074 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline short4 tex3DGrad(texture< short4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9075
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9079
::exit(___);}
#if 0
#line 9075
{ 
#line 9076
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9078
return make_short4(v.x, v.y, v.z, v.w); 
#line 9079
} 
#endif
#line 9081 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ushort4 tex3DGrad(texture< ushort4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9082
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9086
::exit(___);}
#if 0
#line 9082
{ 
#line 9083
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9085
return make_ushort4(v.x, v.y, v.z, v.w); 
#line 9086
} 
#endif
#line 9094 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int tex3DGrad(texture< int, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9095
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9099
::exit(___);}
#if 0
#line 9095
{ 
#line 9096
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9098
return v.x; 
#line 9099
} 
#endif
#line 9101 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned tex3DGrad(texture< unsigned, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9102
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9106
::exit(___);}
#if 0
#line 9102
{ 
#line 9103
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9105
return v.x; 
#line 9106
} 
#endif
#line 9108 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int1 tex3DGrad(texture< int1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9109
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9113
::exit(___);}
#if 0
#line 9109
{ 
#line 9110
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9112
return make_int1(v.x); 
#line 9113
} 
#endif
#line 9115 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint1 tex3DGrad(texture< uint1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9116
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9120
::exit(___);}
#if 0
#line 9116
{ 
#line 9117
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9119
return make_uint1(v.x); 
#line 9120
} 
#endif
#line 9122 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int2 tex3DGrad(texture< int2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9123
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9127
::exit(___);}
#if 0
#line 9123
{ 
#line 9124
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9126
return make_int2(v.x, v.y); 
#line 9127
} 
#endif
#line 9129 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint2 tex3DGrad(texture< uint2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9130
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9134
::exit(___);}
#if 0
#line 9130
{ 
#line 9131
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9133
return make_uint2(v.x, v.y); 
#line 9134
} 
#endif
#line 9136 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline int4 tex3DGrad(texture< int4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9137
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9141
::exit(___);}
#if 0
#line 9137
{ 
#line 9138
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9140
return make_int4(v.x, v.y, v.z, v.w); 
#line 9141
} 
#endif
#line 9143 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline uint4 tex3DGrad(texture< uint4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9144
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9148
::exit(___);}
#if 0
#line 9144
{ 
#line 9145
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9147
return make_uint4(v.x, v.y, v.z, v.w); 
#line 9148
} 
#endif
#line 9158 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long tex3DGrad(texture< long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9159
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9163
::exit(___);}
#if 0
#line 9159
{ 
#line 9160
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9162
return (long)(v.x); 
#line 9163
} 
#endif
#line 9165 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline unsigned long tex3DGrad(texture< unsigned long, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9166
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9170
::exit(___);}
#if 0
#line 9166
{ 
#line 9167
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9169
return (unsigned long)(v.x); 
#line 9170
} 
#endif
#line 9172 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long1 tex3DGrad(texture< long1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9173
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9177
::exit(___);}
#if 0
#line 9173
{ 
#line 9174
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9176
return make_long1(v.x); 
#line 9177
} 
#endif
#line 9179 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong1 tex3DGrad(texture< ulong1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9180
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9184
::exit(___);}
#if 0
#line 9180
{ 
#line 9181
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9183
return make_ulong1(v.x); 
#line 9184
} 
#endif
#line 9186 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long2 tex3DGrad(texture< long2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9187
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9191
::exit(___);}
#if 0
#line 9187
{ 
#line 9188
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9190
return make_long2(v.x, v.y); 
#line 9191
} 
#endif
#line 9193 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong2 tex3DGrad(texture< ulong2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9194
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9198
::exit(___);}
#if 0
#line 9194
{ 
#line 9195
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9197
return make_ulong2(v.x, v.y); 
#line 9198
} 
#endif
#line 9200 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline long4 tex3DGrad(texture< long4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9201
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9205
::exit(___);}
#if 0
#line 9201
{ 
#line 9202
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9204
return make_long4(v.x, v.y, v.z, v.w); 
#line 9205
} 
#endif
#line 9207 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline ulong4 tex3DGrad(texture< ulong4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9208
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9212
::exit(___);}
#if 0
#line 9208
{ 
#line 9209
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9211
return make_ulong4(v.x, v.y, v.z, v.w); 
#line 9212
} 
#endif
#line 9222 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DGrad(texture< float, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9223
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9227
::exit(___);}
#if 0
#line 9223
{ 
#line 9224
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9226
return v.x; 
#line 9227
} 
#endif
#line 9229 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DGrad(texture< float1, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9230
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9234
::exit(___);}
#if 0
#line 9230
{ 
#line 9231
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9233
return make_float1(v.x); 
#line 9234
} 
#endif
#line 9236 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DGrad(texture< float2, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9237
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9241
::exit(___);}
#if 0
#line 9237
{ 
#line 9238
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9240
return make_float2(v.x, v.y); 
#line 9241
} 
#endif
#line 9243 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DGrad(texture< float4, 3, cudaReadModeElementType>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9244
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9248
::exit(___);}
#if 0
#line 9244
{ 
#line 9245
float4 v = __ftexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9247
return make_float4(v.x, v.y, v.z, v.w); 
#line 9248
} 
#endif
#line 9256 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DGrad(texture< char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9257
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9266 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
::exit(___);}
#if 0
#line 9257 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
{ 
#line 9261 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9263 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9265
return w.x; 
#line 9266
} 
#endif
#line 9268 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DGrad(texture< signed char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9269
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9274
::exit(___);}
#if 0
#line 9269
{ 
#line 9270
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9271
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9273
return w.x; 
#line 9274
} 
#endif
#line 9276 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DGrad(texture< unsigned char, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9277
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9282
::exit(___);}
#if 0
#line 9277
{ 
#line 9278
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9279
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9281
return w.x; 
#line 9282
} 
#endif
#line 9284 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DGrad(texture< char1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9285
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9290
::exit(___);}
#if 0
#line 9285
{ 
#line 9286
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9287
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9289
return make_float1(w.x); 
#line 9290
} 
#endif
#line 9292 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DGrad(texture< uchar1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9293
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9298
::exit(___);}
#if 0
#line 9293
{ 
#line 9294
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9295
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9297
return make_float1(w.x); 
#line 9298
} 
#endif
#line 9300 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DGrad(texture< char2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9301
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9306
::exit(___);}
#if 0
#line 9301
{ 
#line 9302
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9303
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9305
return make_float2(w.x, w.y); 
#line 9306
} 
#endif
#line 9308 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DGrad(texture< uchar2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9309
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9314
::exit(___);}
#if 0
#line 9309
{ 
#line 9310
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9311
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9313
return make_float2(w.x, w.y); 
#line 9314
} 
#endif
#line 9316 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DGrad(texture< char4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9317
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9322
::exit(___);}
#if 0
#line 9317
{ 
#line 9318
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9319
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9321
return make_float4(w.x, w.y, w.z, w.w); 
#line 9322
} 
#endif
#line 9324 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DGrad(texture< uchar4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9325
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9330
::exit(___);}
#if 0
#line 9325
{ 
#line 9326
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9327
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9329
return make_float4(w.x, w.y, w.z, w.w); 
#line 9330
} 
#endif
#line 9338 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DGrad(texture< short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9339
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9344
::exit(___);}
#if 0
#line 9339
{ 
#line 9340
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9341
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9343
return w.x; 
#line 9344
} 
#endif
#line 9346 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float tex3DGrad(texture< unsigned short, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9347
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9352
::exit(___);}
#if 0
#line 9347
{ 
#line 9348
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9349
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9351
return w.x; 
#line 9352
} 
#endif
#line 9354 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DGrad(texture< short1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9355
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9360
::exit(___);}
#if 0
#line 9355
{ 
#line 9356
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9357
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9359
return make_float1(w.x); 
#line 9360
} 
#endif
#line 9362 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float1 tex3DGrad(texture< ushort1, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9363
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9368
::exit(___);}
#if 0
#line 9363
{ 
#line 9364
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9365
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9367
return make_float1(w.x); 
#line 9368
} 
#endif
#line 9370 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DGrad(texture< short2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9371
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9376
::exit(___);}
#if 0
#line 9371
{ 
#line 9372
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9373
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9375
return make_float2(w.x, w.y); 
#line 9376
} 
#endif
#line 9378 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float2 tex3DGrad(texture< ushort2, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9379
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9384
::exit(___);}
#if 0
#line 9379
{ 
#line 9380
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9381
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9383
return make_float2(w.x, w.y); 
#line 9384
} 
#endif
#line 9386 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DGrad(texture< short4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9387
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9392
::exit(___);}
#if 0
#line 9387
{ 
#line 9388
int4 v = __itexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9389
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9391
return make_float4(w.x, w.y, w.z, w.w); 
#line 9392
} 
#endif
#line 9394 "e:\\cudatoolkit\\include\\texture_fetch_functions.hpp"
static __forceinline float4 tex3DGrad(texture< ushort4, 3, cudaReadModeNormalizedFloat>  t, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 9395
{int volatile ___ = 1;(void)t;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 9400
::exit(___);}
#if 0
#line 9395
{ 
#line 9396
uint4 v = __utexfetchgrad(t, make_float4(x, y, z, 0), make_float4(dPdx.x, dPdx.y, dPdx.z, 0), make_float4(dPdy.x, dPdy.y, dPdy.z, 0)); 
#line 9397
float4 w = make_float4(__int_as_float(v.x), __int_as_float(v.y), __int_as_float(v.z), __int_as_float(v.w)); 
#line 9399
return make_float4(w.x, w.y, w.z, w.w); 
#line 9400
} 
#endif
#line 70 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
extern "C" { void __tex_1d_v4f32_s32(cudaTextureObject_t, int, float *, float *, float *, float *); } 
#line 71
extern "C" { void __tex_1d_v4f32_f32(cudaTextureObject_t, float, float *, float *, float *, float *); } 
#line 72
extern "C" { void __tex_1d_level_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
#line 73
extern "C" { void __tex_1d_grad_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
#line 74
extern "C" { void __tex_1d_v4s32_s32(cudaTextureObject_t, int, int *, int *, int *, int *); } 
#line 75
extern "C" { void __tex_1d_v4s32_f32(cudaTextureObject_t, float, int *, int *, int *, int *); } 
#line 76
extern "C" { void __tex_1d_level_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
#line 77
extern "C" { void __tex_1d_grad_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
#line 78
extern "C" { void __tex_1d_v4u32_s32(cudaTextureObject_t, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 79
extern "C" { void __tex_1d_v4u32_f32(cudaTextureObject_t, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 80
extern "C" { void __tex_1d_level_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 81
extern "C" { void __tex_1d_grad_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 83
extern "C" { void __tex_1d_array_v4f32_s32(cudaTextureObject_t, int, int, float *, float *, float *, float *); } 
#line 84
extern "C" { void __tex_1d_array_v4f32_f32(cudaTextureObject_t, int, float, float *, float *, float *, float *); } 
#line 85
extern "C" { void __tex_1d_array_level_v4f32_f32(cudaTextureObject_t, int, float, float, float *, float *, float *, float *); } 
#line 86
extern "C" { void __tex_1d_array_grad_v4f32_f32(cudaTextureObject_t, int, float, float, float, float *, float *, float *, float *); } 
#line 87
extern "C" { void __tex_1d_array_v4s32_s32(cudaTextureObject_t, int, int, int *, int *, int *, int *); } 
#line 88
extern "C" { void __tex_1d_array_v4s32_f32(cudaTextureObject_t, int, float, int *, int *, int *, int *); } 
#line 89
extern "C" { void __tex_1d_array_level_v4s32_f32(cudaTextureObject_t, int, float, float, int *, int *, int *, int *); } 
#line 90
extern "C" { void __tex_1d_array_grad_v4s32_f32(cudaTextureObject_t, int, float, float, float, int *, int *, int *, int *); } 
#line 91
extern "C" { void __tex_1d_array_v4u32_s32(cudaTextureObject_t, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 92
extern "C" { void __tex_1d_array_v4u32_f32(cudaTextureObject_t, int, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 93
extern "C" { void __tex_1d_array_level_v4u32_f32(cudaTextureObject_t, int, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 94
extern "C" { void __tex_1d_array_grad_v4u32_f32(cudaTextureObject_t, int, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 96
extern "C" { void __tex_2d_v4f32_s32(cudaTextureObject_t, int, int, float *, float *, float *, float *); } 
#line 97
extern "C" { void __tex_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
#line 98
extern "C" { void __tex_2d_level_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
#line 99
extern "C" { void __tex_2d_grad_v4f32_f32(cudaTextureObject_t, float, float, float, float, float, float, float *, float *, float *, float *); } 
#line 100
extern "C" { void __tex_2d_v4s32_s32(cudaTextureObject_t, int, int, int *, int *, int *, int *); } 
#line 101
extern "C" { void __tex_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
#line 102
extern "C" { void __tex_2d_level_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
#line 103
extern "C" { void __tex_2d_grad_v4s32_f32(cudaTextureObject_t, float, float, float, float, float, float, int *, int *, int *, int *); } 
#line 104
extern "C" { void __tex_2d_v4u32_s32(cudaTextureObject_t, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 105
extern "C" { void __tex_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 106
extern "C" { void __tex_2d_level_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 107
extern "C" { void __tex_2d_grad_v4u32_f32(cudaTextureObject_t, float, float, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 109
extern "C" { void __tex_2d_array_v4f32_s32(cudaTextureObject_t, int, int, int, float *, float *, float *, float *); } 
#line 110
extern "C" { void __tex_2d_array_v4f32_f32(cudaTextureObject_t, int, float, float, float *, float *, float *, float *); } 
#line 111
extern "C" { void __tex_2d_array_level_v4f32_f32(cudaTextureObject_t, int, float, float, float, float *, float *, float *, float *); } 
#line 112
extern "C" { void __tex_2d_array_grad_v4f32_f32(cudaTextureObject_t, int, float, float, float, float, float, float, float *, float *, float *, float *); } 
#line 113
extern "C" { void __tex_2d_array_v4s32_s32(cudaTextureObject_t, int, int, int, int *, int *, int *, int *); } 
#line 114
extern "C" { void __tex_2d_array_v4s32_f32(cudaTextureObject_t, int, float, float, int *, int *, int *, int *); } 
#line 115
extern "C" { void __tex_2d_array_level_v4s32_f32(cudaTextureObject_t, int, float, float, float, int *, int *, int *, int *); } 
#line 116
extern "C" { void __tex_2d_array_grad_v4s32_f32(cudaTextureObject_t, int, float, float, float, float, float, float, int *, int *, int *, int *); } 
#line 117
extern "C" { void __tex_2d_array_v4u32_s32(cudaTextureObject_t, int, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 118
extern "C" { void __tex_2d_array_v4u32_f32(cudaTextureObject_t, int, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 119
extern "C" { void __tex_2d_array_level_v4u32_f32(cudaTextureObject_t, int, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 120
extern "C" { void __tex_2d_array_grad_v4u32_f32(cudaTextureObject_t, int, float, float, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 122
extern "C" { void __tex_3d_v4f32_s32(cudaTextureObject_t, int, int, int, float *, float *, float *, float *); } 
#line 123
extern "C" { void __tex_3d_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
#line 124
extern "C" { void __tex_3d_level_v4f32_f32(cudaTextureObject_t, float, float, float, float, float *, float *, float *, float *); } 
#line 125
extern "C" { void __tex_3d_grad_v4f32_f32(cudaTextureObject_t, float, float, float, float, float, float, float, float, float, float *, float *, float *, float *); } 
#line 126
extern "C" { void __tex_3d_v4s32_s32(cudaTextureObject_t, int, int, int, int *, int *, int *, int *); } 
#line 127
extern "C" { void __tex_3d_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
#line 128
extern "C" { void __tex_3d_level_v4s32_f32(cudaTextureObject_t, float, float, float, float, int *, int *, int *, int *); } 
#line 129
extern "C" { void __tex_3d_grad_v4s32_f32(cudaTextureObject_t, float, float, float, float, float, float, float, float, float, int *, int *, int *, int *); } 
#line 130
extern "C" { void __tex_3d_v4u32_s32(cudaTextureObject_t, int, int, int, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 131
extern "C" { void __tex_3d_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 132
extern "C" { void __tex_3d_level_v4u32_f32(cudaTextureObject_t, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 133
extern "C" { void __tex_3d_grad_v4u32_f32(cudaTextureObject_t, float, float, float, float, float, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 135
extern "C" { void __tex_cube_v4f32_f32(cudaTextureObject_t, float, float, float, float *, float *, float *, float *); } 
#line 136
extern "C" { void __tex_cube_level_v4f32_f32(cudaTextureObject_t, float, float, float, float, float *, float *, float *, float *); } 
#line 137
extern "C" { void __tex_cube_v4s32_f32(cudaTextureObject_t, float, float, float, int *, int *, int *, int *); } 
#line 138
extern "C" { void __tex_cube_level_v4s32_f32(cudaTextureObject_t, float, float, float, float, int *, int *, int *, int *); } 
#line 139
extern "C" { void __tex_cube_v4u32_f32(cudaTextureObject_t, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 140
extern "C" { void __tex_cube_level_v4u32_f32(cudaTextureObject_t, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 142
extern "C" { void __tex_cube_array_v4f32_f32(cudaTextureObject_t, int, float, float, float, float *, float *, float *, float *); } 
#line 143
extern "C" { void __tex_cube_array_level_v4f32_f32(cudaTextureObject_t, int, float, float, float, float, float *, float *, float *, float *); } 
#line 144
extern "C" { void __tex_cube_array_v4s32_f32(cudaTextureObject_t, int, float, float, float, int *, int *, int *, int *); } 
#line 145
extern "C" { void __tex_cube_array_level_v4s32_f32(cudaTextureObject_t, int, float, float, float, float, int *, int *, int *, int *); } 
#line 146
extern "C" { void __tex_cube_array_v4u32_f32(cudaTextureObject_t, int, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 147
extern "C" { void __tex_cube_array_level_v4u32_f32(cudaTextureObject_t, int, float, float, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 149
extern "C" { void __tld4_r_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
#line 150
extern "C" { void __tld4_g_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
#line 151
extern "C" { void __tld4_b_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
#line 152
extern "C" { void __tld4_a_2d_v4f32_f32(cudaTextureObject_t, float, float, float *, float *, float *, float *); } 
#line 153
extern "C" { void __tld4_r_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
#line 154
extern "C" { void __tld4_g_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
#line 155
extern "C" { void __tld4_b_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
#line 156
extern "C" { void __tld4_a_2d_v4s32_f32(cudaTextureObject_t, float, float, int *, int *, int *, int *); } 
#line 157
extern "C" { void __tld4_r_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 158
extern "C" { void __tld4_g_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 159
extern "C" { void __tld4_b_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 160
extern "C" { void __tld4_a_2d_v4u32_f32(cudaTextureObject_t, float, float, unsigned *, unsigned *, unsigned *, unsigned *); } 
#line 169
static __forceinline void tex1Dfetch(char * retVal, cudaTextureObject_t texObject, int x); 
#line 170
static __forceinline void tex1Dfetch(signed char * retVal, cudaTextureObject_t texObject, int x); 
#line 172
static __forceinline void tex1Dfetch(char1 * retVal, cudaTextureObject_t texObject, int x); 
#line 174
static __forceinline void tex1Dfetch(char2 * retVal, cudaTextureObject_t texObject, int x); 
#line 176
static __forceinline void tex1Dfetch(char4 * retVal, cudaTextureObject_t texObject, int x); 
#line 178
static __forceinline void tex1Dfetch(unsigned char * retVal, cudaTextureObject_t texObject, int x); 
#line 180
static __forceinline void tex1Dfetch(uchar1 * retVal, cudaTextureObject_t texObject, int x); 
#line 182
static __forceinline void tex1Dfetch(uchar2 * retVal, cudaTextureObject_t texObject, int x); 
#line 184
static __forceinline void tex1Dfetch(uchar4 * retVal, cudaTextureObject_t texObject, int x); 
#line 192
static __forceinline void tex1Dfetch(short * retVal, cudaTextureObject_t texObject, int x); 
#line 194
static __forceinline void tex1Dfetch(short1 * retVal, cudaTextureObject_t texObject, int x); 
#line 196
static __forceinline void tex1Dfetch(short2 * retVal, cudaTextureObject_t texObject, int x); 
#line 198
static __forceinline void tex1Dfetch(short4 * retVal, cudaTextureObject_t texObject, int x); 
#line 200
static __forceinline void tex1Dfetch(unsigned short * retVal, cudaTextureObject_t texObject, int x); 
#line 202
static __forceinline void tex1Dfetch(ushort1 * retVal, cudaTextureObject_t texObject, int x); 
#line 204
static __forceinline void tex1Dfetch(ushort2 * retVal, cudaTextureObject_t texObject, int x); 
#line 206
static __forceinline void tex1Dfetch(ushort4 * retVal, cudaTextureObject_t texObject, int x); 
#line 214
static __forceinline void tex1Dfetch(int * retVal, cudaTextureObject_t texObject, int x); 
#line 216
static __forceinline void tex1Dfetch(int1 * retVal, cudaTextureObject_t texObject, int x); 
#line 218
static __forceinline void tex1Dfetch(int2 * retVal, cudaTextureObject_t texObject, int x); 
#line 220
static __forceinline void tex1Dfetch(int4 * retVal, cudaTextureObject_t texObject, int x); 
#line 222
static __forceinline void tex1Dfetch(unsigned * retVal, cudaTextureObject_t texObject, int x); 
#line 224
static __forceinline void tex1Dfetch(uint1 * retVal, cudaTextureObject_t texObject, int x); 
#line 226
static __forceinline void tex1Dfetch(uint2 * retVal, cudaTextureObject_t texObject, int x); 
#line 228
static __forceinline void tex1Dfetch(uint4 * retVal, cudaTextureObject_t texObject, int x); 
#line 238
static __forceinline void tex1Dfetch(long * retVal, cudaTextureObject_t texObject, int x); 
#line 240
static __forceinline void tex1Dfetch(long1 * retVal, cudaTextureObject_t texObject, int x); 
#line 242
static __forceinline void tex1Dfetch(long2 * retVal, cudaTextureObject_t texObject, int x); 
#line 244
static __forceinline void tex1Dfetch(long4 * retVal, cudaTextureObject_t texObject, int x); 
#line 246
static __forceinline void tex1Dfetch(unsigned long * retVal, cudaTextureObject_t texObject, int x); 
#line 248
static __forceinline void tex1Dfetch(ulong1 * retVal, cudaTextureObject_t texObject, int x); 
#line 250
static __forceinline void tex1Dfetch(ulong2 * retVal, cudaTextureObject_t texObject, int x); 
#line 252
static __forceinline void tex1Dfetch(ulong4 * retVal, cudaTextureObject_t texObject, int x); 
#line 263 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1Dfetch(float * retVal, cudaTextureObject_t texObject, int x); 
#line 265
static __forceinline void tex1Dfetch(float1 * retVal, cudaTextureObject_t texObject, int x); 
#line 267
static __forceinline void tex1Dfetch(float2 * retVal, cudaTextureObject_t texObject, int x); 
#line 269
static __forceinline void tex1Dfetch(float4 * retVal, cudaTextureObject_t texObject, int x); 
#line 277
template< class T> static __forceinline T 
#line 278
tex1Dfetch(::cudaTextureObject_t texObject, int x) 
#line 279
{int volatile ___ = 1;(void)texObject;(void)x;
#line 283
::exit(___);}
#if 0
#line 279
{ 
#line 280
T ret; 
#line 281
tex1Dfetch(&ret, texObject, x); 
#line 282
return ret; 
#line 283
} 
#endif
#line 291 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(char * retVal, cudaTextureObject_t texObject, float x); 
#line 292
static __forceinline void tex1D(signed char * retVal, cudaTextureObject_t texObject, float x); 
#line 294
static __forceinline void tex1D(char1 * retVal, cudaTextureObject_t texObject, float x); 
#line 296
static __forceinline void tex1D(char2 * retVal, cudaTextureObject_t texObject, float x); 
#line 298
static __forceinline void tex1D(char4 * retVal, cudaTextureObject_t texObject, float x); 
#line 300
static __forceinline void tex1D(unsigned char * retVal, cudaTextureObject_t texObject, float x); 
#line 302
static __forceinline void tex1D(uchar1 * retVal, cudaTextureObject_t texObject, float x); 
#line 304
static __forceinline void tex1D(uchar2 * retVal, cudaTextureObject_t texObject, float x); 
#line 306
static __forceinline void tex1D(uchar4 * retVal, cudaTextureObject_t texObject, float x); 
#line 314
static __forceinline void tex1D(short * retVal, cudaTextureObject_t texObject, float x); 
#line 316
static __forceinline void tex1D(short1 * retVal, cudaTextureObject_t texObject, float x); 
#line 318
static __forceinline void tex1D(short2 * retVal, cudaTextureObject_t texObject, float x); 
#line 320
static __forceinline void tex1D(short4 * retVal, cudaTextureObject_t texObject, float x); 
#line 322
static __forceinline void tex1D(unsigned short * retVal, cudaTextureObject_t texObject, float x); 
#line 324
static __forceinline void tex1D(ushort1 * retVal, cudaTextureObject_t texObject, float x); 
#line 326
static __forceinline void tex1D(ushort2 * retVal, cudaTextureObject_t texObject, float x); 
#line 328
static __forceinline void tex1D(ushort4 * retVal, cudaTextureObject_t texObject, float x); 
#line 336
static __forceinline void tex1D(int * retVal, cudaTextureObject_t texObject, float x); 
#line 338
static __forceinline void tex1D(int1 * retVal, cudaTextureObject_t texObject, float x); 
#line 340
static __forceinline void tex1D(int2 * retVal, cudaTextureObject_t texObject, float x); 
#line 342
static __forceinline void tex1D(int4 * retVal, cudaTextureObject_t texObject, float x); 
#line 344
static __forceinline void tex1D(unsigned * retVal, cudaTextureObject_t texObject, float x); 
#line 346
static __forceinline void tex1D(uint1 * retVal, cudaTextureObject_t texObject, float x); 
#line 348
static __forceinline void tex1D(uint2 * retVal, cudaTextureObject_t texObject, float x); 
#line 350
static __forceinline void tex1D(uint4 * retVal, cudaTextureObject_t texObject, float x); 
#line 360
static __forceinline void tex1D(long * retVal, cudaTextureObject_t texObject, float x); 
#line 362
static __forceinline void tex1D(long1 * retVal, cudaTextureObject_t texObject, float x); 
#line 364
static __forceinline void tex1D(long2 * retVal, cudaTextureObject_t texObject, float x); 
#line 366
static __forceinline void tex1D(long4 * retVal, cudaTextureObject_t texObject, float x); 
#line 368
static __forceinline void tex1D(unsigned long * retVal, cudaTextureObject_t texObject, float x); 
#line 370
static __forceinline void tex1D(ulong1 * retVal, cudaTextureObject_t texObject, float x); 
#line 372
static __forceinline void tex1D(ulong2 * retVal, cudaTextureObject_t texObject, float x); 
#line 374
static __forceinline void tex1D(ulong4 * retVal, cudaTextureObject_t texObject, float x); 
#line 385 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1D(float * retVal, cudaTextureObject_t texObject, float x); 
#line 387
static __forceinline void tex1D(float1 * retVal, cudaTextureObject_t texObject, float x); 
#line 389
static __forceinline void tex1D(float2 * retVal, cudaTextureObject_t texObject, float x); 
#line 391
static __forceinline void tex1D(float4 * retVal, cudaTextureObject_t texObject, float x); 
#line 399
template< class T> static __forceinline T 
#line 400
tex1D(::cudaTextureObject_t texObject, float x) 
#line 401
{int volatile ___ = 1;(void)texObject;(void)x;
#line 405
::exit(___);}
#if 0
#line 401
{ 
#line 402
T ret; 
#line 403
tex1D(&ret, texObject, x); 
#line 404
return ret; 
#line 405
} 
#endif
#line 413 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(char * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 414
static __forceinline void tex2D(signed char * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 416
static __forceinline void tex2D(char1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 418
static __forceinline void tex2D(char2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 420
static __forceinline void tex2D(char4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 422
static __forceinline void tex2D(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 424
static __forceinline void tex2D(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 426
static __forceinline void tex2D(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 428
static __forceinline void tex2D(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 436
static __forceinline void tex2D(short * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 438
static __forceinline void tex2D(short1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 440
static __forceinline void tex2D(short2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 442
static __forceinline void tex2D(short4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 444
static __forceinline void tex2D(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 446
static __forceinline void tex2D(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 448
static __forceinline void tex2D(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 450
static __forceinline void tex2D(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 458
static __forceinline void tex2D(int * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 460
static __forceinline void tex2D(int1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 462
static __forceinline void tex2D(int2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 464
static __forceinline void tex2D(int4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 466
static __forceinline void tex2D(unsigned * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 468
static __forceinline void tex2D(uint1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 470
static __forceinline void tex2D(uint2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 472
static __forceinline void tex2D(uint4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 482
static __forceinline void tex2D(long * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 484
static __forceinline void tex2D(long1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 486
static __forceinline void tex2D(long2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 488
static __forceinline void tex2D(long4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 490
static __forceinline void tex2D(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 492
static __forceinline void tex2D(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 494
static __forceinline void tex2D(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 496
static __forceinline void tex2D(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 507 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2D(float * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 509
static __forceinline void tex2D(float1 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 511
static __forceinline void tex2D(float2 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 513
static __forceinline void tex2D(float4 * retVal, cudaTextureObject_t texObject, float x, float y); 
#line 521
template< class T> static __forceinline T 
#line 522
tex2D(::cudaTextureObject_t texObject, float x, float y) 
#line 523
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;
#line 527
::exit(___);}
#if 0
#line 523
{ 
#line 524
T ret; 
#line 525
tex2D(&ret, texObject, x, y); 
#line 526
return ret; 
#line 527
} 
#endif
#line 535 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 536
static __forceinline void tex3D(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 538
static __forceinline void tex3D(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 540
static __forceinline void tex3D(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 542
static __forceinline void tex3D(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 544
static __forceinline void tex3D(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 546
static __forceinline void tex3D(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 548
static __forceinline void tex3D(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 550
static __forceinline void tex3D(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 558
static __forceinline void tex3D(short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 560
static __forceinline void tex3D(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 562
static __forceinline void tex3D(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 564
static __forceinline void tex3D(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 566
static __forceinline void tex3D(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 568
static __forceinline void tex3D(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 570
static __forceinline void tex3D(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 572
static __forceinline void tex3D(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 580
static __forceinline void tex3D(int * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 582
static __forceinline void tex3D(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 584
static __forceinline void tex3D(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 586
static __forceinline void tex3D(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 588
static __forceinline void tex3D(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 590
static __forceinline void tex3D(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 592
static __forceinline void tex3D(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 594
static __forceinline void tex3D(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 604
static __forceinline void tex3D(long * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 606
static __forceinline void tex3D(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 608
static __forceinline void tex3D(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 610
static __forceinline void tex3D(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 612
static __forceinline void tex3D(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 614
static __forceinline void tex3D(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 616
static __forceinline void tex3D(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 618
static __forceinline void tex3D(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 629 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex3D(float * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 631
static __forceinline void tex3D(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 633
static __forceinline void tex3D(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 635
static __forceinline void tex3D(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 643
template< class T> static __forceinline T 
#line 644
tex3D(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 645
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 649
::exit(___);}
#if 0
#line 645
{ 
#line 646
T ret; 
#line 647
tex3D(&ret, texObject, x, y, z); 
#line 648
return ret; 
#line 649
} 
#endif
#line 657 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(char * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 658
static __forceinline void tex1DLayered(signed char * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 660
static __forceinline void tex1DLayered(char1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 662
static __forceinline void tex1DLayered(char2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 664
static __forceinline void tex1DLayered(char4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 666
static __forceinline void tex1DLayered(unsigned char * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 668
static __forceinline void tex1DLayered(uchar1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 670
static __forceinline void tex1DLayered(uchar2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 672
static __forceinline void tex1DLayered(uchar4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 680
static __forceinline void tex1DLayered(short * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 682
static __forceinline void tex1DLayered(short1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 684
static __forceinline void tex1DLayered(short2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 686
static __forceinline void tex1DLayered(short4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 688
static __forceinline void tex1DLayered(unsigned short * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 690
static __forceinline void tex1DLayered(ushort1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 692
static __forceinline void tex1DLayered(ushort2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 694
static __forceinline void tex1DLayered(ushort4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 702
static __forceinline void tex1DLayered(int * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 704
static __forceinline void tex1DLayered(int1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 706
static __forceinline void tex1DLayered(int2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 708
static __forceinline void tex1DLayered(int4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 710
static __forceinline void tex1DLayered(unsigned * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 712
static __forceinline void tex1DLayered(uint1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 714
static __forceinline void tex1DLayered(uint2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 716
static __forceinline void tex1DLayered(uint4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 726
static __forceinline void tex1DLayered(long * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 728
static __forceinline void tex1DLayered(long1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 730
static __forceinline void tex1DLayered(long2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 732
static __forceinline void tex1DLayered(long4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 734
static __forceinline void tex1DLayered(unsigned long * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 736
static __forceinline void tex1DLayered(ulong1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 738
static __forceinline void tex1DLayered(ulong2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 740
static __forceinline void tex1DLayered(ulong4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 751 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayered(float * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 753
static __forceinline void tex1DLayered(float1 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 755
static __forceinline void tex1DLayered(float2 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 757
static __forceinline void tex1DLayered(float4 * retVal, cudaTextureObject_t texObject, float x, int layer); 
#line 765
template< class T> static __forceinline T 
#line 766
tex1DLayered(::cudaTextureObject_t texObject, float x, int layer) 
#line 767
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;
#line 771
::exit(___);}
#if 0
#line 767
{ 
#line 768
T ret; 
#line 769
tex1DLayered(&ret, texObject, x, layer); 
#line 770
return ret; 
#line 771
} 
#endif
#line 779 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(char * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 780
static __forceinline void tex2DLayered(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 782
static __forceinline void tex2DLayered(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 784
static __forceinline void tex2DLayered(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 786
static __forceinline void tex2DLayered(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 788
static __forceinline void tex2DLayered(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 790
static __forceinline void tex2DLayered(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 792
static __forceinline void tex2DLayered(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 794
static __forceinline void tex2DLayered(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 802
static __forceinline void tex2DLayered(short * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 804
static __forceinline void tex2DLayered(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 806
static __forceinline void tex2DLayered(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 808
static __forceinline void tex2DLayered(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 810
static __forceinline void tex2DLayered(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 812
static __forceinline void tex2DLayered(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 814
static __forceinline void tex2DLayered(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 816
static __forceinline void tex2DLayered(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 824
static __forceinline void tex2DLayered(int * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 826
static __forceinline void tex2DLayered(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 828
static __forceinline void tex2DLayered(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 830
static __forceinline void tex2DLayered(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 832
static __forceinline void tex2DLayered(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 834
static __forceinline void tex2DLayered(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 836
static __forceinline void tex2DLayered(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 838
static __forceinline void tex2DLayered(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 848
static __forceinline void tex2DLayered(long * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 850
static __forceinline void tex2DLayered(long1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 852
static __forceinline void tex2DLayered(long2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 854
static __forceinline void tex2DLayered(long4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 856
static __forceinline void tex2DLayered(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 858
static __forceinline void tex2DLayered(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 860
static __forceinline void tex2DLayered(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 862
static __forceinline void tex2DLayered(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 873 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayered(float * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 875
static __forceinline void tex2DLayered(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 877
static __forceinline void tex2DLayered(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 879
static __forceinline void tex2DLayered(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer); 
#line 887
template< class T> static __forceinline T 
#line 888
tex2DLayered(::cudaTextureObject_t texObject, float x, float y, int layer) 
#line 889
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;
#line 893
::exit(___);}
#if 0
#line 889
{ 
#line 890
T ret; 
#line 891
tex2DLayered(&ret, texObject, x, y, layer); 
#line 892
return ret; 
#line 893
} 
#endif
#line 901 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 902
static __forceinline void texCubemap(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 904
static __forceinline void texCubemap(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 906
static __forceinline void texCubemap(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 908
static __forceinline void texCubemap(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 910
static __forceinline void texCubemap(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 912
static __forceinline void texCubemap(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 914
static __forceinline void texCubemap(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 916
static __forceinline void texCubemap(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 924
static __forceinline void texCubemap(short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 926
static __forceinline void texCubemap(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 928
static __forceinline void texCubemap(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 930
static __forceinline void texCubemap(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 932
static __forceinline void texCubemap(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 934
static __forceinline void texCubemap(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 936
static __forceinline void texCubemap(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 938
static __forceinline void texCubemap(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 946
static __forceinline void texCubemap(int * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 948
static __forceinline void texCubemap(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 950
static __forceinline void texCubemap(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 952
static __forceinline void texCubemap(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 954
static __forceinline void texCubemap(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 956
static __forceinline void texCubemap(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 958
static __forceinline void texCubemap(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 960
static __forceinline void texCubemap(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 970
static __forceinline void texCubemap(long * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 972
static __forceinline void texCubemap(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 974
static __forceinline void texCubemap(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 976
static __forceinline void texCubemap(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 978
static __forceinline void texCubemap(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 980
static __forceinline void texCubemap(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 982
static __forceinline void texCubemap(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 984
static __forceinline void texCubemap(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 995 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemap(float * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 997
static __forceinline void texCubemap(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 999
static __forceinline void texCubemap(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 1001
static __forceinline void texCubemap(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z); 
#line 1009
template< class T> static __forceinline T 
#line 1010
texCubemap(::cudaTextureObject_t texObject, float x, float y, float z) 
#line 1011
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;
#line 1015
::exit(___);}
#if 0
#line 1011
{ 
#line 1012
T ret; 
#line 1013
texCubemap(&ret, texObject, x, y, z); 
#line 1014
return ret; 
#line 1015
} 
#endif
#line 1023 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1024
static __forceinline void texCubemapLayered(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1026
static __forceinline void texCubemapLayered(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1028
static __forceinline void texCubemapLayered(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1030
static __forceinline void texCubemapLayered(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1032
static __forceinline void texCubemapLayered(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1034
static __forceinline void texCubemapLayered(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1036
static __forceinline void texCubemapLayered(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1038
static __forceinline void texCubemapLayered(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1046
static __forceinline void texCubemapLayered(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1048
static __forceinline void texCubemapLayered(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1050
static __forceinline void texCubemapLayered(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1052
static __forceinline void texCubemapLayered(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1054
static __forceinline void texCubemapLayered(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1056
static __forceinline void texCubemapLayered(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1058
static __forceinline void texCubemapLayered(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1060
static __forceinline void texCubemapLayered(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1068
static __forceinline void texCubemapLayered(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1070
static __forceinline void texCubemapLayered(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1072
static __forceinline void texCubemapLayered(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1074
static __forceinline void texCubemapLayered(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1076
static __forceinline void texCubemapLayered(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1078
static __forceinline void texCubemapLayered(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1080
static __forceinline void texCubemapLayered(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1082
static __forceinline void texCubemapLayered(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1092
static __forceinline void texCubemapLayered(long * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1094
static __forceinline void texCubemapLayered(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1096
static __forceinline void texCubemapLayered(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1098
static __forceinline void texCubemapLayered(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1100
static __forceinline void texCubemapLayered(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1102
static __forceinline void texCubemapLayered(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1104
static __forceinline void texCubemapLayered(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1106
static __forceinline void texCubemapLayered(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1117 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayered(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1119
static __forceinline void texCubemapLayered(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1121
static __forceinline void texCubemapLayered(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1123
static __forceinline void texCubemapLayered(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer); 
#line 1131
template< class T> static __forceinline T 
#line 1132
texCubemapLayered(::cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 1133
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 1137
::exit(___);}
#if 0
#line 1133
{ 
#line 1134
T ret; 
#line 1135
texCubemapLayered(&ret, texObject, x, y, z, layer); 
#line 1136
return ret; 
#line 1137
} 
#endif
#line 1145 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2Dgather(char * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1147
static __forceinline void tex2Dgather(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1149
static __forceinline void tex2Dgather(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1151
static __forceinline void tex2Dgather(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1153
static __forceinline void tex2Dgather(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1155
static __forceinline void tex2Dgather(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1157
static __forceinline void tex2Dgather(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1159
static __forceinline void tex2Dgather(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1161
static __forceinline void tex2Dgather(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1169
static __forceinline void tex2Dgather(short * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1171
static __forceinline void tex2Dgather(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1173
static __forceinline void tex2Dgather(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1175
static __forceinline void tex2Dgather(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1177
static __forceinline void tex2Dgather(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1179
static __forceinline void tex2Dgather(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1181
static __forceinline void tex2Dgather(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1183
static __forceinline void tex2Dgather(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1191
static __forceinline void tex2Dgather(int * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1193
static __forceinline void tex2Dgather(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1195
static __forceinline void tex2Dgather(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1197
static __forceinline void tex2Dgather(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1199
static __forceinline void tex2Dgather(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1201
static __forceinline void tex2Dgather(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1203
static __forceinline void tex2Dgather(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1205
static __forceinline void tex2Dgather(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1213
static __forceinline void tex2Dgather(long * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1215
static __forceinline void tex2Dgather(long1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1217
static __forceinline void tex2Dgather(long2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1219
static __forceinline void tex2Dgather(long4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1221
static __forceinline void tex2Dgather(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1223
static __forceinline void tex2Dgather(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1225
static __forceinline void tex2Dgather(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1227
static __forceinline void tex2Dgather(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1235
static __forceinline void tex2Dgather(float * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1237
static __forceinline void tex2Dgather(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1239
static __forceinline void tex2Dgather(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1241
static __forceinline void tex2Dgather(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int comp = 0); 
#line 1249
template< class T> static __forceinline T 
#line 1250
tex2Dgather(::cudaTextureObject_t to, float x, float y, int comp = 0) 
#line 1251
{int volatile ___ = 1;(void)to;(void)x;(void)y;(void)comp;
#line 1255
::exit(___);}
#if 0
#line 1251
{ 
#line 1252
T ret; 
#line 1253
tex2Dgather(&ret, to, x, y, comp); 
#line 1254
return ret; 
#line 1255
} 
#endif
#line 1263 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(char * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1264
static __forceinline void tex1DLod(signed char * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1266
static __forceinline void tex1DLod(char1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1268
static __forceinline void tex1DLod(char2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1270
static __forceinline void tex1DLod(char4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1272
static __forceinline void tex1DLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1274
static __forceinline void tex1DLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1276
static __forceinline void tex1DLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1278
static __forceinline void tex1DLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1286
static __forceinline void tex1DLod(short * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1288
static __forceinline void tex1DLod(short1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1290
static __forceinline void tex1DLod(short2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1292
static __forceinline void tex1DLod(short4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1294
static __forceinline void tex1DLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1296
static __forceinline void tex1DLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1298
static __forceinline void tex1DLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1300
static __forceinline void tex1DLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1308
static __forceinline void tex1DLod(int * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1310
static __forceinline void tex1DLod(int1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1312
static __forceinline void tex1DLod(int2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1314
static __forceinline void tex1DLod(int4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1316
static __forceinline void tex1DLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1318
static __forceinline void tex1DLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1320
static __forceinline void tex1DLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1322
static __forceinline void tex1DLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1332
static __forceinline void tex1DLod(long * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1334
static __forceinline void tex1DLod(long1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1336
static __forceinline void tex1DLod(long2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1338
static __forceinline void tex1DLod(long4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1340
static __forceinline void tex1DLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1342
static __forceinline void tex1DLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1344
static __forceinline void tex1DLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1346
static __forceinline void tex1DLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1357 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLod(float * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1359
static __forceinline void tex1DLod(float1 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1361
static __forceinline void tex1DLod(float2 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1363
static __forceinline void tex1DLod(float4 * retVal, cudaTextureObject_t texObject, float x, float level); 
#line 1371
template< class T> static __forceinline T 
#line 1372
tex1DLod(::cudaTextureObject_t texObject, float x, float level) 
#line 1373
{int volatile ___ = 1;(void)texObject;(void)x;(void)level;
#line 1377
::exit(___);}
#if 0
#line 1373
{ 
#line 1374
T ret; 
#line 1375
tex1DLod(&ret, texObject, x, level); 
#line 1376
return ret; 
#line 1377
} 
#endif
#line 1385 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1386
static __forceinline void tex2DLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1388
static __forceinline void tex2DLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1390
static __forceinline void tex2DLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1392
static __forceinline void tex2DLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1394
static __forceinline void tex2DLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1396
static __forceinline void tex2DLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1398
static __forceinline void tex2DLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1400
static __forceinline void tex2DLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1408
static __forceinline void tex2DLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1410
static __forceinline void tex2DLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1412
static __forceinline void tex2DLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1414
static __forceinline void tex2DLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1416
static __forceinline void tex2DLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1418
static __forceinline void tex2DLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1420
static __forceinline void tex2DLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1422
static __forceinline void tex2DLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1430
static __forceinline void tex2DLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1432
static __forceinline void tex2DLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1434
static __forceinline void tex2DLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1436
static __forceinline void tex2DLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1438
static __forceinline void tex2DLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1440
static __forceinline void tex2DLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1442
static __forceinline void tex2DLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1444
static __forceinline void tex2DLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1454
static __forceinline void tex2DLod(long * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1456
static __forceinline void tex2DLod(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1458
static __forceinline void tex2DLod(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1460
static __forceinline void tex2DLod(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1462
static __forceinline void tex2DLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1464
static __forceinline void tex2DLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1466
static __forceinline void tex2DLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1468
static __forceinline void tex2DLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1479 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1481
static __forceinline void tex2DLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1483
static __forceinline void tex2DLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1485
static __forceinline void tex2DLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float level); 
#line 1493
template< class T> static __forceinline T 
#line 1494
tex2DLod(::cudaTextureObject_t texObject, float x, float y, float level) 
#line 1495
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)level;
#line 1499
::exit(___);}
#if 0
#line 1495
{ 
#line 1496
T ret; 
#line 1497
tex2DLod(&ret, texObject, x, y, level); 
#line 1498
return ret; 
#line 1499
} 
#endif
#line 1507 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1508
static __forceinline void tex3DLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1510
static __forceinline void tex3DLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1512
static __forceinline void tex3DLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1514
static __forceinline void tex3DLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1516
static __forceinline void tex3DLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1518
static __forceinline void tex3DLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1520
static __forceinline void tex3DLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1522
static __forceinline void tex3DLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1530
static __forceinline void tex3DLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1532
static __forceinline void tex3DLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1534
static __forceinline void tex3DLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1536
static __forceinline void tex3DLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1538
static __forceinline void tex3DLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1540
static __forceinline void tex3DLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1542
static __forceinline void tex3DLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1544
static __forceinline void tex3DLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1552
static __forceinline void tex3DLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1554
static __forceinline void tex3DLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1556
static __forceinline void tex3DLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1558
static __forceinline void tex3DLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1560
static __forceinline void tex3DLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1562
static __forceinline void tex3DLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1564
static __forceinline void tex3DLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1566
static __forceinline void tex3DLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1576
static __forceinline void tex3DLod(long * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1578
static __forceinline void tex3DLod(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1580
static __forceinline void tex3DLod(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1582
static __forceinline void tex3DLod(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1584
static __forceinline void tex3DLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1586
static __forceinline void tex3DLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1588
static __forceinline void tex3DLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1590
static __forceinline void tex3DLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1601 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex3DLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1603
static __forceinline void tex3DLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1605
static __forceinline void tex3DLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1607
static __forceinline void tex3DLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1615
template< class T> static __forceinline T 
#line 1616
tex3DLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 1617
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 1621
::exit(___);}
#if 0
#line 1617
{ 
#line 1618
T ret; 
#line 1619
tex3DLod(&ret, texObject, x, y, z, level); 
#line 1620
return ret; 
#line 1621
} 
#endif
#line 1629 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(char * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1630
static __forceinline void tex1DLayeredLod(signed char * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1632
static __forceinline void tex1DLayeredLod(char1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1634
static __forceinline void tex1DLayeredLod(char2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1636
static __forceinline void tex1DLayeredLod(char4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1638
static __forceinline void tex1DLayeredLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1640
static __forceinline void tex1DLayeredLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1642
static __forceinline void tex1DLayeredLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1644
static __forceinline void tex1DLayeredLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1652
static __forceinline void tex1DLayeredLod(short * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1654
static __forceinline void tex1DLayeredLod(short1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1656
static __forceinline void tex1DLayeredLod(short2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1658
static __forceinline void tex1DLayeredLod(short4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1660
static __forceinline void tex1DLayeredLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1662
static __forceinline void tex1DLayeredLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1664
static __forceinline void tex1DLayeredLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1666
static __forceinline void tex1DLayeredLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1674
static __forceinline void tex1DLayeredLod(int * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1676
static __forceinline void tex1DLayeredLod(int1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1678
static __forceinline void tex1DLayeredLod(int2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1680
static __forceinline void tex1DLayeredLod(int4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1682
static __forceinline void tex1DLayeredLod(unsigned * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1684
static __forceinline void tex1DLayeredLod(uint1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1686
static __forceinline void tex1DLayeredLod(uint2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1688
static __forceinline void tex1DLayeredLod(uint4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1698
static __forceinline void tex1DLayeredLod(long * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1700
static __forceinline void tex1DLayeredLod(long1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1702
static __forceinline void tex1DLayeredLod(long2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1704
static __forceinline void tex1DLayeredLod(long4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1706
static __forceinline void tex1DLayeredLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1708
static __forceinline void tex1DLayeredLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1710
static __forceinline void tex1DLayeredLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1712
static __forceinline void tex1DLayeredLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1723 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredLod(float * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1725
static __forceinline void tex1DLayeredLod(float1 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1727
static __forceinline void tex1DLayeredLod(float2 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1729
static __forceinline void tex1DLayeredLod(float4 * retVal, cudaTextureObject_t texObject, float x, int layer, float level); 
#line 1737
template< class T> static __forceinline T 
#line 1738
tex1DLayeredLod(::cudaTextureObject_t texObject, float x, int layer, float level) 
#line 1739
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)level;
#line 1743
::exit(___);}
#if 0
#line 1739
{ 
#line 1740
T ret; 
#line 1741
tex1DLayeredLod(&ret, texObject, x, layer, level); 
#line 1742
return ret; 
#line 1743
} 
#endif
#line 1751 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1752
static __forceinline void tex2DLayeredLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1754
static __forceinline void tex2DLayeredLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1756
static __forceinline void tex2DLayeredLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1758
static __forceinline void tex2DLayeredLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1760
static __forceinline void tex2DLayeredLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1762
static __forceinline void tex2DLayeredLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1764
static __forceinline void tex2DLayeredLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1766
static __forceinline void tex2DLayeredLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1774
static __forceinline void tex2DLayeredLod(short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1776
static __forceinline void tex2DLayeredLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1778
static __forceinline void tex2DLayeredLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1780
static __forceinline void tex2DLayeredLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1782
static __forceinline void tex2DLayeredLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1784
static __forceinline void tex2DLayeredLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1786
static __forceinline void tex2DLayeredLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1788
static __forceinline void tex2DLayeredLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1796
static __forceinline void tex2DLayeredLod(int * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1798
static __forceinline void tex2DLayeredLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1800
static __forceinline void tex2DLayeredLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1802
static __forceinline void tex2DLayeredLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1804
static __forceinline void tex2DLayeredLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1806
static __forceinline void tex2DLayeredLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1808
static __forceinline void tex2DLayeredLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1810
static __forceinline void tex2DLayeredLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1820
static __forceinline void tex2DLayeredLod(long * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1822
static __forceinline void tex2DLayeredLod(long1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1824
static __forceinline void tex2DLayeredLod(long2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1826
static __forceinline void tex2DLayeredLod(long4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1828
static __forceinline void tex2DLayeredLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1830
static __forceinline void tex2DLayeredLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1832
static __forceinline void tex2DLayeredLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1834
static __forceinline void tex2DLayeredLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1845 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredLod(float * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1847
static __forceinline void tex2DLayeredLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1849
static __forceinline void tex2DLayeredLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1851
static __forceinline void tex2DLayeredLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level); 
#line 1859
template< class T> static __forceinline T 
#line 1860
tex2DLayeredLod(::cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 1861
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 1865
::exit(___);}
#if 0
#line 1861
{ 
#line 1862
T ret; 
#line 1863
tex2DLayeredLod(&ret, texObject, x, y, layer, level); 
#line 1864
return ret; 
#line 1865
} 
#endif
#line 1873 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1874
static __forceinline void texCubemapLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1876
static __forceinline void texCubemapLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1878
static __forceinline void texCubemapLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1880
static __forceinline void texCubemapLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1882
static __forceinline void texCubemapLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1884
static __forceinline void texCubemapLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1886
static __forceinline void texCubemapLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1888
static __forceinline void texCubemapLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1896
static __forceinline void texCubemapLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1898
static __forceinline void texCubemapLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1900
static __forceinline void texCubemapLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1902
static __forceinline void texCubemapLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1904
static __forceinline void texCubemapLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1906
static __forceinline void texCubemapLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1908
static __forceinline void texCubemapLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1910
static __forceinline void texCubemapLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1918
static __forceinline void texCubemapLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1920
static __forceinline void texCubemapLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1922
static __forceinline void texCubemapLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1924
static __forceinline void texCubemapLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1926
static __forceinline void texCubemapLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1928
static __forceinline void texCubemapLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1930
static __forceinline void texCubemapLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1932
static __forceinline void texCubemapLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1942
static __forceinline void texCubemapLod(long * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1944
static __forceinline void texCubemapLod(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1946
static __forceinline void texCubemapLod(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1948
static __forceinline void texCubemapLod(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1950
static __forceinline void texCubemapLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1952
static __forceinline void texCubemapLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1954
static __forceinline void texCubemapLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1956
static __forceinline void texCubemapLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1967 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1969
static __forceinline void texCubemapLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1971
static __forceinline void texCubemapLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1973
static __forceinline void texCubemapLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float level); 
#line 1981
template< class T> static __forceinline T 
#line 1982
texCubemapLod(::cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 1983
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 1987
::exit(___);}
#if 0
#line 1983
{ 
#line 1984
T ret; 
#line 1985
texCubemapLod(&ret, texObject, x, y, z, level); 
#line 1986
return ret; 
#line 1987
} 
#endif
#line 1995 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 1996
static __forceinline void texCubemapLayeredLod(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 1998
static __forceinline void texCubemapLayeredLod(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2000
static __forceinline void texCubemapLayeredLod(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2002
static __forceinline void texCubemapLayeredLod(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2004
static __forceinline void texCubemapLayeredLod(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2006
static __forceinline void texCubemapLayeredLod(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2008
static __forceinline void texCubemapLayeredLod(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2010
static __forceinline void texCubemapLayeredLod(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2018
static __forceinline void texCubemapLayeredLod(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2020
static __forceinline void texCubemapLayeredLod(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2022
static __forceinline void texCubemapLayeredLod(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2024
static __forceinline void texCubemapLayeredLod(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2026
static __forceinline void texCubemapLayeredLod(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2028
static __forceinline void texCubemapLayeredLod(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2030
static __forceinline void texCubemapLayeredLod(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2032
static __forceinline void texCubemapLayeredLod(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2040
static __forceinline void texCubemapLayeredLod(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2042
static __forceinline void texCubemapLayeredLod(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2044
static __forceinline void texCubemapLayeredLod(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2046
static __forceinline void texCubemapLayeredLod(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2048
static __forceinline void texCubemapLayeredLod(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2050
static __forceinline void texCubemapLayeredLod(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2052
static __forceinline void texCubemapLayeredLod(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2054
static __forceinline void texCubemapLayeredLod(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2064
static __forceinline void texCubemapLayeredLod(long * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2066
static __forceinline void texCubemapLayeredLod(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2068
static __forceinline void texCubemapLayeredLod(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2070
static __forceinline void texCubemapLayeredLod(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2072
static __forceinline void texCubemapLayeredLod(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2074
static __forceinline void texCubemapLayeredLod(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2076
static __forceinline void texCubemapLayeredLod(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2078
static __forceinline void texCubemapLayeredLod(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2089 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void texCubemapLayeredLod(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2091
static __forceinline void texCubemapLayeredLod(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2093
static __forceinline void texCubemapLayeredLod(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2095
static __forceinline void texCubemapLayeredLod(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level); 
#line 2103
template< class T> static __forceinline T 
#line 2104
texCubemapLayeredLod(::cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 2105
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 2109
::exit(___);}
#if 0
#line 2105
{ 
#line 2106
T ret; 
#line 2107
texCubemapLayeredLod(&ret, texObject, x, y, z, layer, level); 
#line 2108
return ret; 
#line 2109
} 
#endif
#line 2117 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(char * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2118
static __forceinline void tex1DGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2120
static __forceinline void tex1DGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2122
static __forceinline void tex1DGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2124
static __forceinline void tex1DGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2126
static __forceinline void tex1DGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2128
static __forceinline void tex1DGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2130
static __forceinline void tex1DGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2132
static __forceinline void tex1DGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2140
static __forceinline void tex1DGrad(short * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2142
static __forceinline void tex1DGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2144
static __forceinline void tex1DGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2146
static __forceinline void tex1DGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2148
static __forceinline void tex1DGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2150
static __forceinline void tex1DGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2152
static __forceinline void tex1DGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2154
static __forceinline void tex1DGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2162
static __forceinline void tex1DGrad(int * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2164
static __forceinline void tex1DGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2166
static __forceinline void tex1DGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2168
static __forceinline void tex1DGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2170
static __forceinline void tex1DGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2172
static __forceinline void tex1DGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2174
static __forceinline void tex1DGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2176
static __forceinline void tex1DGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2186
static __forceinline void tex1DGrad(long * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2188
static __forceinline void tex1DGrad(long1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2190
static __forceinline void tex1DGrad(long2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2192
static __forceinline void tex1DGrad(long4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2194
static __forceinline void tex1DGrad(unsigned long * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2196
static __forceinline void tex1DGrad(ulong1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2198
static __forceinline void tex1DGrad(ulong2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2200
static __forceinline void tex1DGrad(ulong4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2211 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DGrad(float * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2213
static __forceinline void tex1DGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2215
static __forceinline void tex1DGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2217
static __forceinline void tex1DGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy); 
#line 2225
template< class T> static __forceinline T 
#line 2226
tex1DGrad(::cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 2227
{int volatile ___ = 1;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 2231
::exit(___);}
#if 0
#line 2227
{ 
#line 2228
T ret; 
#line 2229
tex1DGrad(&ret, texObject, x, dPdx, dPdy); 
#line 2230
return ret; 
#line 2231
} 
#endif
#line 2239 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(char * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2240
static __forceinline void tex2DGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2242
static __forceinline void tex2DGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2244
static __forceinline void tex2DGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2246
static __forceinline void tex2DGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2248
static __forceinline void tex2DGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2250
static __forceinline void tex2DGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2252
static __forceinline void tex2DGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2254
static __forceinline void tex2DGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2262
static __forceinline void tex2DGrad(short * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2264
static __forceinline void tex2DGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2266
static __forceinline void tex2DGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2268
static __forceinline void tex2DGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2270
static __forceinline void tex2DGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2272
static __forceinline void tex2DGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2274
static __forceinline void tex2DGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2276
static __forceinline void tex2DGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2284
static __forceinline void tex2DGrad(int * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2286
static __forceinline void tex2DGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2288
static __forceinline void tex2DGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2290
static __forceinline void tex2DGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2292
static __forceinline void tex2DGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2294
static __forceinline void tex2DGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2296
static __forceinline void tex2DGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2298
static __forceinline void tex2DGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2308
static __forceinline void tex2DGrad(long * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2310
static __forceinline void tex2DGrad(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2312
static __forceinline void tex2DGrad(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2314
static __forceinline void tex2DGrad(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2316
static __forceinline void tex2DGrad(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2318
static __forceinline void tex2DGrad(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2320
static __forceinline void tex2DGrad(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2322
static __forceinline void tex2DGrad(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2333 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DGrad(float * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2335
static __forceinline void tex2DGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2337
static __forceinline void tex2DGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2339
static __forceinline void tex2DGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy); 
#line 2347
template< class T> static __forceinline T 
#line 2348
tex2DGrad(::cudaTextureObject_t texObject, float x, float y, ::float2 dPdx, ::float2 dPdy) 
#line 2349
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 2353
::exit(___);}
#if 0
#line 2349
{ 
#line 2350
T ret; 
#line 2351
tex2DGrad(&ret, texObject, x, y, dPdx, dPdy); 
#line 2352
return ret; 
#line 2353
} 
#endif
#line 2361 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2362
static __forceinline void tex3DGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2364
static __forceinline void tex3DGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2366
static __forceinline void tex3DGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2368
static __forceinline void tex3DGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2370
static __forceinline void tex3DGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2372
static __forceinline void tex3DGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2374
static __forceinline void tex3DGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2376
static __forceinline void tex3DGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2384
static __forceinline void tex3DGrad(short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2386
static __forceinline void tex3DGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2388
static __forceinline void tex3DGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2390
static __forceinline void tex3DGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2392
static __forceinline void tex3DGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2394
static __forceinline void tex3DGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2396
static __forceinline void tex3DGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2398
static __forceinline void tex3DGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2406
static __forceinline void tex3DGrad(int * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2408
static __forceinline void tex3DGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2410
static __forceinline void tex3DGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2412
static __forceinline void tex3DGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2414
static __forceinline void tex3DGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2416
static __forceinline void tex3DGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2418
static __forceinline void tex3DGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2420
static __forceinline void tex3DGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2430
static __forceinline void tex3DGrad(long * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2432
static __forceinline void tex3DGrad(long1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2434
static __forceinline void tex3DGrad(long2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2436
static __forceinline void tex3DGrad(long4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2438
static __forceinline void tex3DGrad(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2440
static __forceinline void tex3DGrad(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2442
static __forceinline void tex3DGrad(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2444
static __forceinline void tex3DGrad(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2455 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex3DGrad(float * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2457
static __forceinline void tex3DGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2459
static __forceinline void tex3DGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2461
static __forceinline void tex3DGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy); 
#line 2469
template< class T> static __forceinline T 
#line 2470
tex3DGrad(::cudaTextureObject_t texObject, float x, float y, float z, ::float4 dPdx, ::float4 dPdy) 
#line 2471
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 2475
::exit(___);}
#if 0
#line 2471
{ 
#line 2472
T ret; 
#line 2473
tex3DGrad(&ret, texObject, x, y, z, dPdx, dPdy); 
#line 2474
return ret; 
#line 2475
} 
#endif
#line 2483 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(char * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2484
static __forceinline void tex1DLayeredGrad(signed char * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2486
static __forceinline void tex1DLayeredGrad(char1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2488
static __forceinline void tex1DLayeredGrad(char2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2490
static __forceinline void tex1DLayeredGrad(char4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2492
static __forceinline void tex1DLayeredGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2494
static __forceinline void tex1DLayeredGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2496
static __forceinline void tex1DLayeredGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2498
static __forceinline void tex1DLayeredGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2506
static __forceinline void tex1DLayeredGrad(short * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2508
static __forceinline void tex1DLayeredGrad(short1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2510
static __forceinline void tex1DLayeredGrad(short2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2512
static __forceinline void tex1DLayeredGrad(short4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2514
static __forceinline void tex1DLayeredGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2516
static __forceinline void tex1DLayeredGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2518
static __forceinline void tex1DLayeredGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2520
static __forceinline void tex1DLayeredGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2528
static __forceinline void tex1DLayeredGrad(int * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2530
static __forceinline void tex1DLayeredGrad(int1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2532
static __forceinline void tex1DLayeredGrad(int2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2534
static __forceinline void tex1DLayeredGrad(int4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2536
static __forceinline void tex1DLayeredGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2538
static __forceinline void tex1DLayeredGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2540
static __forceinline void tex1DLayeredGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2542
static __forceinline void tex1DLayeredGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2552
static __forceinline void tex1DLayeredGrad(long * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2554
static __forceinline void tex1DLayeredGrad(long1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2556
static __forceinline void tex1DLayeredGrad(long2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2558
static __forceinline void tex1DLayeredGrad(long4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2560
static __forceinline void tex1DLayeredGrad(unsigned long * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2562
static __forceinline void tex1DLayeredGrad(ulong1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2564
static __forceinline void tex1DLayeredGrad(ulong2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2566
static __forceinline void tex1DLayeredGrad(ulong4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2577 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex1DLayeredGrad(float * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2579
static __forceinline void tex1DLayeredGrad(float1 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2581
static __forceinline void tex1DLayeredGrad(float2 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2583
static __forceinline void tex1DLayeredGrad(float4 * retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy); 
#line 2591
template< class T> static __forceinline T 
#line 2592
tex1DLayeredGrad(::cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 2593
{int volatile ___ = 1;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 2597
::exit(___);}
#if 0
#line 2593
{ 
#line 2594
T ret; 
#line 2595
tex1DLayeredGrad(&ret, texObject, x, layer, dPdx, dPdy); 
#line 2596
return ret; 
#line 2597
} 
#endif
#line 2605 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2606
static __forceinline void tex2DLayeredGrad(signed char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2608
static __forceinline void tex2DLayeredGrad(char1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2610
static __forceinline void tex2DLayeredGrad(char2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2612
static __forceinline void tex2DLayeredGrad(char4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2614
static __forceinline void tex2DLayeredGrad(unsigned char * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2616
static __forceinline void tex2DLayeredGrad(uchar1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2618
static __forceinline void tex2DLayeredGrad(uchar2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2620
static __forceinline void tex2DLayeredGrad(uchar4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2628
static __forceinline void tex2DLayeredGrad(short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2630
static __forceinline void tex2DLayeredGrad(short1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2632
static __forceinline void tex2DLayeredGrad(short2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2634
static __forceinline void tex2DLayeredGrad(short4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2636
static __forceinline void tex2DLayeredGrad(unsigned short * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2638
static __forceinline void tex2DLayeredGrad(ushort1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2640
static __forceinline void tex2DLayeredGrad(ushort2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2642
static __forceinline void tex2DLayeredGrad(ushort4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2650
static __forceinline void tex2DLayeredGrad(int * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2652
static __forceinline void tex2DLayeredGrad(int1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2654
static __forceinline void tex2DLayeredGrad(int2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2656
static __forceinline void tex2DLayeredGrad(int4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2658
static __forceinline void tex2DLayeredGrad(unsigned * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2660
static __forceinline void tex2DLayeredGrad(uint1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2662
static __forceinline void tex2DLayeredGrad(uint2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2664
static __forceinline void tex2DLayeredGrad(uint4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2674
static __forceinline void tex2DLayeredGrad(long * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2676
static __forceinline void tex2DLayeredGrad(long1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2678
static __forceinline void tex2DLayeredGrad(long2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2680
static __forceinline void tex2DLayeredGrad(long4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2682
static __forceinline void tex2DLayeredGrad(unsigned long * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2684
static __forceinline void tex2DLayeredGrad(ulong1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2686
static __forceinline void tex2DLayeredGrad(ulong2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2688
static __forceinline void tex2DLayeredGrad(ulong4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2699 "e:\\cudatoolkit\\include\\texture_indirect_functions.h"
static __forceinline void tex2DLayeredGrad(float * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2701
static __forceinline void tex2DLayeredGrad(float1 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2703
static __forceinline void tex2DLayeredGrad(float2 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2705
static __forceinline void tex2DLayeredGrad(float4 * retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy); 
#line 2713
template< class T> static __forceinline T 
#line 2714
tex2DLayeredGrad(::cudaTextureObject_t texObject, float x, float y, int layer, ::float2 dPdx, ::float2 dPdy) 
#line 2715
{int volatile ___ = 1;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 2719
::exit(___);}
#if 0
#line 2715
{ 
#line 2716
T ret; 
#line 2717
tex2DLayeredGrad(&ret, texObject, x, y, layer, dPdx, dPdy); 
#line 2718
return ret; 
#line 2719
} 
#endif
#line 75 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(char *retVal, cudaTextureObject_t texObject, int x) 
#line 76
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 85 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 76 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 81 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 82
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 84 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 85
} 
#endif
#line 86 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(signed char *retVal, cudaTextureObject_t texObject, int x) 
#line 87
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 91
::exit(___);}
#if 0
#line 87
{ 
#line 88
int4 tmp; 
#line 89
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 90
(*retVal) = ((signed char)(tmp.x)); 
#line 91
} 
#endif
#line 93 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(char1 *retVal, cudaTextureObject_t texObject, int x) 
#line 94
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 98
::exit(___);}
#if 0
#line 94
{ 
#line 95
int4 tmp; 
#line 96
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 97
(*retVal) = make_char1(tmp.x); 
#line 98
} 
#endif
#line 100 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(char2 *retVal, cudaTextureObject_t texObject, int x) 
#line 101
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 105
::exit(___);}
#if 0
#line 101
{ 
#line 102
int4 tmp; 
#line 103
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 104
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 105
} 
#endif
#line 107 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(char4 *retVal, cudaTextureObject_t texObject, int x) 
#line 108
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 112
::exit(___);}
#if 0
#line 108
{ 
#line 109
int4 tmp; 
#line 110
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 111
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 112
} 
#endif
#line 114 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(unsigned char *retVal, cudaTextureObject_t texObject, int x) 
#line 115
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 119
::exit(___);}
#if 0
#line 115
{ 
#line 116
uint4 tmp; 
#line 117
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 118
(*retVal) = ((unsigned char)(tmp.x)); 
#line 119
} 
#endif
#line 121 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(uchar1 *retVal, cudaTextureObject_t texObject, int x) 
#line 122
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 126
::exit(___);}
#if 0
#line 122
{ 
#line 123
uint4 tmp; 
#line 124
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 125
(*retVal) = make_uchar1(tmp.x); 
#line 126
} 
#endif
#line 128 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(uchar2 *retVal, cudaTextureObject_t texObject, int x) 
#line 129
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 133
::exit(___);}
#if 0
#line 129
{ 
#line 130
uint4 tmp; 
#line 131
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 132
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 133
} 
#endif
#line 135 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(uchar4 *retVal, cudaTextureObject_t texObject, int x) 
#line 136
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 140
::exit(___);}
#if 0
#line 136
{ 
#line 137
uint4 tmp; 
#line 138
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 139
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 140
} 
#endif
#line 148 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(short *retVal, cudaTextureObject_t texObject, int x) 
#line 149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 153
::exit(___);}
#if 0
#line 149
{ 
#line 150
int4 tmp; 
#line 151
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 152
(*retVal) = ((short)(tmp.x)); 
#line 153
} 
#endif
#line 155 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(short1 *retVal, cudaTextureObject_t texObject, int x) 
#line 156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 160
::exit(___);}
#if 0
#line 156
{ 
#line 157
int4 tmp; 
#line 158
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 159
(*retVal) = make_short1(tmp.x); 
#line 160
} 
#endif
#line 162 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(short2 *retVal, cudaTextureObject_t texObject, int x) 
#line 163
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 167
::exit(___);}
#if 0
#line 163
{ 
#line 164
int4 tmp; 
#line 165
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 166
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 167
} 
#endif
#line 169 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(short4 *retVal, cudaTextureObject_t texObject, int x) 
#line 170
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 174
::exit(___);}
#if 0
#line 170
{ 
#line 171
int4 tmp; 
#line 172
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 173
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 174
} 
#endif
#line 176 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(unsigned short *retVal, cudaTextureObject_t texObject, int x) 
#line 177
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 181
::exit(___);}
#if 0
#line 177
{ 
#line 178
uint4 tmp; 
#line 179
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 180
(*retVal) = ((unsigned short)(tmp.x)); 
#line 181
} 
#endif
#line 183 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(ushort1 *retVal, cudaTextureObject_t texObject, int x) 
#line 184
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 188
::exit(___);}
#if 0
#line 184
{ 
#line 185
uint4 tmp; 
#line 186
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 187
(*retVal) = make_ushort1(tmp.x); 
#line 188
} 
#endif
#line 190 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(ushort2 *retVal, cudaTextureObject_t texObject, int x) 
#line 191
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 195
::exit(___);}
#if 0
#line 191
{ 
#line 192
uint4 tmp; 
#line 193
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 194
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 195
} 
#endif
#line 197 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(ushort4 *retVal, cudaTextureObject_t texObject, int x) 
#line 198
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 202
::exit(___);}
#if 0
#line 198
{ 
#line 199
uint4 tmp; 
#line 200
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 201
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 202
} 
#endif
#line 210 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(int *retVal, cudaTextureObject_t texObject, int x) 
#line 211
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 215
::exit(___);}
#if 0
#line 211
{ 
#line 212
int4 tmp; 
#line 213
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 214
(*retVal) = (tmp.x); 
#line 215
} 
#endif
#line 217 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(int1 *retVal, cudaTextureObject_t texObject, int x) 
#line 218
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 222
::exit(___);}
#if 0
#line 218
{ 
#line 219
int4 tmp; 
#line 220
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 221
(*retVal) = make_int1(tmp.x); 
#line 222
} 
#endif
#line 224 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(int2 *retVal, cudaTextureObject_t texObject, int x) 
#line 225
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 229
::exit(___);}
#if 0
#line 225
{ 
#line 226
int4 tmp; 
#line 227
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 228
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 229
} 
#endif
#line 231 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(int4 *retVal, cudaTextureObject_t texObject, int x) 
#line 232
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 236
::exit(___);}
#if 0
#line 232
{ 
#line 233
int4 tmp; 
#line 234
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 235
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 236
} 
#endif
#line 238 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(unsigned *retVal, cudaTextureObject_t texObject, int x) 
#line 239
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 243
::exit(___);}
#if 0
#line 239
{ 
#line 240
uint4 tmp; 
#line 241
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 242
(*retVal) = (tmp.x); 
#line 243
} 
#endif
#line 245 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(uint1 *retVal, cudaTextureObject_t texObject, int x) 
#line 246
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 250
::exit(___);}
#if 0
#line 246
{ 
#line 247
uint4 tmp; 
#line 248
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 249
(*retVal) = make_uint1(tmp.x); 
#line 250
} 
#endif
#line 252 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(uint2 *retVal, cudaTextureObject_t texObject, int x) 
#line 253
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 257
::exit(___);}
#if 0
#line 253
{ 
#line 254
uint4 tmp; 
#line 255
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 256
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 257
} 
#endif
#line 259 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(uint4 *retVal, cudaTextureObject_t texObject, int x) 
#line 260
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 264
::exit(___);}
#if 0
#line 260
{ 
#line 261
uint4 tmp; 
#line 262
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 263
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 264
} 
#endif
#line 274 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(long *retVal, cudaTextureObject_t texObject, int x) 
#line 275
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 279
::exit(___);}
#if 0
#line 275
{ 
#line 276
int4 tmp; 
#line 277
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 278
(*retVal) = ((long)(tmp.x)); 
#line 279
} 
#endif
#line 281 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(long1 *retVal, cudaTextureObject_t texObject, int x) 
#line 282
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 286
::exit(___);}
#if 0
#line 282
{ 
#line 283
int4 tmp; 
#line 284
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 285
(*retVal) = make_long1(tmp.x); 
#line 286
} 
#endif
#line 288 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(long2 *retVal, cudaTextureObject_t texObject, int x) 
#line 289
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 293
::exit(___);}
#if 0
#line 289
{ 
#line 290
int4 tmp; 
#line 291
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 292
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 293
} 
#endif
#line 295 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(long4 *retVal, cudaTextureObject_t texObject, int x) 
#line 296
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 300
::exit(___);}
#if 0
#line 296
{ 
#line 297
int4 tmp; 
#line 298
__tex_1d_v4s32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 299
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 300
} 
#endif
#line 302 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(unsigned long *retVal, cudaTextureObject_t texObject, int x) 
#line 303
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 307
::exit(___);}
#if 0
#line 303
{ 
#line 304
uint4 tmp; 
#line 305
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 306
(*retVal) = ((unsigned long)(tmp.x)); 
#line 307
} 
#endif
#line 309 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(ulong1 *retVal, cudaTextureObject_t texObject, int x) 
#line 310
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 314
::exit(___);}
#if 0
#line 310
{ 
#line 311
uint4 tmp; 
#line 312
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 313
(*retVal) = make_ulong1(tmp.x); 
#line 314
} 
#endif
#line 316 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(ulong2 *retVal, cudaTextureObject_t texObject, int x) 
#line 317
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 321
::exit(___);}
#if 0
#line 317
{ 
#line 318
uint4 tmp; 
#line 319
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 320
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 321
} 
#endif
#line 323 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(ulong4 *retVal, cudaTextureObject_t texObject, int x) 
#line 324
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 328
::exit(___);}
#if 0
#line 324
{ 
#line 325
uint4 tmp; 
#line 326
__tex_1d_v4u32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 327
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 328
} 
#endif
#line 339 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(float *retVal, cudaTextureObject_t texObject, int x) 
#line 340
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 344
::exit(___);}
#if 0
#line 340
{ 
#line 341
float4 tmp; 
#line 342
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 343
(*retVal) = (tmp.x); 
#line 344
} 
#endif
#line 346 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(float1 *retVal, cudaTextureObject_t texObject, int x) 
#line 347
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 351
::exit(___);}
#if 0
#line 347
{ 
#line 348
float4 tmp; 
#line 349
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 350
(*retVal) = make_float1(tmp.x); 
#line 351
} 
#endif
#line 353 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(float2 *retVal, cudaTextureObject_t texObject, int x) 
#line 354
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 358
::exit(___);}
#if 0
#line 354
{ 
#line 355
float4 tmp; 
#line 356
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 357
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 358
} 
#endif
#line 360 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1Dfetch(float4 *retVal, cudaTextureObject_t texObject, int x) 
#line 361
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 365
::exit(___);}
#if 0
#line 361
{ 
#line 362
float4 tmp; 
#line 363
__tex_1d_v4f32_s32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 364
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 365
} 
#endif
#line 373 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(char *retVal, cudaTextureObject_t texObject, float x) 
#line 374
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 383 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 374 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 379 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 380
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 382 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 383
} 
#endif
#line 384 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(signed char *retVal, cudaTextureObject_t texObject, float x) 
#line 385
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 389
::exit(___);}
#if 0
#line 385
{ 
#line 386
int4 tmp; 
#line 387
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 388
(*retVal) = ((signed char)(tmp.x)); 
#line 389
} 
#endif
#line 391 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(char1 *retVal, cudaTextureObject_t texObject, float x) 
#line 392
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 396
::exit(___);}
#if 0
#line 392
{ 
#line 393
int4 tmp; 
#line 394
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 395
(*retVal) = make_char1(tmp.x); 
#line 396
} 
#endif
#line 398 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(char2 *retVal, cudaTextureObject_t texObject, float x) 
#line 399
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 403
::exit(___);}
#if 0
#line 399
{ 
#line 400
int4 tmp; 
#line 401
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 402
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 403
} 
#endif
#line 405 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(char4 *retVal, cudaTextureObject_t texObject, float x) 
#line 406
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 410
::exit(___);}
#if 0
#line 406
{ 
#line 407
int4 tmp; 
#line 408
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 409
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 410
} 
#endif
#line 412 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(unsigned char *retVal, cudaTextureObject_t texObject, float x) 
#line 413
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 417
::exit(___);}
#if 0
#line 413
{ 
#line 414
uint4 tmp; 
#line 415
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 416
(*retVal) = ((unsigned char)(tmp.x)); 
#line 417
} 
#endif
#line 419 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(uchar1 *retVal, cudaTextureObject_t texObject, float x) 
#line 420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 424
::exit(___);}
#if 0
#line 420
{ 
#line 421
uint4 tmp; 
#line 422
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 423
(*retVal) = make_uchar1(tmp.x); 
#line 424
} 
#endif
#line 426 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(uchar2 *retVal, cudaTextureObject_t texObject, float x) 
#line 427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 431
::exit(___);}
#if 0
#line 427
{ 
#line 428
uint4 tmp; 
#line 429
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 430
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 431
} 
#endif
#line 433 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(uchar4 *retVal, cudaTextureObject_t texObject, float x) 
#line 434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 438
::exit(___);}
#if 0
#line 434
{ 
#line 435
uint4 tmp; 
#line 436
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 437
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 438
} 
#endif
#line 446 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(short *retVal, cudaTextureObject_t texObject, float x) 
#line 447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 451
::exit(___);}
#if 0
#line 447
{ 
#line 448
int4 tmp; 
#line 449
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 450
(*retVal) = ((short)(tmp.x)); 
#line 451
} 
#endif
#line 453 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(short1 *retVal, cudaTextureObject_t texObject, float x) 
#line 454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 458
::exit(___);}
#if 0
#line 454
{ 
#line 455
int4 tmp; 
#line 456
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 457
(*retVal) = make_short1(tmp.x); 
#line 458
} 
#endif
#line 460 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(short2 *retVal, cudaTextureObject_t texObject, float x) 
#line 461
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 465
::exit(___);}
#if 0
#line 461
{ 
#line 462
int4 tmp; 
#line 463
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 464
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 465
} 
#endif
#line 467 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(short4 *retVal, cudaTextureObject_t texObject, float x) 
#line 468
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 472
::exit(___);}
#if 0
#line 468
{ 
#line 469
int4 tmp; 
#line 470
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 471
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 472
} 
#endif
#line 474 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(unsigned short *retVal, cudaTextureObject_t texObject, float x) 
#line 475
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 479
::exit(___);}
#if 0
#line 475
{ 
#line 476
uint4 tmp; 
#line 477
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 478
(*retVal) = ((unsigned short)(tmp.x)); 
#line 479
} 
#endif
#line 481 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(ushort1 *retVal, cudaTextureObject_t texObject, float x) 
#line 482
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 486
::exit(___);}
#if 0
#line 482
{ 
#line 483
uint4 tmp; 
#line 484
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 485
(*retVal) = make_ushort1(tmp.x); 
#line 486
} 
#endif
#line 488 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(ushort2 *retVal, cudaTextureObject_t texObject, float x) 
#line 489
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 493
::exit(___);}
#if 0
#line 489
{ 
#line 490
uint4 tmp; 
#line 491
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 492
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 493
} 
#endif
#line 495 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(ushort4 *retVal, cudaTextureObject_t texObject, float x) 
#line 496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 500
::exit(___);}
#if 0
#line 496
{ 
#line 497
uint4 tmp; 
#line 498
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 499
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 500
} 
#endif
#line 508 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(int *retVal, cudaTextureObject_t texObject, float x) 
#line 509
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 513
::exit(___);}
#if 0
#line 509
{ 
#line 510
int4 tmp; 
#line 511
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 512
(*retVal) = (tmp.x); 
#line 513
} 
#endif
#line 515 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(int1 *retVal, cudaTextureObject_t texObject, float x) 
#line 516
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 520
::exit(___);}
#if 0
#line 516
{ 
#line 517
int4 tmp; 
#line 518
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 519
(*retVal) = make_int1(tmp.x); 
#line 520
} 
#endif
#line 522 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(int2 *retVal, cudaTextureObject_t texObject, float x) 
#line 523
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 527
::exit(___);}
#if 0
#line 523
{ 
#line 524
int4 tmp; 
#line 525
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 526
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 527
} 
#endif
#line 529 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(int4 *retVal, cudaTextureObject_t texObject, float x) 
#line 530
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 534
::exit(___);}
#if 0
#line 530
{ 
#line 531
int4 tmp; 
#line 532
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 533
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 534
} 
#endif
#line 536 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(unsigned *retVal, cudaTextureObject_t texObject, float x) 
#line 537
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 541
::exit(___);}
#if 0
#line 537
{ 
#line 538
uint4 tmp; 
#line 539
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 540
(*retVal) = (tmp.x); 
#line 541
} 
#endif
#line 543 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(uint1 *retVal, cudaTextureObject_t texObject, float x) 
#line 544
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 548
::exit(___);}
#if 0
#line 544
{ 
#line 545
uint4 tmp; 
#line 546
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 547
(*retVal) = make_uint1(tmp.x); 
#line 548
} 
#endif
#line 550 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(uint2 *retVal, cudaTextureObject_t texObject, float x) 
#line 551
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 555
::exit(___);}
#if 0
#line 551
{ 
#line 552
uint4 tmp; 
#line 553
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 554
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 555
} 
#endif
#line 557 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(uint4 *retVal, cudaTextureObject_t texObject, float x) 
#line 558
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 562
::exit(___);}
#if 0
#line 558
{ 
#line 559
uint4 tmp; 
#line 560
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 561
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 562
} 
#endif
#line 572 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(long *retVal, cudaTextureObject_t texObject, float x) 
#line 573
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 577
::exit(___);}
#if 0
#line 573
{ 
#line 574
int4 tmp; 
#line 575
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 576
(*retVal) = ((long)(tmp.x)); 
#line 577
} 
#endif
#line 579 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(long1 *retVal, cudaTextureObject_t texObject, float x) 
#line 580
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 584
::exit(___);}
#if 0
#line 580
{ 
#line 581
int4 tmp; 
#line 582
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 583
(*retVal) = make_long1(tmp.x); 
#line 584
} 
#endif
#line 586 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(long2 *retVal, cudaTextureObject_t texObject, float x) 
#line 587
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 591
::exit(___);}
#if 0
#line 587
{ 
#line 588
int4 tmp; 
#line 589
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 590
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 591
} 
#endif
#line 593 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(long4 *retVal, cudaTextureObject_t texObject, float x) 
#line 594
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 598
::exit(___);}
#if 0
#line 594
{ 
#line 595
int4 tmp; 
#line 596
__tex_1d_v4s32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 597
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 598
} 
#endif
#line 600 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(unsigned long *retVal, cudaTextureObject_t texObject, float x) 
#line 601
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 605
::exit(___);}
#if 0
#line 601
{ 
#line 602
uint4 tmp; 
#line 603
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 604
(*retVal) = ((unsigned long)(tmp.x)); 
#line 605
} 
#endif
#line 607 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(ulong1 *retVal, cudaTextureObject_t texObject, float x) 
#line 608
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 612
::exit(___);}
#if 0
#line 608
{ 
#line 609
uint4 tmp; 
#line 610
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 611
(*retVal) = make_ulong1(tmp.x); 
#line 612
} 
#endif
#line 614 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(ulong2 *retVal, cudaTextureObject_t texObject, float x) 
#line 615
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 619
::exit(___);}
#if 0
#line 615
{ 
#line 616
uint4 tmp; 
#line 617
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 618
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 619
} 
#endif
#line 621 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(ulong4 *retVal, cudaTextureObject_t texObject, float x) 
#line 622
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 626
::exit(___);}
#if 0
#line 622
{ 
#line 623
uint4 tmp; 
#line 624
__tex_1d_v4u32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 625
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 626
} 
#endif
#line 637 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(float *retVal, cudaTextureObject_t texObject, float x) 
#line 638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 642
::exit(___);}
#if 0
#line 638
{ 
#line 639
float4 tmp; 
#line 640
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 641
(*retVal) = (tmp.x); 
#line 642
} 
#endif
#line 644 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(float1 *retVal, cudaTextureObject_t texObject, float x) 
#line 645
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 649
::exit(___);}
#if 0
#line 645
{ 
#line 646
float4 tmp; 
#line 647
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 648
(*retVal) = make_float1(tmp.x); 
#line 649
} 
#endif
#line 651 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(float2 *retVal, cudaTextureObject_t texObject, float x) 
#line 652
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 656
::exit(___);}
#if 0
#line 652
{ 
#line 653
float4 tmp; 
#line 654
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 655
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 656
} 
#endif
#line 658 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1D(float4 *retVal, cudaTextureObject_t texObject, float x) 
#line 659
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;
#line 663
::exit(___);}
#if 0
#line 659
{ 
#line 660
float4 tmp; 
#line 661
__tex_1d_v4f32_f32(texObject, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 662
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 663
} 
#endif
#line 671 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 672
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 681 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 672 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 677 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 678
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 680 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 681
} 
#endif
#line 682 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(signed char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 683
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 687
::exit(___);}
#if 0
#line 683
{ 
#line 684
int4 tmp; 
#line 685
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 686
(*retVal) = ((signed char)(tmp.x)); 
#line 687
} 
#endif
#line 689 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(char1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 690
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 694
::exit(___);}
#if 0
#line 690
{ 
#line 691
int4 tmp; 
#line 692
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 693
(*retVal) = make_char1(tmp.x); 
#line 694
} 
#endif
#line 696 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(char2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 697
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 701
::exit(___);}
#if 0
#line 697
{ 
#line 698
int4 tmp; 
#line 699
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 700
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 701
} 
#endif
#line 703 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(char4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 704
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 708
::exit(___);}
#if 0
#line 704
{ 
#line 705
int4 tmp; 
#line 706
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 707
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 708
} 
#endif
#line 710 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 711
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 715
::exit(___);}
#if 0
#line 711
{ 
#line 712
uint4 tmp; 
#line 713
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 714
(*retVal) = ((unsigned char)(tmp.x)); 
#line 715
} 
#endif
#line 717 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 722
::exit(___);}
#if 0
#line 718
{ 
#line 719
uint4 tmp; 
#line 720
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 721
(*retVal) = make_uchar1(tmp.x); 
#line 722
} 
#endif
#line 724 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 729
::exit(___);}
#if 0
#line 725
{ 
#line 726
uint4 tmp; 
#line 727
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 728
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 729
} 
#endif
#line 731 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 736
::exit(___);}
#if 0
#line 732
{ 
#line 733
uint4 tmp; 
#line 734
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 735
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 736
} 
#endif
#line 744 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(short *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 745
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 749
::exit(___);}
#if 0
#line 745
{ 
#line 746
int4 tmp; 
#line 747
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 748
(*retVal) = ((short)(tmp.x)); 
#line 749
} 
#endif
#line 751 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(short1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 756
::exit(___);}
#if 0
#line 752
{ 
#line 753
int4 tmp; 
#line 754
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 755
(*retVal) = make_short1(tmp.x); 
#line 756
} 
#endif
#line 758 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(short2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 759
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 763
::exit(___);}
#if 0
#line 759
{ 
#line 760
int4 tmp; 
#line 761
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 762
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 763
} 
#endif
#line 765 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(short4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 766
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 770
::exit(___);}
#if 0
#line 766
{ 
#line 767
int4 tmp; 
#line 768
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 769
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 770
} 
#endif
#line 772 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 773
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 777
::exit(___);}
#if 0
#line 773
{ 
#line 774
uint4 tmp; 
#line 775
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 776
(*retVal) = ((unsigned short)(tmp.x)); 
#line 777
} 
#endif
#line 779 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 780
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 784
::exit(___);}
#if 0
#line 780
{ 
#line 781
uint4 tmp; 
#line 782
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 783
(*retVal) = make_ushort1(tmp.x); 
#line 784
} 
#endif
#line 786 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 787
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 791
::exit(___);}
#if 0
#line 787
{ 
#line 788
uint4 tmp; 
#line 789
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 790
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 791
} 
#endif
#line 793 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 794
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 798
::exit(___);}
#if 0
#line 794
{ 
#line 795
uint4 tmp; 
#line 796
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 797
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 798
} 
#endif
#line 806 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(int *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 807
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 811
::exit(___);}
#if 0
#line 807
{ 
#line 808
int4 tmp; 
#line 809
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 810
(*retVal) = (tmp.x); 
#line 811
} 
#endif
#line 813 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(int1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 814
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 818
::exit(___);}
#if 0
#line 814
{ 
#line 815
int4 tmp; 
#line 816
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 817
(*retVal) = make_int1(tmp.x); 
#line 818
} 
#endif
#line 820 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(int2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 821
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 825
::exit(___);}
#if 0
#line 821
{ 
#line 822
int4 tmp; 
#line 823
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 824
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 825
} 
#endif
#line 827 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(int4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 828
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 832
::exit(___);}
#if 0
#line 828
{ 
#line 829
int4 tmp; 
#line 830
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 831
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 832
} 
#endif
#line 834 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 835
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 839
::exit(___);}
#if 0
#line 835
{ 
#line 836
uint4 tmp; 
#line 837
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 838
(*retVal) = (tmp.x); 
#line 839
} 
#endif
#line 841 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 842
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 846
::exit(___);}
#if 0
#line 842
{ 
#line 843
uint4 tmp; 
#line 844
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 845
(*retVal) = make_uint1(tmp.x); 
#line 846
} 
#endif
#line 848 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 849
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 853
::exit(___);}
#if 0
#line 849
{ 
#line 850
uint4 tmp; 
#line 851
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 852
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 853
} 
#endif
#line 855 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 856
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 860
::exit(___);}
#if 0
#line 856
{ 
#line 857
uint4 tmp; 
#line 858
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 859
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 860
} 
#endif
#line 870 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(long *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 871
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 875
::exit(___);}
#if 0
#line 871
{ 
#line 872
int4 tmp; 
#line 873
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 874
(*retVal) = ((long)(tmp.x)); 
#line 875
} 
#endif
#line 877 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(long1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 878
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 882
::exit(___);}
#if 0
#line 878
{ 
#line 879
int4 tmp; 
#line 880
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 881
(*retVal) = make_long1(tmp.x); 
#line 882
} 
#endif
#line 884 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(long2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 885
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 889
::exit(___);}
#if 0
#line 885
{ 
#line 886
int4 tmp; 
#line 887
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 888
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 889
} 
#endif
#line 891 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(long4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 892
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 896
::exit(___);}
#if 0
#line 892
{ 
#line 893
int4 tmp; 
#line 894
__tex_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 895
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 896
} 
#endif
#line 898 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 899
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 903
::exit(___);}
#if 0
#line 899
{ 
#line 900
uint4 tmp; 
#line 901
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 902
(*retVal) = ((unsigned long)(tmp.x)); 
#line 903
} 
#endif
#line 905 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 906
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 910
::exit(___);}
#if 0
#line 906
{ 
#line 907
uint4 tmp; 
#line 908
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 909
(*retVal) = make_ulong1(tmp.x); 
#line 910
} 
#endif
#line 912 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 913
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 917
::exit(___);}
#if 0
#line 913
{ 
#line 914
uint4 tmp; 
#line 915
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 916
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 917
} 
#endif
#line 919 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 920
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 924
::exit(___);}
#if 0
#line 920
{ 
#line 921
uint4 tmp; 
#line 922
__tex_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 923
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 924
} 
#endif
#line 935 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(float *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 940
::exit(___);}
#if 0
#line 936
{ 
#line 937
float4 tmp; 
#line 938
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 939
(*retVal) = (tmp.x); 
#line 940
} 
#endif
#line 942 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(float1 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 943
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 947
::exit(___);}
#if 0
#line 943
{ 
#line 944
float4 tmp; 
#line 945
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 946
(*retVal) = make_float1(tmp.x); 
#line 947
} 
#endif
#line 949 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(float2 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 950
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 954
::exit(___);}
#if 0
#line 950
{ 
#line 951
float4 tmp; 
#line 952
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 953
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 954
} 
#endif
#line 956 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2D(float4 *retVal, cudaTextureObject_t texObject, float x, float y) 
#line 957
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;
#line 961
::exit(___);}
#if 0
#line 957
{ 
#line 958
float4 tmp; 
#line 959
__tex_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 960
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 961
} 
#endif
#line 969 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 970
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 979 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 970 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 975 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 976
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 978 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 979
} 
#endif
#line 980 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 981
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 985
::exit(___);}
#if 0
#line 981
{ 
#line 982
int4 tmp; 
#line 983
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 984
(*retVal) = ((signed char)(tmp.x)); 
#line 985
} 
#endif
#line 987 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 988
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 992
::exit(___);}
#if 0
#line 988
{ 
#line 989
int4 tmp; 
#line 990
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 991
(*retVal) = make_char1(tmp.x); 
#line 992
} 
#endif
#line 994 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 995
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 999
::exit(___);}
#if 0
#line 995
{ 
#line 996
int4 tmp; 
#line 997
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 998
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 999
} 
#endif
#line 1001 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1002
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1006
::exit(___);}
#if 0
#line 1002
{ 
#line 1003
int4 tmp; 
#line 1004
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1005
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1006
} 
#endif
#line 1008 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1009
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1013
::exit(___);}
#if 0
#line 1009
{ 
#line 1010
uint4 tmp; 
#line 1011
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1012
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1013
} 
#endif
#line 1015 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1020
::exit(___);}
#if 0
#line 1016
{ 
#line 1017
uint4 tmp; 
#line 1018
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1019
(*retVal) = make_uchar1(tmp.x); 
#line 1020
} 
#endif
#line 1022 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1027
::exit(___);}
#if 0
#line 1023
{ 
#line 1024
uint4 tmp; 
#line 1025
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1026
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1027
} 
#endif
#line 1029 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1034
::exit(___);}
#if 0
#line 1030
{ 
#line 1031
uint4 tmp; 
#line 1032
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1033
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1034
} 
#endif
#line 1042 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1043
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1047
::exit(___);}
#if 0
#line 1043
{ 
#line 1044
int4 tmp; 
#line 1045
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1046
(*retVal) = ((short)(tmp.x)); 
#line 1047
} 
#endif
#line 1049 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1054
::exit(___);}
#if 0
#line 1050
{ 
#line 1051
int4 tmp; 
#line 1052
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1053
(*retVal) = make_short1(tmp.x); 
#line 1054
} 
#endif
#line 1056 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1057
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1061
::exit(___);}
#if 0
#line 1057
{ 
#line 1058
int4 tmp; 
#line 1059
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1060
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1061
} 
#endif
#line 1063 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1064
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1068
::exit(___);}
#if 0
#line 1064
{ 
#line 1065
int4 tmp; 
#line 1066
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1067
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1068
} 
#endif
#line 1070 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1071
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1075
::exit(___);}
#if 0
#line 1071
{ 
#line 1072
uint4 tmp; 
#line 1073
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1074
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1075
} 
#endif
#line 1077 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1082
::exit(___);}
#if 0
#line 1078
{ 
#line 1079
uint4 tmp; 
#line 1080
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1081
(*retVal) = make_ushort1(tmp.x); 
#line 1082
} 
#endif
#line 1084 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1085
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1089
::exit(___);}
#if 0
#line 1085
{ 
#line 1086
uint4 tmp; 
#line 1087
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1088
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1089
} 
#endif
#line 1091 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1092
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1096
::exit(___);}
#if 0
#line 1092
{ 
#line 1093
uint4 tmp; 
#line 1094
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1095
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1096
} 
#endif
#line 1104 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1105
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1109
::exit(___);}
#if 0
#line 1105
{ 
#line 1106
int4 tmp; 
#line 1107
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1108
(*retVal) = (tmp.x); 
#line 1109
} 
#endif
#line 1111 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1112
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1116
::exit(___);}
#if 0
#line 1112
{ 
#line 1113
int4 tmp; 
#line 1114
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1115
(*retVal) = make_int1(tmp.x); 
#line 1116
} 
#endif
#line 1118 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1119
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1123
::exit(___);}
#if 0
#line 1119
{ 
#line 1120
int4 tmp; 
#line 1121
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1122
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1123
} 
#endif
#line 1125 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1126
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1130
::exit(___);}
#if 0
#line 1126
{ 
#line 1127
int4 tmp; 
#line 1128
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1129
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1130
} 
#endif
#line 1132 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1133
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1137
::exit(___);}
#if 0
#line 1133
{ 
#line 1134
uint4 tmp; 
#line 1135
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1136
(*retVal) = (tmp.x); 
#line 1137
} 
#endif
#line 1139 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1140
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1144
::exit(___);}
#if 0
#line 1140
{ 
#line 1141
uint4 tmp; 
#line 1142
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1143
(*retVal) = make_uint1(tmp.x); 
#line 1144
} 
#endif
#line 1146 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1147
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1151
::exit(___);}
#if 0
#line 1147
{ 
#line 1148
uint4 tmp; 
#line 1149
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1150
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1151
} 
#endif
#line 1153 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1154
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1158
::exit(___);}
#if 0
#line 1154
{ 
#line 1155
uint4 tmp; 
#line 1156
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1157
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1158
} 
#endif
#line 1168 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1169
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1173
::exit(___);}
#if 0
#line 1169
{ 
#line 1170
int4 tmp; 
#line 1171
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1172
(*retVal) = ((long)(tmp.x)); 
#line 1173
} 
#endif
#line 1175 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1176
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1180
::exit(___);}
#if 0
#line 1176
{ 
#line 1177
int4 tmp; 
#line 1178
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1179
(*retVal) = make_long1(tmp.x); 
#line 1180
} 
#endif
#line 1182 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1183
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1187
::exit(___);}
#if 0
#line 1183
{ 
#line 1184
int4 tmp; 
#line 1185
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1186
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1187
} 
#endif
#line 1189 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1190
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1194
::exit(___);}
#if 0
#line 1190
{ 
#line 1191
int4 tmp; 
#line 1192
__tex_3d_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1193
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1194
} 
#endif
#line 1196 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1197
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1201
::exit(___);}
#if 0
#line 1197
{ 
#line 1198
uint4 tmp; 
#line 1199
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1200
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1201
} 
#endif
#line 1203 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1204
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1208
::exit(___);}
#if 0
#line 1204
{ 
#line 1205
uint4 tmp; 
#line 1206
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1207
(*retVal) = make_ulong1(tmp.x); 
#line 1208
} 
#endif
#line 1210 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1211
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1215
::exit(___);}
#if 0
#line 1211
{ 
#line 1212
uint4 tmp; 
#line 1213
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1214
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1215
} 
#endif
#line 1217 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1218
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1222
::exit(___);}
#if 0
#line 1218
{ 
#line 1219
uint4 tmp; 
#line 1220
__tex_3d_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1221
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1222
} 
#endif
#line 1233 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1238
::exit(___);}
#if 0
#line 1234
{ 
#line 1235
float4 tmp; 
#line 1236
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1237
(*retVal) = (tmp.x); 
#line 1238
} 
#endif
#line 1240 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1241
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1245
::exit(___);}
#if 0
#line 1241
{ 
#line 1242
float4 tmp; 
#line 1243
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1244
(*retVal) = make_float1(tmp.x); 
#line 1245
} 
#endif
#line 1247 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1248
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1252
::exit(___);}
#if 0
#line 1248
{ 
#line 1249
float4 tmp; 
#line 1250
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1251
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1252
} 
#endif
#line 1254 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3D(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1255
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1259
::exit(___);}
#if 0
#line 1255
{ 
#line 1256
float4 tmp; 
#line 1257
__tex_3d_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1258
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1259
} 
#endif
#line 1267 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1268
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1277 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 1268 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 1273 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 1274
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1276 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 1277
} 
#endif
#line 1278 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1279
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1283
::exit(___);}
#if 0
#line 1279
{ 
#line 1280
int4 tmp; 
#line 1281
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1282
(*retVal) = ((signed char)(tmp.x)); 
#line 1283
} 
#endif
#line 1285 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1286
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1290
::exit(___);}
#if 0
#line 1286
{ 
#line 1287
int4 tmp; 
#line 1288
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1289
(*retVal) = make_char1(tmp.x); 
#line 1290
} 
#endif
#line 1292 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1293
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1297
::exit(___);}
#if 0
#line 1293
{ 
#line 1294
int4 tmp; 
#line 1295
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1296
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1297
} 
#endif
#line 1299 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1300
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1304
::exit(___);}
#if 0
#line 1300
{ 
#line 1301
int4 tmp; 
#line 1302
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1303
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1304
} 
#endif
#line 1306 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1307
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1311
::exit(___);}
#if 0
#line 1307
{ 
#line 1308
uint4 tmp; 
#line 1309
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1310
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1311
} 
#endif
#line 1313 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1318
::exit(___);}
#if 0
#line 1314
{ 
#line 1315
uint4 tmp; 
#line 1316
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1317
(*retVal) = make_uchar1(tmp.x); 
#line 1318
} 
#endif
#line 1320 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1325
::exit(___);}
#if 0
#line 1321
{ 
#line 1322
uint4 tmp; 
#line 1323
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1324
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1325
} 
#endif
#line 1327 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1332
::exit(___);}
#if 0
#line 1328
{ 
#line 1329
uint4 tmp; 
#line 1330
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1331
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1332
} 
#endif
#line 1340 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(short *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1341
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1345
::exit(___);}
#if 0
#line 1341
{ 
#line 1342
int4 tmp; 
#line 1343
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1344
(*retVal) = ((short)(tmp.x)); 
#line 1345
} 
#endif
#line 1347 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1352
::exit(___);}
#if 0
#line 1348
{ 
#line 1349
int4 tmp; 
#line 1350
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1351
(*retVal) = make_short1(tmp.x); 
#line 1352
} 
#endif
#line 1354 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1359
::exit(___);}
#if 0
#line 1355
{ 
#line 1356
int4 tmp; 
#line 1357
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1358
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1359
} 
#endif
#line 1361 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1366
::exit(___);}
#if 0
#line 1362
{ 
#line 1363
int4 tmp; 
#line 1364
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1365
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1366
} 
#endif
#line 1368 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1373
::exit(___);}
#if 0
#line 1369
{ 
#line 1370
uint4 tmp; 
#line 1371
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1372
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1373
} 
#endif
#line 1375 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1380
::exit(___);}
#if 0
#line 1376
{ 
#line 1377
uint4 tmp; 
#line 1378
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1379
(*retVal) = make_ushort1(tmp.x); 
#line 1380
} 
#endif
#line 1382 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1387
::exit(___);}
#if 0
#line 1383
{ 
#line 1384
uint4 tmp; 
#line 1385
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1386
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1387
} 
#endif
#line 1389 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1394
::exit(___);}
#if 0
#line 1390
{ 
#line 1391
uint4 tmp; 
#line 1392
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1393
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1394
} 
#endif
#line 1402 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(int *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1403
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1407
::exit(___);}
#if 0
#line 1403
{ 
#line 1404
int4 tmp; 
#line 1405
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1406
(*retVal) = (tmp.x); 
#line 1407
} 
#endif
#line 1409 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1410
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1414
::exit(___);}
#if 0
#line 1410
{ 
#line 1411
int4 tmp; 
#line 1412
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1413
(*retVal) = make_int1(tmp.x); 
#line 1414
} 
#endif
#line 1416 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1417
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1421
::exit(___);}
#if 0
#line 1417
{ 
#line 1418
int4 tmp; 
#line 1419
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1420
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1421
} 
#endif
#line 1423 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1424
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1428
::exit(___);}
#if 0
#line 1424
{ 
#line 1425
int4 tmp; 
#line 1426
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1427
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1428
} 
#endif
#line 1430 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1431
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1435
::exit(___);}
#if 0
#line 1431
{ 
#line 1432
uint4 tmp; 
#line 1433
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1434
(*retVal) = (tmp.x); 
#line 1435
} 
#endif
#line 1437 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1438
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1442
::exit(___);}
#if 0
#line 1438
{ 
#line 1439
uint4 tmp; 
#line 1440
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1441
(*retVal) = make_uint1(tmp.x); 
#line 1442
} 
#endif
#line 1444 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1445
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1449
::exit(___);}
#if 0
#line 1445
{ 
#line 1446
uint4 tmp; 
#line 1447
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1448
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1449
} 
#endif
#line 1451 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1452
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1456
::exit(___);}
#if 0
#line 1452
{ 
#line 1453
uint4 tmp; 
#line 1454
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1455
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1456
} 
#endif
#line 1466 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(long *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1467
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1471
::exit(___);}
#if 0
#line 1467
{ 
#line 1468
int4 tmp; 
#line 1469
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1470
(*retVal) = ((long)(tmp.x)); 
#line 1471
} 
#endif
#line 1473 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1474
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1478
::exit(___);}
#if 0
#line 1474
{ 
#line 1475
int4 tmp; 
#line 1476
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1477
(*retVal) = make_long1(tmp.x); 
#line 1478
} 
#endif
#line 1480 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1481
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1485
::exit(___);}
#if 0
#line 1481
{ 
#line 1482
int4 tmp; 
#line 1483
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1484
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1485
} 
#endif
#line 1487 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1488
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1492
::exit(___);}
#if 0
#line 1488
{ 
#line 1489
int4 tmp; 
#line 1490
__tex_1d_array_v4s32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1491
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1492
} 
#endif
#line 1494 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1495
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1499
::exit(___);}
#if 0
#line 1495
{ 
#line 1496
uint4 tmp; 
#line 1497
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1498
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1499
} 
#endif
#line 1501 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1502
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1506
::exit(___);}
#if 0
#line 1502
{ 
#line 1503
uint4 tmp; 
#line 1504
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1505
(*retVal) = make_ulong1(tmp.x); 
#line 1506
} 
#endif
#line 1508 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1509
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1513
::exit(___);}
#if 0
#line 1509
{ 
#line 1510
uint4 tmp; 
#line 1511
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1512
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1513
} 
#endif
#line 1515 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1516
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1520
::exit(___);}
#if 0
#line 1516
{ 
#line 1517
uint4 tmp; 
#line 1518
__tex_1d_array_v4u32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1519
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1520
} 
#endif
#line 1531 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(float *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1536
::exit(___);}
#if 0
#line 1532
{ 
#line 1533
float4 tmp; 
#line 1534
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1535
(*retVal) = (tmp.x); 
#line 1536
} 
#endif
#line 1538 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1539
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1543
::exit(___);}
#if 0
#line 1539
{ 
#line 1540
float4 tmp; 
#line 1541
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1542
(*retVal) = make_float1(tmp.x); 
#line 1543
} 
#endif
#line 1545 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1546
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1550
::exit(___);}
#if 0
#line 1546
{ 
#line 1547
float4 tmp; 
#line 1548
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1549
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1550
} 
#endif
#line 1552 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, int layer) 
#line 1553
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;
#line 1557
::exit(___);}
#if 0
#line 1553
{ 
#line 1554
float4 tmp; 
#line 1555
__tex_1d_array_v4f32_f32(texObject, layer, x, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1556
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1557
} 
#endif
#line 1565 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1566
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1575 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 1566 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 1571 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 1572
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1574 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 1575
} 
#endif
#line 1576 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1577
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1581
::exit(___);}
#if 0
#line 1577
{ 
#line 1578
int4 tmp; 
#line 1579
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1580
(*retVal) = ((signed char)(tmp.x)); 
#line 1581
} 
#endif
#line 1583 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1584
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1588
::exit(___);}
#if 0
#line 1584
{ 
#line 1585
int4 tmp; 
#line 1586
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1587
(*retVal) = make_char1(tmp.x); 
#line 1588
} 
#endif
#line 1590 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1591
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1595
::exit(___);}
#if 0
#line 1591
{ 
#line 1592
int4 tmp; 
#line 1593
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1594
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1595
} 
#endif
#line 1597 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1598
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1602
::exit(___);}
#if 0
#line 1598
{ 
#line 1599
int4 tmp; 
#line 1600
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1601
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1602
} 
#endif
#line 1604 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1605
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1609
::exit(___);}
#if 0
#line 1605
{ 
#line 1606
uint4 tmp; 
#line 1607
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1608
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1609
} 
#endif
#line 1611 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1616
::exit(___);}
#if 0
#line 1612
{ 
#line 1613
uint4 tmp; 
#line 1614
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1615
(*retVal) = make_uchar1(tmp.x); 
#line 1616
} 
#endif
#line 1618 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1623
::exit(___);}
#if 0
#line 1619
{ 
#line 1620
uint4 tmp; 
#line 1621
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1622
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1623
} 
#endif
#line 1625 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1630
::exit(___);}
#if 0
#line 1626
{ 
#line 1627
uint4 tmp; 
#line 1628
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1629
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1630
} 
#endif
#line 1638 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1639
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1643
::exit(___);}
#if 0
#line 1639
{ 
#line 1640
int4 tmp; 
#line 1641
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1642
(*retVal) = ((short)(tmp.x)); 
#line 1643
} 
#endif
#line 1645 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1646
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1650
::exit(___);}
#if 0
#line 1646
{ 
#line 1647
int4 tmp; 
#line 1648
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1649
(*retVal) = make_short1(tmp.x); 
#line 1650
} 
#endif
#line 1652 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1653
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1657
::exit(___);}
#if 0
#line 1653
{ 
#line 1654
int4 tmp; 
#line 1655
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1656
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1657
} 
#endif
#line 1659 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1664
::exit(___);}
#if 0
#line 1660
{ 
#line 1661
int4 tmp; 
#line 1662
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1663
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1664
} 
#endif
#line 1666 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1671
::exit(___);}
#if 0
#line 1667
{ 
#line 1668
uint4 tmp; 
#line 1669
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1670
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1671
} 
#endif
#line 1673 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1678
::exit(___);}
#if 0
#line 1674
{ 
#line 1675
uint4 tmp; 
#line 1676
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1677
(*retVal) = make_ushort1(tmp.x); 
#line 1678
} 
#endif
#line 1680 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1685
::exit(___);}
#if 0
#line 1681
{ 
#line 1682
uint4 tmp; 
#line 1683
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1684
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1685
} 
#endif
#line 1687 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1692
::exit(___);}
#if 0
#line 1688
{ 
#line 1689
uint4 tmp; 
#line 1690
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1691
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1692
} 
#endif
#line 1700 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1701
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1705
::exit(___);}
#if 0
#line 1701
{ 
#line 1702
int4 tmp; 
#line 1703
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1704
(*retVal) = (tmp.x); 
#line 1705
} 
#endif
#line 1707 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1708
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1712
::exit(___);}
#if 0
#line 1708
{ 
#line 1709
int4 tmp; 
#line 1710
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1711
(*retVal) = make_int1(tmp.x); 
#line 1712
} 
#endif
#line 1714 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1715
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1719
::exit(___);}
#if 0
#line 1715
{ 
#line 1716
int4 tmp; 
#line 1717
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1718
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 1719
} 
#endif
#line 1721 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1722
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1726
::exit(___);}
#if 0
#line 1722
{ 
#line 1723
int4 tmp; 
#line 1724
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1725
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1726
} 
#endif
#line 1728 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1729
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1733
::exit(___);}
#if 0
#line 1729
{ 
#line 1730
uint4 tmp; 
#line 1731
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1732
(*retVal) = (tmp.x); 
#line 1733
} 
#endif
#line 1735 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1736
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1740
::exit(___);}
#if 0
#line 1736
{ 
#line 1737
uint4 tmp; 
#line 1738
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1739
(*retVal) = make_uint1(tmp.x); 
#line 1740
} 
#endif
#line 1742 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1743
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1747
::exit(___);}
#if 0
#line 1743
{ 
#line 1744
uint4 tmp; 
#line 1745
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1746
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 1747
} 
#endif
#line 1749 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1750
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1754
::exit(___);}
#if 0
#line 1750
{ 
#line 1751
uint4 tmp; 
#line 1752
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1753
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1754
} 
#endif
#line 1764 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1765
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1769
::exit(___);}
#if 0
#line 1765
{ 
#line 1766
int4 tmp; 
#line 1767
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1768
(*retVal) = ((long)(tmp.x)); 
#line 1769
} 
#endif
#line 1771 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1772
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1776
::exit(___);}
#if 0
#line 1772
{ 
#line 1773
int4 tmp; 
#line 1774
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1775
(*retVal) = make_long1(tmp.x); 
#line 1776
} 
#endif
#line 1778 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1779
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1783
::exit(___);}
#if 0
#line 1779
{ 
#line 1780
int4 tmp; 
#line 1781
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1782
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 1783
} 
#endif
#line 1785 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1786
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1790
::exit(___);}
#if 0
#line 1786
{ 
#line 1787
int4 tmp; 
#line 1788
__tex_2d_array_v4s32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1789
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1790
} 
#endif
#line 1792 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1793
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1797
::exit(___);}
#if 0
#line 1793
{ 
#line 1794
uint4 tmp; 
#line 1795
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1796
(*retVal) = ((unsigned long)(tmp.x)); 
#line 1797
} 
#endif
#line 1799 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1800
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1804
::exit(___);}
#if 0
#line 1800
{ 
#line 1801
uint4 tmp; 
#line 1802
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1803
(*retVal) = make_ulong1(tmp.x); 
#line 1804
} 
#endif
#line 1806 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1807
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1811
::exit(___);}
#if 0
#line 1807
{ 
#line 1808
uint4 tmp; 
#line 1809
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1810
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 1811
} 
#endif
#line 1813 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1814
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1818
::exit(___);}
#if 0
#line 1814
{ 
#line 1815
uint4 tmp; 
#line 1816
__tex_2d_array_v4u32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1817
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1818
} 
#endif
#line 1829 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1834
::exit(___);}
#if 0
#line 1830
{ 
#line 1831
float4 tmp; 
#line 1832
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1833
(*retVal) = (tmp.x); 
#line 1834
} 
#endif
#line 1836 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1837
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1841
::exit(___);}
#if 0
#line 1837
{ 
#line 1838
float4 tmp; 
#line 1839
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1840
(*retVal) = make_float1(tmp.x); 
#line 1841
} 
#endif
#line 1843 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1844
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1848
::exit(___);}
#if 0
#line 1844
{ 
#line 1845
float4 tmp; 
#line 1846
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1847
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 1848
} 
#endif
#line 1850 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer) 
#line 1851
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;
#line 1855
::exit(___);}
#if 0
#line 1851
{ 
#line 1852
float4 tmp; 
#line 1853
__tex_2d_array_v4f32_f32(texObject, layer, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1854
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1855
} 
#endif
#line 1863 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1864
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1873 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 1864 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 1869 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 1870
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1872 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 1873
} 
#endif
#line 1874 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1875
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1879
::exit(___);}
#if 0
#line 1875
{ 
#line 1876
int4 tmp; 
#line 1877
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1878
(*retVal) = ((signed char)(tmp.x)); 
#line 1879
} 
#endif
#line 1881 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1882
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1886
::exit(___);}
#if 0
#line 1882
{ 
#line 1883
int4 tmp; 
#line 1884
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1885
(*retVal) = make_char1(tmp.x); 
#line 1886
} 
#endif
#line 1888 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1889
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1893
::exit(___);}
#if 0
#line 1889
{ 
#line 1890
int4 tmp; 
#line 1891
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1892
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 1893
} 
#endif
#line 1895 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1896
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1900
::exit(___);}
#if 0
#line 1896
{ 
#line 1897
int4 tmp; 
#line 1898
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1899
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1900
} 
#endif
#line 1902 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1903
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1907
::exit(___);}
#if 0
#line 1903
{ 
#line 1904
uint4 tmp; 
#line 1905
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1906
(*retVal) = ((unsigned char)(tmp.x)); 
#line 1907
} 
#endif
#line 1909 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1914
::exit(___);}
#if 0
#line 1910
{ 
#line 1911
uint4 tmp; 
#line 1912
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1913
(*retVal) = make_uchar1(tmp.x); 
#line 1914
} 
#endif
#line 1916 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1921
::exit(___);}
#if 0
#line 1917
{ 
#line 1918
uint4 tmp; 
#line 1919
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1920
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 1921
} 
#endif
#line 1923 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1928
::exit(___);}
#if 0
#line 1924
{ 
#line 1925
uint4 tmp; 
#line 1926
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1927
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1928
} 
#endif
#line 1936 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1937
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1941
::exit(___);}
#if 0
#line 1937
{ 
#line 1938
int4 tmp; 
#line 1939
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1940
(*retVal) = ((short)(tmp.x)); 
#line 1941
} 
#endif
#line 1943 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1944
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1948
::exit(___);}
#if 0
#line 1944
{ 
#line 1945
int4 tmp; 
#line 1946
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1947
(*retVal) = make_short1(tmp.x); 
#line 1948
} 
#endif
#line 1950 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1951
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1955
::exit(___);}
#if 0
#line 1951
{ 
#line 1952
int4 tmp; 
#line 1953
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1954
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 1955
} 
#endif
#line 1957 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1958
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1962
::exit(___);}
#if 0
#line 1958
{ 
#line 1959
int4 tmp; 
#line 1960
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1961
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1962
} 
#endif
#line 1964 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1965
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1969
::exit(___);}
#if 0
#line 1965
{ 
#line 1966
uint4 tmp; 
#line 1967
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1968
(*retVal) = ((unsigned short)(tmp.x)); 
#line 1969
} 
#endif
#line 1971 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1976
::exit(___);}
#if 0
#line 1972
{ 
#line 1973
uint4 tmp; 
#line 1974
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1975
(*retVal) = make_ushort1(tmp.x); 
#line 1976
} 
#endif
#line 1978 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1983
::exit(___);}
#if 0
#line 1979
{ 
#line 1980
uint4 tmp; 
#line 1981
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1982
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 1983
} 
#endif
#line 1985 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 1990
::exit(___);}
#if 0
#line 1986
{ 
#line 1987
uint4 tmp; 
#line 1988
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 1989
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 1990
} 
#endif
#line 1998 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(int *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 1999
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2003
::exit(___);}
#if 0
#line 1999
{ 
#line 2000
int4 tmp; 
#line 2001
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2002
(*retVal) = (tmp.x); 
#line 2003
} 
#endif
#line 2005 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2006
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2010
::exit(___);}
#if 0
#line 2006
{ 
#line 2007
int4 tmp; 
#line 2008
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2009
(*retVal) = make_int1(tmp.x); 
#line 2010
} 
#endif
#line 2012 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2013
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2017
::exit(___);}
#if 0
#line 2013
{ 
#line 2014
int4 tmp; 
#line 2015
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2016
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2017
} 
#endif
#line 2019 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2020
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2024
::exit(___);}
#if 0
#line 2020
{ 
#line 2021
int4 tmp; 
#line 2022
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2023
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2024
} 
#endif
#line 2026 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2027
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2031
::exit(___);}
#if 0
#line 2027
{ 
#line 2028
uint4 tmp; 
#line 2029
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2030
(*retVal) = (tmp.x); 
#line 2031
} 
#endif
#line 2033 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2034
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2038
::exit(___);}
#if 0
#line 2034
{ 
#line 2035
uint4 tmp; 
#line 2036
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2037
(*retVal) = make_uint1(tmp.x); 
#line 2038
} 
#endif
#line 2040 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2041
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2045
::exit(___);}
#if 0
#line 2041
{ 
#line 2042
uint4 tmp; 
#line 2043
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2044
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2045
} 
#endif
#line 2047 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2048
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2052
::exit(___);}
#if 0
#line 2048
{ 
#line 2049
uint4 tmp; 
#line 2050
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2051
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2052
} 
#endif
#line 2062 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2063
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2067
::exit(___);}
#if 0
#line 2063
{ 
#line 2064
int4 tmp; 
#line 2065
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2066
(*retVal) = ((long)(tmp.x)); 
#line 2067
} 
#endif
#line 2069 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2070
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2074
::exit(___);}
#if 0
#line 2070
{ 
#line 2071
int4 tmp; 
#line 2072
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2073
(*retVal) = make_long1(tmp.x); 
#line 2074
} 
#endif
#line 2076 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2077
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2081
::exit(___);}
#if 0
#line 2077
{ 
#line 2078
int4 tmp; 
#line 2079
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2080
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2081
} 
#endif
#line 2083 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2084
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2088
::exit(___);}
#if 0
#line 2084
{ 
#line 2085
int4 tmp; 
#line 2086
__tex_cube_v4s32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2087
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2088
} 
#endif
#line 2090 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2091
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2095
::exit(___);}
#if 0
#line 2091
{ 
#line 2092
uint4 tmp; 
#line 2093
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2094
(*retVal) = ((unsigned long)(tmp.x)); 
#line 2095
} 
#endif
#line 2097 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2098
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2102
::exit(___);}
#if 0
#line 2098
{ 
#line 2099
uint4 tmp; 
#line 2100
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2101
(*retVal) = make_ulong1(tmp.x); 
#line 2102
} 
#endif
#line 2104 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2105
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2109
::exit(___);}
#if 0
#line 2105
{ 
#line 2106
uint4 tmp; 
#line 2107
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2108
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 2109
} 
#endif
#line 2111 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2112
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2116
::exit(___);}
#if 0
#line 2112
{ 
#line 2113
uint4 tmp; 
#line 2114
__tex_cube_v4u32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2115
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2116
} 
#endif
#line 2127 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(float *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2128
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2132
::exit(___);}
#if 0
#line 2128
{ 
#line 2129
float4 tmp; 
#line 2130
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2131
(*retVal) = (tmp.x); 
#line 2132
} 
#endif
#line 2134 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2135
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2139
::exit(___);}
#if 0
#line 2135
{ 
#line 2136
float4 tmp; 
#line 2137
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2138
(*retVal) = make_float1(tmp.x); 
#line 2139
} 
#endif
#line 2141 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2142
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2146
::exit(___);}
#if 0
#line 2142
{ 
#line 2143
float4 tmp; 
#line 2144
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2145
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2146
} 
#endif
#line 2148 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemap(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z) 
#line 2149
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;
#line 2153
::exit(___);}
#if 0
#line 2149
{ 
#line 2150
float4 tmp; 
#line 2151
__tex_cube_v4f32_f32(texObject, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2152
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2153
} 
#endif
#line 2161 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2162
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2171 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 2162 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 2167 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 2168
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2170 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 2171
} 
#endif
#line 2172 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2173
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2177
::exit(___);}
#if 0
#line 2173
{ 
#line 2174
int4 tmp; 
#line 2175
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2176
(*retVal) = ((signed char)(tmp.x)); 
#line 2177
} 
#endif
#line 2179 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2180
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2184
::exit(___);}
#if 0
#line 2180
{ 
#line 2181
int4 tmp; 
#line 2182
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2183
(*retVal) = make_char1(tmp.x); 
#line 2184
} 
#endif
#line 2186 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2187
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2191
::exit(___);}
#if 0
#line 2187
{ 
#line 2188
int4 tmp; 
#line 2189
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2190
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2191
} 
#endif
#line 2193 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2194
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2198
::exit(___);}
#if 0
#line 2194
{ 
#line 2195
int4 tmp; 
#line 2196
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2197
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2198
} 
#endif
#line 2200 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2201
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2205
::exit(___);}
#if 0
#line 2201
{ 
#line 2202
uint4 tmp; 
#line 2203
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2204
(*retVal) = ((unsigned char)(tmp.x)); 
#line 2205
} 
#endif
#line 2207 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2208
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2212
::exit(___);}
#if 0
#line 2208
{ 
#line 2209
uint4 tmp; 
#line 2210
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2211
(*retVal) = make_uchar1(tmp.x); 
#line 2212
} 
#endif
#line 2214 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2215
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2219
::exit(___);}
#if 0
#line 2215
{ 
#line 2216
uint4 tmp; 
#line 2217
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2218
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2219
} 
#endif
#line 2221 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2226
::exit(___);}
#if 0
#line 2222
{ 
#line 2223
uint4 tmp; 
#line 2224
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2225
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2226
} 
#endif
#line 2234 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2235
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2239
::exit(___);}
#if 0
#line 2235
{ 
#line 2236
int4 tmp; 
#line 2237
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2238
(*retVal) = ((short)(tmp.x)); 
#line 2239
} 
#endif
#line 2241 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2242
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2246
::exit(___);}
#if 0
#line 2242
{ 
#line 2243
int4 tmp; 
#line 2244
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2245
(*retVal) = make_short1(tmp.x); 
#line 2246
} 
#endif
#line 2248 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2249
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2253
::exit(___);}
#if 0
#line 2249
{ 
#line 2250
int4 tmp; 
#line 2251
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2252
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2253
} 
#endif
#line 2255 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2256
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2260
::exit(___);}
#if 0
#line 2256
{ 
#line 2257
int4 tmp; 
#line 2258
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2259
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2260
} 
#endif
#line 2262 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2263
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2267
::exit(___);}
#if 0
#line 2263
{ 
#line 2264
uint4 tmp; 
#line 2265
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2266
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2267
} 
#endif
#line 2269 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2270
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2274
::exit(___);}
#if 0
#line 2270
{ 
#line 2271
uint4 tmp; 
#line 2272
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2273
(*retVal) = make_ushort1(tmp.x); 
#line 2274
} 
#endif
#line 2276 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2281
::exit(___);}
#if 0
#line 2277
{ 
#line 2278
uint4 tmp; 
#line 2279
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2280
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2281
} 
#endif
#line 2283 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2288
::exit(___);}
#if 0
#line 2284
{ 
#line 2285
uint4 tmp; 
#line 2286
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2287
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2288
} 
#endif
#line 2296 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2297
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2301
::exit(___);}
#if 0
#line 2297
{ 
#line 2298
int4 tmp; 
#line 2299
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2300
(*retVal) = (tmp.x); 
#line 2301
} 
#endif
#line 2303 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2304
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2308
::exit(___);}
#if 0
#line 2304
{ 
#line 2305
int4 tmp; 
#line 2306
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2307
(*retVal) = make_int1(tmp.x); 
#line 2308
} 
#endif
#line 2310 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2311
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2315
::exit(___);}
#if 0
#line 2311
{ 
#line 2312
int4 tmp; 
#line 2313
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2314
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2315
} 
#endif
#line 2317 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2318
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2322
::exit(___);}
#if 0
#line 2318
{ 
#line 2319
int4 tmp; 
#line 2320
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2321
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2322
} 
#endif
#line 2324 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2325
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2329
::exit(___);}
#if 0
#line 2325
{ 
#line 2326
uint4 tmp; 
#line 2327
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2328
(*retVal) = (tmp.x); 
#line 2329
} 
#endif
#line 2331 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2332
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2336
::exit(___);}
#if 0
#line 2332
{ 
#line 2333
uint4 tmp; 
#line 2334
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2335
(*retVal) = make_uint1(tmp.x); 
#line 2336
} 
#endif
#line 2338 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2339
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2343
::exit(___);}
#if 0
#line 2339
{ 
#line 2340
uint4 tmp; 
#line 2341
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2342
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2343
} 
#endif
#line 2345 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2346
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2350
::exit(___);}
#if 0
#line 2346
{ 
#line 2347
uint4 tmp; 
#line 2348
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2349
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2350
} 
#endif
#line 2360 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2361
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2365
::exit(___);}
#if 0
#line 2361
{ 
#line 2362
int4 tmp; 
#line 2363
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2364
(*retVal) = ((long)(tmp.x)); 
#line 2365
} 
#endif
#line 2367 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2368
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2372
::exit(___);}
#if 0
#line 2368
{ 
#line 2369
int4 tmp; 
#line 2370
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2371
(*retVal) = make_long1(tmp.x); 
#line 2372
} 
#endif
#line 2374 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2375
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2379
::exit(___);}
#if 0
#line 2375
{ 
#line 2376
int4 tmp; 
#line 2377
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2378
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2379
} 
#endif
#line 2381 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2382
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2386
::exit(___);}
#if 0
#line 2382
{ 
#line 2383
int4 tmp; 
#line 2384
__tex_cube_array_v4s32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2385
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2386
} 
#endif
#line 2388 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2389
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2393
::exit(___);}
#if 0
#line 2389
{ 
#line 2390
uint4 tmp; 
#line 2391
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2392
(*retVal) = ((unsigned long)(tmp.x)); 
#line 2393
} 
#endif
#line 2395 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2396
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2400
::exit(___);}
#if 0
#line 2396
{ 
#line 2397
uint4 tmp; 
#line 2398
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2399
(*retVal) = make_ulong1(tmp.x); 
#line 2400
} 
#endif
#line 2402 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2403
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2407
::exit(___);}
#if 0
#line 2403
{ 
#line 2404
uint4 tmp; 
#line 2405
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2406
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 2407
} 
#endif
#line 2409 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2410
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2414
::exit(___);}
#if 0
#line 2410
{ 
#line 2411
uint4 tmp; 
#line 2412
__tex_cube_array_v4u32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2413
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2414
} 
#endif
#line 2425 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2430
::exit(___);}
#if 0
#line 2426
{ 
#line 2427
float4 tmp; 
#line 2428
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2429
(*retVal) = (tmp.x); 
#line 2430
} 
#endif
#line 2432 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2433
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2437
::exit(___);}
#if 0
#line 2433
{ 
#line 2434
float4 tmp; 
#line 2435
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2436
(*retVal) = make_float1(tmp.x); 
#line 2437
} 
#endif
#line 2439 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2440
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2444
::exit(___);}
#if 0
#line 2440
{ 
#line 2441
float4 tmp; 
#line 2442
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2443
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 2444
} 
#endif
#line 2446 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayered(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer) 
#line 2447
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;
#line 2451
::exit(___);}
#if 0
#line 2447
{ 
#line 2448
float4 tmp; 
#line 2449
__tex_cube_array_v4f32_f32(texObject, layer, x, y, z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2450
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2451
} 
#endif
#line 2459 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(char *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2460
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2475
::exit(___);}
#if 0
#line 2460
{ 
#line 2461
int4 tmp; 
#line 2462
if (comp == 0) { 
#line 2463
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2464
} else { 
#line 2465
if (comp == 1) { 
#line 2466
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2467
} else { 
#line 2468
if (comp == 2) { 
#line 2469
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2470
} else { 
#line 2471
if (comp == 3) { 
#line 2472
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2473
}  }  }  }  
#line 2474
(*retVal) = ((char)(tmp.x)); 
#line 2475
} 
#endif
#line 2477 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2478
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2493
::exit(___);}
#if 0
#line 2478
{ 
#line 2479
int4 tmp; 
#line 2480
if (comp == 0) { 
#line 2481
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2482
} else { 
#line 2483
if (comp == 1) { 
#line 2484
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2485
} else { 
#line 2486
if (comp == 2) { 
#line 2487
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2488
} else { 
#line 2489
if (comp == 3) { 
#line 2490
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2491
}  }  }  }  
#line 2492
(*retVal) = ((signed char)(tmp.x)); 
#line 2493
} 
#endif
#line 2495 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2496
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2511
::exit(___);}
#if 0
#line 2496
{ 
#line 2497
int4 tmp; 
#line 2498
if (comp == 0) { 
#line 2499
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2500
} else { 
#line 2501
if (comp == 1) { 
#line 2502
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2503
} else { 
#line 2504
if (comp == 2) { 
#line 2505
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2506
} else { 
#line 2507
if (comp == 3) { 
#line 2508
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2509
}  }  }  }  
#line 2510
(*retVal) = make_char1(tmp.x); 
#line 2511
} 
#endif
#line 2513 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2529
::exit(___);}
#if 0
#line 2514
{ 
#line 2515
int4 tmp; 
#line 2516
if (comp == 0) { 
#line 2517
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2518
} else { 
#line 2519
if (comp == 1) { 
#line 2520
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2521
} else { 
#line 2522
if (comp == 2) { 
#line 2523
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2524
} else { 
#line 2525
if (comp == 3) { 
#line 2526
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2527
}  }  }  }  
#line 2528
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 2529
} 
#endif
#line 2531 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2547
::exit(___);}
#if 0
#line 2532
{ 
#line 2533
int4 tmp; 
#line 2534
if (comp == 0) { 
#line 2535
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2536
} else { 
#line 2537
if (comp == 1) { 
#line 2538
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2539
} else { 
#line 2540
if (comp == 2) { 
#line 2541
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2542
} else { 
#line 2543
if (comp == 3) { 
#line 2544
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2545
}  }  }  }  
#line 2546
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2547
} 
#endif
#line 2549 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2550
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2565
::exit(___);}
#if 0
#line 2550
{ 
#line 2551
uint4 tmp; 
#line 2552
if (comp == 0) { 
#line 2553
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2554
} else { 
#line 2555
if (comp == 1) { 
#line 2556
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2557
} else { 
#line 2558
if (comp == 2) { 
#line 2559
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2560
} else { 
#line 2561
if (comp == 3) { 
#line 2562
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2563
}  }  }  }  
#line 2564
(*retVal) = ((unsigned char)(tmp.x)); 
#line 2565
} 
#endif
#line 2567 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2568
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2583
::exit(___);}
#if 0
#line 2568
{ 
#line 2569
uint4 tmp; 
#line 2570
if (comp == 0) { 
#line 2571
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2572
} else { 
#line 2573
if (comp == 1) { 
#line 2574
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2575
} else { 
#line 2576
if (comp == 2) { 
#line 2577
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2578
} else { 
#line 2579
if (comp == 3) { 
#line 2580
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2581
}  }  }  }  
#line 2582
(*retVal) = make_uchar1(tmp.x); 
#line 2583
} 
#endif
#line 2585 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2586
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2601
::exit(___);}
#if 0
#line 2586
{ 
#line 2587
uint4 tmp; 
#line 2588
if (comp == 0) { 
#line 2589
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2590
} else { 
#line 2591
if (comp == 1) { 
#line 2592
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2593
} else { 
#line 2594
if (comp == 2) { 
#line 2595
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2596
} else { 
#line 2597
if (comp == 3) { 
#line 2598
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2599
}  }  }  }  
#line 2600
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 2601
} 
#endif
#line 2603 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2619
::exit(___);}
#if 0
#line 2604
{ 
#line 2605
uint4 tmp; 
#line 2606
if (comp == 0) { 
#line 2607
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2608
} else { 
#line 2609
if (comp == 1) { 
#line 2610
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2611
} else { 
#line 2612
if (comp == 2) { 
#line 2613
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2614
} else { 
#line 2615
if (comp == 3) { 
#line 2616
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2617
}  }  }  }  
#line 2618
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2619
} 
#endif
#line 2627 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(short *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2628
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2643
::exit(___);}
#if 0
#line 2628
{ 
#line 2629
int4 tmp; 
#line 2630
if (comp == 0) { 
#line 2631
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2632
} else { 
#line 2633
if (comp == 1) { 
#line 2634
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2635
} else { 
#line 2636
if (comp == 2) { 
#line 2637
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2638
} else { 
#line 2639
if (comp == 3) { 
#line 2640
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2641
}  }  }  }  
#line 2642
(*retVal) = ((short)(tmp.x)); 
#line 2643
} 
#endif
#line 2645 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2646
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2661
::exit(___);}
#if 0
#line 2646
{ 
#line 2647
int4 tmp; 
#line 2648
if (comp == 0) { 
#line 2649
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2650
} else { 
#line 2651
if (comp == 1) { 
#line 2652
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2653
} else { 
#line 2654
if (comp == 2) { 
#line 2655
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2656
} else { 
#line 2657
if (comp == 3) { 
#line 2658
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2659
}  }  }  }  
#line 2660
(*retVal) = make_short1(tmp.x); 
#line 2661
} 
#endif
#line 2663 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2664
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2679
::exit(___);}
#if 0
#line 2664
{ 
#line 2665
int4 tmp; 
#line 2666
if (comp == 0) { 
#line 2667
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2668
} else { 
#line 2669
if (comp == 1) { 
#line 2670
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2671
} else { 
#line 2672
if (comp == 2) { 
#line 2673
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2674
} else { 
#line 2675
if (comp == 3) { 
#line 2676
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2677
}  }  }  }  
#line 2678
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 2679
} 
#endif
#line 2681 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2697
::exit(___);}
#if 0
#line 2682
{ 
#line 2683
int4 tmp; 
#line 2684
if (comp == 0) { 
#line 2685
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2686
} else { 
#line 2687
if (comp == 1) { 
#line 2688
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2689
} else { 
#line 2690
if (comp == 2) { 
#line 2691
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2692
} else { 
#line 2693
if (comp == 3) { 
#line 2694
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2695
}  }  }  }  
#line 2696
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2697
} 
#endif
#line 2699 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2700
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2715
::exit(___);}
#if 0
#line 2700
{ 
#line 2701
uint4 tmp; 
#line 2702
if (comp == 0) { 
#line 2703
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2704
} else { 
#line 2705
if (comp == 1) { 
#line 2706
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2707
} else { 
#line 2708
if (comp == 2) { 
#line 2709
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2710
} else { 
#line 2711
if (comp == 3) { 
#line 2712
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2713
}  }  }  }  
#line 2714
(*retVal) = ((unsigned short)(tmp.x)); 
#line 2715
} 
#endif
#line 2717 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2733
::exit(___);}
#if 0
#line 2718
{ 
#line 2719
uint4 tmp; 
#line 2720
if (comp == 0) { 
#line 2721
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2722
} else { 
#line 2723
if (comp == 1) { 
#line 2724
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2725
} else { 
#line 2726
if (comp == 2) { 
#line 2727
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2728
} else { 
#line 2729
if (comp == 3) { 
#line 2730
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2731
}  }  }  }  
#line 2732
(*retVal) = make_ushort1(tmp.x); 
#line 2733
} 
#endif
#line 2735 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2736
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2751
::exit(___);}
#if 0
#line 2736
{ 
#line 2737
uint4 tmp; 
#line 2738
if (comp == 0) { 
#line 2739
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2740
} else { 
#line 2741
if (comp == 1) { 
#line 2742
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2743
} else { 
#line 2744
if (comp == 2) { 
#line 2745
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2746
} else { 
#line 2747
if (comp == 3) { 
#line 2748
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2749
}  }  }  }  
#line 2750
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 2751
} 
#endif
#line 2753 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2754
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2769
::exit(___);}
#if 0
#line 2754
{ 
#line 2755
uint4 tmp; 
#line 2756
if (comp == 0) { 
#line 2757
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2758
} else { 
#line 2759
if (comp == 1) { 
#line 2760
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2761
} else { 
#line 2762
if (comp == 2) { 
#line 2763
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2764
} else { 
#line 2765
if (comp == 3) { 
#line 2766
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2767
}  }  }  }  
#line 2768
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2769
} 
#endif
#line 2777 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(int *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2778
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2793
::exit(___);}
#if 0
#line 2778
{ 
#line 2779
int4 tmp; 
#line 2780
if (comp == 0) { 
#line 2781
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2782
} else { 
#line 2783
if (comp == 1) { 
#line 2784
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2785
} else { 
#line 2786
if (comp == 2) { 
#line 2787
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2788
} else { 
#line 2789
if (comp == 3) { 
#line 2790
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2791
}  }  }  }  
#line 2792
(*retVal) = (tmp.x); 
#line 2793
} 
#endif
#line 2795 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2796
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2811
::exit(___);}
#if 0
#line 2796
{ 
#line 2797
int4 tmp; 
#line 2798
if (comp == 0) { 
#line 2799
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2800
} else { 
#line 2801
if (comp == 1) { 
#line 2802
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2803
} else { 
#line 2804
if (comp == 2) { 
#line 2805
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2806
} else { 
#line 2807
if (comp == 3) { 
#line 2808
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2809
}  }  }  }  
#line 2810
(*retVal) = make_int1(tmp.x); 
#line 2811
} 
#endif
#line 2813 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2814
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2829
::exit(___);}
#if 0
#line 2814
{ 
#line 2815
int4 tmp; 
#line 2816
if (comp == 0) { 
#line 2817
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2818
} else { 
#line 2819
if (comp == 1) { 
#line 2820
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2821
} else { 
#line 2822
if (comp == 2) { 
#line 2823
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2824
} else { 
#line 2825
if (comp == 3) { 
#line 2826
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2827
}  }  }  }  
#line 2828
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 2829
} 
#endif
#line 2831 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2832
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2847
::exit(___);}
#if 0
#line 2832
{ 
#line 2833
int4 tmp; 
#line 2834
if (comp == 0) { 
#line 2835
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2836
} else { 
#line 2837
if (comp == 1) { 
#line 2838
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2839
} else { 
#line 2840
if (comp == 2) { 
#line 2841
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2842
} else { 
#line 2843
if (comp == 3) { 
#line 2844
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2845
}  }  }  }  
#line 2846
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2847
} 
#endif
#line 2849 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2850
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2865
::exit(___);}
#if 0
#line 2850
{ 
#line 2851
uint4 tmp; 
#line 2852
if (comp == 0) { 
#line 2853
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2854
} else { 
#line 2855
if (comp == 1) { 
#line 2856
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2857
} else { 
#line 2858
if (comp == 2) { 
#line 2859
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2860
} else { 
#line 2861
if (comp == 3) { 
#line 2862
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2863
}  }  }  }  
#line 2864
(*retVal) = (tmp.x); 
#line 2865
} 
#endif
#line 2867 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2868
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2883
::exit(___);}
#if 0
#line 2868
{ 
#line 2869
uint4 tmp; 
#line 2870
if (comp == 0) { 
#line 2871
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2872
} else { 
#line 2873
if (comp == 1) { 
#line 2874
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2875
} else { 
#line 2876
if (comp == 2) { 
#line 2877
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2878
} else { 
#line 2879
if (comp == 3) { 
#line 2880
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2881
}  }  }  }  
#line 2882
(*retVal) = make_uint1(tmp.x); 
#line 2883
} 
#endif
#line 2885 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2886
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2901
::exit(___);}
#if 0
#line 2886
{ 
#line 2887
uint4 tmp; 
#line 2888
if (comp == 0) { 
#line 2889
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2890
} else { 
#line 2891
if (comp == 1) { 
#line 2892
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2893
} else { 
#line 2894
if (comp == 2) { 
#line 2895
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2896
} else { 
#line 2897
if (comp == 3) { 
#line 2898
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2899
}  }  }  }  
#line 2900
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 2901
} 
#endif
#line 2903 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2904
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2919
::exit(___);}
#if 0
#line 2904
{ 
#line 2905
uint4 tmp; 
#line 2906
if (comp == 0) { 
#line 2907
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2908
} else { 
#line 2909
if (comp == 1) { 
#line 2910
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2911
} else { 
#line 2912
if (comp == 2) { 
#line 2913
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2914
} else { 
#line 2915
if (comp == 3) { 
#line 2916
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2917
}  }  }  }  
#line 2918
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2919
} 
#endif
#line 2927 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(long *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2928
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2943
::exit(___);}
#if 0
#line 2928
{ 
#line 2929
int4 tmp; 
#line 2930
if (comp == 0) { 
#line 2931
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2932
} else { 
#line 2933
if (comp == 1) { 
#line 2934
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2935
} else { 
#line 2936
if (comp == 2) { 
#line 2937
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2938
} else { 
#line 2939
if (comp == 3) { 
#line 2940
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2941
}  }  }  }  
#line 2942
(*retVal) = ((long)(tmp.x)); 
#line 2943
} 
#endif
#line 2945 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2946
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2961
::exit(___);}
#if 0
#line 2946
{ 
#line 2947
int4 tmp; 
#line 2948
if (comp == 0) { 
#line 2949
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2950
} else { 
#line 2951
if (comp == 1) { 
#line 2952
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2953
} else { 
#line 2954
if (comp == 2) { 
#line 2955
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2956
} else { 
#line 2957
if (comp == 3) { 
#line 2958
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2959
}  }  }  }  
#line 2960
(*retVal) = make_long1(tmp.x); 
#line 2961
} 
#endif
#line 2963 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2964
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2979
::exit(___);}
#if 0
#line 2964
{ 
#line 2965
int4 tmp; 
#line 2966
if (comp == 0) { 
#line 2967
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2968
} else { 
#line 2969
if (comp == 1) { 
#line 2970
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2971
} else { 
#line 2972
if (comp == 2) { 
#line 2973
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2974
} else { 
#line 2975
if (comp == 3) { 
#line 2976
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2977
}  }  }  }  
#line 2978
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 2979
} 
#endif
#line 2981 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 2982
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 2997
::exit(___);}
#if 0
#line 2982
{ 
#line 2983
int4 tmp; 
#line 2984
if (comp == 0) { 
#line 2985
__tld4_r_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2986
} else { 
#line 2987
if (comp == 1) { 
#line 2988
__tld4_g_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2989
} else { 
#line 2990
if (comp == 2) { 
#line 2991
__tld4_b_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2992
} else { 
#line 2993
if (comp == 3) { 
#line 2994
__tld4_a_2d_v4s32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 2995
}  }  }  }  
#line 2996
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 2997
} 
#endif
#line 2999 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3015
::exit(___);}
#if 0
#line 3000
{ 
#line 3001
uint4 tmp; 
#line 3002
if (comp == 0) { 
#line 3003
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3004
} else { 
#line 3005
if (comp == 1) { 
#line 3006
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3007
} else { 
#line 3008
if (comp == 2) { 
#line 3009
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3010
} else { 
#line 3011
if (comp == 3) { 
#line 3012
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3013
}  }  }  }  
#line 3014
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3015
} 
#endif
#line 3017 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3018
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3033
::exit(___);}
#if 0
#line 3018
{ 
#line 3019
uint4 tmp; 
#line 3020
if (comp == 0) { 
#line 3021
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3022
} else { 
#line 3023
if (comp == 1) { 
#line 3024
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3025
} else { 
#line 3026
if (comp == 2) { 
#line 3027
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3028
} else { 
#line 3029
if (comp == 3) { 
#line 3030
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3031
}  }  }  }  
#line 3032
(*retVal) = make_ulong1(tmp.x); 
#line 3033
} 
#endif
#line 3035 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3036
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3051
::exit(___);}
#if 0
#line 3036
{ 
#line 3037
uint4 tmp; 
#line 3038
if (comp == 0) { 
#line 3039
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3040
} else { 
#line 3041
if (comp == 1) { 
#line 3042
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3043
} else { 
#line 3044
if (comp == 2) { 
#line 3045
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3046
} else { 
#line 3047
if (comp == 3) { 
#line 3048
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3049
}  }  }  }  
#line 3050
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3051
} 
#endif
#line 3053 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3054
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3069
::exit(___);}
#if 0
#line 3054
{ 
#line 3055
uint4 tmp; 
#line 3056
if (comp == 0) { 
#line 3057
__tld4_r_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3058
} else { 
#line 3059
if (comp == 1) { 
#line 3060
__tld4_g_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3061
} else { 
#line 3062
if (comp == 2) { 
#line 3063
__tld4_b_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3064
} else { 
#line 3065
if (comp == 3) { 
#line 3066
__tld4_a_2d_v4u32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3067
}  }  }  }  
#line 3068
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3069
} 
#endif
#line 3077 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(float *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3078
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3093
::exit(___);}
#if 0
#line 3078
{ 
#line 3079
float4 tmp; 
#line 3080
if (comp == 0) { 
#line 3081
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3082
} else { 
#line 3083
if (comp == 1) { 
#line 3084
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3085
} else { 
#line 3086
if (comp == 2) { 
#line 3087
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3088
} else { 
#line 3089
if (comp == 3) { 
#line 3090
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3091
}  }  }  }  
#line 3092
(*retVal) = (tmp.x); 
#line 3093
} 
#endif
#line 3095 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3111
::exit(___);}
#if 0
#line 3096
{ 
#line 3097
float4 tmp; 
#line 3098
if (comp == 0) { 
#line 3099
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3100
} else { 
#line 3101
if (comp == 1) { 
#line 3102
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3103
} else { 
#line 3104
if (comp == 2) { 
#line 3105
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3106
} else { 
#line 3107
if (comp == 3) { 
#line 3108
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3109
}  }  }  }  
#line 3110
(*retVal) = make_float1(tmp.x); 
#line 3111
} 
#endif
#line 3113 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3114
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3129
::exit(___);}
#if 0
#line 3114
{ 
#line 3115
float4 tmp; 
#line 3116
if (comp == 0) { 
#line 3117
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3118
} else { 
#line 3119
if (comp == 1) { 
#line 3120
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3121
} else { 
#line 3122
if (comp == 2) { 
#line 3123
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3124
} else { 
#line 3125
if (comp == 3) { 
#line 3126
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3127
}  }  }  }  
#line 3128
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3129
} 
#endif
#line 3131 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2Dgather(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int comp) 
#line 3132
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)comp;
#line 3147
::exit(___);}
#if 0
#line 3132
{ 
#line 3133
float4 tmp; 
#line 3134
if (comp == 0) { 
#line 3135
__tld4_r_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3136
} else { 
#line 3137
if (comp == 1) { 
#line 3138
__tld4_g_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3139
} else { 
#line 3140
if (comp == 2) { 
#line 3141
__tld4_b_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3142
} else { 
#line 3143
if (comp == 3) { 
#line 3144
__tld4_a_2d_v4f32_f32(texObject, x, y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3145
}  }  }  }  
#line 3146
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3147
} 
#endif
#line 3155 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3156
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3165 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 3156 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 3161 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 3162
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3164 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 3165
} 
#endif
#line 3166 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3167
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3171
::exit(___);}
#if 0
#line 3167
{ 
#line 3168
int4 tmp; 
#line 3169
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3170
(*retVal) = ((signed char)(tmp.x)); 
#line 3171
} 
#endif
#line 3173 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3174
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3178
::exit(___);}
#if 0
#line 3174
{ 
#line 3175
int4 tmp; 
#line 3176
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3177
(*retVal) = make_char1(tmp.x); 
#line 3178
} 
#endif
#line 3180 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3181
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3185
::exit(___);}
#if 0
#line 3181
{ 
#line 3182
int4 tmp; 
#line 3183
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3184
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3185
} 
#endif
#line 3187 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3188
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3192
::exit(___);}
#if 0
#line 3188
{ 
#line 3189
int4 tmp; 
#line 3190
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3191
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3192
} 
#endif
#line 3194 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3195
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3199
::exit(___);}
#if 0
#line 3195
{ 
#line 3196
uint4 tmp; 
#line 3197
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3198
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3199
} 
#endif
#line 3201 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3202
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3206
::exit(___);}
#if 0
#line 3202
{ 
#line 3203
uint4 tmp; 
#line 3204
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3205
(*retVal) = make_uchar1(tmp.x); 
#line 3206
} 
#endif
#line 3208 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3213
::exit(___);}
#if 0
#line 3209
{ 
#line 3210
uint4 tmp; 
#line 3211
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3212
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3213
} 
#endif
#line 3215 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3216
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3220
::exit(___);}
#if 0
#line 3216
{ 
#line 3217
uint4 tmp; 
#line 3218
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3219
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3220
} 
#endif
#line 3228 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(short *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3233
::exit(___);}
#if 0
#line 3229
{ 
#line 3230
int4 tmp; 
#line 3231
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3232
(*retVal) = ((short)(tmp.x)); 
#line 3233
} 
#endif
#line 3235 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3236
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3240
::exit(___);}
#if 0
#line 3236
{ 
#line 3237
int4 tmp; 
#line 3238
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3239
(*retVal) = make_short1(tmp.x); 
#line 3240
} 
#endif
#line 3242 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3243
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3247
::exit(___);}
#if 0
#line 3243
{ 
#line 3244
int4 tmp; 
#line 3245
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3246
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3247
} 
#endif
#line 3249 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3250
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3254
::exit(___);}
#if 0
#line 3250
{ 
#line 3251
int4 tmp; 
#line 3252
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3253
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3254
} 
#endif
#line 3256 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3257
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3261
::exit(___);}
#if 0
#line 3257
{ 
#line 3258
uint4 tmp; 
#line 3259
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3260
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3261
} 
#endif
#line 3263 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3264
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3268
::exit(___);}
#if 0
#line 3264
{ 
#line 3265
uint4 tmp; 
#line 3266
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3267
(*retVal) = make_ushort1(tmp.x); 
#line 3268
} 
#endif
#line 3270 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3275
::exit(___);}
#if 0
#line 3271
{ 
#line 3272
uint4 tmp; 
#line 3273
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3274
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3275
} 
#endif
#line 3277 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3282
::exit(___);}
#if 0
#line 3278
{ 
#line 3279
uint4 tmp; 
#line 3280
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3281
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3282
} 
#endif
#line 3290 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(int *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3295
::exit(___);}
#if 0
#line 3291
{ 
#line 3292
int4 tmp; 
#line 3293
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3294
(*retVal) = (tmp.x); 
#line 3295
} 
#endif
#line 3297 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3302
::exit(___);}
#if 0
#line 3298
{ 
#line 3299
int4 tmp; 
#line 3300
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3301
(*retVal) = make_int1(tmp.x); 
#line 3302
} 
#endif
#line 3304 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3305
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3309
::exit(___);}
#if 0
#line 3305
{ 
#line 3306
int4 tmp; 
#line 3307
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3308
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3309
} 
#endif
#line 3311 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3312
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3316
::exit(___);}
#if 0
#line 3312
{ 
#line 3313
int4 tmp; 
#line 3314
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3315
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3316
} 
#endif
#line 3318 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3319
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3323
::exit(___);}
#if 0
#line 3319
{ 
#line 3320
uint4 tmp; 
#line 3321
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3322
(*retVal) = (tmp.x); 
#line 3323
} 
#endif
#line 3325 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3326
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3330
::exit(___);}
#if 0
#line 3326
{ 
#line 3327
uint4 tmp; 
#line 3328
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3329
(*retVal) = make_uint1(tmp.x); 
#line 3330
} 
#endif
#line 3332 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3333
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3337
::exit(___);}
#if 0
#line 3333
{ 
#line 3334
uint4 tmp; 
#line 3335
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3336
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3337
} 
#endif
#line 3339 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3340
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3344
::exit(___);}
#if 0
#line 3340
{ 
#line 3341
uint4 tmp; 
#line 3342
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3343
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3344
} 
#endif
#line 3354 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(long *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3355
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3359
::exit(___);}
#if 0
#line 3355
{ 
#line 3356
int4 tmp; 
#line 3357
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3358
(*retVal) = ((long)(tmp.x)); 
#line 3359
} 
#endif
#line 3361 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3362
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3366
::exit(___);}
#if 0
#line 3362
{ 
#line 3363
int4 tmp; 
#line 3364
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3365
(*retVal) = make_long1(tmp.x); 
#line 3366
} 
#endif
#line 3368 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3369
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3373
::exit(___);}
#if 0
#line 3369
{ 
#line 3370
int4 tmp; 
#line 3371
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3372
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3373
} 
#endif
#line 3375 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3376
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3380
::exit(___);}
#if 0
#line 3376
{ 
#line 3377
int4 tmp; 
#line 3378
__tex_1d_level_v4s32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3379
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3380
} 
#endif
#line 3382 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3383
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3387
::exit(___);}
#if 0
#line 3383
{ 
#line 3384
uint4 tmp; 
#line 3385
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3386
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3387
} 
#endif
#line 3389 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3390
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3394
::exit(___);}
#if 0
#line 3390
{ 
#line 3391
uint4 tmp; 
#line 3392
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3393
(*retVal) = make_ulong1(tmp.x); 
#line 3394
} 
#endif
#line 3396 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3397
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3401
::exit(___);}
#if 0
#line 3397
{ 
#line 3398
uint4 tmp; 
#line 3399
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3400
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3401
} 
#endif
#line 3403 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3404
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3408
::exit(___);}
#if 0
#line 3404
{ 
#line 3405
uint4 tmp; 
#line 3406
__tex_1d_level_v4u32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3407
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3408
} 
#endif
#line 3419 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(float *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3420
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3424
::exit(___);}
#if 0
#line 3420
{ 
#line 3421
float4 tmp; 
#line 3422
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3423
(*retVal) = (tmp.x); 
#line 3424
} 
#endif
#line 3426 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3427
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3431
::exit(___);}
#if 0
#line 3427
{ 
#line 3428
float4 tmp; 
#line 3429
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3430
(*retVal) = make_float1(tmp.x); 
#line 3431
} 
#endif
#line 3433 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3438
::exit(___);}
#if 0
#line 3434
{ 
#line 3435
float4 tmp; 
#line 3436
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3437
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3438
} 
#endif
#line 3440 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float level) 
#line 3441
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)level;
#line 3445
::exit(___);}
#if 0
#line 3441
{ 
#line 3442
float4 tmp; 
#line 3443
__tex_1d_level_v4f32_f32(texObject, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3444
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3445
} 
#endif
#line 3453 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3454
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3463 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 3454 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 3459 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 3460
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3462 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 3463
} 
#endif
#line 3464 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3465
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3469
::exit(___);}
#if 0
#line 3465
{ 
#line 3466
int4 tmp; 
#line 3467
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3468
(*retVal) = ((signed char)(tmp.x)); 
#line 3469
} 
#endif
#line 3471 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3472
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3476
::exit(___);}
#if 0
#line 3472
{ 
#line 3473
int4 tmp; 
#line 3474
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3475
(*retVal) = make_char1(tmp.x); 
#line 3476
} 
#endif
#line 3478 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3479
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3483
::exit(___);}
#if 0
#line 3479
{ 
#line 3480
int4 tmp; 
#line 3481
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3482
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3483
} 
#endif
#line 3485 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3486
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3490
::exit(___);}
#if 0
#line 3486
{ 
#line 3487
int4 tmp; 
#line 3488
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3489
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3490
} 
#endif
#line 3492 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3493
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3497
::exit(___);}
#if 0
#line 3493
{ 
#line 3494
uint4 tmp; 
#line 3495
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3496
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3497
} 
#endif
#line 3499 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3500
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3504
::exit(___);}
#if 0
#line 3500
{ 
#line 3501
uint4 tmp; 
#line 3502
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3503
(*retVal) = make_uchar1(tmp.x); 
#line 3504
} 
#endif
#line 3506 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3511
::exit(___);}
#if 0
#line 3507
{ 
#line 3508
uint4 tmp; 
#line 3509
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3510
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3511
} 
#endif
#line 3513 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3518
::exit(___);}
#if 0
#line 3514
{ 
#line 3515
uint4 tmp; 
#line 3516
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3517
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3518
} 
#endif
#line 3526 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3527
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3531
::exit(___);}
#if 0
#line 3527
{ 
#line 3528
int4 tmp; 
#line 3529
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3530
(*retVal) = ((short)(tmp.x)); 
#line 3531
} 
#endif
#line 3533 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3534
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3538
::exit(___);}
#if 0
#line 3534
{ 
#line 3535
int4 tmp; 
#line 3536
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3537
(*retVal) = make_short1(tmp.x); 
#line 3538
} 
#endif
#line 3540 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3541
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3545
::exit(___);}
#if 0
#line 3541
{ 
#line 3542
int4 tmp; 
#line 3543
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3544
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3545
} 
#endif
#line 3547 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3548
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3552
::exit(___);}
#if 0
#line 3548
{ 
#line 3549
int4 tmp; 
#line 3550
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3551
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3552
} 
#endif
#line 3554 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3555
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3559
::exit(___);}
#if 0
#line 3555
{ 
#line 3556
uint4 tmp; 
#line 3557
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3558
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3559
} 
#endif
#line 3561 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3562
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3566
::exit(___);}
#if 0
#line 3562
{ 
#line 3563
uint4 tmp; 
#line 3564
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3565
(*retVal) = make_ushort1(tmp.x); 
#line 3566
} 
#endif
#line 3568 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3573
::exit(___);}
#if 0
#line 3569
{ 
#line 3570
uint4 tmp; 
#line 3571
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3572
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3573
} 
#endif
#line 3575 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3580
::exit(___);}
#if 0
#line 3576
{ 
#line 3577
uint4 tmp; 
#line 3578
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3579
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3580
} 
#endif
#line 3588 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3593
::exit(___);}
#if 0
#line 3589
{ 
#line 3590
int4 tmp; 
#line 3591
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3592
(*retVal) = (tmp.x); 
#line 3593
} 
#endif
#line 3595 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3600
::exit(___);}
#if 0
#line 3596
{ 
#line 3597
int4 tmp; 
#line 3598
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3599
(*retVal) = make_int1(tmp.x); 
#line 3600
} 
#endif
#line 3602 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3603
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3607
::exit(___);}
#if 0
#line 3603
{ 
#line 3604
int4 tmp; 
#line 3605
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3606
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3607
} 
#endif
#line 3609 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3610
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3614
::exit(___);}
#if 0
#line 3610
{ 
#line 3611
int4 tmp; 
#line 3612
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3613
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3614
} 
#endif
#line 3616 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3617
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3621
::exit(___);}
#if 0
#line 3617
{ 
#line 3618
uint4 tmp; 
#line 3619
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3620
(*retVal) = (tmp.x); 
#line 3621
} 
#endif
#line 3623 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3624
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3628
::exit(___);}
#if 0
#line 3624
{ 
#line 3625
uint4 tmp; 
#line 3626
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3627
(*retVal) = make_uint1(tmp.x); 
#line 3628
} 
#endif
#line 3630 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3631
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3635
::exit(___);}
#if 0
#line 3631
{ 
#line 3632
uint4 tmp; 
#line 3633
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3634
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3635
} 
#endif
#line 3637 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3638
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3642
::exit(___);}
#if 0
#line 3638
{ 
#line 3639
uint4 tmp; 
#line 3640
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3641
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3642
} 
#endif
#line 3652 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3653
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3657
::exit(___);}
#if 0
#line 3653
{ 
#line 3654
int4 tmp; 
#line 3655
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3656
(*retVal) = ((long)(tmp.x)); 
#line 3657
} 
#endif
#line 3659 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3660
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3664
::exit(___);}
#if 0
#line 3660
{ 
#line 3661
int4 tmp; 
#line 3662
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3663
(*retVal) = make_long1(tmp.x); 
#line 3664
} 
#endif
#line 3666 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3667
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3671
::exit(___);}
#if 0
#line 3667
{ 
#line 3668
int4 tmp; 
#line 3669
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3670
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3671
} 
#endif
#line 3673 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3674
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3678
::exit(___);}
#if 0
#line 3674
{ 
#line 3675
int4 tmp; 
#line 3676
__tex_2d_level_v4s32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3677
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3678
} 
#endif
#line 3680 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3681
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3685
::exit(___);}
#if 0
#line 3681
{ 
#line 3682
uint4 tmp; 
#line 3683
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3684
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3685
} 
#endif
#line 3687 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3688
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3692
::exit(___);}
#if 0
#line 3688
{ 
#line 3689
uint4 tmp; 
#line 3690
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3691
(*retVal) = make_ulong1(tmp.x); 
#line 3692
} 
#endif
#line 3694 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3695
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3699
::exit(___);}
#if 0
#line 3695
{ 
#line 3696
uint4 tmp; 
#line 3697
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3698
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3699
} 
#endif
#line 3701 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3702
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3706
::exit(___);}
#if 0
#line 3702
{ 
#line 3703
uint4 tmp; 
#line 3704
__tex_2d_level_v4u32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3705
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3706
} 
#endif
#line 3717 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3718
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3722
::exit(___);}
#if 0
#line 3718
{ 
#line 3719
float4 tmp; 
#line 3720
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3721
(*retVal) = (tmp.x); 
#line 3722
} 
#endif
#line 3724 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3725
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3729
::exit(___);}
#if 0
#line 3725
{ 
#line 3726
float4 tmp; 
#line 3727
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3728
(*retVal) = make_float1(tmp.x); 
#line 3729
} 
#endif
#line 3731 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3732
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3736
::exit(___);}
#if 0
#line 3732
{ 
#line 3733
float4 tmp; 
#line 3734
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3735
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 3736
} 
#endif
#line 3738 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float level) 
#line 3739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)level;
#line 3743
::exit(___);}
#if 0
#line 3739
{ 
#line 3740
float4 tmp; 
#line 3741
__tex_2d_level_v4f32_f32(texObject, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3742
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3743
} 
#endif
#line 3751 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3752
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3761 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 3752 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 3757 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 3758
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3760 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 3761
} 
#endif
#line 3762 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3763
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3767
::exit(___);}
#if 0
#line 3763
{ 
#line 3764
int4 tmp; 
#line 3765
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3766
(*retVal) = ((signed char)(tmp.x)); 
#line 3767
} 
#endif
#line 3769 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3770
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3774
::exit(___);}
#if 0
#line 3770
{ 
#line 3771
int4 tmp; 
#line 3772
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3773
(*retVal) = make_char1(tmp.x); 
#line 3774
} 
#endif
#line 3776 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3777
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3781
::exit(___);}
#if 0
#line 3777
{ 
#line 3778
int4 tmp; 
#line 3779
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3780
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 3781
} 
#endif
#line 3783 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3784
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3788
::exit(___);}
#if 0
#line 3784
{ 
#line 3785
int4 tmp; 
#line 3786
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3787
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3788
} 
#endif
#line 3790 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3791
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3795
::exit(___);}
#if 0
#line 3791
{ 
#line 3792
uint4 tmp; 
#line 3793
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3794
(*retVal) = ((unsigned char)(tmp.x)); 
#line 3795
} 
#endif
#line 3797 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3798
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3802
::exit(___);}
#if 0
#line 3798
{ 
#line 3799
uint4 tmp; 
#line 3800
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3801
(*retVal) = make_uchar1(tmp.x); 
#line 3802
} 
#endif
#line 3804 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3805
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3809
::exit(___);}
#if 0
#line 3805
{ 
#line 3806
uint4 tmp; 
#line 3807
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3808
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 3809
} 
#endif
#line 3811 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3812
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3816
::exit(___);}
#if 0
#line 3812
{ 
#line 3813
uint4 tmp; 
#line 3814
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3815
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3816
} 
#endif
#line 3824 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3829
::exit(___);}
#if 0
#line 3825
{ 
#line 3826
int4 tmp; 
#line 3827
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3828
(*retVal) = ((short)(tmp.x)); 
#line 3829
} 
#endif
#line 3831 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3832
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3836
::exit(___);}
#if 0
#line 3832
{ 
#line 3833
int4 tmp; 
#line 3834
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3835
(*retVal) = make_short1(tmp.x); 
#line 3836
} 
#endif
#line 3838 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3839
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3843
::exit(___);}
#if 0
#line 3839
{ 
#line 3840
int4 tmp; 
#line 3841
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3842
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 3843
} 
#endif
#line 3845 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3846
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3850
::exit(___);}
#if 0
#line 3846
{ 
#line 3847
int4 tmp; 
#line 3848
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3849
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3850
} 
#endif
#line 3852 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3853
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3857
::exit(___);}
#if 0
#line 3853
{ 
#line 3854
uint4 tmp; 
#line 3855
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3856
(*retVal) = ((unsigned short)(tmp.x)); 
#line 3857
} 
#endif
#line 3859 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3860
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3864
::exit(___);}
#if 0
#line 3860
{ 
#line 3861
uint4 tmp; 
#line 3862
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3863
(*retVal) = make_ushort1(tmp.x); 
#line 3864
} 
#endif
#line 3866 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3867
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3871
::exit(___);}
#if 0
#line 3867
{ 
#line 3868
uint4 tmp; 
#line 3869
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3870
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 3871
} 
#endif
#line 3873 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3874
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3878
::exit(___);}
#if 0
#line 3874
{ 
#line 3875
uint4 tmp; 
#line 3876
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3877
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3878
} 
#endif
#line 3886 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3887
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3891
::exit(___);}
#if 0
#line 3887
{ 
#line 3888
int4 tmp; 
#line 3889
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3890
(*retVal) = (tmp.x); 
#line 3891
} 
#endif
#line 3893 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3894
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3898
::exit(___);}
#if 0
#line 3894
{ 
#line 3895
int4 tmp; 
#line 3896
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3897
(*retVal) = make_int1(tmp.x); 
#line 3898
} 
#endif
#line 3900 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3901
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3905
::exit(___);}
#if 0
#line 3901
{ 
#line 3902
int4 tmp; 
#line 3903
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3904
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 3905
} 
#endif
#line 3907 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3908
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3912
::exit(___);}
#if 0
#line 3908
{ 
#line 3909
int4 tmp; 
#line 3910
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3911
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3912
} 
#endif
#line 3914 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3915
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3919
::exit(___);}
#if 0
#line 3915
{ 
#line 3916
uint4 tmp; 
#line 3917
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3918
(*retVal) = (tmp.x); 
#line 3919
} 
#endif
#line 3921 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3922
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3926
::exit(___);}
#if 0
#line 3922
{ 
#line 3923
uint4 tmp; 
#line 3924
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3925
(*retVal) = make_uint1(tmp.x); 
#line 3926
} 
#endif
#line 3928 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3929
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3933
::exit(___);}
#if 0
#line 3929
{ 
#line 3930
uint4 tmp; 
#line 3931
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3932
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 3933
} 
#endif
#line 3935 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3936
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3940
::exit(___);}
#if 0
#line 3936
{ 
#line 3937
uint4 tmp; 
#line 3938
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3939
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3940
} 
#endif
#line 3950 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3951
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3955
::exit(___);}
#if 0
#line 3951
{ 
#line 3952
int4 tmp; 
#line 3953
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3954
(*retVal) = ((long)(tmp.x)); 
#line 3955
} 
#endif
#line 3957 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3958
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3962
::exit(___);}
#if 0
#line 3958
{ 
#line 3959
int4 tmp; 
#line 3960
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3961
(*retVal) = make_long1(tmp.x); 
#line 3962
} 
#endif
#line 3964 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3965
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3969
::exit(___);}
#if 0
#line 3965
{ 
#line 3966
int4 tmp; 
#line 3967
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3968
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 3969
} 
#endif
#line 3971 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3972
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3976
::exit(___);}
#if 0
#line 3972
{ 
#line 3973
int4 tmp; 
#line 3974
__tex_3d_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3975
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 3976
} 
#endif
#line 3978 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3979
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3983
::exit(___);}
#if 0
#line 3979
{ 
#line 3980
uint4 tmp; 
#line 3981
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3982
(*retVal) = ((unsigned long)(tmp.x)); 
#line 3983
} 
#endif
#line 3985 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3986
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3990
::exit(___);}
#if 0
#line 3986
{ 
#line 3987
uint4 tmp; 
#line 3988
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3989
(*retVal) = make_ulong1(tmp.x); 
#line 3990
} 
#endif
#line 3992 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 3993
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 3997
::exit(___);}
#if 0
#line 3993
{ 
#line 3994
uint4 tmp; 
#line 3995
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 3996
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 3997
} 
#endif
#line 3999 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4000
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4004
::exit(___);}
#if 0
#line 4000
{ 
#line 4001
uint4 tmp; 
#line 4002
__tex_3d_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4003
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4004
} 
#endif
#line 4015 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4016
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4020
::exit(___);}
#if 0
#line 4016
{ 
#line 4017
float4 tmp; 
#line 4018
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4019
(*retVal) = (tmp.x); 
#line 4020
} 
#endif
#line 4022 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4023
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4027
::exit(___);}
#if 0
#line 4023
{ 
#line 4024
float4 tmp; 
#line 4025
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4026
(*retVal) = make_float1(tmp.x); 
#line 4027
} 
#endif
#line 4029 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4030
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4034
::exit(___);}
#if 0
#line 4030
{ 
#line 4031
float4 tmp; 
#line 4032
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4033
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4034
} 
#endif
#line 4036 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4041
::exit(___);}
#if 0
#line 4037
{ 
#line 4038
float4 tmp; 
#line 4039
__tex_3d_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4040
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4041
} 
#endif
#line 4049 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4050
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4059 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 4050 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 4055 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 4056
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4058 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 4059
} 
#endif
#line 4060 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4061
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4065
::exit(___);}
#if 0
#line 4061
{ 
#line 4062
int4 tmp; 
#line 4063
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4064
(*retVal) = ((signed char)(tmp.x)); 
#line 4065
} 
#endif
#line 4067 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4068
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4072
::exit(___);}
#if 0
#line 4068
{ 
#line 4069
int4 tmp; 
#line 4070
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4071
(*retVal) = make_char1(tmp.x); 
#line 4072
} 
#endif
#line 4074 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4075
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4079
::exit(___);}
#if 0
#line 4075
{ 
#line 4076
int4 tmp; 
#line 4077
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4078
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4079
} 
#endif
#line 4081 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4082
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4086
::exit(___);}
#if 0
#line 4082
{ 
#line 4083
int4 tmp; 
#line 4084
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4085
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4086
} 
#endif
#line 4088 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4089
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4093
::exit(___);}
#if 0
#line 4089
{ 
#line 4090
uint4 tmp; 
#line 4091
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4092
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4093
} 
#endif
#line 4095 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4096
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4100
::exit(___);}
#if 0
#line 4096
{ 
#line 4097
uint4 tmp; 
#line 4098
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4099
(*retVal) = make_uchar1(tmp.x); 
#line 4100
} 
#endif
#line 4102 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4103
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4107
::exit(___);}
#if 0
#line 4103
{ 
#line 4104
uint4 tmp; 
#line 4105
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4106
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4107
} 
#endif
#line 4109 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4110
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4114
::exit(___);}
#if 0
#line 4110
{ 
#line 4111
uint4 tmp; 
#line 4112
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4113
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4114
} 
#endif
#line 4122 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4123
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4127
::exit(___);}
#if 0
#line 4123
{ 
#line 4124
int4 tmp; 
#line 4125
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4126
(*retVal) = ((short)(tmp.x)); 
#line 4127
} 
#endif
#line 4129 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4130
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4134
::exit(___);}
#if 0
#line 4130
{ 
#line 4131
int4 tmp; 
#line 4132
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4133
(*retVal) = make_short1(tmp.x); 
#line 4134
} 
#endif
#line 4136 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4137
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4141
::exit(___);}
#if 0
#line 4137
{ 
#line 4138
int4 tmp; 
#line 4139
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4140
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4141
} 
#endif
#line 4143 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4144
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4148
::exit(___);}
#if 0
#line 4144
{ 
#line 4145
int4 tmp; 
#line 4146
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4147
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4148
} 
#endif
#line 4150 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4151
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4155
::exit(___);}
#if 0
#line 4151
{ 
#line 4152
uint4 tmp; 
#line 4153
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4154
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4155
} 
#endif
#line 4157 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4158
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4162
::exit(___);}
#if 0
#line 4158
{ 
#line 4159
uint4 tmp; 
#line 4160
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4161
(*retVal) = make_ushort1(tmp.x); 
#line 4162
} 
#endif
#line 4164 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4165
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4169
::exit(___);}
#if 0
#line 4165
{ 
#line 4166
uint4 tmp; 
#line 4167
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4168
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4169
} 
#endif
#line 4171 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4172
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4176
::exit(___);}
#if 0
#line 4172
{ 
#line 4173
uint4 tmp; 
#line 4174
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4175
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4176
} 
#endif
#line 4184 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4185
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4189
::exit(___);}
#if 0
#line 4185
{ 
#line 4186
int4 tmp; 
#line 4187
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4188
(*retVal) = (tmp.x); 
#line 4189
} 
#endif
#line 4191 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4192
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4196
::exit(___);}
#if 0
#line 4192
{ 
#line 4193
int4 tmp; 
#line 4194
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4195
(*retVal) = make_int1(tmp.x); 
#line 4196
} 
#endif
#line 4198 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4199
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4203
::exit(___);}
#if 0
#line 4199
{ 
#line 4200
int4 tmp; 
#line 4201
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4202
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4203
} 
#endif
#line 4205 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4206
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4210
::exit(___);}
#if 0
#line 4206
{ 
#line 4207
int4 tmp; 
#line 4208
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4209
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4210
} 
#endif
#line 4212 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4213
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4217
::exit(___);}
#if 0
#line 4213
{ 
#line 4214
uint4 tmp; 
#line 4215
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4216
(*retVal) = (tmp.x); 
#line 4217
} 
#endif
#line 4219 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4220
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4224
::exit(___);}
#if 0
#line 4220
{ 
#line 4221
uint4 tmp; 
#line 4222
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4223
(*retVal) = make_uint1(tmp.x); 
#line 4224
} 
#endif
#line 4226 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4227
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4231
::exit(___);}
#if 0
#line 4227
{ 
#line 4228
uint4 tmp; 
#line 4229
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4230
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4231
} 
#endif
#line 4233 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4234
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4238
::exit(___);}
#if 0
#line 4234
{ 
#line 4235
uint4 tmp; 
#line 4236
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4237
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4238
} 
#endif
#line 4248 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4249
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4253
::exit(___);}
#if 0
#line 4249
{ 
#line 4250
int4 tmp; 
#line 4251
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4252
(*retVal) = ((long)(tmp.x)); 
#line 4253
} 
#endif
#line 4255 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4256
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4260
::exit(___);}
#if 0
#line 4256
{ 
#line 4257
int4 tmp; 
#line 4258
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4259
(*retVal) = make_long1(tmp.x); 
#line 4260
} 
#endif
#line 4262 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4263
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4267
::exit(___);}
#if 0
#line 4263
{ 
#line 4264
int4 tmp; 
#line 4265
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4266
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4267
} 
#endif
#line 4269 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4270
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4274
::exit(___);}
#if 0
#line 4270
{ 
#line 4271
int4 tmp; 
#line 4272
__tex_1d_array_level_v4s32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4273
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4274
} 
#endif
#line 4276 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4277
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4281
::exit(___);}
#if 0
#line 4277
{ 
#line 4278
uint4 tmp; 
#line 4279
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4280
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4281
} 
#endif
#line 4283 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4284
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4288
::exit(___);}
#if 0
#line 4284
{ 
#line 4285
uint4 tmp; 
#line 4286
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4287
(*retVal) = make_ulong1(tmp.x); 
#line 4288
} 
#endif
#line 4290 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4291
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4295
::exit(___);}
#if 0
#line 4291
{ 
#line 4292
uint4 tmp; 
#line 4293
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4294
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4295
} 
#endif
#line 4297 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4298
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4302
::exit(___);}
#if 0
#line 4298
{ 
#line 4299
uint4 tmp; 
#line 4300
__tex_1d_array_level_v4u32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4301
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4302
} 
#endif
#line 4313 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4314
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4318
::exit(___);}
#if 0
#line 4314
{ 
#line 4315
float4 tmp; 
#line 4316
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4317
(*retVal) = (tmp.x); 
#line 4318
} 
#endif
#line 4320 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4321
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4325
::exit(___);}
#if 0
#line 4321
{ 
#line 4322
float4 tmp; 
#line 4323
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4324
(*retVal) = make_float1(tmp.x); 
#line 4325
} 
#endif
#line 4327 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4328
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4332
::exit(___);}
#if 0
#line 4328
{ 
#line 4329
float4 tmp; 
#line 4330
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4331
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4332
} 
#endif
#line 4334 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float level) 
#line 4335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)level;
#line 4339
::exit(___);}
#if 0
#line 4335
{ 
#line 4336
float4 tmp; 
#line 4337
__tex_1d_array_level_v4f32_f32(texObject, layer, x, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4338
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4339
} 
#endif
#line 4347 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4348
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4357 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 4348 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 4353 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 4354
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4356 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 4357
} 
#endif
#line 4358 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4359
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4363
::exit(___);}
#if 0
#line 4359
{ 
#line 4360
int4 tmp; 
#line 4361
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4362
(*retVal) = ((signed char)(tmp.x)); 
#line 4363
} 
#endif
#line 4365 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4366
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4370
::exit(___);}
#if 0
#line 4366
{ 
#line 4367
int4 tmp; 
#line 4368
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4369
(*retVal) = make_char1(tmp.x); 
#line 4370
} 
#endif
#line 4372 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4373
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4377
::exit(___);}
#if 0
#line 4373
{ 
#line 4374
int4 tmp; 
#line 4375
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4376
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4377
} 
#endif
#line 4379 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4380
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4384
::exit(___);}
#if 0
#line 4380
{ 
#line 4381
int4 tmp; 
#line 4382
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4383
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4384
} 
#endif
#line 4386 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4387
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4391
::exit(___);}
#if 0
#line 4387
{ 
#line 4388
uint4 tmp; 
#line 4389
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4390
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4391
} 
#endif
#line 4393 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4394
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4398
::exit(___);}
#if 0
#line 4394
{ 
#line 4395
uint4 tmp; 
#line 4396
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4397
(*retVal) = make_uchar1(tmp.x); 
#line 4398
} 
#endif
#line 4400 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4401
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4405
::exit(___);}
#if 0
#line 4401
{ 
#line 4402
uint4 tmp; 
#line 4403
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4404
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4405
} 
#endif
#line 4407 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4408
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4412
::exit(___);}
#if 0
#line 4408
{ 
#line 4409
uint4 tmp; 
#line 4410
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4411
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4412
} 
#endif
#line 4420 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4421
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4425
::exit(___);}
#if 0
#line 4421
{ 
#line 4422
int4 tmp; 
#line 4423
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4424
(*retVal) = ((short)(tmp.x)); 
#line 4425
} 
#endif
#line 4427 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4428
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4432
::exit(___);}
#if 0
#line 4428
{ 
#line 4429
int4 tmp; 
#line 4430
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4431
(*retVal) = make_short1(tmp.x); 
#line 4432
} 
#endif
#line 4434 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4435
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4439
::exit(___);}
#if 0
#line 4435
{ 
#line 4436
int4 tmp; 
#line 4437
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4438
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4439
} 
#endif
#line 4441 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4442
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4446
::exit(___);}
#if 0
#line 4442
{ 
#line 4443
int4 tmp; 
#line 4444
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4445
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4446
} 
#endif
#line 4448 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4449
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4453
::exit(___);}
#if 0
#line 4449
{ 
#line 4450
uint4 tmp; 
#line 4451
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4452
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4453
} 
#endif
#line 4455 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4456
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4460
::exit(___);}
#if 0
#line 4456
{ 
#line 4457
uint4 tmp; 
#line 4458
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4459
(*retVal) = make_ushort1(tmp.x); 
#line 4460
} 
#endif
#line 4462 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4463
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4467
::exit(___);}
#if 0
#line 4463
{ 
#line 4464
uint4 tmp; 
#line 4465
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4466
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4467
} 
#endif
#line 4469 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4470
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4474
::exit(___);}
#if 0
#line 4470
{ 
#line 4471
uint4 tmp; 
#line 4472
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4473
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4474
} 
#endif
#line 4482 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4483
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4487
::exit(___);}
#if 0
#line 4483
{ 
#line 4484
int4 tmp; 
#line 4485
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4486
(*retVal) = (tmp.x); 
#line 4487
} 
#endif
#line 4489 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4490
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4494
::exit(___);}
#if 0
#line 4490
{ 
#line 4491
int4 tmp; 
#line 4492
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4493
(*retVal) = make_int1(tmp.x); 
#line 4494
} 
#endif
#line 4496 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4497
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4501
::exit(___);}
#if 0
#line 4497
{ 
#line 4498
int4 tmp; 
#line 4499
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4500
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4501
} 
#endif
#line 4503 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4504
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4508
::exit(___);}
#if 0
#line 4504
{ 
#line 4505
int4 tmp; 
#line 4506
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4507
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4508
} 
#endif
#line 4510 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4511
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4515
::exit(___);}
#if 0
#line 4511
{ 
#line 4512
uint4 tmp; 
#line 4513
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4514
(*retVal) = (tmp.x); 
#line 4515
} 
#endif
#line 4517 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4518
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4522
::exit(___);}
#if 0
#line 4518
{ 
#line 4519
uint4 tmp; 
#line 4520
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4521
(*retVal) = make_uint1(tmp.x); 
#line 4522
} 
#endif
#line 4524 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4525
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4529
::exit(___);}
#if 0
#line 4525
{ 
#line 4526
uint4 tmp; 
#line 4527
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4528
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4529
} 
#endif
#line 4531 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4532
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4536
::exit(___);}
#if 0
#line 4532
{ 
#line 4533
uint4 tmp; 
#line 4534
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4535
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4536
} 
#endif
#line 4546 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4547
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4551
::exit(___);}
#if 0
#line 4547
{ 
#line 4548
int4 tmp; 
#line 4549
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4550
(*retVal) = ((long)(tmp.x)); 
#line 4551
} 
#endif
#line 4553 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4554
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4558
::exit(___);}
#if 0
#line 4554
{ 
#line 4555
int4 tmp; 
#line 4556
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4557
(*retVal) = make_long1(tmp.x); 
#line 4558
} 
#endif
#line 4560 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4561
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4565
::exit(___);}
#if 0
#line 4561
{ 
#line 4562
int4 tmp; 
#line 4563
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4564
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4565
} 
#endif
#line 4567 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4568
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4572
::exit(___);}
#if 0
#line 4568
{ 
#line 4569
int4 tmp; 
#line 4570
__tex_2d_array_level_v4s32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4571
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4572
} 
#endif
#line 4574 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4575
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4579
::exit(___);}
#if 0
#line 4575
{ 
#line 4576
uint4 tmp; 
#line 4577
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4578
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4579
} 
#endif
#line 4581 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4582
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4586
::exit(___);}
#if 0
#line 4582
{ 
#line 4583
uint4 tmp; 
#line 4584
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4585
(*retVal) = make_ulong1(tmp.x); 
#line 4586
} 
#endif
#line 4588 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4589
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4593
::exit(___);}
#if 0
#line 4589
{ 
#line 4590
uint4 tmp; 
#line 4591
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4592
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4593
} 
#endif
#line 4595 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4596
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4600
::exit(___);}
#if 0
#line 4596
{ 
#line 4597
uint4 tmp; 
#line 4598
__tex_2d_array_level_v4u32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4599
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4600
} 
#endif
#line 4611 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4612
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4616
::exit(___);}
#if 0
#line 4612
{ 
#line 4613
float4 tmp; 
#line 4614
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4615
(*retVal) = (tmp.x); 
#line 4616
} 
#endif
#line 4618 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4619
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4623
::exit(___);}
#if 0
#line 4619
{ 
#line 4620
float4 tmp; 
#line 4621
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4622
(*retVal) = make_float1(tmp.x); 
#line 4623
} 
#endif
#line 4625 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4626
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4630
::exit(___);}
#if 0
#line 4626
{ 
#line 4627
float4 tmp; 
#line 4628
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4629
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4630
} 
#endif
#line 4632 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float level) 
#line 4633
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)level;
#line 4637
::exit(___);}
#if 0
#line 4633
{ 
#line 4634
float4 tmp; 
#line 4635
__tex_2d_array_level_v4f32_f32(texObject, layer, x, y, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4636
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4637
} 
#endif
#line 4645 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4646
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4655 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 4646 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 4651 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 4652
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4654 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 4655
} 
#endif
#line 4656 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4657
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4661
::exit(___);}
#if 0
#line 4657
{ 
#line 4658
int4 tmp; 
#line 4659
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4660
(*retVal) = ((signed char)(tmp.x)); 
#line 4661
} 
#endif
#line 4663 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4664
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4668
::exit(___);}
#if 0
#line 4664
{ 
#line 4665
int4 tmp; 
#line 4666
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4667
(*retVal) = make_char1(tmp.x); 
#line 4668
} 
#endif
#line 4670 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4671
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4675
::exit(___);}
#if 0
#line 4671
{ 
#line 4672
int4 tmp; 
#line 4673
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4674
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4675
} 
#endif
#line 4677 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4678
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4682
::exit(___);}
#if 0
#line 4678
{ 
#line 4679
int4 tmp; 
#line 4680
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4681
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4682
} 
#endif
#line 4684 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4685
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4689
::exit(___);}
#if 0
#line 4685
{ 
#line 4686
uint4 tmp; 
#line 4687
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4688
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4689
} 
#endif
#line 4691 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4692
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4696
::exit(___);}
#if 0
#line 4692
{ 
#line 4693
uint4 tmp; 
#line 4694
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4695
(*retVal) = make_uchar1(tmp.x); 
#line 4696
} 
#endif
#line 4698 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4699
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4703
::exit(___);}
#if 0
#line 4699
{ 
#line 4700
uint4 tmp; 
#line 4701
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4702
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 4703
} 
#endif
#line 4705 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4706
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4710
::exit(___);}
#if 0
#line 4706
{ 
#line 4707
uint4 tmp; 
#line 4708
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4709
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4710
} 
#endif
#line 4718 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4719
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4723
::exit(___);}
#if 0
#line 4719
{ 
#line 4720
int4 tmp; 
#line 4721
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4722
(*retVal) = ((short)(tmp.x)); 
#line 4723
} 
#endif
#line 4725 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4726
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4730
::exit(___);}
#if 0
#line 4726
{ 
#line 4727
int4 tmp; 
#line 4728
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4729
(*retVal) = make_short1(tmp.x); 
#line 4730
} 
#endif
#line 4732 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4733
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4737
::exit(___);}
#if 0
#line 4733
{ 
#line 4734
int4 tmp; 
#line 4735
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4736
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 4737
} 
#endif
#line 4739 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4740
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4744
::exit(___);}
#if 0
#line 4740
{ 
#line 4741
int4 tmp; 
#line 4742
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4743
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4744
} 
#endif
#line 4746 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4747
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4751
::exit(___);}
#if 0
#line 4747
{ 
#line 4748
uint4 tmp; 
#line 4749
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4750
(*retVal) = ((unsigned short)(tmp.x)); 
#line 4751
} 
#endif
#line 4753 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4754
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4758
::exit(___);}
#if 0
#line 4754
{ 
#line 4755
uint4 tmp; 
#line 4756
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4757
(*retVal) = make_ushort1(tmp.x); 
#line 4758
} 
#endif
#line 4760 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4761
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4765
::exit(___);}
#if 0
#line 4761
{ 
#line 4762
uint4 tmp; 
#line 4763
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4764
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 4765
} 
#endif
#line 4767 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4768
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4772
::exit(___);}
#if 0
#line 4768
{ 
#line 4769
uint4 tmp; 
#line 4770
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4771
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4772
} 
#endif
#line 4780 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4781
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4785
::exit(___);}
#if 0
#line 4781
{ 
#line 4782
int4 tmp; 
#line 4783
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4784
(*retVal) = (tmp.x); 
#line 4785
} 
#endif
#line 4787 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4788
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4792
::exit(___);}
#if 0
#line 4788
{ 
#line 4789
int4 tmp; 
#line 4790
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4791
(*retVal) = make_int1(tmp.x); 
#line 4792
} 
#endif
#line 4794 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4795
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4799
::exit(___);}
#if 0
#line 4795
{ 
#line 4796
int4 tmp; 
#line 4797
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4798
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 4799
} 
#endif
#line 4801 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4802
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4806
::exit(___);}
#if 0
#line 4802
{ 
#line 4803
int4 tmp; 
#line 4804
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4805
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4806
} 
#endif
#line 4808 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4809
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4813
::exit(___);}
#if 0
#line 4809
{ 
#line 4810
uint4 tmp; 
#line 4811
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4812
(*retVal) = (tmp.x); 
#line 4813
} 
#endif
#line 4815 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4816
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4820
::exit(___);}
#if 0
#line 4816
{ 
#line 4817
uint4 tmp; 
#line 4818
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4819
(*retVal) = make_uint1(tmp.x); 
#line 4820
} 
#endif
#line 4822 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4823
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4827
::exit(___);}
#if 0
#line 4823
{ 
#line 4824
uint4 tmp; 
#line 4825
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4826
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 4827
} 
#endif
#line 4829 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4830
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4834
::exit(___);}
#if 0
#line 4830
{ 
#line 4831
uint4 tmp; 
#line 4832
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4833
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4834
} 
#endif
#line 4844 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4845
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4849
::exit(___);}
#if 0
#line 4845
{ 
#line 4846
int4 tmp; 
#line 4847
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4848
(*retVal) = ((long)(tmp.x)); 
#line 4849
} 
#endif
#line 4851 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4852
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4856
::exit(___);}
#if 0
#line 4852
{ 
#line 4853
int4 tmp; 
#line 4854
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4855
(*retVal) = make_long1(tmp.x); 
#line 4856
} 
#endif
#line 4858 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4859
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4863
::exit(___);}
#if 0
#line 4859
{ 
#line 4860
int4 tmp; 
#line 4861
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4862
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 4863
} 
#endif
#line 4865 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4866
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4870
::exit(___);}
#if 0
#line 4866
{ 
#line 4867
int4 tmp; 
#line 4868
__tex_cube_level_v4s32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4869
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4870
} 
#endif
#line 4872 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4873
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4877
::exit(___);}
#if 0
#line 4873
{ 
#line 4874
uint4 tmp; 
#line 4875
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4876
(*retVal) = ((unsigned long)(tmp.x)); 
#line 4877
} 
#endif
#line 4879 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4880
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4884
::exit(___);}
#if 0
#line 4880
{ 
#line 4881
uint4 tmp; 
#line 4882
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4883
(*retVal) = make_ulong1(tmp.x); 
#line 4884
} 
#endif
#line 4886 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4887
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4891
::exit(___);}
#if 0
#line 4887
{ 
#line 4888
uint4 tmp; 
#line 4889
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4890
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 4891
} 
#endif
#line 4893 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4894
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4898
::exit(___);}
#if 0
#line 4894
{ 
#line 4895
uint4 tmp; 
#line 4896
__tex_cube_level_v4u32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4897
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4898
} 
#endif
#line 4909 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4910
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4914
::exit(___);}
#if 0
#line 4910
{ 
#line 4911
float4 tmp; 
#line 4912
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4913
(*retVal) = (tmp.x); 
#line 4914
} 
#endif
#line 4916 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4917
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4921
::exit(___);}
#if 0
#line 4917
{ 
#line 4918
float4 tmp; 
#line 4919
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4920
(*retVal) = make_float1(tmp.x); 
#line 4921
} 
#endif
#line 4923 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4924
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4928
::exit(___);}
#if 0
#line 4924
{ 
#line 4925
float4 tmp; 
#line 4926
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4927
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 4928
} 
#endif
#line 4930 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float level) 
#line 4931
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)level;
#line 4935
::exit(___);}
#if 0
#line 4931
{ 
#line 4932
float4 tmp; 
#line 4933
__tex_cube_level_v4f32_f32(texObject, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4934
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4935
} 
#endif
#line 4943 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4944
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4953 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 4944 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 4949 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 4950
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4952 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 4953
} 
#endif
#line 4954 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4955
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4959
::exit(___);}
#if 0
#line 4955
{ 
#line 4956
int4 tmp; 
#line 4957
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4958
(*retVal) = ((signed char)(tmp.x)); 
#line 4959
} 
#endif
#line 4961 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4962
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4966
::exit(___);}
#if 0
#line 4962
{ 
#line 4963
int4 tmp; 
#line 4964
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4965
(*retVal) = make_char1(tmp.x); 
#line 4966
} 
#endif
#line 4968 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4969
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4973
::exit(___);}
#if 0
#line 4969
{ 
#line 4970
int4 tmp; 
#line 4971
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4972
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 4973
} 
#endif
#line 4975 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4976
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4980
::exit(___);}
#if 0
#line 4976
{ 
#line 4977
int4 tmp; 
#line 4978
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4979
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 4980
} 
#endif
#line 4982 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4983
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4987
::exit(___);}
#if 0
#line 4983
{ 
#line 4984
uint4 tmp; 
#line 4985
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4986
(*retVal) = ((unsigned char)(tmp.x)); 
#line 4987
} 
#endif
#line 4989 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4990
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 4994
::exit(___);}
#if 0
#line 4990
{ 
#line 4991
uint4 tmp; 
#line 4992
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 4993
(*retVal) = make_uchar1(tmp.x); 
#line 4994
} 
#endif
#line 4996 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 4997
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5001
::exit(___);}
#if 0
#line 4997
{ 
#line 4998
uint4 tmp; 
#line 4999
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5000
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5001
} 
#endif
#line 5003 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5004
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5008
::exit(___);}
#if 0
#line 5004
{ 
#line 5005
uint4 tmp; 
#line 5006
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5007
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5008
} 
#endif
#line 5016 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5017
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5021
::exit(___);}
#if 0
#line 5017
{ 
#line 5018
int4 tmp; 
#line 5019
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5020
(*retVal) = ((short)(tmp.x)); 
#line 5021
} 
#endif
#line 5023 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5024
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5028
::exit(___);}
#if 0
#line 5024
{ 
#line 5025
int4 tmp; 
#line 5026
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5027
(*retVal) = make_short1(tmp.x); 
#line 5028
} 
#endif
#line 5030 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5031
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5035
::exit(___);}
#if 0
#line 5031
{ 
#line 5032
int4 tmp; 
#line 5033
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5034
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5035
} 
#endif
#line 5037 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5038
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5042
::exit(___);}
#if 0
#line 5038
{ 
#line 5039
int4 tmp; 
#line 5040
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5041
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5042
} 
#endif
#line 5044 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5045
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5049
::exit(___);}
#if 0
#line 5045
{ 
#line 5046
uint4 tmp; 
#line 5047
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5048
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5049
} 
#endif
#line 5051 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5052
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5056
::exit(___);}
#if 0
#line 5052
{ 
#line 5053
uint4 tmp; 
#line 5054
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5055
(*retVal) = make_ushort1(tmp.x); 
#line 5056
} 
#endif
#line 5058 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5059
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5063
::exit(___);}
#if 0
#line 5059
{ 
#line 5060
uint4 tmp; 
#line 5061
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5062
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5063
} 
#endif
#line 5065 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5066
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5070
::exit(___);}
#if 0
#line 5066
{ 
#line 5067
uint4 tmp; 
#line 5068
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5069
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5070
} 
#endif
#line 5078 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5079
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5083
::exit(___);}
#if 0
#line 5079
{ 
#line 5080
int4 tmp; 
#line 5081
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5082
(*retVal) = (tmp.x); 
#line 5083
} 
#endif
#line 5085 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5086
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5090
::exit(___);}
#if 0
#line 5086
{ 
#line 5087
int4 tmp; 
#line 5088
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5089
(*retVal) = make_int1(tmp.x); 
#line 5090
} 
#endif
#line 5092 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5093
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5097
::exit(___);}
#if 0
#line 5093
{ 
#line 5094
int4 tmp; 
#line 5095
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5096
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5097
} 
#endif
#line 5099 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5100
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5104
::exit(___);}
#if 0
#line 5100
{ 
#line 5101
int4 tmp; 
#line 5102
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5103
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5104
} 
#endif
#line 5106 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5107
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5111
::exit(___);}
#if 0
#line 5107
{ 
#line 5108
uint4 tmp; 
#line 5109
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5110
(*retVal) = (tmp.x); 
#line 5111
} 
#endif
#line 5113 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5114
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5118
::exit(___);}
#if 0
#line 5114
{ 
#line 5115
uint4 tmp; 
#line 5116
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5117
(*retVal) = make_uint1(tmp.x); 
#line 5118
} 
#endif
#line 5120 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5121
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5125
::exit(___);}
#if 0
#line 5121
{ 
#line 5122
uint4 tmp; 
#line 5123
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5124
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5125
} 
#endif
#line 5127 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5128
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5132
::exit(___);}
#if 0
#line 5128
{ 
#line 5129
uint4 tmp; 
#line 5130
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5131
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5132
} 
#endif
#line 5142 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5143
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5147
::exit(___);}
#if 0
#line 5143
{ 
#line 5144
int4 tmp; 
#line 5145
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5146
(*retVal) = ((long)(tmp.x)); 
#line 5147
} 
#endif
#line 5149 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5150
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5154
::exit(___);}
#if 0
#line 5150
{ 
#line 5151
int4 tmp; 
#line 5152
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5153
(*retVal) = make_long1(tmp.x); 
#line 5154
} 
#endif
#line 5156 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5157
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5161
::exit(___);}
#if 0
#line 5157
{ 
#line 5158
int4 tmp; 
#line 5159
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5160
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5161
} 
#endif
#line 5163 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5164
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5168
::exit(___);}
#if 0
#line 5164
{ 
#line 5165
int4 tmp; 
#line 5166
__tex_cube_array_level_v4s32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5167
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5168
} 
#endif
#line 5170 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5171
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5175
::exit(___);}
#if 0
#line 5171
{ 
#line 5172
uint4 tmp; 
#line 5173
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5174
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5175
} 
#endif
#line 5177 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5178
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5182
::exit(___);}
#if 0
#line 5178
{ 
#line 5179
uint4 tmp; 
#line 5180
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5181
(*retVal) = make_ulong1(tmp.x); 
#line 5182
} 
#endif
#line 5184 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5185
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5189
::exit(___);}
#if 0
#line 5185
{ 
#line 5186
uint4 tmp; 
#line 5187
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5188
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5189
} 
#endif
#line 5191 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5192
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5196
::exit(___);}
#if 0
#line 5192
{ 
#line 5193
uint4 tmp; 
#line 5194
__tex_cube_array_level_v4u32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5195
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5196
} 
#endif
#line 5207 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5208
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5212
::exit(___);}
#if 0
#line 5208
{ 
#line 5209
float4 tmp; 
#line 5210
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5211
(*retVal) = (tmp.x); 
#line 5212
} 
#endif
#line 5214 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5215
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5219
::exit(___);}
#if 0
#line 5215
{ 
#line 5216
float4 tmp; 
#line 5217
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5218
(*retVal) = make_float1(tmp.x); 
#line 5219
} 
#endif
#line 5221 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5222
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5226
::exit(___);}
#if 0
#line 5222
{ 
#line 5223
float4 tmp; 
#line 5224
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5225
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5226
} 
#endif
#line 5228 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void texCubemapLayeredLod(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, int layer, float level) 
#line 5229
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)layer;(void)level;
#line 5233
::exit(___);}
#if 0
#line 5229
{ 
#line 5230
float4 tmp; 
#line 5231
__tex_cube_array_level_v4f32_f32(texObject, layer, x, y, z, level, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5232
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5233
} 
#endif
#line 5241 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5242
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5251 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 5242 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 5247 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 5248
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5250 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 5251
} 
#endif
#line 5252 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5253
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5257
::exit(___);}
#if 0
#line 5253
{ 
#line 5254
int4 tmp; 
#line 5255
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5256
(*retVal) = ((signed char)(tmp.x)); 
#line 5257
} 
#endif
#line 5259 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5260
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5264
::exit(___);}
#if 0
#line 5260
{ 
#line 5261
int4 tmp; 
#line 5262
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5263
(*retVal) = make_char1(tmp.x); 
#line 5264
} 
#endif
#line 5266 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5267
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5271
::exit(___);}
#if 0
#line 5267
{ 
#line 5268
int4 tmp; 
#line 5269
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5270
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5271
} 
#endif
#line 5273 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5274
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5278
::exit(___);}
#if 0
#line 5274
{ 
#line 5275
int4 tmp; 
#line 5276
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5277
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5278
} 
#endif
#line 5280 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5281
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5285
::exit(___);}
#if 0
#line 5281
{ 
#line 5282
uint4 tmp; 
#line 5283
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5284
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5285
} 
#endif
#line 5287 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5288
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5292
::exit(___);}
#if 0
#line 5288
{ 
#line 5289
uint4 tmp; 
#line 5290
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5291
(*retVal) = make_uchar1(tmp.x); 
#line 5292
} 
#endif
#line 5294 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5295
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5299
::exit(___);}
#if 0
#line 5295
{ 
#line 5296
uint4 tmp; 
#line 5297
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5298
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5299
} 
#endif
#line 5301 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5302
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5306
::exit(___);}
#if 0
#line 5302
{ 
#line 5303
uint4 tmp; 
#line 5304
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5305
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5306
} 
#endif
#line 5314 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5315
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5319
::exit(___);}
#if 0
#line 5315
{ 
#line 5316
int4 tmp; 
#line 5317
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5318
(*retVal) = ((short)(tmp.x)); 
#line 5319
} 
#endif
#line 5321 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5322
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5326
::exit(___);}
#if 0
#line 5322
{ 
#line 5323
int4 tmp; 
#line 5324
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5325
(*retVal) = make_short1(tmp.x); 
#line 5326
} 
#endif
#line 5328 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5329
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5333
::exit(___);}
#if 0
#line 5329
{ 
#line 5330
int4 tmp; 
#line 5331
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5332
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5333
} 
#endif
#line 5335 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5336
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5340
::exit(___);}
#if 0
#line 5336
{ 
#line 5337
int4 tmp; 
#line 5338
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5339
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5340
} 
#endif
#line 5342 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5343
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5347
::exit(___);}
#if 0
#line 5343
{ 
#line 5344
uint4 tmp; 
#line 5345
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5346
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5347
} 
#endif
#line 5349 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5350
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5354
::exit(___);}
#if 0
#line 5350
{ 
#line 5351
uint4 tmp; 
#line 5352
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5353
(*retVal) = make_ushort1(tmp.x); 
#line 5354
} 
#endif
#line 5356 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5357
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5361
::exit(___);}
#if 0
#line 5357
{ 
#line 5358
uint4 tmp; 
#line 5359
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5360
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5361
} 
#endif
#line 5363 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5364
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5368
::exit(___);}
#if 0
#line 5364
{ 
#line 5365
uint4 tmp; 
#line 5366
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5367
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5368
} 
#endif
#line 5376 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(int *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5377
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5381
::exit(___);}
#if 0
#line 5377
{ 
#line 5378
int4 tmp; 
#line 5379
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5380
(*retVal) = (tmp.x); 
#line 5381
} 
#endif
#line 5383 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5384
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5388
::exit(___);}
#if 0
#line 5384
{ 
#line 5385
int4 tmp; 
#line 5386
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5387
(*retVal) = make_int1(tmp.x); 
#line 5388
} 
#endif
#line 5390 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5391
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5395
::exit(___);}
#if 0
#line 5391
{ 
#line 5392
int4 tmp; 
#line 5393
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5394
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5395
} 
#endif
#line 5397 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5398
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5402
::exit(___);}
#if 0
#line 5398
{ 
#line 5399
int4 tmp; 
#line 5400
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5401
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5402
} 
#endif
#line 5404 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5405
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5409
::exit(___);}
#if 0
#line 5405
{ 
#line 5406
uint4 tmp; 
#line 5407
__asm tex.grad.1d.v4.u32.f32 {%0, %1, %2, %3}, [%4, {%5}], {%6}, {%7};
(*retVal) = (tmp.x); 
#line 5409
} 
#endif
#line 5411 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5412
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5416
::exit(___);}
#if 0
#line 5412
{ 
#line 5413
uint4 tmp; 
#line 5414
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5415
(*retVal) = make_uint1(tmp.x); 
#line 5416
} 
#endif
#line 5418 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5419
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5423
::exit(___);}
#if 0
#line 5419
{ 
#line 5420
uint4 tmp; 
#line 5421
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5422
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5423
} 
#endif
#line 5425 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5426
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5430
::exit(___);}
#if 0
#line 5426
{ 
#line 5427
uint4 tmp; 
#line 5428
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5429
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5430
} 
#endif
#line 5440 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5441
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5445
::exit(___);}
#if 0
#line 5441
{ 
#line 5442
int4 tmp; 
#line 5443
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5444
(*retVal) = ((long)(tmp.x)); 
#line 5445
} 
#endif
#line 5447 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5448
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5452
::exit(___);}
#if 0
#line 5448
{ 
#line 5449
int4 tmp; 
#line 5450
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5451
(*retVal) = make_long1(tmp.x); 
#line 5452
} 
#endif
#line 5454 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5455
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5459
::exit(___);}
#if 0
#line 5455
{ 
#line 5456
int4 tmp; 
#line 5457
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5458
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5459
} 
#endif
#line 5461 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5462
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5466
::exit(___);}
#if 0
#line 5462
{ 
#line 5463
int4 tmp; 
#line 5464
__tex_1d_grad_v4s32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5465
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5466
} 
#endif
#line 5468 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5469
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5473
::exit(___);}
#if 0
#line 5469
{ 
#line 5470
uint4 tmp; 
#line 5471
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5472
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5473
} 
#endif
#line 5475 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5476
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5480
::exit(___);}
#if 0
#line 5476
{ 
#line 5477
uint4 tmp; 
#line 5478
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5479
(*retVal) = make_ulong1(tmp.x); 
#line 5480
} 
#endif
#line 5482 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5483
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5487
::exit(___);}
#if 0
#line 5483
{ 
#line 5484
uint4 tmp; 
#line 5485
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5486
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5487
} 
#endif
#line 5489 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5490
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5494
::exit(___);}
#if 0
#line 5490
{ 
#line 5491
uint4 tmp; 
#line 5492
__tex_1d_grad_v4u32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5493
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5494
} 
#endif
#line 5505 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(float *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5506
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5510
::exit(___);}
#if 0
#line 5506
{ 
#line 5507
float4 tmp; 
#line 5508
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5509
(*retVal) = (tmp.x); 
#line 5510
} 
#endif
#line 5512 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5513
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5517
::exit(___);}
#if 0
#line 5513
{ 
#line 5514
float4 tmp; 
#line 5515
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5516
(*retVal) = make_float1(tmp.x); 
#line 5517
} 
#endif
#line 5519 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5520
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5524
::exit(___);}
#if 0
#line 5520
{ 
#line 5521
float4 tmp; 
#line 5522
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5523
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5524
} 
#endif
#line 5526 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float dPdx, float dPdy) 
#line 5527
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)dPdx;(void)dPdy;
#line 5531
::exit(___);}
#if 0
#line 5527
{ 
#line 5528
float4 tmp; 
#line 5529
__tex_1d_grad_v4f32_f32(texObject, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5530
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5531
} 
#endif
#line 5539 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5540
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5549 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 5540 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 5545 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 5546
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5548 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 5549
} 
#endif
#line 5550 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5551
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5555
::exit(___);}
#if 0
#line 5551
{ 
#line 5552
int4 tmp; 
#line 5553
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5554
(*retVal) = ((signed char)(tmp.x)); 
#line 5555
} 
#endif
#line 5557 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5558
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5562
::exit(___);}
#if 0
#line 5558
{ 
#line 5559
int4 tmp; 
#line 5560
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5561
(*retVal) = make_char1(tmp.x); 
#line 5562
} 
#endif
#line 5564 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5565
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5569
::exit(___);}
#if 0
#line 5565
{ 
#line 5566
int4 tmp; 
#line 5567
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5568
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5569
} 
#endif
#line 5571 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5572
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5576
::exit(___);}
#if 0
#line 5572
{ 
#line 5573
int4 tmp; 
#line 5574
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5575
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5576
} 
#endif
#line 5578 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5579
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5583
::exit(___);}
#if 0
#line 5579
{ 
#line 5580
uint4 tmp; 
#line 5581
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5582
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5583
} 
#endif
#line 5585 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5586
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5590
::exit(___);}
#if 0
#line 5586
{ 
#line 5587
uint4 tmp; 
#line 5588
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5589
(*retVal) = make_uchar1(tmp.x); 
#line 5590
} 
#endif
#line 5592 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5593
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5597
::exit(___);}
#if 0
#line 5593
{ 
#line 5594
uint4 tmp; 
#line 5595
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5596
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5597
} 
#endif
#line 5599 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5600
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5604
::exit(___);}
#if 0
#line 5600
{ 
#line 5601
uint4 tmp; 
#line 5602
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5603
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5604
} 
#endif
#line 5612 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5613
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5617
::exit(___);}
#if 0
#line 5613
{ 
#line 5614
int4 tmp; 
#line 5615
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5616
(*retVal) = ((short)(tmp.x)); 
#line 5617
} 
#endif
#line 5619 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5620
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5624
::exit(___);}
#if 0
#line 5620
{ 
#line 5621
int4 tmp; 
#line 5622
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5623
(*retVal) = make_short1(tmp.x); 
#line 5624
} 
#endif
#line 5626 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5627
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5631
::exit(___);}
#if 0
#line 5627
{ 
#line 5628
int4 tmp; 
#line 5629
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5630
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5631
} 
#endif
#line 5633 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5634
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5638
::exit(___);}
#if 0
#line 5634
{ 
#line 5635
int4 tmp; 
#line 5636
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5637
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5638
} 
#endif
#line 5640 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5641
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5645
::exit(___);}
#if 0
#line 5641
{ 
#line 5642
uint4 tmp; 
#line 5643
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5644
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5645
} 
#endif
#line 5647 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5648
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5652
::exit(___);}
#if 0
#line 5648
{ 
#line 5649
uint4 tmp; 
#line 5650
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5651
(*retVal) = make_ushort1(tmp.x); 
#line 5652
} 
#endif
#line 5654 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5655
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5659
::exit(___);}
#if 0
#line 5655
{ 
#line 5656
uint4 tmp; 
#line 5657
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5658
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5659
} 
#endif
#line 5661 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5662
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5666
::exit(___);}
#if 0
#line 5662
{ 
#line 5663
uint4 tmp; 
#line 5664
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5665
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5666
} 
#endif
#line 5674 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5679
::exit(___);}
#if 0
#line 5675
{ 
#line 5676
int4 tmp; 
#line 5677
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5678
(*retVal) = (tmp.x); 
#line 5679
} 
#endif
#line 5681 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5686
::exit(___);}
#if 0
#line 5682
{ 
#line 5683
int4 tmp; 
#line 5684
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5685
(*retVal) = make_int1(tmp.x); 
#line 5686
} 
#endif
#line 5688 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5689
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5693
::exit(___);}
#if 0
#line 5689
{ 
#line 5690
int4 tmp; 
#line 5691
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5692
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5693
} 
#endif
#line 5695 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5696
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5700
::exit(___);}
#if 0
#line 5696
{ 
#line 5697
int4 tmp; 
#line 5698
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5699
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5700
} 
#endif
#line 5702 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5703
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5707
::exit(___);}
#if 0
#line 5703
{ 
#line 5704
uint4 tmp; 
#line 5705
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5706
(*retVal) = (tmp.x); 
#line 5707
} 
#endif
#line 5709 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5710
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5714
::exit(___);}
#if 0
#line 5710
{ 
#line 5711
uint4 tmp; 
#line 5712
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5713
(*retVal) = make_uint1(tmp.x); 
#line 5714
} 
#endif
#line 5716 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5717
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5721
::exit(___);}
#if 0
#line 5717
{ 
#line 5718
uint4 tmp; 
#line 5719
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5720
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 5721
} 
#endif
#line 5723 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5724
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5728
::exit(___);}
#if 0
#line 5724
{ 
#line 5725
uint4 tmp; 
#line 5726
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5727
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5728
} 
#endif
#line 5738 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5739
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5743
::exit(___);}
#if 0
#line 5739
{ 
#line 5740
int4 tmp; 
#line 5741
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5742
(*retVal) = ((long)(tmp.x)); 
#line 5743
} 
#endif
#line 5745 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5746
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5750
::exit(___);}
#if 0
#line 5746
{ 
#line 5747
int4 tmp; 
#line 5748
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5749
(*retVal) = make_long1(tmp.x); 
#line 5750
} 
#endif
#line 5752 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5753
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5757
::exit(___);}
#if 0
#line 5753
{ 
#line 5754
int4 tmp; 
#line 5755
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5756
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 5757
} 
#endif
#line 5759 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5760
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5764
::exit(___);}
#if 0
#line 5760
{ 
#line 5761
int4 tmp; 
#line 5762
__tex_2d_grad_v4s32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5763
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5764
} 
#endif
#line 5766 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5767
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5771
::exit(___);}
#if 0
#line 5767
{ 
#line 5768
uint4 tmp; 
#line 5769
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5770
(*retVal) = ((unsigned long)(tmp.x)); 
#line 5771
} 
#endif
#line 5773 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5774
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5778
::exit(___);}
#if 0
#line 5774
{ 
#line 5775
uint4 tmp; 
#line 5776
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5777
(*retVal) = make_ulong1(tmp.x); 
#line 5778
} 
#endif
#line 5780 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5781
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5785
::exit(___);}
#if 0
#line 5781
{ 
#line 5782
uint4 tmp; 
#line 5783
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5784
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 5785
} 
#endif
#line 5787 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5788
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5792
::exit(___);}
#if 0
#line 5788
{ 
#line 5789
uint4 tmp; 
#line 5790
__tex_2d_grad_v4u32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5791
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5792
} 
#endif
#line 5803 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5804
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5808
::exit(___);}
#if 0
#line 5804
{ 
#line 5805
float4 tmp; 
#line 5806
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5807
(*retVal) = (tmp.x); 
#line 5808
} 
#endif
#line 5810 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5811
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5815
::exit(___);}
#if 0
#line 5811
{ 
#line 5812
float4 tmp; 
#line 5813
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5814
(*retVal) = make_float1(tmp.x); 
#line 5815
} 
#endif
#line 5817 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5818
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5822
::exit(___);}
#if 0
#line 5818
{ 
#line 5819
float4 tmp; 
#line 5820
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5821
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 5822
} 
#endif
#line 5824 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float2 dPdx, float2 dPdy) 
#line 5825
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)dPdx;(void)dPdy;
#line 5829
::exit(___);}
#if 0
#line 5825
{ 
#line 5826
float4 tmp; 
#line 5827
__tex_2d_grad_v4f32_f32(texObject, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5828
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5829
} 
#endif
#line 5837 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5838
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5847 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 5838 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 5843 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 5844
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5846 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 5847
} 
#endif
#line 5848 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5849
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5853
::exit(___);}
#if 0
#line 5849
{ 
#line 5850
int4 tmp; 
#line 5851
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5852
(*retVal) = ((signed char)(tmp.x)); 
#line 5853
} 
#endif
#line 5855 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5856
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5860
::exit(___);}
#if 0
#line 5856
{ 
#line 5857
int4 tmp; 
#line 5858
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5859
(*retVal) = make_char1(tmp.x); 
#line 5860
} 
#endif
#line 5862 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5863
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5867
::exit(___);}
#if 0
#line 5863
{ 
#line 5864
int4 tmp; 
#line 5865
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5866
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 5867
} 
#endif
#line 5869 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5870
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5874
::exit(___);}
#if 0
#line 5870
{ 
#line 5871
int4 tmp; 
#line 5872
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5873
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5874
} 
#endif
#line 5876 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5877
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5881
::exit(___);}
#if 0
#line 5877
{ 
#line 5878
uint4 tmp; 
#line 5879
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5880
(*retVal) = ((unsigned char)(tmp.x)); 
#line 5881
} 
#endif
#line 5883 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5884
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5888
::exit(___);}
#if 0
#line 5884
{ 
#line 5885
uint4 tmp; 
#line 5886
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5887
(*retVal) = make_uchar1(tmp.x); 
#line 5888
} 
#endif
#line 5890 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5891
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5895
::exit(___);}
#if 0
#line 5891
{ 
#line 5892
uint4 tmp; 
#line 5893
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5894
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 5895
} 
#endif
#line 5897 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5898
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5902
::exit(___);}
#if 0
#line 5898
{ 
#line 5899
uint4 tmp; 
#line 5900
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5901
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5902
} 
#endif
#line 5910 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5911
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5915
::exit(___);}
#if 0
#line 5911
{ 
#line 5912
int4 tmp; 
#line 5913
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5914
(*retVal) = ((short)(tmp.x)); 
#line 5915
} 
#endif
#line 5917 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5918
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5922
::exit(___);}
#if 0
#line 5918
{ 
#line 5919
int4 tmp; 
#line 5920
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5921
(*retVal) = make_short1(tmp.x); 
#line 5922
} 
#endif
#line 5924 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5925
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5929
::exit(___);}
#if 0
#line 5925
{ 
#line 5926
int4 tmp; 
#line 5927
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5928
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 5929
} 
#endif
#line 5931 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5932
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5936
::exit(___);}
#if 0
#line 5932
{ 
#line 5933
int4 tmp; 
#line 5934
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5935
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5936
} 
#endif
#line 5938 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5939
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5943
::exit(___);}
#if 0
#line 5939
{ 
#line 5940
uint4 tmp; 
#line 5941
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5942
(*retVal) = ((unsigned short)(tmp.x)); 
#line 5943
} 
#endif
#line 5945 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5946
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5950
::exit(___);}
#if 0
#line 5946
{ 
#line 5947
uint4 tmp; 
#line 5948
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5949
(*retVal) = make_ushort1(tmp.x); 
#line 5950
} 
#endif
#line 5952 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5953
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5957
::exit(___);}
#if 0
#line 5953
{ 
#line 5954
uint4 tmp; 
#line 5955
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5956
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 5957
} 
#endif
#line 5959 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5960
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5964
::exit(___);}
#if 0
#line 5960
{ 
#line 5961
uint4 tmp; 
#line 5962
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5963
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5964
} 
#endif
#line 5972 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5973
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5977
::exit(___);}
#if 0
#line 5973
{ 
#line 5974
int4 tmp; 
#line 5975
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5976
(*retVal) = (tmp.x); 
#line 5977
} 
#endif
#line 5979 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5980
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5984
::exit(___);}
#if 0
#line 5980
{ 
#line 5981
int4 tmp; 
#line 5982
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5983
(*retVal) = make_int1(tmp.x); 
#line 5984
} 
#endif
#line 5986 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5987
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5991
::exit(___);}
#if 0
#line 5987
{ 
#line 5988
int4 tmp; 
#line 5989
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5990
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 5991
} 
#endif
#line 5993 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 5994
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 5998
::exit(___);}
#if 0
#line 5994
{ 
#line 5995
int4 tmp; 
#line 5996
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 5997
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 5998
} 
#endif
#line 6000 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6001
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6005
::exit(___);}
#if 0
#line 6001
{ 
#line 6002
uint4 tmp; 
#line 6003
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6004
(*retVal) = (tmp.x); 
#line 6005
} 
#endif
#line 6007 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6008
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6012
::exit(___);}
#if 0
#line 6008
{ 
#line 6009
uint4 tmp; 
#line 6010
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6011
(*retVal) = make_uint1(tmp.x); 
#line 6012
} 
#endif
#line 6014 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6015
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6019
::exit(___);}
#if 0
#line 6015
{ 
#line 6016
uint4 tmp; 
#line 6017
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6018
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6019
} 
#endif
#line 6021 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6022
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6026
::exit(___);}
#if 0
#line 6022
{ 
#line 6023
uint4 tmp; 
#line 6024
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6025
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6026
} 
#endif
#line 6036 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6037
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6041
::exit(___);}
#if 0
#line 6037
{ 
#line 6038
int4 tmp; 
#line 6039
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6040
(*retVal) = ((long)(tmp.x)); 
#line 6041
} 
#endif
#line 6043 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6044
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6048
::exit(___);}
#if 0
#line 6044
{ 
#line 6045
int4 tmp; 
#line 6046
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6047
(*retVal) = make_long1(tmp.x); 
#line 6048
} 
#endif
#line 6050 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6051
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6055
::exit(___);}
#if 0
#line 6051
{ 
#line 6052
int4 tmp; 
#line 6053
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6054
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6055
} 
#endif
#line 6057 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6058
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6062
::exit(___);}
#if 0
#line 6058
{ 
#line 6059
int4 tmp; 
#line 6060
__tex_3d_grad_v4s32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6061
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6062
} 
#endif
#line 6064 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6065
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6069
::exit(___);}
#if 0
#line 6065
{ 
#line 6066
uint4 tmp; 
#line 6067
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6068
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6069
} 
#endif
#line 6071 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6072
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6076
::exit(___);}
#if 0
#line 6072
{ 
#line 6073
uint4 tmp; 
#line 6074
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6075
(*retVal) = make_ulong1(tmp.x); 
#line 6076
} 
#endif
#line 6078 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6079
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6083
::exit(___);}
#if 0
#line 6079
{ 
#line 6080
uint4 tmp; 
#line 6081
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6082
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6083
} 
#endif
#line 6085 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6086
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6090
::exit(___);}
#if 0
#line 6086
{ 
#line 6087
uint4 tmp; 
#line 6088
__tex_3d_grad_v4u32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6089
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6090
} 
#endif
#line 6101 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6102
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6106
::exit(___);}
#if 0
#line 6102
{ 
#line 6103
float4 tmp; 
#line 6104
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6105
(*retVal) = (tmp.x); 
#line 6106
} 
#endif
#line 6108 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6109
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6113
::exit(___);}
#if 0
#line 6109
{ 
#line 6110
float4 tmp; 
#line 6111
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6112
(*retVal) = make_float1(tmp.x); 
#line 6113
} 
#endif
#line 6115 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6116
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6120
::exit(___);}
#if 0
#line 6116
{ 
#line 6117
float4 tmp; 
#line 6118
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6119
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6120
} 
#endif
#line 6122 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex3DGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, float z, float4 dPdx, float4 dPdy) 
#line 6123
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)z;(void)dPdx;(void)dPdy;
#line 6127
::exit(___);}
#if 0
#line 6123
{ 
#line 6124
float4 tmp; 
#line 6125
__tex_3d_grad_v4f32_f32(texObject, x, y, z, dPdx.x, dPdx.y, dPdx.z, dPdy.x, dPdy.y, dPdy.z, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6126
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6127
} 
#endif
#line 6135 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6136
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6145 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 6136 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 6141 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 6142
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6144 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 6145
} 
#endif
#line 6146 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6147
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6151
::exit(___);}
#if 0
#line 6147
{ 
#line 6148
int4 tmp; 
#line 6149
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6150
(*retVal) = ((signed char)(tmp.x)); 
#line 6151
} 
#endif
#line 6153 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6154
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6158
::exit(___);}
#if 0
#line 6154
{ 
#line 6155
int4 tmp; 
#line 6156
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6157
(*retVal) = make_char1(tmp.x); 
#line 6158
} 
#endif
#line 6160 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6161
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6165
::exit(___);}
#if 0
#line 6161
{ 
#line 6162
int4 tmp; 
#line 6163
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6164
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6165
} 
#endif
#line 6167 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6168
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6172
::exit(___);}
#if 0
#line 6168
{ 
#line 6169
int4 tmp; 
#line 6170
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6171
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6172
} 
#endif
#line 6174 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6175
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6179
::exit(___);}
#if 0
#line 6175
{ 
#line 6176
uint4 tmp; 
#line 6177
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6178
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6179
} 
#endif
#line 6181 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6182
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6186
::exit(___);}
#if 0
#line 6182
{ 
#line 6183
uint4 tmp; 
#line 6184
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6185
(*retVal) = make_uchar1(tmp.x); 
#line 6186
} 
#endif
#line 6188 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6189
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6193
::exit(___);}
#if 0
#line 6189
{ 
#line 6190
uint4 tmp; 
#line 6191
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6192
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6193
} 
#endif
#line 6195 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6196
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6200
::exit(___);}
#if 0
#line 6196
{ 
#line 6197
uint4 tmp; 
#line 6198
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6199
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6200
} 
#endif
#line 6208 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6209
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6213
::exit(___);}
#if 0
#line 6209
{ 
#line 6210
int4 tmp; 
#line 6211
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6212
(*retVal) = ((short)(tmp.x)); 
#line 6213
} 
#endif
#line 6215 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6216
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6220
::exit(___);}
#if 0
#line 6216
{ 
#line 6217
int4 tmp; 
#line 6218
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6219
(*retVal) = make_short1(tmp.x); 
#line 6220
} 
#endif
#line 6222 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6223
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6227
::exit(___);}
#if 0
#line 6223
{ 
#line 6224
int4 tmp; 
#line 6225
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6226
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6227
} 
#endif
#line 6229 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6230
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6234
::exit(___);}
#if 0
#line 6230
{ 
#line 6231
int4 tmp; 
#line 6232
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6233
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6234
} 
#endif
#line 6236 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6237
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6241
::exit(___);}
#if 0
#line 6237
{ 
#line 6238
uint4 tmp; 
#line 6239
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6240
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6241
} 
#endif
#line 6243 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6244
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6248
::exit(___);}
#if 0
#line 6244
{ 
#line 6245
uint4 tmp; 
#line 6246
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6247
(*retVal) = make_ushort1(tmp.x); 
#line 6248
} 
#endif
#line 6250 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6251
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6255
::exit(___);}
#if 0
#line 6251
{ 
#line 6252
uint4 tmp; 
#line 6253
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6254
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6255
} 
#endif
#line 6257 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6258
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6262
::exit(___);}
#if 0
#line 6258
{ 
#line 6259
uint4 tmp; 
#line 6260
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6261
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6262
} 
#endif
#line 6270 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6271
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6275
::exit(___);}
#if 0
#line 6271
{ 
#line 6272
int4 tmp; 
#line 6273
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6274
(*retVal) = (tmp.x); 
#line 6275
} 
#endif
#line 6277 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6278
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6282
::exit(___);}
#if 0
#line 6278
{ 
#line 6279
int4 tmp; 
#line 6280
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6281
(*retVal) = make_int1(tmp.x); 
#line 6282
} 
#endif
#line 6284 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6285
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6289
::exit(___);}
#if 0
#line 6285
{ 
#line 6286
int4 tmp; 
#line 6287
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6288
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6289
} 
#endif
#line 6291 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6292
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6296
::exit(___);}
#if 0
#line 6292
{ 
#line 6293
int4 tmp; 
#line 6294
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6295
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6296
} 
#endif
#line 6298 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6299
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6303
::exit(___);}
#if 0
#line 6299
{ 
#line 6300
uint4 tmp; 
#line 6301
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6302
(*retVal) = (tmp.x); 
#line 6303
} 
#endif
#line 6305 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6306
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6310
::exit(___);}
#if 0
#line 6306
{ 
#line 6307
uint4 tmp; 
#line 6308
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6309
(*retVal) = make_uint1(tmp.x); 
#line 6310
} 
#endif
#line 6312 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6313
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6317
::exit(___);}
#if 0
#line 6313
{ 
#line 6314
uint4 tmp; 
#line 6315
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6316
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6317
} 
#endif
#line 6319 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6320
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6324
::exit(___);}
#if 0
#line 6320
{ 
#line 6321
uint4 tmp; 
#line 6322
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6323
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6324
} 
#endif
#line 6334 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6335
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6339
::exit(___);}
#if 0
#line 6335
{ 
#line 6336
int4 tmp; 
#line 6337
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6338
(*retVal) = ((long)(tmp.x)); 
#line 6339
} 
#endif
#line 6341 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6342
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6346
::exit(___);}
#if 0
#line 6342
{ 
#line 6343
int4 tmp; 
#line 6344
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6345
(*retVal) = make_long1(tmp.x); 
#line 6346
} 
#endif
#line 6348 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6349
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6353
::exit(___);}
#if 0
#line 6349
{ 
#line 6350
int4 tmp; 
#line 6351
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6352
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6353
} 
#endif
#line 6355 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6356
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6360
::exit(___);}
#if 0
#line 6356
{ 
#line 6357
int4 tmp; 
#line 6358
__tex_1d_array_grad_v4s32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6359
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6360
} 
#endif
#line 6362 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6363
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6367
::exit(___);}
#if 0
#line 6363
{ 
#line 6364
uint4 tmp; 
#line 6365
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6366
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6367
} 
#endif
#line 6369 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6370
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6374
::exit(___);}
#if 0
#line 6370
{ 
#line 6371
uint4 tmp; 
#line 6372
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6373
(*retVal) = make_ulong1(tmp.x); 
#line 6374
} 
#endif
#line 6376 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6377
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6381
::exit(___);}
#if 0
#line 6377
{ 
#line 6378
uint4 tmp; 
#line 6379
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6380
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6381
} 
#endif
#line 6383 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6384
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6388
::exit(___);}
#if 0
#line 6384
{ 
#line 6385
uint4 tmp; 
#line 6386
__tex_1d_array_grad_v4u32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6387
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6388
} 
#endif
#line 6399 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6400
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6404
::exit(___);}
#if 0
#line 6400
{ 
#line 6401
float4 tmp; 
#line 6402
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6403
(*retVal) = (tmp.x); 
#line 6404
} 
#endif
#line 6406 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6407
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6411
::exit(___);}
#if 0
#line 6407
{ 
#line 6408
float4 tmp; 
#line 6409
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6410
(*retVal) = make_float1(tmp.x); 
#line 6411
} 
#endif
#line 6413 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6414
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6418
::exit(___);}
#if 0
#line 6414
{ 
#line 6415
float4 tmp; 
#line 6416
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6417
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6418
} 
#endif
#line 6420 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex1DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, int layer, float dPdx, float dPdy) 
#line 6421
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)layer;(void)dPdx;(void)dPdy;
#line 6425
::exit(___);}
#if 0
#line 6421
{ 
#line 6422
float4 tmp; 
#line 6423
__tex_1d_array_grad_v4f32_f32(texObject, layer, x, dPdx, dPdy, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6424
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6425
} 
#endif
#line 6433 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6434
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6443 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
::exit(___);}
#if 0
#line 6434 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
{ 
#line 6439 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
int4 tmp; 
#line 6440
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6442 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
(*retVal) = ((char)(tmp.x)); 
#line 6443
} 
#endif
#line 6444 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(signed char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6445
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6449
::exit(___);}
#if 0
#line 6445
{ 
#line 6446
int4 tmp; 
#line 6447
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6448
(*retVal) = ((signed char)(tmp.x)); 
#line 6449
} 
#endif
#line 6451 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(char1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6452
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6456
::exit(___);}
#if 0
#line 6452
{ 
#line 6453
int4 tmp; 
#line 6454
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6455
(*retVal) = make_char1(tmp.x); 
#line 6456
} 
#endif
#line 6458 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(char2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6459
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6463
::exit(___);}
#if 0
#line 6459
{ 
#line 6460
int4 tmp; 
#line 6461
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6462
(*retVal) = make_char2(tmp.x, tmp.y); 
#line 6463
} 
#endif
#line 6465 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(char4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6466
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6470
::exit(___);}
#if 0
#line 6466
{ 
#line 6467
int4 tmp; 
#line 6468
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6469
(*retVal) = make_char4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6470
} 
#endif
#line 6472 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(unsigned char *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6473
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6477
::exit(___);}
#if 0
#line 6473
{ 
#line 6474
uint4 tmp; 
#line 6475
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6476
(*retVal) = ((unsigned char)(tmp.x)); 
#line 6477
} 
#endif
#line 6479 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(uchar1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6480
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6484
::exit(___);}
#if 0
#line 6480
{ 
#line 6481
uint4 tmp; 
#line 6482
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6483
(*retVal) = make_uchar1(tmp.x); 
#line 6484
} 
#endif
#line 6486 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(uchar2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6487
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6491
::exit(___);}
#if 0
#line 6487
{ 
#line 6488
uint4 tmp; 
#line 6489
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6490
(*retVal) = make_uchar2(tmp.x, tmp.y); 
#line 6491
} 
#endif
#line 6493 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(uchar4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6494
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6498
::exit(___);}
#if 0
#line 6494
{ 
#line 6495
uint4 tmp; 
#line 6496
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6497
(*retVal) = make_uchar4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6498
} 
#endif
#line 6506 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6507
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6511
::exit(___);}
#if 0
#line 6507
{ 
#line 6508
int4 tmp; 
#line 6509
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6510
(*retVal) = ((short)(tmp.x)); 
#line 6511
} 
#endif
#line 6513 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(short1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6514
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6518
::exit(___);}
#if 0
#line 6514
{ 
#line 6515
int4 tmp; 
#line 6516
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6517
(*retVal) = make_short1(tmp.x); 
#line 6518
} 
#endif
#line 6520 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(short2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6521
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6525
::exit(___);}
#if 0
#line 6521
{ 
#line 6522
int4 tmp; 
#line 6523
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6524
(*retVal) = make_short2(tmp.x, tmp.y); 
#line 6525
} 
#endif
#line 6527 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(short4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6528
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6532
::exit(___);}
#if 0
#line 6528
{ 
#line 6529
int4 tmp; 
#line 6530
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6531
(*retVal) = make_short4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6532
} 
#endif
#line 6534 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(unsigned short *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6535
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6539
::exit(___);}
#if 0
#line 6535
{ 
#line 6536
uint4 tmp; 
#line 6537
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6538
(*retVal) = ((unsigned short)(tmp.x)); 
#line 6539
} 
#endif
#line 6541 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(ushort1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6542
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6546
::exit(___);}
#if 0
#line 6542
{ 
#line 6543
uint4 tmp; 
#line 6544
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6545
(*retVal) = make_ushort1(tmp.x); 
#line 6546
} 
#endif
#line 6548 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(ushort2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6549
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6553
::exit(___);}
#if 0
#line 6549
{ 
#line 6550
uint4 tmp; 
#line 6551
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6552
(*retVal) = make_ushort2(tmp.x, tmp.y); 
#line 6553
} 
#endif
#line 6555 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(ushort4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6556
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6560
::exit(___);}
#if 0
#line 6556
{ 
#line 6557
uint4 tmp; 
#line 6558
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6559
(*retVal) = make_ushort4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6560
} 
#endif
#line 6568 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(int *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6569
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6573
::exit(___);}
#if 0
#line 6569
{ 
#line 6570
int4 tmp; 
#line 6571
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6572
(*retVal) = (tmp.x); 
#line 6573
} 
#endif
#line 6575 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(int1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6576
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6580
::exit(___);}
#if 0
#line 6576
{ 
#line 6577
int4 tmp; 
#line 6578
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6579
(*retVal) = make_int1(tmp.x); 
#line 6580
} 
#endif
#line 6582 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(int2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6583
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6587
::exit(___);}
#if 0
#line 6583
{ 
#line 6584
int4 tmp; 
#line 6585
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6586
(*retVal) = make_int2(tmp.x, tmp.y); 
#line 6587
} 
#endif
#line 6589 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(int4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6590
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6594
::exit(___);}
#if 0
#line 6590
{ 
#line 6591
int4 tmp; 
#line 6592
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6593
(*retVal) = make_int4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6594
} 
#endif
#line 6596 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(unsigned *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6597
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6601
::exit(___);}
#if 0
#line 6597
{ 
#line 6598
uint4 tmp; 
#line 6599
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6600
(*retVal) = (tmp.x); 
#line 6601
} 
#endif
#line 6603 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(uint1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6604
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6608
::exit(___);}
#if 0
#line 6604
{ 
#line 6605
uint4 tmp; 
#line 6606
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6607
(*retVal) = make_uint1(tmp.x); 
#line 6608
} 
#endif
#line 6610 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(uint2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6611
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6615
::exit(___);}
#if 0
#line 6611
{ 
#line 6612
uint4 tmp; 
#line 6613
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6614
(*retVal) = make_uint2(tmp.x, tmp.y); 
#line 6615
} 
#endif
#line 6617 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(uint4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6618
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6622
::exit(___);}
#if 0
#line 6618
{ 
#line 6619
uint4 tmp; 
#line 6620
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6621
(*retVal) = make_uint4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6622
} 
#endif
#line 6632 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6633
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6637
::exit(___);}
#if 0
#line 6633
{ 
#line 6634
int4 tmp; 
#line 6635
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6636
(*retVal) = ((long)(tmp.x)); 
#line 6637
} 
#endif
#line 6639 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(long1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6640
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6644
::exit(___);}
#if 0
#line 6640
{ 
#line 6641
int4 tmp; 
#line 6642
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6643
(*retVal) = make_long1(tmp.x); 
#line 6644
} 
#endif
#line 6646 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(long2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6647
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6651
::exit(___);}
#if 0
#line 6647
{ 
#line 6648
int4 tmp; 
#line 6649
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6650
(*retVal) = make_long2(tmp.x, tmp.y); 
#line 6651
} 
#endif
#line 6653 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(long4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6654
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6658
::exit(___);}
#if 0
#line 6654
{ 
#line 6655
int4 tmp; 
#line 6656
__tex_2d_array_grad_v4s32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6657
(*retVal) = make_long4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6658
} 
#endif
#line 6660 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(unsigned long *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6661
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6665
::exit(___);}
#if 0
#line 6661
{ 
#line 6662
uint4 tmp; 
#line 6663
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6664
(*retVal) = ((unsigned long)(tmp.x)); 
#line 6665
} 
#endif
#line 6667 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(ulong1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6668
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6672
::exit(___);}
#if 0
#line 6668
{ 
#line 6669
uint4 tmp; 
#line 6670
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6671
(*retVal) = make_ulong1(tmp.x); 
#line 6672
} 
#endif
#line 6674 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(ulong2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6675
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6679
::exit(___);}
#if 0
#line 6675
{ 
#line 6676
uint4 tmp; 
#line 6677
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6678
(*retVal) = make_ulong2(tmp.x, tmp.y); 
#line 6679
} 
#endif
#line 6681 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(ulong4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6682
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6686
::exit(___);}
#if 0
#line 6682
{ 
#line 6683
uint4 tmp; 
#line 6684
__tex_2d_array_grad_v4u32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6685
(*retVal) = make_ulong4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6686
} 
#endif
#line 6697 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(float *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6698
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6702
::exit(___);}
#if 0
#line 6698
{ 
#line 6699
float4 tmp; 
#line 6700
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6701
(*retVal) = (tmp.x); 
#line 6702
} 
#endif
#line 6704 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(float1 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6705
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6709
::exit(___);}
#if 0
#line 6705
{ 
#line 6706
float4 tmp; 
#line 6707
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6708
(*retVal) = make_float1(tmp.x); 
#line 6709
} 
#endif
#line 6711 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(float2 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6712
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6716
::exit(___);}
#if 0
#line 6712
{ 
#line 6713
float4 tmp; 
#line 6714
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6715
(*retVal) = make_float2(tmp.x, tmp.y); 
#line 6716
} 
#endif
#line 6718 "e:\\cudatoolkit\\include\\texture_indirect_functions.hpp"
static __forceinline void tex2DLayeredGrad(float4 *retVal, cudaTextureObject_t texObject, float x, float y, int layer, float2 dPdx, float2 dPdy) 
#line 6719
{int volatile ___ = 1;(void)retVal;(void)texObject;(void)x;(void)y;(void)layer;(void)dPdx;(void)dPdy;
#line 6723
::exit(___);}
#if 0
#line 6719
{ 
#line 6720
float4 tmp; 
#line 6721
__tex_2d_array_grad_v4f32_f32(texObject, layer, x, y, dPdx.x, dPdx.y, dPdy.x, dPdy.y, &(tmp.x), &(tmp.y), &(tmp.z), &(tmp.w)); 
#line 6722
(*retVal) = make_float4(tmp.x, tmp.y, tmp.z, tmp.w); 
#line 6723
} 
#endif
#line 77 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
extern "C" { void __suld_1d_i8_clamp(char *, unsigned __int64, int); } 
#line 78
extern "C" { void __suld_1d_i16_clamp(short *, unsigned __int64, int); } 
#line 79
extern "C" { void __suld_1d_i32_clamp(int *, unsigned __int64, int); } 
#line 80
extern "C" { void __suld_1d_i64_clamp(__int64 *, unsigned __int64, int); } 
#line 81
extern "C" { void __suld_1d_v2i8_clamp(char *, char *, unsigned __int64, int); } 
#line 82
extern "C" { void __suld_1d_v2i16_clamp(short *, short *, unsigned __int64, int); } 
#line 83
extern "C" { void __suld_1d_v2i32_clamp(int *, int *, unsigned __int64, int); } 
#line 84
extern "C" { void __suld_1d_v2i64_clamp(__int64 *, __int64 *, unsigned __int64, int); } 
#line 85
extern "C" { void __suld_1d_v4i8_clamp(char *, char *, char *, char *, unsigned __int64, int); } 
#line 86
extern "C" { void __suld_1d_v4i16_clamp(short *, short *, short *, short *, unsigned __int64, int); } 
#line 87
extern "C" { void __suld_1d_v4i32_clamp(int *, int *, int *, int *, unsigned __int64, int); } 
#line 88
extern "C" { void __suld_1d_array_i8_clamp(char *, unsigned __int64, int, int); } 
#line 89
extern "C" { void __suld_1d_array_i16_clamp(short *, unsigned __int64, int, int); } 
#line 90
extern "C" { void __suld_1d_array_i32_clamp(int *, unsigned __int64, int, int); } 
#line 91
extern "C" { void __suld_1d_array_i64_clamp(__int64 *, unsigned __int64, int, int); } 
#line 92
extern "C" { void __suld_1d_array_v2i8_clamp(char *, char *, unsigned __int64, int, int); } 
#line 93
extern "C" { void __suld_1d_array_v2i16_clamp(short *, short *, unsigned __int64, int, int); } 
#line 94
extern "C" { void __suld_1d_array_v2i32_clamp(int *, int *, unsigned __int64, int, int); } 
#line 95
extern "C" { void __suld_1d_array_v2i64_clamp(__int64 *, __int64 *, unsigned __int64, int, int); } 
#line 96
extern "C" { void __suld_1d_array_v4i8_clamp(char *, char *, char *, char *, unsigned __int64, int, int); } 
#line 97
extern "C" { void __suld_1d_array_v4i16_clamp(short *, short *, short *, short *, unsigned __int64, int, int); } 
#line 98
extern "C" { void __suld_1d_array_v4i32_clamp(int *, int *, int *, int *, unsigned __int64, int, int); } 
#line 99
extern "C" { void __suld_2d_i8_clamp(char *, unsigned __int64, int, int); } 
#line 100
extern "C" { void __suld_2d_i16_clamp(short *, unsigned __int64, int, int); } 
#line 101
extern "C" { void __suld_2d_i32_clamp(int *, unsigned __int64, int, int); } 
#line 102
extern "C" { void __suld_2d_i64_clamp(__int64 *, unsigned __int64, int, int); } 
#line 103
extern "C" { void __suld_2d_v2i8_clamp(char *, char *, unsigned __int64, int, int); } 
#line 104
extern "C" { void __suld_2d_v2i16_clamp(short *, short *, unsigned __int64, int, int); } 
#line 105
extern "C" { void __suld_2d_v2i32_clamp(int *, int *, unsigned __int64, int, int); } 
#line 106
extern "C" { void __suld_2d_v2i64_clamp(__int64 *, __int64 *, unsigned __int64, int, int); } 
#line 107
extern "C" { void __suld_2d_v4i8_clamp(char *, char *, char *, char *, unsigned __int64, int, int); } 
#line 108
extern "C" { void __suld_2d_v4i16_clamp(short *, short *, short *, short *, unsigned __int64, int, int); } 
#line 109
extern "C" { void __suld_2d_v4i32_clamp(int *, int *, int *, int *, unsigned __int64, int, int); } 
#line 110
extern "C" { void __suld_2d_array_i8_clamp(char *, unsigned __int64, int, int, int); } 
#line 111
extern "C" { void __suld_2d_array_i16_clamp(short *, unsigned __int64, int, int, int); } 
#line 112
extern "C" { void __suld_2d_array_i32_clamp(int *, unsigned __int64, int, int, int); } 
#line 113
extern "C" { void __suld_2d_array_i64_clamp(__int64 *, unsigned __int64, int, int, int); } 
#line 114
extern "C" { void __suld_2d_array_v2i8_clamp(char *, char *, unsigned __int64, int, int, int); } 
#line 115
extern "C" { void __suld_2d_array_v2i16_clamp(short *, short *, unsigned __int64, int, int, int); } 
#line 116
extern "C" { void __suld_2d_array_v2i32_clamp(int *, int *, unsigned __int64, int, int, int); } 
#line 117
extern "C" { void __suld_2d_array_v2i64_clamp(__int64 *, __int64 *, unsigned __int64, int, int, int); } 
#line 118
extern "C" { void __suld_2d_array_v4i8_clamp(char *, char *, char *, char *, unsigned __int64, int, int, int); } 
#line 119
extern "C" { void __suld_2d_array_v4i16_clamp(short *, short *, short *, short *, unsigned __int64, int, int, int); } 
#line 120
extern "C" { void __suld_2d_array_v4i32_clamp(int *, int *, int *, int *, unsigned __int64, int, int, int); } 
#line 121
extern "C" { void __suld_3d_i8_clamp(char *, unsigned __int64, int, int, int); } 
#line 122
extern "C" { void __suld_3d_i16_clamp(short *, unsigned __int64, int, int, int); } 
#line 123
extern "C" { void __suld_3d_i32_clamp(int *, unsigned __int64, int, int, int); } 
#line 124
extern "C" { void __suld_3d_i64_clamp(__int64 *, unsigned __int64, int, int, int); } 
#line 125
extern "C" { void __suld_3d_v2i8_clamp(char *, char *, unsigned __int64, int, int, int); } 
#line 126
extern "C" { void __suld_3d_v2i16_clamp(short *, short *, unsigned __int64, int, int, int); } 
#line 127
extern "C" { void __suld_3d_v2i32_clamp(int *, int *, unsigned __int64, int, int, int); } 
#line 128
extern "C" { void __suld_3d_v2i64_clamp(__int64 *, __int64 *, unsigned __int64, int, int, int); } 
#line 129
extern "C" { void __suld_3d_v4i8_clamp(char *, char *, char *, char *, unsigned __int64, int, int, int); } 
#line 130
extern "C" { void __suld_3d_v4i16_clamp(short *, short *, short *, short *, unsigned __int64, int, int, int); } 
#line 131
extern "C" { void __suld_3d_v4i32_clamp(int *, int *, int *, int *, unsigned __int64, int, int, int); } 
#line 132
extern "C" { void __suld_1d_i8_trap(char *, unsigned __int64, int); } 
#line 133
extern "C" { void __suld_1d_i16_trap(short *, unsigned __int64, int); } 
#line 134
extern "C" { void __suld_1d_i32_trap(int *, unsigned __int64, int); } 
#line 135
extern "C" { void __suld_1d_i64_trap(__int64 *, unsigned __int64, int); } 
#line 136
extern "C" { void __suld_1d_v2i8_trap(char *, char *, unsigned __int64, int); } 
#line 137
extern "C" { void __suld_1d_v2i16_trap(short *, short *, unsigned __int64, int); } 
#line 138
extern "C" { void __suld_1d_v2i32_trap(int *, int *, unsigned __int64, int); } 
#line 139
extern "C" { void __suld_1d_v2i64_trap(__int64 *, __int64 *, unsigned __int64, int); } 
#line 140
extern "C" { void __suld_1d_v4i8_trap(char *, char *, char *, char *, unsigned __int64, int); } 
#line 141
extern "C" { void __suld_1d_v4i16_trap(short *, short *, short *, short *, unsigned __int64, int); } 
#line 142
extern "C" { void __suld_1d_v4i32_trap(int *, int *, int *, int *, unsigned __int64, int); } 
#line 143
extern "C" { void __suld_1d_array_i8_trap(char *, unsigned __int64, int, int); } 
#line 144
extern "C" { void __suld_1d_array_i16_trap(short *, unsigned __int64, int, int); } 
#line 145
extern "C" { void __suld_1d_array_i32_trap(int *, unsigned __int64, int, int); } 
#line 146
extern "C" { void __suld_1d_array_i64_trap(__int64 *, unsigned __int64, int, int); } 
#line 147
extern "C" { void __suld_1d_array_v2i8_trap(char *, char *, unsigned __int64, int, int); } 
#line 148
extern "C" { void __suld_1d_array_v2i16_trap(short *, short *, unsigned __int64, int, int); } 
#line 149
extern "C" { void __suld_1d_array_v2i32_trap(int *, int *, unsigned __int64, int, int); } 
#line 150
extern "C" { void __suld_1d_array_v2i64_trap(__int64 *, __int64 *, unsigned __int64, int, int); } 
#line 151
extern "C" { void __suld_1d_array_v4i8_trap(char *, char *, char *, char *, unsigned __int64, int, int); } 
#line 152
extern "C" { void __suld_1d_array_v4i16_trap(short *, short *, short *, short *, unsigned __int64, int, int); } 
#line 153
extern "C" { void __suld_1d_array_v4i32_trap(int *, int *, int *, int *, unsigned __int64, int, int); } 
#line 154
extern "C" { void __suld_2d_i8_trap(char *, unsigned __int64, int, int); } 
#line 155
extern "C" { void __suld_2d_i16_trap(short *, unsigned __int64, int, int); } 
#line 156
extern "C" { void __suld_2d_i32_trap(int *, unsigned __int64, int, int); } 
#line 157
extern "C" { void __suld_2d_i64_trap(__int64 *, unsigned __int64, int, int); } 
#line 158
extern "C" { void __suld_2d_v2i8_trap(char *, char *, unsigned __int64, int, int); } 
#line 159
extern "C" { void __suld_2d_v2i16_trap(short *, short *, unsigned __int64, int, int); } 
#line 160
extern "C" { void __suld_2d_v2i32_trap(int *, int *, unsigned __int64, int, int); } 
#line 161
extern "C" { void __suld_2d_v2i64_trap(__int64 *, __int64 *, unsigned __int64, int, int); } 
#line 162
extern "C" { void __suld_2d_v4i8_trap(char *, char *, char *, char *, unsigned __int64, int, int); } 
#line 163
extern "C" { void __suld_2d_v4i16_trap(short *, short *, short *, short *, unsigned __int64, int, int); } 
#line 164
extern "C" { void __suld_2d_v4i32_trap(int *, int *, int *, int *, unsigned __int64, int, int); } 
#line 165
extern "C" { void __suld_2d_array_i8_trap(char *, unsigned __int64, int, int, int); } 
#line 166
extern "C" { void __suld_2d_array_i16_trap(short *, unsigned __int64, int, int, int); } 
#line 167
extern "C" { void __suld_2d_array_i32_trap(int *, unsigned __int64, int, int, int); } 
#line 168
extern "C" { void __suld_2d_array_i64_trap(__int64 *, unsigned __int64, int, int, int); } 
#line 169
extern "C" { void __suld_2d_array_v2i8_trap(char *, char *, unsigned __int64, int, int, int); } 
#line 170
extern "C" { void __suld_2d_array_v2i16_trap(short *, short *, unsigned __int64, int, int, int); } 
#line 171
extern "C" { void __suld_2d_array_v2i32_trap(int *, int *, unsigned __int64, int, int, int); } 
#line 172
extern "C" { void __suld_2d_array_v2i64_trap(__int64 *, __int64 *, unsigned __int64, int, int, int); } 
#line 173
extern "C" { void __suld_2d_array_v4i8_trap(char *, char *, char *, char *, unsigned __int64, int, int, int); } 
#line 174
extern "C" { void __suld_2d_array_v4i16_trap(short *, short *, short *, short *, unsigned __int64, int, int, int); } 
#line 175
extern "C" { void __suld_2d_array_v4i32_trap(int *, int *, int *, int *, unsigned __int64, int, int, int); } 
#line 176
extern "C" { void __suld_3d_i8_trap(char *, unsigned __int64, int, int, int); } 
#line 177
extern "C" { void __suld_3d_i16_trap(short *, unsigned __int64, int, int, int); } 
#line 178
extern "C" { void __suld_3d_i32_trap(int *, unsigned __int64, int, int, int); } 
#line 179
extern "C" { void __suld_3d_i64_trap(__int64 *, unsigned __int64, int, int, int); } 
#line 180
extern "C" { void __suld_3d_v2i8_trap(char *, char *, unsigned __int64, int, int, int); } 
#line 181
extern "C" { void __suld_3d_v2i16_trap(short *, short *, unsigned __int64, int, int, int); } 
#line 182
extern "C" { void __suld_3d_v2i32_trap(int *, int *, unsigned __int64, int, int, int); } 
#line 183
extern "C" { void __suld_3d_v2i64_trap(__int64 *, __int64 *, unsigned __int64, int, int, int); } 
#line 184
extern "C" { void __suld_3d_v4i8_trap(char *, char *, char *, char *, unsigned __int64, int, int, int); } 
#line 185
extern "C" { void __suld_3d_v4i16_trap(short *, short *, short *, short *, unsigned __int64, int, int, int); } 
#line 186
extern "C" { void __suld_3d_v4i32_trap(int *, int *, int *, int *, unsigned __int64, int, int, int); } 
#line 187
extern "C" { void __suld_1d_i8_zero(char *, unsigned __int64, int); } 
#line 188
extern "C" { void __suld_1d_i16_zero(short *, unsigned __int64, int); } 
#line 189
extern "C" { void __suld_1d_i32_zero(int *, unsigned __int64, int); } 
#line 190
extern "C" { void __suld_1d_i64_zero(__int64 *, unsigned __int64, int); } 
#line 191
extern "C" { void __suld_1d_v2i8_zero(char *, char *, unsigned __int64, int); } 
#line 192
extern "C" { void __suld_1d_v2i16_zero(short *, short *, unsigned __int64, int); } 
#line 193
extern "C" { void __suld_1d_v2i32_zero(int *, int *, unsigned __int64, int); } 
#line 194
extern "C" { void __suld_1d_v2i64_zero(__int64 *, __int64 *, unsigned __int64, int); } 
#line 195
extern "C" { void __suld_1d_v4i8_zero(char *, char *, char *, char *, unsigned __int64, int); } 
#line 196
extern "C" { void __suld_1d_v4i16_zero(short *, short *, short *, short *, unsigned __int64, int); } 
#line 197
extern "C" { void __suld_1d_v4i32_zero(int *, int *, int *, int *, unsigned __int64, int); } 
#line 198
extern "C" { void __suld_1d_array_i8_zero(char *, unsigned __int64, int, int); } 
#line 199
extern "C" { void __suld_1d_array_i16_zero(short *, unsigned __int64, int, int); } 
#line 200
extern "C" { void __suld_1d_array_i32_zero(int *, unsigned __int64, int, int); } 
#line 201
extern "C" { void __suld_1d_array_i64_zero(__int64 *, unsigned __int64, int, int); } 
#line 202
extern "C" { void __suld_1d_array_v2i8_zero(char *, char *, unsigned __int64, int, int); } 
#line 203
extern "C" { void __suld_1d_array_v2i16_zero(short *, short *, unsigned __int64, int, int); } 
#line 204
extern "C" { void __suld_1d_array_v2i32_zero(int *, int *, unsigned __int64, int, int); } 
#line 205
extern "C" { void __suld_1d_array_v2i64_zero(__int64 *, __int64 *, unsigned __int64, int, int); } 
#line 206
extern "C" { void __suld_1d_array_v4i8_zero(char *, char *, char *, char *, unsigned __int64, int, int); } 
#line 207
extern "C" { void __suld_1d_array_v4i16_zero(short *, short *, short *, short *, unsigned __int64, int, int); } 
#line 208
extern "C" { void __suld_1d_array_v4i32_zero(int *, int *, int *, int *, unsigned __int64, int, int); } 
#line 209
extern "C" { void __suld_2d_i8_zero(char *, unsigned __int64, int, int); } 
#line 210
extern "C" { void __suld_2d_i16_zero(short *, unsigned __int64, int, int); } 
#line 211
extern "C" { void __suld_2d_i32_zero(int *, unsigned __int64, int, int); } 
#line 212
extern "C" { void __suld_2d_i64_zero(__int64 *, unsigned __int64, int, int); } 
#line 213
extern "C" { void __suld_2d_v2i8_zero(char *, char *, unsigned __int64, int, int); } 
#line 214
extern "C" { void __suld_2d_v2i16_zero(short *, short *, unsigned __int64, int, int); } 
#line 215
extern "C" { void __suld_2d_v2i32_zero(int *, int *, unsigned __int64, int, int); } 
#line 216
extern "C" { void __suld_2d_v2i64_zero(__int64 *, __int64 *, unsigned __int64, int, int); } 
#line 217
extern "C" { void __suld_2d_v4i8_zero(char *, char *, char *, char *, unsigned __int64, int, int); } 
#line 218
extern "C" { void __suld_2d_v4i16_zero(short *, short *, short *, short *, unsigned __int64, int, int); } 
#line 219
extern "C" { void __suld_2d_v4i32_zero(int *, int *, int *, int *, unsigned __int64, int, int); } 
#line 220
extern "C" { void __suld_2d_array_i8_zero(char *, unsigned __int64, int, int, int); } 
#line 221
extern "C" { void __suld_2d_array_i16_zero(short *, unsigned __int64, int, int, int); } 
#line 222
extern "C" { void __suld_2d_array_i32_zero(int *, unsigned __int64, int, int, int); } 
#line 223
extern "C" { void __suld_2d_array_i64_zero(__int64 *, unsigned __int64, int, int, int); } 
#line 224
extern "C" { void __suld_2d_array_v2i8_zero(char *, char *, unsigned __int64, int, int, int); } 
#line 225
extern "C" { void __suld_2d_array_v2i16_zero(short *, short *, unsigned __int64, int, int, int); } 
#line 226
extern "C" { void __suld_2d_array_v2i32_zero(int *, int *, unsigned __int64, int, int, int); } 
#line 227
extern "C" { void __suld_2d_array_v2i64_zero(__int64 *, __int64 *, unsigned __int64, int, int, int); } 
#line 228
extern "C" { void __suld_2d_array_v4i8_zero(char *, char *, char *, char *, unsigned __int64, int, int, int); } 
#line 229
extern "C" { void __suld_2d_array_v4i16_zero(short *, short *, short *, short *, unsigned __int64, int, int, int); } 
#line 230
extern "C" { void __suld_2d_array_v4i32_zero(int *, int *, int *, int *, unsigned __int64, int, int, int); } 
#line 231
extern "C" { void __suld_3d_i8_zero(char *, unsigned __int64, int, int, int); } 
#line 232
extern "C" { void __suld_3d_i16_zero(short *, unsigned __int64, int, int, int); } 
#line 233
extern "C" { void __suld_3d_i32_zero(int *, unsigned __int64, int, int, int); } 
#line 234
extern "C" { void __suld_3d_i64_zero(__int64 *, unsigned __int64, int, int, int); } 
#line 235
extern "C" { void __suld_3d_v2i8_zero(char *, char *, unsigned __int64, int, int, int); } 
#line 236
extern "C" { void __suld_3d_v2i16_zero(short *, short *, unsigned __int64, int, int, int); } 
#line 237
extern "C" { void __suld_3d_v2i32_zero(int *, int *, unsigned __int64, int, int, int); } 
#line 238
extern "C" { void __suld_3d_v2i64_zero(__int64 *, __int64 *, unsigned __int64, int, int, int); } 
#line 239
extern "C" { void __suld_3d_v4i8_zero(char *, char *, char *, char *, unsigned __int64, int, int, int); } 
#line 240
extern "C" { void __suld_3d_v4i16_zero(short *, short *, short *, short *, unsigned __int64, int, int, int); } 
#line 241
extern "C" { void __suld_3d_v4i32_zero(int *, int *, int *, int *, unsigned __int64, int, int, int); } 
#line 243
extern "C" { void __sust_b_1d_i8_clamp(cudaSurfaceObject_t, int, unsigned char); } 
#line 244
extern "C" { void __sust_b_1d_i16_clamp(cudaSurfaceObject_t, int, unsigned short); } 
#line 245
extern "C" { void __sust_b_1d_i32_clamp(cudaSurfaceObject_t, int, unsigned); } 
#line 246
extern "C" { void __sust_b_1d_i64_clamp(cudaSurfaceObject_t, int, unsigned __int64); } 
#line 247
extern "C" { void __sust_b_1d_v2i8_clamp(cudaSurfaceObject_t, int, uchar2); } 
#line 248
extern "C" { void __sust_b_1d_v2i16_clamp(cudaSurfaceObject_t, int, ushort2); } 
#line 249
extern "C" { void __sust_b_1d_v2i32_clamp(cudaSurfaceObject_t, int, uint2); } 
#line 250
extern "C" { void __sust_b_1d_v2i64_clamp(cudaSurfaceObject_t, int, ulonglong2); } 
#line 251
extern "C" { void __sust_b_1d_v4i8_clamp(cudaSurfaceObject_t, int, uchar4); } 
#line 252
extern "C" { void __sust_b_1d_v4i16_clamp(cudaSurfaceObject_t, int, ushort4); } 
#line 253
extern "C" { void __sust_b_1d_v4i32_clamp(cudaSurfaceObject_t, int, uint4); } 
#line 254
extern "C" { void __sust_b_1d_array_i8_clamp(cudaSurfaceObject_t, int, int, unsigned char); } 
#line 255
extern "C" { void __sust_b_1d_array_i16_clamp(cudaSurfaceObject_t, int, int, unsigned short); } 
#line 256
extern "C" { void __sust_b_1d_array_i32_clamp(cudaSurfaceObject_t, int, int, unsigned); } 
#line 257
extern "C" { void __sust_b_1d_array_i64_clamp(cudaSurfaceObject_t, int, int, unsigned __int64); } 
#line 258
extern "C" { void __sust_b_1d_array_v2i8_clamp(cudaSurfaceObject_t, int, int, uchar2); } 
#line 259
extern "C" { void __sust_b_1d_array_v2i16_clamp(cudaSurfaceObject_t, int, int, ushort2); } 
#line 260
extern "C" { void __sust_b_1d_array_v2i32_clamp(cudaSurfaceObject_t, int, int, uint2); } 
#line 261
extern "C" { void __sust_b_1d_array_v2i64_clamp(cudaSurfaceObject_t, int, int, ulonglong2); } 
#line 262
extern "C" { void __sust_b_1d_array_v4i8_clamp(cudaSurfaceObject_t, int, int, uchar4); } 
#line 263
extern "C" { void __sust_b_1d_array_v4i16_clamp(cudaSurfaceObject_t, int, int, ushort4); } 
#line 264
extern "C" { void __sust_b_1d_array_v4i32_clamp(cudaSurfaceObject_t, int, int, uint4); } 
#line 265
extern "C" { void __sust_b_2d_i8_clamp(cudaSurfaceObject_t, int, int, unsigned char); } 
#line 266
extern "C" { void __sust_b_2d_i16_clamp(cudaSurfaceObject_t, int, int, unsigned short); } 
#line 267
extern "C" { void __sust_b_2d_i32_clamp(cudaSurfaceObject_t, int, int, unsigned); } 
#line 268
extern "C" { void __sust_b_2d_i64_clamp(cudaSurfaceObject_t, int, int, unsigned __int64); } 
#line 269
extern "C" { void __sust_b_2d_v2i8_clamp(cudaSurfaceObject_t, int, int, uchar2); } 
#line 270
extern "C" { void __sust_b_2d_v2i16_clamp(cudaSurfaceObject_t, int, int, ushort2); } 
#line 271
extern "C" { void __sust_b_2d_v2i32_clamp(cudaSurfaceObject_t, int, int, uint2); } 
#line 272
extern "C" { void __sust_b_2d_v2i64_clamp(cudaSurfaceObject_t, int, int, ulonglong2); } 
#line 273
extern "C" { void __sust_b_2d_v4i8_clamp(cudaSurfaceObject_t, int, int, uchar4); } 
#line 274
extern "C" { void __sust_b_2d_v4i16_clamp(cudaSurfaceObject_t, int, int, ushort4); } 
#line 275
extern "C" { void __sust_b_2d_v4i32_clamp(cudaSurfaceObject_t, int, int, uint4); } 
#line 276
extern "C" { void __sust_b_2d_array_i8_clamp(cudaSurfaceObject_t, int, int, int, unsigned char); } 
#line 277
extern "C" { void __sust_b_2d_array_i16_clamp(cudaSurfaceObject_t, int, int, int, unsigned short); } 
#line 278
extern "C" { void __sust_b_2d_array_i32_clamp(cudaSurfaceObject_t, int, int, int, unsigned); } 
#line 279
extern "C" { void __sust_b_2d_array_i64_clamp(cudaSurfaceObject_t, int, int, int, unsigned __int64); } 
#line 280
extern "C" { void __sust_b_2d_array_v2i8_clamp(cudaSurfaceObject_t, int, int, int, uchar2); } 
#line 281
extern "C" { void __sust_b_2d_array_v2i16_clamp(cudaSurfaceObject_t, int, int, int, ushort2); } 
#line 282
extern "C" { void __sust_b_2d_array_v2i32_clamp(cudaSurfaceObject_t, int, int, int, uint2); } 
#line 283
extern "C" { void __sust_b_2d_array_v2i64_clamp(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
#line 284
extern "C" { void __sust_b_2d_array_v4i8_clamp(cudaSurfaceObject_t, int, int, int, uchar4); } 
#line 285
extern "C" { void __sust_b_2d_array_v4i16_clamp(cudaSurfaceObject_t, int, int, int, ushort4); } 
#line 286
extern "C" { void __sust_b_2d_array_v4i32_clamp(cudaSurfaceObject_t, int, int, int, uint4); } 
#line 287
extern "C" { void __sust_b_3d_i8_clamp(cudaSurfaceObject_t, int, int, int, unsigned char); } 
#line 288
extern "C" { void __sust_b_3d_i16_clamp(cudaSurfaceObject_t, int, int, int, unsigned short); } 
#line 289
extern "C" { void __sust_b_3d_i32_clamp(cudaSurfaceObject_t, int, int, int, unsigned); } 
#line 290
extern "C" { void __sust_b_3d_i64_clamp(cudaSurfaceObject_t, int, int, int, unsigned __int64); } 
#line 291
extern "C" { void __sust_b_3d_v2i8_clamp(cudaSurfaceObject_t, int, int, int, uchar2); } 
#line 292
extern "C" { void __sust_b_3d_v2i16_clamp(cudaSurfaceObject_t, int, int, int, ushort2); } 
#line 293
extern "C" { void __sust_b_3d_v2i32_clamp(cudaSurfaceObject_t, int, int, int, uint2); } 
#line 294
extern "C" { void __sust_b_3d_v2i64_clamp(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
#line 295
extern "C" { void __sust_b_3d_v4i8_clamp(cudaSurfaceObject_t, int, int, int, uchar4); } 
#line 296
extern "C" { void __sust_b_3d_v4i16_clamp(cudaSurfaceObject_t, int, int, int, ushort4); } 
#line 297
extern "C" { void __sust_b_3d_v4i32_clamp(cudaSurfaceObject_t, int, int, int, uint4); } 
#line 298
extern "C" { void __sust_b_1d_i8_trap(cudaSurfaceObject_t, int, unsigned char); } 
#line 299
extern "C" { void __sust_b_1d_i16_trap(cudaSurfaceObject_t, int, unsigned short); } 
#line 300
extern "C" { void __sust_b_1d_i32_trap(cudaSurfaceObject_t, int, unsigned); } 
#line 301
extern "C" { void __sust_b_1d_i64_trap(cudaSurfaceObject_t, int, unsigned __int64); } 
#line 302
extern "C" { void __sust_b_1d_v2i8_trap(cudaSurfaceObject_t, int, uchar2); } 
#line 303
extern "C" { void __sust_b_1d_v2i16_trap(cudaSurfaceObject_t, int, ushort2); } 
#line 304
extern "C" { void __sust_b_1d_v2i32_trap(cudaSurfaceObject_t, int, uint2); } 
#line 305
extern "C" { void __sust_b_1d_v2i64_trap(cudaSurfaceObject_t, int, ulonglong2); } 
#line 306
extern "C" { void __sust_b_1d_v4i8_trap(cudaSurfaceObject_t, int, uchar4); } 
#line 307
extern "C" { void __sust_b_1d_v4i16_trap(cudaSurfaceObject_t, int, ushort4); } 
#line 308
extern "C" { void __sust_b_1d_v4i32_trap(cudaSurfaceObject_t, int, uint4); } 
#line 309
extern "C" { void __sust_b_1d_array_i8_trap(cudaSurfaceObject_t, int, int, unsigned char); } 
#line 310
extern "C" { void __sust_b_1d_array_i16_trap(cudaSurfaceObject_t, int, int, unsigned short); } 
#line 311
extern "C" { void __sust_b_1d_array_i32_trap(cudaSurfaceObject_t, int, int, unsigned); } 
#line 312
extern "C" { void __sust_b_1d_array_i64_trap(cudaSurfaceObject_t, int, int, unsigned __int64); } 
#line 313
extern "C" { void __sust_b_1d_array_v2i8_trap(cudaSurfaceObject_t, int, int, uchar2); } 
#line 314
extern "C" { void __sust_b_1d_array_v2i16_trap(cudaSurfaceObject_t, int, int, ushort2); } 
#line 315
extern "C" { void __sust_b_1d_array_v2i32_trap(cudaSurfaceObject_t, int, int, uint2); } 
#line 316
extern "C" { void __sust_b_1d_array_v2i64_trap(cudaSurfaceObject_t, int, int, ulonglong2); } 
#line 317
extern "C" { void __sust_b_1d_array_v4i8_trap(cudaSurfaceObject_t, int, int, uchar4); } 
#line 318
extern "C" { void __sust_b_1d_array_v4i16_trap(cudaSurfaceObject_t, int, int, ushort4); } 
#line 319
extern "C" { void __sust_b_1d_array_v4i32_trap(cudaSurfaceObject_t, int, int, uint4); } 
#line 320
extern "C" { void __sust_b_2d_i8_trap(cudaSurfaceObject_t, int, int, unsigned char); } 
#line 321
extern "C" { void __sust_b_2d_i16_trap(cudaSurfaceObject_t, int, int, unsigned short); } 
#line 322
extern "C" { void __sust_b_2d_i32_trap(cudaSurfaceObject_t, int, int, unsigned); } 
#line 323
extern "C" { void __sust_b_2d_i64_trap(cudaSurfaceObject_t, int, int, unsigned __int64); } 
#line 324
extern "C" { void __sust_b_2d_v2i8_trap(cudaSurfaceObject_t, int, int, uchar2); } 
#line 325
extern "C" { void __sust_b_2d_v2i16_trap(cudaSurfaceObject_t, int, int, ushort2); } 
#line 326
extern "C" { void __sust_b_2d_v2i32_trap(cudaSurfaceObject_t, int, int, uint2); } 
#line 327
extern "C" { void __sust_b_2d_v2i64_trap(cudaSurfaceObject_t, int, int, ulonglong2); } 
#line 328
extern "C" { void __sust_b_2d_v4i8_trap(cudaSurfaceObject_t, int, int, uchar4); } 
#line 329
extern "C" { void __sust_b_2d_v4i16_trap(cudaSurfaceObject_t, int, int, ushort4); } 
#line 330
extern "C" { void __sust_b_2d_v4i32_trap(cudaSurfaceObject_t, int, int, uint4); } 
#line 331
extern "C" { void __sust_b_2d_array_i8_trap(cudaSurfaceObject_t, int, int, int, unsigned char); } 
#line 332
extern "C" { void __sust_b_2d_array_i16_trap(cudaSurfaceObject_t, int, int, int, unsigned short); } 
#line 333
extern "C" { void __sust_b_2d_array_i32_trap(cudaSurfaceObject_t, int, int, int, unsigned); } 
#line 334
extern "C" { void __sust_b_2d_array_i64_trap(cudaSurfaceObject_t, int, int, int, unsigned __int64); } 
#line 335
extern "C" { void __sust_b_2d_array_v2i8_trap(cudaSurfaceObject_t, int, int, int, uchar2); } 
#line 336
extern "C" { void __sust_b_2d_array_v2i16_trap(cudaSurfaceObject_t, int, int, int, ushort2); } 
#line 337
extern "C" { void __sust_b_2d_array_v2i32_trap(cudaSurfaceObject_t, int, int, int, uint2); } 
#line 338
extern "C" { void __sust_b_2d_array_v2i64_trap(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
#line 339
extern "C" { void __sust_b_2d_array_v4i8_trap(cudaSurfaceObject_t, int, int, int, uchar4); } 
#line 340
extern "C" { void __sust_b_2d_array_v4i16_trap(cudaSurfaceObject_t, int, int, int, ushort4); } 
#line 341
extern "C" { void __sust_b_2d_array_v4i32_trap(cudaSurfaceObject_t, int, int, int, uint4); } 
#line 342
extern "C" { void __sust_b_3d_i8_trap(cudaSurfaceObject_t, int, int, int, unsigned char); } 
#line 343
extern "C" { void __sust_b_3d_i16_trap(cudaSurfaceObject_t, int, int, int, unsigned short); } 
#line 344
extern "C" { void __sust_b_3d_i32_trap(cudaSurfaceObject_t, int, int, int, unsigned); } 
#line 345
extern "C" { void __sust_b_3d_i64_trap(cudaSurfaceObject_t, int, int, int, unsigned __int64); } 
#line 346
extern "C" { void __sust_b_3d_v2i8_trap(cudaSurfaceObject_t, int, int, int, uchar2); } 
#line 347
extern "C" { void __sust_b_3d_v2i16_trap(cudaSurfaceObject_t, int, int, int, ushort2); } 
#line 348
extern "C" { void __sust_b_3d_v2i32_trap(cudaSurfaceObject_t, int, int, int, uint2); } 
#line 349
extern "C" { void __sust_b_3d_v2i64_trap(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
#line 350
extern "C" { void __sust_b_3d_v4i8_trap(cudaSurfaceObject_t, int, int, int, uchar4); } 
#line 351
extern "C" { void __sust_b_3d_v4i16_trap(cudaSurfaceObject_t, int, int, int, ushort4); } 
#line 352
extern "C" { void __sust_b_3d_v4i32_trap(cudaSurfaceObject_t, int, int, int, uint4); } 
#line 353
extern "C" { void __sust_b_1d_i8_zero(cudaSurfaceObject_t, int, unsigned char); } 
#line 354
extern "C" { void __sust_b_1d_i16_zero(cudaSurfaceObject_t, int, unsigned short); } 
#line 355
extern "C" { void __sust_b_1d_i32_zero(cudaSurfaceObject_t, int, unsigned); } 
#line 356
extern "C" { void __sust_b_1d_i64_zero(cudaSurfaceObject_t, int, unsigned __int64); } 
#line 357
extern "C" { void __sust_b_1d_v2i8_zero(cudaSurfaceObject_t, int, uchar2); } 
#line 358
extern "C" { void __sust_b_1d_v2i16_zero(cudaSurfaceObject_t, int, ushort2); } 
#line 359
extern "C" { void __sust_b_1d_v2i32_zero(cudaSurfaceObject_t, int, uint2); } 
#line 360
extern "C" { void __sust_b_1d_v2i64_zero(cudaSurfaceObject_t, int, ulonglong2); } 
#line 361
extern "C" { void __sust_b_1d_v4i8_zero(cudaSurfaceObject_t, int, uchar4); } 
#line 362
extern "C" { void __sust_b_1d_v4i16_zero(cudaSurfaceObject_t, int, ushort4); } 
#line 363
extern "C" { void __sust_b_1d_v4i32_zero(cudaSurfaceObject_t, int, uint4); } 
#line 364
extern "C" { void __sust_b_1d_array_i8_zero(cudaSurfaceObject_t, int, int, unsigned char); } 
#line 365
extern "C" { void __sust_b_1d_array_i16_zero(cudaSurfaceObject_t, int, int, unsigned short); } 
#line 366
extern "C" { void __sust_b_1d_array_i32_zero(cudaSurfaceObject_t, int, int, unsigned); } 
#line 367
extern "C" { void __sust_b_1d_array_i64_zero(cudaSurfaceObject_t, int, int, unsigned __int64); } 
#line 368
extern "C" { void __sust_b_1d_array_v2i8_zero(cudaSurfaceObject_t, int, int, uchar2); } 
#line 369
extern "C" { void __sust_b_1d_array_v2i16_zero(cudaSurfaceObject_t, int, int, ushort2); } 
#line 370
extern "C" { void __sust_b_1d_array_v2i32_zero(cudaSurfaceObject_t, int, int, uint2); } 
#line 371
extern "C" { void __sust_b_1d_array_v2i64_zero(cudaSurfaceObject_t, int, int, ulonglong2); } 
#line 372
extern "C" { void __sust_b_1d_array_v4i8_zero(cudaSurfaceObject_t, int, int, uchar4); } 
#line 373
extern "C" { void __sust_b_1d_array_v4i16_zero(cudaSurfaceObject_t, int, int, ushort4); } 
#line 374
extern "C" { void __sust_b_1d_array_v4i32_zero(cudaSurfaceObject_t, int, int, uint4); } 
#line 375
extern "C" { void __sust_b_2d_i8_zero(cudaSurfaceObject_t, int, int, unsigned char); } 
#line 376
extern "C" { void __sust_b_2d_i16_zero(cudaSurfaceObject_t, int, int, unsigned short); } 
#line 377
extern "C" { void __sust_b_2d_i32_zero(cudaSurfaceObject_t, int, int, unsigned); } 
#line 378
extern "C" { void __sust_b_2d_i64_zero(cudaSurfaceObject_t, int, int, unsigned __int64); } 
#line 379
extern "C" { void __sust_b_2d_v2i8_zero(cudaSurfaceObject_t, int, int, uchar2); } 
#line 380
extern "C" { void __sust_b_2d_v2i16_zero(cudaSurfaceObject_t, int, int, ushort2); } 
#line 381
extern "C" { void __sust_b_2d_v2i32_zero(cudaSurfaceObject_t, int, int, uint2); } 
#line 382
extern "C" { void __sust_b_2d_v2i64_zero(cudaSurfaceObject_t, int, int, ulonglong2); } 
#line 383
extern "C" { void __sust_b_2d_v4i8_zero(cudaSurfaceObject_t, int, int, uchar4); } 
#line 384
extern "C" { void __sust_b_2d_v4i16_zero(cudaSurfaceObject_t, int, int, ushort4); } 
#line 385
extern "C" { void __sust_b_2d_v4i32_zero(cudaSurfaceObject_t, int, int, uint4); } 
#line 386
extern "C" { void __sust_b_2d_array_i8_zero(cudaSurfaceObject_t, int, int, int, unsigned char); } 
#line 387
extern "C" { void __sust_b_2d_array_i16_zero(cudaSurfaceObject_t, int, int, int, unsigned short); } 
#line 388
extern "C" { void __sust_b_2d_array_i32_zero(cudaSurfaceObject_t, int, int, int, unsigned); } 
#line 389
extern "C" { void __sust_b_2d_array_i64_zero(cudaSurfaceObject_t, int, int, int, unsigned __int64); } 
#line 390
extern "C" { void __sust_b_2d_array_v2i8_zero(cudaSurfaceObject_t, int, int, int, uchar2); } 
#line 391
extern "C" { void __sust_b_2d_array_v2i16_zero(cudaSurfaceObject_t, int, int, int, ushort2); } 
#line 392
extern "C" { void __sust_b_2d_array_v2i32_zero(cudaSurfaceObject_t, int, int, int, uint2); } 
#line 393
extern "C" { void __sust_b_2d_array_v2i64_zero(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
#line 394
extern "C" { void __sust_b_2d_array_v4i8_zero(cudaSurfaceObject_t, int, int, int, uchar4); } 
#line 395
extern "C" { void __sust_b_2d_array_v4i16_zero(cudaSurfaceObject_t, int, int, int, ushort4); } 
#line 396
extern "C" { void __sust_b_2d_array_v4i32_zero(cudaSurfaceObject_t, int, int, int, uint4); } 
#line 397
extern "C" { void __sust_b_3d_i8_zero(cudaSurfaceObject_t, int, int, int, unsigned char); } 
#line 398
extern "C" { void __sust_b_3d_i16_zero(cudaSurfaceObject_t, int, int, int, unsigned short); } 
#line 399
extern "C" { void __sust_b_3d_i32_zero(cudaSurfaceObject_t, int, int, int, unsigned); } 
#line 400
extern "C" { void __sust_b_3d_i64_zero(cudaSurfaceObject_t, int, int, int, unsigned __int64); } 
#line 401
extern "C" { void __sust_b_3d_v2i8_zero(cudaSurfaceObject_t, int, int, int, uchar2); } 
#line 402
extern "C" { void __sust_b_3d_v2i16_zero(cudaSurfaceObject_t, int, int, int, ushort2); } 
#line 403
extern "C" { void __sust_b_3d_v2i32_zero(cudaSurfaceObject_t, int, int, int, uint2); } 
#line 404
extern "C" { void __sust_b_3d_v2i64_zero(cudaSurfaceObject_t, int, int, int, ulonglong2); } 
#line 405
extern "C" { void __sust_b_3d_v4i8_zero(cudaSurfaceObject_t, int, int, int, uchar4); } 
#line 406
extern "C" { void __sust_b_3d_v4i16_zero(cudaSurfaceObject_t, int, int, int, ushort4); } 
#line 407
extern "C" { void __sust_b_3d_v4i32_zero(cudaSurfaceObject_t, int, int, int, uint4); } 
#line 410
static __forceinline void surf1Dread(char * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 412
static __forceinline void surf1Dread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 414
static __forceinline void surf1Dread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 416
static __forceinline void surf1Dread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 418
static __forceinline void surf1Dread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 420
static __forceinline void surf1Dread(short * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 422
static __forceinline void surf1Dread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 424
static __forceinline void surf1Dread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 426
static __forceinline void surf1Dread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 428
static __forceinline void surf1Dread(int * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 430
static __forceinline void surf1Dread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 432
static __forceinline void surf1Dread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 434
static __forceinline void surf1Dread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 436
static __forceinline void surf1Dread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 438
static __forceinline void surf1Dread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 440
static __forceinline void surf1Dread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 442
static __forceinline void surf1Dread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 444
static __forceinline void surf1Dread(float * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 446
static __forceinline void surf1Dread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 454
static __forceinline void surf1Dread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 456
static __forceinline void surf1Dread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 458
static __forceinline void surf1Dread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 460
static __forceinline void surf1Dread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 462
static __forceinline void surf1Dread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 464
static __forceinline void surf1Dread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 466
static __forceinline void surf1Dread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 468
static __forceinline void surf1Dread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 470
static __forceinline void surf1Dread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 478
static __forceinline void surf1Dread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 480
static __forceinline void surf1Dread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 482
static __forceinline void surf1Dread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 484
static __forceinline void surf1Dread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 486
static __forceinline void surf1Dread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 488
static __forceinline void surf1Dread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 490
static __forceinline void surf1Dread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 498
template< class T> static __forceinline T 
#line 499
surf1Dread(::cudaSurfaceObject_t surfObject, int x, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 500
{int volatile ___ = 1;(void)surfObject;(void)x;(void)boundaryMode;
#line 504
::exit(___);}
#if 0
#line 500
{ 
#line 501
T ret; 
#line 502
surf1Dread(&ret, surfObject, x, boundaryMode); 
#line 503
return ret; 
#line 504
} 
#endif
#line 512 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surf2Dread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 514
static __forceinline void surf2Dread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 516
static __forceinline void surf2Dread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 518
static __forceinline void surf2Dread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 520
static __forceinline void surf2Dread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 522
static __forceinline void surf2Dread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 524
static __forceinline void surf2Dread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 526
static __forceinline void surf2Dread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 528
static __forceinline void surf2Dread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 530
static __forceinline void surf2Dread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 532
static __forceinline void surf2Dread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 534
static __forceinline void surf2Dread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 536
static __forceinline void surf2Dread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 538
static __forceinline void surf2Dread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 540
static __forceinline void surf2Dread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 542
static __forceinline void surf2Dread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 544
static __forceinline void surf2Dread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 546
static __forceinline void surf2Dread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 548
static __forceinline void surf2Dread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 556
static __forceinline void surf2Dread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 558
static __forceinline void surf2Dread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 560
static __forceinline void surf2Dread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 562
static __forceinline void surf2Dread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 564
static __forceinline void surf2Dread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 566
static __forceinline void surf2Dread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 568
static __forceinline void surf2Dread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 570
static __forceinline void surf2Dread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 572
static __forceinline void surf2Dread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 580
static __forceinline void surf2Dread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 582
static __forceinline void surf2Dread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 584
static __forceinline void surf2Dread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 586
static __forceinline void surf2Dread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 588
static __forceinline void surf2Dread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 590
static __forceinline void surf2Dread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 592
static __forceinline void surf2Dread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 600
template< class T> static __forceinline T 
#line 601
surf2Dread(::cudaSurfaceObject_t surfObject, int x, int y, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 602
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 606
::exit(___);}
#if 0
#line 602
{ 
#line 603
T ret; 
#line 604
surf2Dread(&ret, surfObject, x, y, boundaryMode); 
#line 605
return ret; 
#line 606
} 
#endif
#line 614 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surf3Dread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 616
static __forceinline void surf3Dread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 618
static __forceinline void surf3Dread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 620
static __forceinline void surf3Dread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 622
static __forceinline void surf3Dread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 624
static __forceinline void surf3Dread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 626
static __forceinline void surf3Dread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 628
static __forceinline void surf3Dread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 630
static __forceinline void surf3Dread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 632
static __forceinline void surf3Dread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 634
static __forceinline void surf3Dread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 636
static __forceinline void surf3Dread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 638
static __forceinline void surf3Dread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 640
static __forceinline void surf3Dread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 642
static __forceinline void surf3Dread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 644
static __forceinline void surf3Dread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 646
static __forceinline void surf3Dread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 648
static __forceinline void surf3Dread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 650
static __forceinline void surf3Dread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 658
static __forceinline void surf3Dread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 660
static __forceinline void surf3Dread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 662
static __forceinline void surf3Dread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 664
static __forceinline void surf3Dread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 666
static __forceinline void surf3Dread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 668
static __forceinline void surf3Dread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 670
static __forceinline void surf3Dread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 672
static __forceinline void surf3Dread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 674
static __forceinline void surf3Dread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 682
static __forceinline void surf3Dread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 684
static __forceinline void surf3Dread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 686
static __forceinline void surf3Dread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 688
static __forceinline void surf3Dread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 690
static __forceinline void surf3Dread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 692
static __forceinline void surf3Dread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 694
static __forceinline void surf3Dread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 702
template< class T> static __forceinline T 
#line 703
surf3Dread(::cudaSurfaceObject_t surfObject, int x, int y, int z, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 704
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 708
::exit(___);}
#if 0
#line 704
{ 
#line 705
T ret; 
#line 706
surf3Dread(&ret, surfObject, x, y, z, boundaryMode); 
#line 707
return ret; 
#line 708
} 
#endif
#line 716 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surf1DLayeredread(char * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 718
static __forceinline void surf1DLayeredread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 720
static __forceinline void surf1DLayeredread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 722
static __forceinline void surf1DLayeredread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 724
static __forceinline void surf1DLayeredread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 726
static __forceinline void surf1DLayeredread(short * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 728
static __forceinline void surf1DLayeredread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 730
static __forceinline void surf1DLayeredread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 732
static __forceinline void surf1DLayeredread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 734
static __forceinline void surf1DLayeredread(int * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 736
static __forceinline void surf1DLayeredread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 738
static __forceinline void surf1DLayeredread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 740
static __forceinline void surf1DLayeredread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 742
static __forceinline void surf1DLayeredread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 744
static __forceinline void surf1DLayeredread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 746
static __forceinline void surf1DLayeredread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 748
static __forceinline void surf1DLayeredread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 750
static __forceinline void surf1DLayeredread(float * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 752
static __forceinline void surf1DLayeredread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 760
static __forceinline void surf1DLayeredread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 762
static __forceinline void surf1DLayeredread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 764
static __forceinline void surf1DLayeredread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 766
static __forceinline void surf1DLayeredread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 768
static __forceinline void surf1DLayeredread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 770
static __forceinline void surf1DLayeredread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 772
static __forceinline void surf1DLayeredread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 774
static __forceinline void surf1DLayeredread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 776
static __forceinline void surf1DLayeredread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 784
static __forceinline void surf1DLayeredread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 786
static __forceinline void surf1DLayeredread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 788
static __forceinline void surf1DLayeredread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 790
static __forceinline void surf1DLayeredread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 792
static __forceinline void surf1DLayeredread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 794
static __forceinline void surf1DLayeredread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 796
static __forceinline void surf1DLayeredread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 804
template< class T> static __forceinline T 
#line 805
surf1DLayeredread(::cudaSurfaceObject_t surfObject, int x, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 806
{int volatile ___ = 1;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 810
::exit(___);}
#if 0
#line 806
{ 
#line 807
T ret; 
#line 808
surf1DLayeredread(&ret, surfObject, x, layer, boundaryMode); 
#line 809
return ret; 
#line 810
} 
#endif
#line 818 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surf2DLayeredread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 820
static __forceinline void surf2DLayeredread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 822
static __forceinline void surf2DLayeredread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 824
static __forceinline void surf2DLayeredread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 826
static __forceinline void surf2DLayeredread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 828
static __forceinline void surf2DLayeredread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 830
static __forceinline void surf2DLayeredread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 832
static __forceinline void surf2DLayeredread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 834
static __forceinline void surf2DLayeredread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 836
static __forceinline void surf2DLayeredread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 838
static __forceinline void surf2DLayeredread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 840
static __forceinline void surf2DLayeredread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 842
static __forceinline void surf2DLayeredread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 844
static __forceinline void surf2DLayeredread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 846
static __forceinline void surf2DLayeredread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 848
static __forceinline void surf2DLayeredread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 850
static __forceinline void surf2DLayeredread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 852
static __forceinline void surf2DLayeredread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 854
static __forceinline void surf2DLayeredread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 862
static __forceinline void surf2DLayeredread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 864
static __forceinline void surf2DLayeredread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 866
static __forceinline void surf2DLayeredread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 868
static __forceinline void surf2DLayeredread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 870
static __forceinline void surf2DLayeredread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 872
static __forceinline void surf2DLayeredread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 874
static __forceinline void surf2DLayeredread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 876
static __forceinline void surf2DLayeredread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 878
static __forceinline void surf2DLayeredread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 886
static __forceinline void surf2DLayeredread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 888
static __forceinline void surf2DLayeredread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 890
static __forceinline void surf2DLayeredread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 892
static __forceinline void surf2DLayeredread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 894
static __forceinline void surf2DLayeredread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 896
static __forceinline void surf2DLayeredread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 898
static __forceinline void surf2DLayeredread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 906
template< class T> static __forceinline T 
#line 907
surf2DLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layer, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 908
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 912
::exit(___);}
#if 0
#line 908
{ 
#line 909
T ret; 
#line 910
surf2DLayeredread(&ret, surfObject, x, y, layer, boundaryMode); 
#line 911
return ret; 
#line 912
} 
#endif
#line 920 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 922
static __forceinline void surfCubemapread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 924
static __forceinline void surfCubemapread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 926
static __forceinline void surfCubemapread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 928
static __forceinline void surfCubemapread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 930
static __forceinline void surfCubemapread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 932
static __forceinline void surfCubemapread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 934
static __forceinline void surfCubemapread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 936
static __forceinline void surfCubemapread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 938
static __forceinline void surfCubemapread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 940
static __forceinline void surfCubemapread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 942
static __forceinline void surfCubemapread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 944
static __forceinline void surfCubemapread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 946
static __forceinline void surfCubemapread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 948
static __forceinline void surfCubemapread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 950
static __forceinline void surfCubemapread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 952
static __forceinline void surfCubemapread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 954
static __forceinline void surfCubemapread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 956
static __forceinline void surfCubemapread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 964
static __forceinline void surfCubemapread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 966
static __forceinline void surfCubemapread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 968
static __forceinline void surfCubemapread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 970
static __forceinline void surfCubemapread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 972
static __forceinline void surfCubemapread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 974
static __forceinline void surfCubemapread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 976
static __forceinline void surfCubemapread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 978
static __forceinline void surfCubemapread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 980
static __forceinline void surfCubemapread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 988
static __forceinline void surfCubemapread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 990
static __forceinline void surfCubemapread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 992
static __forceinline void surfCubemapread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 994
static __forceinline void surfCubemapread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 996
static __forceinline void surfCubemapread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 998
static __forceinline void surfCubemapread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1000
static __forceinline void surfCubemapread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1008
template< class T> static __forceinline T 
#line 1009
surfCubemapread(::cudaSurfaceObject_t surfObject, int x, int y, int face, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1010
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 1014
::exit(___);}
#if 0
#line 1010
{ 
#line 1011
T ret; 
#line 1012
surfCubemapread(&ret, surfObject, face, x, y, boundaryMode); 
#line 1013
return ret; 
#line 1014
} 
#endif
#line 1022 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surfCubemapLayeredread(char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1024
static __forceinline void surfCubemapLayeredread(signed char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1026
static __forceinline void surfCubemapLayeredread(char1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1028
static __forceinline void surfCubemapLayeredread(unsigned char * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1030
static __forceinline void surfCubemapLayeredread(uchar1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1032
static __forceinline void surfCubemapLayeredread(short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1034
static __forceinline void surfCubemapLayeredread(short1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1036
static __forceinline void surfCubemapLayeredread(unsigned short * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1038
static __forceinline void surfCubemapLayeredread(ushort1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1040
static __forceinline void surfCubemapLayeredread(int * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1042
static __forceinline void surfCubemapLayeredread(int1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1044
static __forceinline void surfCubemapLayeredread(unsigned * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1046
static __forceinline void surfCubemapLayeredread(uint1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1048
static __forceinline void surfCubemapLayeredread(__int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1050
static __forceinline void surfCubemapLayeredread(longlong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1052
static __forceinline void surfCubemapLayeredread(unsigned __int64 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1054
static __forceinline void surfCubemapLayeredread(ulonglong1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1056
static __forceinline void surfCubemapLayeredread(float * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1058
static __forceinline void surfCubemapLayeredread(float1 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1066
static __forceinline void surfCubemapLayeredread(char2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1068
static __forceinline void surfCubemapLayeredread(uchar2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1070
static __forceinline void surfCubemapLayeredread(short2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1072
static __forceinline void surfCubemapLayeredread(ushort2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1074
static __forceinline void surfCubemapLayeredread(int2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1076
static __forceinline void surfCubemapLayeredread(uint2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1078
static __forceinline void surfCubemapLayeredread(longlong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1080
static __forceinline void surfCubemapLayeredread(ulonglong2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1082
static __forceinline void surfCubemapLayeredread(float2 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1090
static __forceinline void surfCubemapLayeredread(char4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1092
static __forceinline void surfCubemapLayeredread(uchar4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1094
static __forceinline void surfCubemapLayeredread(short4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1096
static __forceinline void surfCubemapLayeredread(ushort4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1098
static __forceinline void surfCubemapLayeredread(int4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1100
static __forceinline void surfCubemapLayeredread(uint4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1102
static __forceinline void surfCubemapLayeredread(float4 * retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1110
template< class T> static __forceinline T 
#line 1111
surfCubemapLayeredread(::cudaSurfaceObject_t surfObject, int x, int y, int layerface, ::cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap) 
#line 1112
{int volatile ___ = 1;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 1116
::exit(___);}
#if 0
#line 1112
{ 
#line 1113
T ret; 
#line 1114
surfCubemapLayeredread(&ret, surfObject, x, y, layerface, boundaryMode); 
#line 1115
return ret; 
#line 1116
} 
#endif
#line 1124 "e:\\cudatoolkit\\include\\surface_indirect_functions.h"
static __forceinline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1126
static __forceinline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1128
static __forceinline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1130
static __forceinline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1132
static __forceinline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1134
static __forceinline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1136
static __forceinline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1138
static __forceinline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1140
static __forceinline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1142
static __forceinline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1144
static __forceinline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1146
static __forceinline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1148
static __forceinline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1150
static __forceinline void surf1Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1152
static __forceinline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1154
static __forceinline void surf1Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1156
static __forceinline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1158
static __forceinline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1160
static __forceinline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1168
static __forceinline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1170
static __forceinline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1172
static __forceinline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1174
static __forceinline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1176
static __forceinline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1178
static __forceinline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1180
static __forceinline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1182
static __forceinline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1184
static __forceinline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1192
static __forceinline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1194
static __forceinline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1196
static __forceinline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1198
static __forceinline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1200
static __forceinline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1202
static __forceinline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1204
static __forceinline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1212
static __forceinline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1214
static __forceinline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1216
static __forceinline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1218
static __forceinline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1220
static __forceinline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1222
static __forceinline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1224
static __forceinline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1226
static __forceinline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1228
static __forceinline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1230
static __forceinline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1232
static __forceinline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1234
static __forceinline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1236
static __forceinline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1238
static __forceinline void surf2Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1240
static __forceinline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1242
static __forceinline void surf2Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1244
static __forceinline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1246
static __forceinline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1248
static __forceinline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1256
static __forceinline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1258
static __forceinline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1260
static __forceinline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1262
static __forceinline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1264
static __forceinline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1266
static __forceinline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1268
static __forceinline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1270
static __forceinline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1272
static __forceinline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1280
static __forceinline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1282
static __forceinline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1284
static __forceinline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1286
static __forceinline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1288
static __forceinline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1290
static __forceinline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1292
static __forceinline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1301
static __forceinline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1303
static __forceinline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1305
static __forceinline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1307
static __forceinline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1309
static __forceinline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1311
static __forceinline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1313
static __forceinline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1315
static __forceinline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1317
static __forceinline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1319
static __forceinline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1321
static __forceinline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1323
static __forceinline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1325
static __forceinline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1327
static __forceinline void surf3Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1329
static __forceinline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1331
static __forceinline void surf3Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1333
static __forceinline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1335
static __forceinline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1337
static __forceinline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1345
static __forceinline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1347
static __forceinline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1349
static __forceinline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1351
static __forceinline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1353
static __forceinline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1355
static __forceinline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1357
static __forceinline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1359
static __forceinline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1361
static __forceinline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1369
static __forceinline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1371
static __forceinline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1373
static __forceinline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1375
static __forceinline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1377
static __forceinline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1379
static __forceinline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1381
static __forceinline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1389
static __forceinline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1391
static __forceinline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1393
static __forceinline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1395
static __forceinline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1397
static __forceinline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1399
static __forceinline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1401
static __forceinline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1403
static __forceinline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1405
static __forceinline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1407
static __forceinline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1409
static __forceinline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1411
static __forceinline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1413
static __forceinline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1415
static __forceinline void surf1DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1417
static __forceinline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1419
static __forceinline void surf1DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1421
static __forceinline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1423
static __forceinline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1425
static __forceinline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1433
static __forceinline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1435
static __forceinline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1437
static __forceinline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1439
static __forceinline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1441
static __forceinline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1443
static __forceinline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1445
static __forceinline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1447
static __forceinline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1449
static __forceinline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1457
static __forceinline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1459
static __forceinline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1461
static __forceinline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1463
static __forceinline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1465
static __forceinline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1467
static __forceinline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1469
static __forceinline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1477
static __forceinline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1479
static __forceinline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1481
static __forceinline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1483
static __forceinline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1485
static __forceinline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1487
static __forceinline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1489
static __forceinline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1491
static __forceinline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1493
static __forceinline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1495
static __forceinline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1497
static __forceinline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1499
static __forceinline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1501
static __forceinline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1503
static __forceinline void surf2DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1505
static __forceinline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1507
static __forceinline void surf2DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1509
static __forceinline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1511
static __forceinline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1513
static __forceinline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1521
static __forceinline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1523
static __forceinline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1525
static __forceinline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1527
static __forceinline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1529
static __forceinline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1531
static __forceinline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1533
static __forceinline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1535
static __forceinline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1537
static __forceinline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1545
static __forceinline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1547
static __forceinline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1549
static __forceinline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1551
static __forceinline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1553
static __forceinline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1555
static __forceinline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1557
static __forceinline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1565
static __forceinline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1567
static __forceinline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1569
static __forceinline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1571
static __forceinline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1573
static __forceinline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1575
static __forceinline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1577
static __forceinline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1579
static __forceinline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1581
static __forceinline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1583
static __forceinline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1585
static __forceinline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1587
static __forceinline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1589
static __forceinline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1591
static __forceinline void surfCubemapwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1593
static __forceinline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1595
static __forceinline void surfCubemapwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1597
static __forceinline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1599
static __forceinline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1601
static __forceinline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1609
static __forceinline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1611
static __forceinline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1613
static __forceinline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1615
static __forceinline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1617
static __forceinline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1619
static __forceinline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1621
static __forceinline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1623
static __forceinline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1625
static __forceinline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1633
static __forceinline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1635
static __forceinline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1637
static __forceinline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1639
static __forceinline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1641
static __forceinline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1643
static __forceinline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1645
static __forceinline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1653
static __forceinline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1655
static __forceinline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1657
static __forceinline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1659
static __forceinline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1661
static __forceinline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1663
static __forceinline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1665
static __forceinline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1667
static __forceinline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1669
static __forceinline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1671
static __forceinline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1673
static __forceinline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1675
static __forceinline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1677
static __forceinline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1679
static __forceinline void surfCubemapLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1681
static __forceinline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1683
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1685
static __forceinline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1687
static __forceinline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1689
static __forceinline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1697
static __forceinline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1699
static __forceinline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1701
static __forceinline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1703
static __forceinline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1705
static __forceinline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1707
static __forceinline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1709
static __forceinline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1711
static __forceinline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1713
static __forceinline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1721
static __forceinline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1723
static __forceinline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1725
static __forceinline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1727
static __forceinline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1729
static __forceinline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1731
static __forceinline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 1733
static __forceinline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode = cudaBoundaryModeTrap); 
#line 76 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 77
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 89
::exit(___);}
#if 0
#line 77
{ 
#line 78
char tmp; 
#line 79
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 80
__suld_1d_i8_trap(&tmp, surfObject, x); 
#line 81
} else { 
#line 82
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 83
__suld_1d_i8_clamp(&tmp, surfObject, x); 
#line 84
} else { 
#line 85
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 86
__suld_1d_i8_zero(&tmp, surfObject, x); 
#line 87
}  }  }  
#line 88
(*retVal) = tmp; 
#line 89
} 
#endif
#line 91 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 92
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 104
::exit(___);}
#if 0
#line 92
{ 
#line 93
signed char tmp; 
#line 94
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 95
__suld_1d_i8_trap((char *)(&tmp), surfObject, x); 
#line 96
} else { 
#line 97
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 98
__suld_1d_i8_clamp((char *)(&tmp), surfObject, x); 
#line 99
} else { 
#line 100
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 101
__suld_1d_i8_zero((char *)(&tmp), surfObject, x); 
#line 102
}  }  }  
#line 103
(*retVal) = tmp; 
#line 104
} 
#endif
#line 106 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 107
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 119
::exit(___);}
#if 0
#line 107
{ 
#line 108
char1 tmp; 
#line 109
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 110
__suld_1d_i8_trap((char *)(&(tmp.x)), surfObject, x); 
#line 111
} else { 
#line 112
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 113
__suld_1d_i8_clamp((char *)(&(tmp.x)), surfObject, x); 
#line 114
} else { 
#line 115
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 116
__suld_1d_i8_zero((char *)(&(tmp.x)), surfObject, x); 
#line 117
}  }  }  
#line 118
(*retVal) = make_char1(tmp.x); 
#line 119
} 
#endif
#line 121 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 122
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 134
::exit(___);}
#if 0
#line 122
{ 
#line 123
unsigned char tmp; 
#line 124
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 125
__suld_1d_i8_trap((char *)(&tmp), surfObject, x); 
#line 126
} else { 
#line 127
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 128
__suld_1d_i8_clamp((char *)(&tmp), surfObject, x); 
#line 129
} else { 
#line 130
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 131
__suld_1d_i8_zero((char *)(&tmp), surfObject, x); 
#line 132
}  }  }  
#line 133
(*retVal) = tmp; 
#line 134
} 
#endif
#line 136 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 137
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 149
::exit(___);}
#if 0
#line 137
{ 
#line 138
uchar1 tmp; 
#line 139
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 140
__suld_1d_i8_trap((char *)(&(tmp.x)), surfObject, x); 
#line 141
} else { 
#line 142
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 143
__suld_1d_i8_clamp((char *)(&(tmp.x)), surfObject, x); 
#line 144
} else { 
#line 145
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 146
__suld_1d_i8_zero((char *)(&(tmp.x)), surfObject, x); 
#line 147
}  }  }  
#line 148
(*retVal) = make_uchar1(tmp.x); 
#line 149
} 
#endif
#line 151 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 152
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 164
::exit(___);}
#if 0
#line 152
{ 
#line 153
short tmp; 
#line 154
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 155
__suld_1d_i16_trap(&tmp, surfObject, x); 
#line 156
} else { 
#line 157
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 158
__suld_1d_i16_clamp(&tmp, surfObject, x); 
#line 159
} else { 
#line 160
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 161
__suld_1d_i16_zero(&tmp, surfObject, x); 
#line 162
}  }  }  
#line 163
(*retVal) = tmp; 
#line 164
} 
#endif
#line 166 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 167
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 179
::exit(___);}
#if 0
#line 167
{ 
#line 168
short tmp; 
#line 169
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 170
__suld_1d_i16_trap(&tmp, surfObject, x); 
#line 171
} else { 
#line 172
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 173
__suld_1d_i16_clamp(&tmp, surfObject, x); 
#line 174
} else { 
#line 175
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 176
__suld_1d_i16_zero(&tmp, surfObject, x); 
#line 177
}  }  }  
#line 178
(*retVal) = make_short1(tmp); 
#line 179
} 
#endif
#line 181 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 182
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 194
::exit(___);}
#if 0
#line 182
{ 
#line 183
unsigned short tmp; 
#line 184
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 185
__suld_1d_i16_trap((short *)(&tmp), surfObject, x); 
#line 186
} else { 
#line 187
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 188
__suld_1d_i16_clamp((short *)(&tmp), surfObject, x); 
#line 189
} else { 
#line 190
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 191
__suld_1d_i16_zero((short *)(&tmp), surfObject, x); 
#line 192
}  }  }  
#line 193
(*retVal) = tmp; 
#line 194
} 
#endif
#line 196 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 197
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 209
::exit(___);}
#if 0
#line 197
{ 
#line 198
unsigned short tmp; 
#line 199
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 200
__suld_1d_i16_trap((short *)(&tmp), surfObject, x); 
#line 201
} else { 
#line 202
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 203
__suld_1d_i16_clamp((short *)(&tmp), surfObject, x); 
#line 204
} else { 
#line 205
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 206
__suld_1d_i16_zero((short *)(&tmp), surfObject, x); 
#line 207
}  }  }  
#line 208
(*retVal) = make_ushort1(tmp); 
#line 209
} 
#endif
#line 211 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 212
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 224
::exit(___);}
#if 0
#line 212
{ 
#line 213
int tmp; 
#line 214
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 215
__suld_1d_i32_trap(&tmp, surfObject, x); 
#line 216
} else { 
#line 217
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 218
__suld_1d_i32_clamp(&tmp, surfObject, x); 
#line 219
} else { 
#line 220
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 221
__suld_1d_i32_zero(&tmp, surfObject, x); 
#line 222
}  }  }  
#line 223
(*retVal) = tmp; 
#line 224
} 
#endif
#line 226 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 227
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 239
::exit(___);}
#if 0
#line 227
{ 
#line 228
int tmp; 
#line 229
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 230
__suld_1d_i32_trap(&tmp, surfObject, x); 
#line 231
} else { 
#line 232
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 233
__suld_1d_i32_clamp(&tmp, surfObject, x); 
#line 234
} else { 
#line 235
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 236
__suld_1d_i32_zero(&tmp, surfObject, x); 
#line 237
}  }  }  
#line 238
(*retVal) = make_int1(tmp); 
#line 239
} 
#endif
#line 241 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 242
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 254
::exit(___);}
#if 0
#line 242
{ 
#line 243
unsigned tmp; 
#line 244
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 245
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
#line 246
} else { 
#line 247
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 248
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
#line 249
} else { 
#line 250
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 251
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
#line 252
}  }  }  
#line 253
(*retVal) = tmp; 
#line 254
} 
#endif
#line 256 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 257
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 269
::exit(___);}
#if 0
#line 257
{ 
#line 258
unsigned tmp; 
#line 259
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 260
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
#line 261
} else { 
#line 262
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 263
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
#line 264
} else { 
#line 265
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 266
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
#line 267
}  }  }  
#line 268
(*retVal) = make_uint1(tmp); 
#line 269
} 
#endif
#line 271 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 272
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 284
::exit(___);}
#if 0
#line 272
{ 
#line 273
__int64 tmp; 
#line 274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 275
__suld_1d_i64_trap(&tmp, surfObject, x); 
#line 276
} else { 
#line 277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 278
__suld_1d_i64_clamp(&tmp, surfObject, x); 
#line 279
} else { 
#line 280
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 281
__suld_1d_i64_zero(&tmp, surfObject, x); 
#line 282
}  }  }  
#line 283
(*retVal) = tmp; 
#line 284
} 
#endif
#line 286 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 287
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 299
::exit(___);}
#if 0
#line 287
{ 
#line 288
__int64 tmp; 
#line 289
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 290
__suld_1d_i64_trap(&tmp, surfObject, x); 
#line 291
} else { 
#line 292
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 293
__suld_1d_i64_clamp(&tmp, surfObject, x); 
#line 294
} else { 
#line 295
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 296
__suld_1d_i64_zero(&tmp, surfObject, x); 
#line 297
}  }  }  
#line 298
(*retVal) = make_longlong1(tmp); 
#line 299
} 
#endif
#line 301 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 302
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 314
::exit(___);}
#if 0
#line 302
{ 
#line 303
unsigned __int64 tmp; 
#line 304
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 305
__suld_1d_i64_trap((__int64 *)(&tmp), surfObject, x); 
#line 306
} else { 
#line 307
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 308
__suld_1d_i64_clamp((__int64 *)(&tmp), surfObject, x); 
#line 309
} else { 
#line 310
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 311
__suld_1d_i64_zero((__int64 *)(&tmp), surfObject, x); 
#line 312
}  }  }  
#line 313
(*retVal) = tmp; 
#line 314
} 
#endif
#line 316 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 317
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 329
::exit(___);}
#if 0
#line 317
{ 
#line 318
unsigned __int64 tmp; 
#line 319
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 320
__suld_1d_i64_trap((__int64 *)(&tmp), surfObject, x); 
#line 321
} else { 
#line 322
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 323
__suld_1d_i64_clamp((__int64 *)(&tmp), surfObject, x); 
#line 324
} else { 
#line 325
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 326
__suld_1d_i64_zero((__int64 *)(&tmp), surfObject, x); 
#line 327
}  }  }  
#line 328
(*retVal) = make_ulonglong1(tmp); 
#line 329
} 
#endif
#line 331 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 332
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 344
::exit(___);}
#if 0
#line 332
{ 
#line 333
float tmp; 
#line 334
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 335
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
#line 336
} else { 
#line 337
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 338
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
#line 339
} else { 
#line 340
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 341
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
#line 342
}  }  }  
#line 343
(*retVal) = tmp; 
#line 344
} 
#endif
#line 346 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 347
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 359
::exit(___);}
#if 0
#line 347
{ 
#line 348
float tmp; 
#line 349
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 350
__suld_1d_i32_trap((int *)(&tmp), surfObject, x); 
#line 351
} else { 
#line 352
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 353
__suld_1d_i32_clamp((int *)(&tmp), surfObject, x); 
#line 354
} else { 
#line 355
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 356
__suld_1d_i32_zero((int *)(&tmp), surfObject, x); 
#line 357
}  }  }  
#line 358
(*retVal) = make_float1(tmp); 
#line 359
} 
#endif
#line 367 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 368
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 380
::exit(___);}
#if 0
#line 368
{ 
#line 369
char2 tmp; 
#line 370
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 371
__suld_1d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
#line 372
} else { 
#line 373
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 374
__suld_1d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
#line 375
} else { 
#line 376
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 377
__suld_1d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
#line 378
}  }  }  
#line 379
(*retVal) = tmp; 
#line 380
} 
#endif
#line 382 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 383
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 395
::exit(___);}
#if 0
#line 383
{ 
#line 384
uchar2 tmp; 
#line 385
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 386
__suld_1d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
#line 387
} else { 
#line 388
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 389
__suld_1d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
#line 390
} else { 
#line 391
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 392
__suld_1d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x); 
#line 393
}  }  }  
#line 394
(*retVal) = tmp; 
#line 395
} 
#endif
#line 397 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 398
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 410
::exit(___);}
#if 0
#line 398
{ 
#line 399
short2 tmp; 
#line 400
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 401
__suld_1d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
#line 402
} else { 
#line 403
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 404
__suld_1d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
#line 405
} else { 
#line 406
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 407
__suld_1d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
#line 408
}  }  }  
#line 409
(*retVal) = tmp; 
#line 410
} 
#endif
#line 412 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 413
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 425
::exit(___);}
#if 0
#line 413
{ 
#line 414
ushort2 tmp; 
#line 415
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 416
__suld_1d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
#line 417
} else { 
#line 418
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 419
__suld_1d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
#line 420
} else { 
#line 421
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 422
__suld_1d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x); 
#line 423
}  }  }  
#line 424
(*retVal) = tmp; 
#line 425
} 
#endif
#line 427 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 428
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 440
::exit(___);}
#if 0
#line 428
{ 
#line 429
int2 tmp; 
#line 430
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 431
__suld_1d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 432
} else { 
#line 433
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 434
__suld_1d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 435
} else { 
#line 436
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 437
__suld_1d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 438
}  }  }  
#line 439
(*retVal) = tmp; 
#line 440
} 
#endif
#line 442 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 443
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 455
::exit(___);}
#if 0
#line 443
{ 
#line 444
uint2 tmp; 
#line 445
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 446
__suld_1d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 447
} else { 
#line 448
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 449
__suld_1d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 450
} else { 
#line 451
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 452
__suld_1d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 453
}  }  }  
#line 454
(*retVal) = tmp; 
#line 455
} 
#endif
#line 457 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 458
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 470
::exit(___);}
#if 0
#line 458
{ 
#line 459
longlong2 tmp; 
#line 460
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 461
__suld_1d_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x); 
#line 462
} else { 
#line 463
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 464
__suld_1d_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x); 
#line 465
} else { 
#line 466
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 467
__suld_1d_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x); 
#line 468
}  }  }  
#line 469
(*retVal) = tmp; 
#line 470
} 
#endif
#line 472 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 473
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 485
::exit(___);}
#if 0
#line 473
{ 
#line 474
ulonglong2 tmp; 
#line 475
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 476
__suld_1d_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x); 
#line 477
} else { 
#line 478
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 479
__suld_1d_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x); 
#line 480
} else { 
#line 481
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 482
__suld_1d_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x); 
#line 483
}  }  }  
#line 484
(*retVal) = tmp; 
#line 485
} 
#endif
#line 487 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 488
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 500
::exit(___);}
#if 0
#line 488
{ 
#line 489
float2 tmp; 
#line 490
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 491
__suld_1d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 492
} else { 
#line 493
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 494
__suld_1d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 495
} else { 
#line 496
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 497
__suld_1d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x); 
#line 498
}  }  }  
#line 499
(*retVal) = tmp; 
#line 500
} 
#endif
#line 508 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 509
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 521
::exit(___);}
#if 0
#line 509
{ 
#line 510
char4 tmp; 
#line 511
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 512
__suld_1d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
#line 513
} else { 
#line 514
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 515
__suld_1d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
#line 516
} else { 
#line 517
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 518
__suld_1d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
#line 519
}  }  }  
#line 520
(*retVal) = tmp; 
#line 521
} 
#endif
#line 523 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 524
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 536
::exit(___);}
#if 0
#line 524
{ 
#line 525
uchar4 tmp; 
#line 526
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 527
__suld_1d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
#line 528
} else { 
#line 529
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 530
__suld_1d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
#line 531
} else { 
#line 532
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 533
__suld_1d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x); 
#line 534
}  }  }  
#line 535
(*retVal) = tmp; 
#line 536
} 
#endif
#line 538 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 539
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 551
::exit(___);}
#if 0
#line 539
{ 
#line 540
short4 tmp; 
#line 541
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 542
__suld_1d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
#line 543
} else { 
#line 544
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 545
__suld_1d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
#line 546
} else { 
#line 547
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 548
__suld_1d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
#line 549
}  }  }  
#line 550
(*retVal) = tmp; 
#line 551
} 
#endif
#line 553 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 554
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 566
::exit(___);}
#if 0
#line 554
{ 
#line 555
ushort4 tmp; 
#line 556
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 557
__suld_1d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
#line 558
} else { 
#line 559
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 560
__suld_1d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
#line 561
} else { 
#line 562
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 563
__suld_1d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x); 
#line 564
}  }  }  
#line 565
(*retVal) = tmp; 
#line 566
} 
#endif
#line 568 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 569
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 581
::exit(___);}
#if 0
#line 569
{ 
#line 570
int4 tmp; 
#line 571
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 572
__suld_1d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 573
} else { 
#line 574
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 575
__suld_1d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 576
} else { 
#line 577
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 578
__suld_1d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 579
}  }  }  
#line 580
(*retVal) = tmp; 
#line 581
} 
#endif
#line 583 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 584
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 596
::exit(___);}
#if 0
#line 584
{ 
#line 585
uint4 tmp; 
#line 586
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 587
__suld_1d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 588
} else { 
#line 589
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 590
__suld_1d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 591
} else { 
#line 592
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 593
__suld_1d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 594
}  }  }  
#line 595
(*retVal) = tmp; 
#line 596
} 
#endif
#line 598 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 599
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)boundaryMode;
#line 611
::exit(___);}
#if 0
#line 599
{ 
#line 600
float4 tmp; 
#line 601
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 602
__suld_1d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 603
} else { 
#line 604
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 605
__suld_1d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 606
} else { 
#line 607
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 608
__suld_1d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x); 
#line 609
}  }  }  
#line 610
(*retVal) = tmp; 
#line 611
} 
#endif
#line 619 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 620
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 632
::exit(___);}
#if 0
#line 620
{ 
#line 621
char tmp; 
#line 622
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 623
__suld_2d_i8_trap(&tmp, surfObject, x, y); 
#line 624
} else { 
#line 625
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 626
__suld_2d_i8_clamp(&tmp, surfObject, x, y); 
#line 627
} else { 
#line 628
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 629
__suld_2d_i8_zero(&tmp, surfObject, x, y); 
#line 630
}  }  }  
#line 631
(*retVal) = tmp; 
#line 632
} 
#endif
#line 634 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 635
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 647
::exit(___);}
#if 0
#line 635
{ 
#line 636
signed char tmp; 
#line 637
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 638
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
#line 639
} else { 
#line 640
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 641
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
#line 642
} else { 
#line 643
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 644
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
#line 645
}  }  }  
#line 646
(*retVal) = tmp; 
#line 647
} 
#endif
#line 649 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 650
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 662
::exit(___);}
#if 0
#line 650
{ 
#line 651
char tmp; 
#line 652
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 653
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
#line 654
} else { 
#line 655
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 656
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
#line 657
} else { 
#line 658
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 659
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
#line 660
}  }  }  
#line 661
(*retVal) = make_char1(tmp); 
#line 662
} 
#endif
#line 664 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 665
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 677
::exit(___);}
#if 0
#line 665
{ 
#line 666
unsigned char tmp; 
#line 667
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 668
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
#line 669
} else { 
#line 670
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 671
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
#line 672
} else { 
#line 673
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 674
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
#line 675
}  }  }  
#line 676
(*retVal) = tmp; 
#line 677
} 
#endif
#line 679 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 680
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 692
::exit(___);}
#if 0
#line 680
{ 
#line 681
unsigned char tmp; 
#line 682
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 683
__suld_2d_i8_trap((char *)(&tmp), surfObject, x, y); 
#line 684
} else { 
#line 685
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 686
__suld_2d_i8_clamp((char *)(&tmp), surfObject, x, y); 
#line 687
} else { 
#line 688
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 689
__suld_2d_i8_zero((char *)(&tmp), surfObject, x, y); 
#line 690
}  }  }  
#line 691
(*retVal) = make_uchar1(tmp); 
#line 692
} 
#endif
#line 694 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 695
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 707
::exit(___);}
#if 0
#line 695
{ 
#line 696
short tmp; 
#line 697
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 698
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
#line 699
} else { 
#line 700
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 701
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
#line 702
} else { 
#line 703
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 704
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
#line 705
}  }  }  
#line 706
(*retVal) = tmp; 
#line 707
} 
#endif
#line 709 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 710
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 722
::exit(___);}
#if 0
#line 710
{ 
#line 711
short tmp; 
#line 712
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 713
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
#line 714
} else { 
#line 715
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 716
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
#line 717
} else { 
#line 718
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 719
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
#line 720
}  }  }  
#line 721
(*retVal) = make_short1(tmp); 
#line 722
} 
#endif
#line 724 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 725
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 737
::exit(___);}
#if 0
#line 725
{ 
#line 726
unsigned short tmp; 
#line 727
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 728
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
#line 729
} else { 
#line 730
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 731
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
#line 732
} else { 
#line 733
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 734
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
#line 735
}  }  }  
#line 736
(*retVal) = tmp; 
#line 737
} 
#endif
#line 739 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 740
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 752
::exit(___);}
#if 0
#line 740
{ 
#line 741
unsigned short tmp; 
#line 742
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 743
__suld_2d_i16_trap((short *)(&tmp), surfObject, x, y); 
#line 744
} else { 
#line 745
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 746
__suld_2d_i16_clamp((short *)(&tmp), surfObject, x, y); 
#line 747
} else { 
#line 748
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 749
__suld_2d_i16_zero((short *)(&tmp), surfObject, x, y); 
#line 750
}  }  }  
#line 751
(*retVal) = make_ushort1(tmp); 
#line 752
} 
#endif
#line 754 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 755
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 767
::exit(___);}
#if 0
#line 755
{ 
#line 756
int tmp; 
#line 757
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 758
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
#line 759
} else { 
#line 760
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 761
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
#line 762
} else { 
#line 763
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 764
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
#line 765
}  }  }  
#line 766
(*retVal) = tmp; 
#line 767
} 
#endif
#line 769 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 770
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 782
::exit(___);}
#if 0
#line 770
{ 
#line 771
int tmp; 
#line 772
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 773
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
#line 774
} else { 
#line 775
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 776
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
#line 777
} else { 
#line 778
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 779
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
#line 780
}  }  }  
#line 781
(*retVal) = make_int1(tmp); 
#line 782
} 
#endif
#line 784 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 785
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 797
::exit(___);}
#if 0
#line 785
{ 
#line 786
unsigned tmp; 
#line 787
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 788
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
#line 789
} else { 
#line 790
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 791
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
#line 792
} else { 
#line 793
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 794
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
#line 795
}  }  }  
#line 796
(*retVal) = tmp; 
#line 797
} 
#endif
#line 799 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 800
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 812
::exit(___);}
#if 0
#line 800
{ 
#line 801
unsigned tmp; 
#line 802
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 803
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
#line 804
} else { 
#line 805
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 806
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
#line 807
} else { 
#line 808
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 809
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
#line 810
}  }  }  
#line 811
(*retVal) = make_uint1(tmp); 
#line 812
} 
#endif
#line 814 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 815
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 827
::exit(___);}
#if 0
#line 815
{ 
#line 816
__int64 tmp; 
#line 817
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 818
__suld_2d_i64_trap((__int64 *)(&tmp), surfObject, x, y); 
#line 819
} else { 
#line 820
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 821
__suld_2d_i64_clamp((__int64 *)(&tmp), surfObject, x, y); 
#line 822
} else { 
#line 823
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 824
__suld_2d_i64_zero((__int64 *)(&tmp), surfObject, x, y); 
#line 825
}  }  }  
#line 826
(*retVal) = tmp; 
#line 827
} 
#endif
#line 829 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 830
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 842
::exit(___);}
#if 0
#line 830
{ 
#line 831
__int64 tmp; 
#line 832
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 833
__suld_2d_i64_trap((__int64 *)(&tmp), surfObject, x, y); 
#line 834
} else { 
#line 835
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 836
__suld_2d_i64_clamp((__int64 *)(&tmp), surfObject, x, y); 
#line 837
} else { 
#line 838
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 839
__suld_2d_i64_zero((__int64 *)(&tmp), surfObject, x, y); 
#line 840
}  }  }  
#line 841
(*retVal) = make_longlong1(tmp); 
#line 842
} 
#endif
#line 844 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 845
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 857
::exit(___);}
#if 0
#line 845
{ 
#line 846
unsigned __int64 tmp; 
#line 847
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 848
__suld_2d_i64_trap((__int64 *)(&tmp), surfObject, x, y); 
#line 849
} else { 
#line 850
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 851
__suld_2d_i64_clamp((__int64 *)(&tmp), surfObject, x, y); 
#line 852
} else { 
#line 853
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 854
__suld_2d_i64_zero((__int64 *)(&tmp), surfObject, x, y); 
#line 855
}  }  }  
#line 856
(*retVal) = tmp; 
#line 857
} 
#endif
#line 859 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 860
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 872
::exit(___);}
#if 0
#line 860
{ 
#line 861
unsigned __int64 tmp; 
#line 862
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 863
__suld_2d_i64_trap((__int64 *)(&tmp), surfObject, x, y); 
#line 864
} else { 
#line 865
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 866
__suld_2d_i64_clamp((__int64 *)(&tmp), surfObject, x, y); 
#line 867
} else { 
#line 868
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 869
__suld_2d_i64_zero((__int64 *)(&tmp), surfObject, x, y); 
#line 870
}  }  }  
#line 871
(*retVal) = make_ulonglong1(tmp); 
#line 872
} 
#endif
#line 874 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 875
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 887
::exit(___);}
#if 0
#line 875
{ 
#line 876
float tmp; 
#line 877
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 878
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
#line 879
} else { 
#line 880
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 881
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
#line 882
} else { 
#line 883
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 884
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
#line 885
}  }  }  
#line 886
(*retVal) = tmp; 
#line 887
} 
#endif
#line 889 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 890
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 902
::exit(___);}
#if 0
#line 890
{ 
#line 891
float tmp; 
#line 892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 893
__suld_2d_i32_trap((int *)(&tmp), surfObject, x, y); 
#line 894
} else { 
#line 895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 896
__suld_2d_i32_clamp((int *)(&tmp), surfObject, x, y); 
#line 897
} else { 
#line 898
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 899
__suld_2d_i32_zero((int *)(&tmp), surfObject, x, y); 
#line 900
}  }  }  
#line 901
(*retVal) = make_float1(tmp); 
#line 902
} 
#endif
#line 910 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 911
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 923
::exit(___);}
#if 0
#line 911
{ 
#line 912
char2 tmp; 
#line 913
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 914
__suld_2d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
#line 915
} else { 
#line 916
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 917
__suld_2d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
#line 918
} else { 
#line 919
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 920
__suld_2d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
#line 921
}  }  }  
#line 922
(*retVal) = tmp; 
#line 923
} 
#endif
#line 925 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 926
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 938
::exit(___);}
#if 0
#line 926
{ 
#line 927
uchar2 tmp; 
#line 928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 929
__suld_2d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
#line 930
} else { 
#line 931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 932
__suld_2d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
#line 933
} else { 
#line 934
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 935
__suld_2d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y); 
#line 936
}  }  }  
#line 937
(*retVal) = tmp; 
#line 938
} 
#endif
#line 940 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 941
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 953
::exit(___);}
#if 0
#line 941
{ 
#line 942
short2 tmp; 
#line 943
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 944
__suld_2d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
#line 945
} else { 
#line 946
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 947
__suld_2d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
#line 948
} else { 
#line 949
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 950
__suld_2d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
#line 951
}  }  }  
#line 952
(*retVal) = tmp; 
#line 953
} 
#endif
#line 955 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 956
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 968
::exit(___);}
#if 0
#line 956
{ 
#line 957
ushort2 tmp; 
#line 958
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 959
__suld_2d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
#line 960
} else { 
#line 961
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 962
__suld_2d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
#line 963
} else { 
#line 964
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 965
__suld_2d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y); 
#line 966
}  }  }  
#line 967
(*retVal) = tmp; 
#line 968
} 
#endif
#line 970 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 971
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 983
::exit(___);}
#if 0
#line 971
{ 
#line 972
int2 tmp; 
#line 973
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 974
__suld_2d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 975
} else { 
#line 976
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 977
__suld_2d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 978
} else { 
#line 979
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 980
__suld_2d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 981
}  }  }  
#line 982
(*retVal) = tmp; 
#line 983
} 
#endif
#line 985 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 986
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 998
::exit(___);}
#if 0
#line 986
{ 
#line 987
uint2 tmp; 
#line 988
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 989
__suld_2d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 990
} else { 
#line 991
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 992
__suld_2d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 993
} else { 
#line 994
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 995
__suld_2d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 996
}  }  }  
#line 997
(*retVal) = tmp; 
#line 998
} 
#endif
#line 1000 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1001
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1013
::exit(___);}
#if 0
#line 1001
{ 
#line 1002
longlong2 tmp; 
#line 1003
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1004
__suld_2d_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y); 
#line 1005
} else { 
#line 1006
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1007
__suld_2d_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y); 
#line 1008
} else { 
#line 1009
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1010
__suld_2d_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y); 
#line 1011
}  }  }  
#line 1012
(*retVal) = tmp; 
#line 1013
} 
#endif
#line 1015 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1016
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1028
::exit(___);}
#if 0
#line 1016
{ 
#line 1017
ulonglong2 tmp; 
#line 1018
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1019
__suld_2d_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y); 
#line 1020
} else { 
#line 1021
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1022
__suld_2d_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y); 
#line 1023
} else { 
#line 1024
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1025
__suld_2d_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y); 
#line 1026
}  }  }  
#line 1027
(*retVal) = tmp; 
#line 1028
} 
#endif
#line 1030 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1031
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1043
::exit(___);}
#if 0
#line 1031
{ 
#line 1032
float2 tmp; 
#line 1033
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1034
__suld_2d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 1035
} else { 
#line 1036
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1037
__suld_2d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 1038
} else { 
#line 1039
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1040
__suld_2d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y); 
#line 1041
}  }  }  
#line 1042
(*retVal) = tmp; 
#line 1043
} 
#endif
#line 1051 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1052
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1064
::exit(___);}
#if 0
#line 1052
{ 
#line 1053
char4 tmp; 
#line 1054
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1055
__suld_2d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
#line 1056
} else { 
#line 1057
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1058
__suld_2d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
#line 1059
} else { 
#line 1060
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1061
__suld_2d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
#line 1062
}  }  }  
#line 1063
(*retVal) = tmp; 
#line 1064
} 
#endif
#line 1066 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1067
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1079
::exit(___);}
#if 0
#line 1067
{ 
#line 1068
uchar4 tmp; 
#line 1069
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1070
__suld_2d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
#line 1071
} else { 
#line 1072
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1073
__suld_2d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
#line 1074
} else { 
#line 1075
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1076
__suld_2d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y); 
#line 1077
}  }  }  
#line 1078
(*retVal) = tmp; 
#line 1079
} 
#endif
#line 1081 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1082
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1094
::exit(___);}
#if 0
#line 1082
{ 
#line 1083
short4 tmp; 
#line 1084
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1085
__suld_2d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
#line 1086
} else { 
#line 1087
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1088
__suld_2d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
#line 1089
} else { 
#line 1090
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1091
__suld_2d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
#line 1092
}  }  }  
#line 1093
(*retVal) = tmp; 
#line 1094
} 
#endif
#line 1096 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1097
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1109
::exit(___);}
#if 0
#line 1097
{ 
#line 1098
ushort4 tmp; 
#line 1099
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1100
__suld_2d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
#line 1101
} else { 
#line 1102
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1103
__suld_2d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
#line 1104
} else { 
#line 1105
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1106
__suld_2d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y); 
#line 1107
}  }  }  
#line 1108
(*retVal) = tmp; 
#line 1109
} 
#endif
#line 1111 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1112
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1124
::exit(___);}
#if 0
#line 1112
{ 
#line 1113
int4 tmp; 
#line 1114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1115
__suld_2d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1116
} else { 
#line 1117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1118
__suld_2d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1119
} else { 
#line 1120
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1121
__suld_2d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1122
}  }  }  
#line 1123
(*retVal) = tmp; 
#line 1124
} 
#endif
#line 1126 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1127
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1139
::exit(___);}
#if 0
#line 1127
{ 
#line 1128
uint4 tmp; 
#line 1129
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1130
__suld_2d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1131
} else { 
#line 1132
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1133
__suld_2d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1134
} else { 
#line 1135
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1136
__suld_2d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1137
}  }  }  
#line 1138
(*retVal) = tmp; 
#line 1139
} 
#endif
#line 1141 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 1142
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 1154
::exit(___);}
#if 0
#line 1142
{ 
#line 1143
float4 tmp; 
#line 1144
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1145
__suld_2d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1146
} else { 
#line 1147
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1148
__suld_2d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1149
} else { 
#line 1150
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1151
__suld_2d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y); 
#line 1152
}  }  }  
#line 1153
(*retVal) = tmp; 
#line 1154
} 
#endif
#line 1162 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1163
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1175
::exit(___);}
#if 0
#line 1163
{ 
#line 1164
char tmp; 
#line 1165
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1166
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
#line 1167
} else { 
#line 1168
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1169
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
#line 1170
} else { 
#line 1171
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1172
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
#line 1173
}  }  }  
#line 1174
(*retVal) = tmp; 
#line 1175
} 
#endif
#line 1177 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1178
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1190
::exit(___);}
#if 0
#line 1178
{ 
#line 1179
signed char tmp; 
#line 1180
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1181
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
#line 1182
} else { 
#line 1183
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1184
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
#line 1185
} else { 
#line 1186
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1187
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
#line 1188
}  }  }  
#line 1189
(*retVal) = tmp; 
#line 1190
} 
#endif
#line 1192 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1193
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1205
::exit(___);}
#if 0
#line 1193
{ 
#line 1194
char tmp; 
#line 1195
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1196
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
#line 1197
} else { 
#line 1198
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1199
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
#line 1200
} else { 
#line 1201
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1202
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
#line 1203
}  }  }  
#line 1204
(*retVal) = make_char1(tmp); 
#line 1205
} 
#endif
#line 1207 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1208
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1220
::exit(___);}
#if 0
#line 1208
{ 
#line 1209
unsigned char tmp; 
#line 1210
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1211
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
#line 1212
} else { 
#line 1213
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1214
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
#line 1215
} else { 
#line 1216
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1217
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
#line 1218
}  }  }  
#line 1219
(*retVal) = tmp; 
#line 1220
} 
#endif
#line 1222 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1223
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1235
::exit(___);}
#if 0
#line 1223
{ 
#line 1224
unsigned char tmp; 
#line 1225
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1226
__suld_3d_i8_trap((char *)(&tmp), surfObject, x, y, z); 
#line 1227
} else { 
#line 1228
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1229
__suld_3d_i8_clamp((char *)(&tmp), surfObject, x, y, z); 
#line 1230
} else { 
#line 1231
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1232
__suld_3d_i8_zero((char *)(&tmp), surfObject, x, y, z); 
#line 1233
}  }  }  
#line 1234
(*retVal) = make_uchar1(tmp); 
#line 1235
} 
#endif
#line 1237 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1238
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1250
::exit(___);}
#if 0
#line 1238
{ 
#line 1239
short tmp; 
#line 1240
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1241
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
#line 1242
} else { 
#line 1243
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1244
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
#line 1245
} else { 
#line 1246
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1247
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
#line 1248
}  }  }  
#line 1249
(*retVal) = tmp; 
#line 1250
} 
#endif
#line 1252 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1253
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1265
::exit(___);}
#if 0
#line 1253
{ 
#line 1254
short tmp; 
#line 1255
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1256
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
#line 1257
} else { 
#line 1258
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1259
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
#line 1260
} else { 
#line 1261
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1262
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
#line 1263
}  }  }  
#line 1264
(*retVal) = make_short1(tmp); 
#line 1265
} 
#endif
#line 1267 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1268
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1280
::exit(___);}
#if 0
#line 1268
{ 
#line 1269
unsigned short tmp; 
#line 1270
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1271
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
#line 1272
} else { 
#line 1273
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1274
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
#line 1275
} else { 
#line 1276
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1277
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
#line 1278
}  }  }  
#line 1279
(*retVal) = tmp; 
#line 1280
} 
#endif
#line 1282 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1283
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1295
::exit(___);}
#if 0
#line 1283
{ 
#line 1284
unsigned short tmp; 
#line 1285
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1286
__suld_3d_i16_trap((short *)(&tmp), surfObject, x, y, z); 
#line 1287
} else { 
#line 1288
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1289
__suld_3d_i16_clamp((short *)(&tmp), surfObject, x, y, z); 
#line 1290
} else { 
#line 1291
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1292
__suld_3d_i16_zero((short *)(&tmp), surfObject, x, y, z); 
#line 1293
}  }  }  
#line 1294
(*retVal) = make_ushort1(tmp); 
#line 1295
} 
#endif
#line 1297 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1298
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1310
::exit(___);}
#if 0
#line 1298
{ 
#line 1299
int tmp; 
#line 1300
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1301
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
#line 1302
} else { 
#line 1303
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1304
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
#line 1305
} else { 
#line 1306
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1307
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
#line 1308
}  }  }  
#line 1309
(*retVal) = tmp; 
#line 1310
} 
#endif
#line 1312 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1313
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1325
::exit(___);}
#if 0
#line 1313
{ 
#line 1314
int tmp; 
#line 1315
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1316
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
#line 1317
} else { 
#line 1318
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1319
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
#line 1320
} else { 
#line 1321
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1322
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
#line 1323
}  }  }  
#line 1324
(*retVal) = make_int1(tmp); 
#line 1325
} 
#endif
#line 1327 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1328
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1340
::exit(___);}
#if 0
#line 1328
{ 
#line 1329
unsigned tmp; 
#line 1330
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1331
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
#line 1332
} else { 
#line 1333
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1334
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
#line 1335
} else { 
#line 1336
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1337
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
#line 1338
}  }  }  
#line 1339
(*retVal) = tmp; 
#line 1340
} 
#endif
#line 1342 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1343
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1355
::exit(___);}
#if 0
#line 1343
{ 
#line 1344
unsigned tmp; 
#line 1345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1346
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
#line 1347
} else { 
#line 1348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1349
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
#line 1350
} else { 
#line 1351
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1352
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
#line 1353
}  }  }  
#line 1354
(*retVal) = make_uint1(tmp); 
#line 1355
} 
#endif
#line 1357 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1358
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1370
::exit(___);}
#if 0
#line 1358
{ 
#line 1359
__int64 tmp; 
#line 1360
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1361
__suld_3d_i64_trap((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1362
} else { 
#line 1363
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1364
__suld_3d_i64_clamp((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1365
} else { 
#line 1366
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1367
__suld_3d_i64_zero((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1368
}  }  }  
#line 1369
(*retVal) = tmp; 
#line 1370
} 
#endif
#line 1372 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1373
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1385
::exit(___);}
#if 0
#line 1373
{ 
#line 1374
__int64 tmp; 
#line 1375
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1376
__suld_3d_i64_trap((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1377
} else { 
#line 1378
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1379
__suld_3d_i64_clamp((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1380
} else { 
#line 1381
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1382
__suld_3d_i64_zero((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1383
}  }  }  
#line 1384
(*retVal) = make_longlong1(tmp); 
#line 1385
} 
#endif
#line 1387 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1388
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1400
::exit(___);}
#if 0
#line 1388
{ 
#line 1389
unsigned __int64 tmp; 
#line 1390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1391
__suld_3d_i64_trap((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1392
} else { 
#line 1393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1394
__suld_3d_i64_clamp((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1395
} else { 
#line 1396
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1397
__suld_3d_i64_zero((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1398
}  }  }  
#line 1399
(*retVal) = tmp; 
#line 1400
} 
#endif
#line 1402 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1403
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1415
::exit(___);}
#if 0
#line 1403
{ 
#line 1404
unsigned __int64 tmp; 
#line 1405
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1406
__suld_3d_i64_trap((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1407
} else { 
#line 1408
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1409
__suld_3d_i64_clamp((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1410
} else { 
#line 1411
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1412
__suld_3d_i64_zero((__int64 *)(&tmp), surfObject, x, y, z); 
#line 1413
}  }  }  
#line 1414
(*retVal) = make_ulonglong1(tmp); 
#line 1415
} 
#endif
#line 1417 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1418
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1430
::exit(___);}
#if 0
#line 1418
{ 
#line 1419
float tmp; 
#line 1420
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1421
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
#line 1422
} else { 
#line 1423
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1424
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
#line 1425
} else { 
#line 1426
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1427
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
#line 1428
}  }  }  
#line 1429
(*retVal) = tmp; 
#line 1430
} 
#endif
#line 1432 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1433
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1445
::exit(___);}
#if 0
#line 1433
{ 
#line 1434
float tmp; 
#line 1435
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1436
__suld_3d_i32_trap((int *)(&tmp), surfObject, x, y, z); 
#line 1437
} else { 
#line 1438
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1439
__suld_3d_i32_clamp((int *)(&tmp), surfObject, x, y, z); 
#line 1440
} else { 
#line 1441
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1442
__suld_3d_i32_zero((int *)(&tmp), surfObject, x, y, z); 
#line 1443
}  }  }  
#line 1444
(*retVal) = make_float1(tmp); 
#line 1445
} 
#endif
#line 1453 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1454
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1466
::exit(___);}
#if 0
#line 1454
{ 
#line 1455
char2 tmp; 
#line 1456
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1457
__suld_3d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
#line 1458
} else { 
#line 1459
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1460
__suld_3d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
#line 1461
} else { 
#line 1462
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1463
__suld_3d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
#line 1464
}  }  }  
#line 1465
(*retVal) = tmp; 
#line 1466
} 
#endif
#line 1468 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1469
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1481
::exit(___);}
#if 0
#line 1469
{ 
#line 1470
uchar2 tmp; 
#line 1471
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1472
__suld_3d_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
#line 1473
} else { 
#line 1474
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1475
__suld_3d_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
#line 1476
} else { 
#line 1477
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1478
__suld_3d_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, x, y, z); 
#line 1479
}  }  }  
#line 1480
(*retVal) = tmp; 
#line 1481
} 
#endif
#line 1483 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1484
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1496
::exit(___);}
#if 0
#line 1484
{ 
#line 1485
short2 tmp; 
#line 1486
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1487
__suld_3d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
#line 1488
} else { 
#line 1489
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1490
__suld_3d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
#line 1491
} else { 
#line 1492
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1493
__suld_3d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
#line 1494
}  }  }  
#line 1495
(*retVal) = tmp; 
#line 1496
} 
#endif
#line 1498 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1499
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1511
::exit(___);}
#if 0
#line 1499
{ 
#line 1500
ushort2 tmp; 
#line 1501
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1502
__suld_3d_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
#line 1503
} else { 
#line 1504
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1505
__suld_3d_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
#line 1506
} else { 
#line 1507
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1508
__suld_3d_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, x, y, z); 
#line 1509
}  }  }  
#line 1510
(*retVal) = tmp; 
#line 1511
} 
#endif
#line 1513 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1514
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1526
::exit(___);}
#if 0
#line 1514
{ 
#line 1515
int2 tmp; 
#line 1516
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1517
__suld_3d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1518
} else { 
#line 1519
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1520
__suld_3d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1521
} else { 
#line 1522
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1523
__suld_3d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1524
}  }  }  
#line 1525
(*retVal) = tmp; 
#line 1526
} 
#endif
#line 1528 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1529
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1541
::exit(___);}
#if 0
#line 1529
{ 
#line 1530
uint2 tmp; 
#line 1531
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1532
__suld_3d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1533
} else { 
#line 1534
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1535
__suld_3d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1536
} else { 
#line 1537
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1538
__suld_3d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1539
}  }  }  
#line 1540
(*retVal) = tmp; 
#line 1541
} 
#endif
#line 1543 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1544
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1556
::exit(___);}
#if 0
#line 1544
{ 
#line 1545
longlong2 tmp; 
#line 1546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1547
__suld_3d_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y, z); 
#line 1548
} else { 
#line 1549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1550
__suld_3d_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y, z); 
#line 1551
} else { 
#line 1552
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1553
__suld_3d_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y, z); 
#line 1554
}  }  }  
#line 1555
(*retVal) = tmp; 
#line 1556
} 
#endif
#line 1558 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1559
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1571
::exit(___);}
#if 0
#line 1559
{ 
#line 1560
ulonglong2 tmp; 
#line 1561
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1562
__suld_3d_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y, z); 
#line 1563
} else { 
#line 1564
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1565
__suld_3d_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y, z); 
#line 1566
} else { 
#line 1567
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1568
__suld_3d_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, x, y, z); 
#line 1569
}  }  }  
#line 1570
(*retVal) = tmp; 
#line 1571
} 
#endif
#line 1573 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1574
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1586
::exit(___);}
#if 0
#line 1574
{ 
#line 1575
float2 tmp; 
#line 1576
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1577
__suld_3d_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1578
} else { 
#line 1579
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1580
__suld_3d_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1581
} else { 
#line 1582
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1583
__suld_3d_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, x, y, z); 
#line 1584
}  }  }  
#line 1585
(*retVal) = tmp; 
#line 1586
} 
#endif
#line 1594 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1595
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1607
::exit(___);}
#if 0
#line 1595
{ 
#line 1596
char4 tmp; 
#line 1597
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1598
__suld_3d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
#line 1599
} else { 
#line 1600
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1601
__suld_3d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
#line 1602
} else { 
#line 1603
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1604
__suld_3d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
#line 1605
}  }  }  
#line 1606
(*retVal) = tmp; 
#line 1607
} 
#endif
#line 1609 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1610
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1622
::exit(___);}
#if 0
#line 1610
{ 
#line 1611
uchar4 tmp; 
#line 1612
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1613
__suld_3d_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
#line 1614
} else { 
#line 1615
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1616
__suld_3d_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
#line 1617
} else { 
#line 1618
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1619
__suld_3d_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, x, y, z); 
#line 1620
}  }  }  
#line 1621
(*retVal) = tmp; 
#line 1622
} 
#endif
#line 1624 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1625
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1637
::exit(___);}
#if 0
#line 1625
{ 
#line 1626
short4 tmp; 
#line 1627
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1628
__suld_3d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
#line 1629
} else { 
#line 1630
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1631
__suld_3d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
#line 1632
} else { 
#line 1633
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1634
__suld_3d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
#line 1635
}  }  }  
#line 1636
(*retVal) = tmp; 
#line 1637
} 
#endif
#line 1639 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1640
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1652
::exit(___);}
#if 0
#line 1640
{ 
#line 1641
ushort4 tmp; 
#line 1642
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1643
__suld_3d_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
#line 1644
} else { 
#line 1645
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1646
__suld_3d_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
#line 1647
} else { 
#line 1648
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1649
__suld_3d_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, x, y, z); 
#line 1650
}  }  }  
#line 1651
(*retVal) = tmp; 
#line 1652
} 
#endif
#line 1654 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1655
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1667
::exit(___);}
#if 0
#line 1655
{ 
#line 1656
int4 tmp; 
#line 1657
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1658
__suld_3d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1659
} else { 
#line 1660
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1661
__suld_3d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1662
} else { 
#line 1663
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1664
__suld_3d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1665
}  }  }  
#line 1666
(*retVal) = tmp; 
#line 1667
} 
#endif
#line 1669 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1670
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1682
::exit(___);}
#if 0
#line 1670
{ 
#line 1671
uint4 tmp; 
#line 1672
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1673
__suld_3d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1674
} else { 
#line 1675
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1676
__suld_3d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1677
} else { 
#line 1678
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1679
__suld_3d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1680
}  }  }  
#line 1681
(*retVal) = tmp; 
#line 1682
} 
#endif
#line 1684 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 1685
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 1697
::exit(___);}
#if 0
#line 1685
{ 
#line 1686
float4 tmp; 
#line 1687
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1688
__suld_3d_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1689
} else { 
#line 1690
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1691
__suld_3d_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1692
} else { 
#line 1693
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1694
__suld_3d_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, x, y, z); 
#line 1695
}  }  }  
#line 1696
(*retVal) = tmp; 
#line 1697
} 
#endif
#line 1705 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1706
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1718
::exit(___);}
#if 0
#line 1706
{ 
#line 1707
char tmp; 
#line 1708
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1709
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
#line 1710
} else { 
#line 1711
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1712
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
#line 1713
} else { 
#line 1714
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1715
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
#line 1716
}  }  }  
#line 1717
(*retVal) = tmp; 
#line 1718
} 
#endif
#line 1720 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1721
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1733
::exit(___);}
#if 0
#line 1721
{ 
#line 1722
signed char tmp; 
#line 1723
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1724
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
#line 1725
} else { 
#line 1726
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1727
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
#line 1728
} else { 
#line 1729
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1730
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
#line 1731
}  }  }  
#line 1732
(*retVal) = tmp; 
#line 1733
} 
#endif
#line 1735 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1736
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1748
::exit(___);}
#if 0
#line 1736
{ 
#line 1737
char tmp; 
#line 1738
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1739
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
#line 1740
} else { 
#line 1741
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1742
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
#line 1743
} else { 
#line 1744
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1745
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
#line 1746
}  }  }  
#line 1747
(*retVal) = make_char1(tmp); 
#line 1748
} 
#endif
#line 1750 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1751
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1763
::exit(___);}
#if 0
#line 1751
{ 
#line 1752
unsigned char tmp; 
#line 1753
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1754
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
#line 1755
} else { 
#line 1756
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1757
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
#line 1758
} else { 
#line 1759
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1760
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
#line 1761
}  }  }  
#line 1762
(*retVal) = tmp; 
#line 1763
} 
#endif
#line 1765 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1766
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1778
::exit(___);}
#if 0
#line 1766
{ 
#line 1767
unsigned char tmp; 
#line 1768
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1769
__suld_1d_array_i8_trap((char *)(&tmp), surfObject, layer, x); 
#line 1770
} else { 
#line 1771
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1772
__suld_1d_array_i8_clamp((char *)(&tmp), surfObject, layer, x); 
#line 1773
} else { 
#line 1774
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1775
__suld_1d_array_i8_zero((char *)(&tmp), surfObject, layer, x); 
#line 1776
}  }  }  
#line 1777
(*retVal) = make_uchar1(tmp); 
#line 1778
} 
#endif
#line 1780 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1781
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1793
::exit(___);}
#if 0
#line 1781
{ 
#line 1782
short tmp; 
#line 1783
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1784
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
#line 1785
} else { 
#line 1786
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1787
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
#line 1788
} else { 
#line 1789
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1790
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
#line 1791
}  }  }  
#line 1792
(*retVal) = tmp; 
#line 1793
} 
#endif
#line 1795 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1796
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1808
::exit(___);}
#if 0
#line 1796
{ 
#line 1797
short tmp; 
#line 1798
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1799
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
#line 1800
} else { 
#line 1801
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1802
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
#line 1803
} else { 
#line 1804
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1805
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
#line 1806
}  }  }  
#line 1807
(*retVal) = make_short1(tmp); 
#line 1808
} 
#endif
#line 1810 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1811
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1823
::exit(___);}
#if 0
#line 1811
{ 
#line 1812
unsigned short tmp; 
#line 1813
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1814
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
#line 1815
} else { 
#line 1816
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1817
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
#line 1818
} else { 
#line 1819
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1820
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
#line 1821
}  }  }  
#line 1822
(*retVal) = tmp; 
#line 1823
} 
#endif
#line 1825 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1826
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1838
::exit(___);}
#if 0
#line 1826
{ 
#line 1827
unsigned short tmp; 
#line 1828
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1829
__suld_1d_array_i16_trap((short *)(&tmp), surfObject, layer, x); 
#line 1830
} else { 
#line 1831
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1832
__suld_1d_array_i16_clamp((short *)(&tmp), surfObject, layer, x); 
#line 1833
} else { 
#line 1834
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1835
__suld_1d_array_i16_zero((short *)(&tmp), surfObject, layer, x); 
#line 1836
}  }  }  
#line 1837
(*retVal) = make_ushort1(tmp); 
#line 1838
} 
#endif
#line 1840 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1841
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1853
::exit(___);}
#if 0
#line 1841
{ 
#line 1842
int tmp; 
#line 1843
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1844
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
#line 1845
} else { 
#line 1846
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1847
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
#line 1848
} else { 
#line 1849
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1850
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
#line 1851
}  }  }  
#line 1852
(*retVal) = tmp; 
#line 1853
} 
#endif
#line 1855 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1856
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1868
::exit(___);}
#if 0
#line 1856
{ 
#line 1857
int tmp; 
#line 1858
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1859
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
#line 1860
} else { 
#line 1861
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1862
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
#line 1863
} else { 
#line 1864
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1865
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
#line 1866
}  }  }  
#line 1867
(*retVal) = make_int1(tmp); 
#line 1868
} 
#endif
#line 1870 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1871
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1883
::exit(___);}
#if 0
#line 1871
{ 
#line 1872
unsigned tmp; 
#line 1873
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1874
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
#line 1875
} else { 
#line 1876
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1877
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
#line 1878
} else { 
#line 1879
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1880
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
#line 1881
}  }  }  
#line 1882
(*retVal) = tmp; 
#line 1883
} 
#endif
#line 1885 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1886
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1898
::exit(___);}
#if 0
#line 1886
{ 
#line 1887
unsigned tmp; 
#line 1888
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1889
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
#line 1890
} else { 
#line 1891
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1892
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
#line 1893
} else { 
#line 1894
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1895
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
#line 1896
}  }  }  
#line 1897
(*retVal) = make_uint1(tmp); 
#line 1898
} 
#endif
#line 1900 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1901
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1913
::exit(___);}
#if 0
#line 1901
{ 
#line 1902
__int64 tmp; 
#line 1903
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1904
__suld_1d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x); 
#line 1905
} else { 
#line 1906
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1907
__suld_1d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x); 
#line 1908
} else { 
#line 1909
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1910
__suld_1d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x); 
#line 1911
}  }  }  
#line 1912
(*retVal) = tmp; 
#line 1913
} 
#endif
#line 1915 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1916
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1928
::exit(___);}
#if 0
#line 1916
{ 
#line 1917
__int64 tmp; 
#line 1918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1919
__suld_1d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x); 
#line 1920
} else { 
#line 1921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1922
__suld_1d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x); 
#line 1923
} else { 
#line 1924
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1925
__suld_1d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x); 
#line 1926
}  }  }  
#line 1927
(*retVal) = make_longlong1(tmp); 
#line 1928
} 
#endif
#line 1930 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1931
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1943
::exit(___);}
#if 0
#line 1931
{ 
#line 1932
unsigned __int64 tmp; 
#line 1933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1934
__suld_1d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x); 
#line 1935
} else { 
#line 1936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1937
__suld_1d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x); 
#line 1938
} else { 
#line 1939
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1940
__suld_1d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x); 
#line 1941
}  }  }  
#line 1942
(*retVal) = tmp; 
#line 1943
} 
#endif
#line 1945 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1946
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1958
::exit(___);}
#if 0
#line 1946
{ 
#line 1947
unsigned __int64 tmp; 
#line 1948
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1949
__suld_1d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x); 
#line 1950
} else { 
#line 1951
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1952
__suld_1d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x); 
#line 1953
} else { 
#line 1954
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1955
__suld_1d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x); 
#line 1956
}  }  }  
#line 1957
(*retVal) = make_ulonglong1(tmp); 
#line 1958
} 
#endif
#line 1960 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1961
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1973
::exit(___);}
#if 0
#line 1961
{ 
#line 1962
float tmp; 
#line 1963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1964
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
#line 1965
} else { 
#line 1966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1967
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
#line 1968
} else { 
#line 1969
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1970
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
#line 1971
}  }  }  
#line 1972
(*retVal) = tmp; 
#line 1973
} 
#endif
#line 1975 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1976
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 1988
::exit(___);}
#if 0
#line 1976
{ 
#line 1977
float tmp; 
#line 1978
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 1979
__suld_1d_array_i32_trap((int *)(&tmp), surfObject, layer, x); 
#line 1980
} else { 
#line 1981
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 1982
__suld_1d_array_i32_clamp((int *)(&tmp), surfObject, layer, x); 
#line 1983
} else { 
#line 1984
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 1985
__suld_1d_array_i32_zero((int *)(&tmp), surfObject, layer, x); 
#line 1986
}  }  }  
#line 1987
(*retVal) = make_float1(tmp); 
#line 1988
} 
#endif
#line 1996 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 1997
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2009
::exit(___);}
#if 0
#line 1997
{ 
#line 1998
char2 tmp; 
#line 1999
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2000
__suld_1d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
#line 2001
} else { 
#line 2002
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2003
__suld_1d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
#line 2004
} else { 
#line 2005
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2006
__suld_1d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
#line 2007
}  }  }  
#line 2008
(*retVal) = tmp; 
#line 2009
} 
#endif
#line 2011 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2012
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2024
::exit(___);}
#if 0
#line 2012
{ 
#line 2013
uchar2 tmp; 
#line 2014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2015
__suld_1d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
#line 2016
} else { 
#line 2017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2018
__suld_1d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
#line 2019
} else { 
#line 2020
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2021
__suld_1d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x); 
#line 2022
}  }  }  
#line 2023
(*retVal) = tmp; 
#line 2024
} 
#endif
#line 2026 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2027
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2039
::exit(___);}
#if 0
#line 2027
{ 
#line 2028
short2 tmp; 
#line 2029
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2030
__suld_1d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
#line 2031
} else { 
#line 2032
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2033
__suld_1d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
#line 2034
} else { 
#line 2035
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2036
__suld_1d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
#line 2037
}  }  }  
#line 2038
(*retVal) = tmp; 
#line 2039
} 
#endif
#line 2041 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2042
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2054
::exit(___);}
#if 0
#line 2042
{ 
#line 2043
ushort2 tmp; 
#line 2044
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2045
__suld_1d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
#line 2046
} else { 
#line 2047
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2048
__suld_1d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
#line 2049
} else { 
#line 2050
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2051
__suld_1d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x); 
#line 2052
}  }  }  
#line 2053
(*retVal) = tmp; 
#line 2054
} 
#endif
#line 2056 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2057
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2069
::exit(___);}
#if 0
#line 2057
{ 
#line 2058
int2 tmp; 
#line 2059
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2060
__suld_1d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2061
} else { 
#line 2062
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2063
__suld_1d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2064
} else { 
#line 2065
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2066
__suld_1d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2067
}  }  }  
#line 2068
(*retVal) = tmp; 
#line 2069
} 
#endif
#line 2071 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2072
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2084
::exit(___);}
#if 0
#line 2072
{ 
#line 2073
uint2 tmp; 
#line 2074
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2075
__suld_1d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2076
} else { 
#line 2077
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2078
__suld_1d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2079
} else { 
#line 2080
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2081
__suld_1d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2082
}  }  }  
#line 2083
(*retVal) = tmp; 
#line 2084
} 
#endif
#line 2086 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2087
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2099
::exit(___);}
#if 0
#line 2087
{ 
#line 2088
longlong2 tmp; 
#line 2089
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2090
__suld_1d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x); 
#line 2091
} else { 
#line 2092
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2093
__suld_1d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x); 
#line 2094
} else { 
#line 2095
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2096
__suld_1d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x); 
#line 2097
}  }  }  
#line 2098
(*retVal) = tmp; 
#line 2099
} 
#endif
#line 2101 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2102
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2114
::exit(___);}
#if 0
#line 2102
{ 
#line 2103
ulonglong2 tmp; 
#line 2104
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2105
__suld_1d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x); 
#line 2106
} else { 
#line 2107
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2108
__suld_1d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x); 
#line 2109
} else { 
#line 2110
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2111
__suld_1d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x); 
#line 2112
}  }  }  
#line 2113
(*retVal) = tmp; 
#line 2114
} 
#endif
#line 2116 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2117
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2129
::exit(___);}
#if 0
#line 2117
{ 
#line 2118
float2 tmp; 
#line 2119
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2120
__suld_1d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2121
} else { 
#line 2122
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2123
__suld_1d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2124
} else { 
#line 2125
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2126
__suld_1d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x); 
#line 2127
}  }  }  
#line 2128
(*retVal) = tmp; 
#line 2129
} 
#endif
#line 2137 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2138
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2150
::exit(___);}
#if 0
#line 2138
{ 
#line 2139
char4 tmp; 
#line 2140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2141
__suld_1d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
#line 2142
} else { 
#line 2143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2144
__suld_1d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
#line 2145
} else { 
#line 2146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2147
__suld_1d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
#line 2148
}  }  }  
#line 2149
(*retVal) = tmp; 
#line 2150
} 
#endif
#line 2152 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2153
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2165
::exit(___);}
#if 0
#line 2153
{ 
#line 2154
uchar4 tmp; 
#line 2155
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2156
__suld_1d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
#line 2157
} else { 
#line 2158
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2159
__suld_1d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
#line 2160
} else { 
#line 2161
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2162
__suld_1d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x); 
#line 2163
}  }  }  
#line 2164
(*retVal) = tmp; 
#line 2165
} 
#endif
#line 2167 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2168
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2180
::exit(___);}
#if 0
#line 2168
{ 
#line 2169
short4 tmp; 
#line 2170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2171
__suld_1d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
#line 2172
} else { 
#line 2173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2174
__suld_1d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
#line 2175
} else { 
#line 2176
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2177
__suld_1d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
#line 2178
}  }  }  
#line 2179
(*retVal) = tmp; 
#line 2180
} 
#endif
#line 2182 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2183
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2195
::exit(___);}
#if 0
#line 2183
{ 
#line 2184
ushort4 tmp; 
#line 2185
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2186
__suld_1d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
#line 2187
} else { 
#line 2188
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2189
__suld_1d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
#line 2190
} else { 
#line 2191
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2192
__suld_1d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x); 
#line 2193
}  }  }  
#line 2194
(*retVal) = tmp; 
#line 2195
} 
#endif
#line 2197 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2198
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2210
::exit(___);}
#if 0
#line 2198
{ 
#line 2199
int4 tmp; 
#line 2200
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2201
__suld_1d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2202
} else { 
#line 2203
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2204
__suld_1d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2205
} else { 
#line 2206
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2207
__suld_1d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2208
}  }  }  
#line 2209
(*retVal) = tmp; 
#line 2210
} 
#endif
#line 2212 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2213
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2225
::exit(___);}
#if 0
#line 2213
{ 
#line 2214
uint4 tmp; 
#line 2215
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2216
__suld_1d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2217
} else { 
#line 2218
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2219
__suld_1d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2220
} else { 
#line 2221
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2222
__suld_1d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2223
}  }  }  
#line 2224
(*retVal) = tmp; 
#line 2225
} 
#endif
#line 2227 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2228
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 2240
::exit(___);}
#if 0
#line 2228
{ 
#line 2229
float4 tmp; 
#line 2230
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2231
__suld_1d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2232
} else { 
#line 2233
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2234
__suld_1d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2235
} else { 
#line 2236
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2237
__suld_1d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x); 
#line 2238
}  }  }  
#line 2239
(*retVal) = tmp; 
#line 2240
} 
#endif
#line 2248 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2249
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2261
::exit(___);}
#if 0
#line 2249
{ 
#line 2250
char tmp; 
#line 2251
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2252
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
#line 2253
} else { 
#line 2254
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2255
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
#line 2256
} else { 
#line 2257
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2258
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
#line 2259
}  }  }  
#line 2260
(*retVal) = tmp; 
#line 2261
} 
#endif
#line 2263 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2264
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2276
::exit(___);}
#if 0
#line 2264
{ 
#line 2265
signed char tmp; 
#line 2266
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2267
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
#line 2268
} else { 
#line 2269
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2270
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
#line 2271
} else { 
#line 2272
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2273
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
#line 2274
}  }  }  
#line 2275
(*retVal) = tmp; 
#line 2276
} 
#endif
#line 2278 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2279
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2291
::exit(___);}
#if 0
#line 2279
{ 
#line 2280
char tmp; 
#line 2281
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2282
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
#line 2283
} else { 
#line 2284
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2285
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
#line 2286
} else { 
#line 2287
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2288
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
#line 2289
}  }  }  
#line 2290
(*retVal) = make_char1(tmp); 
#line 2291
} 
#endif
#line 2293 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2294
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2306
::exit(___);}
#if 0
#line 2294
{ 
#line 2295
unsigned char tmp; 
#line 2296
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2297
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
#line 2298
} else { 
#line 2299
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2300
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
#line 2301
} else { 
#line 2302
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2303
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
#line 2304
}  }  }  
#line 2305
(*retVal) = tmp; 
#line 2306
} 
#endif
#line 2308 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2309
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2321
::exit(___);}
#if 0
#line 2309
{ 
#line 2310
unsigned char tmp; 
#line 2311
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2312
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layer, x, y); 
#line 2313
} else { 
#line 2314
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2315
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layer, x, y); 
#line 2316
} else { 
#line 2317
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2318
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layer, x, y); 
#line 2319
}  }  }  
#line 2320
(*retVal) = make_uchar1(tmp); 
#line 2321
} 
#endif
#line 2323 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2324
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2336
::exit(___);}
#if 0
#line 2324
{ 
#line 2325
short tmp; 
#line 2326
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2327
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
#line 2328
} else { 
#line 2329
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2330
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
#line 2331
} else { 
#line 2332
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2333
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
#line 2334
}  }  }  
#line 2335
(*retVal) = tmp; 
#line 2336
} 
#endif
#line 2338 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2339
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2351
::exit(___);}
#if 0
#line 2339
{ 
#line 2340
short tmp; 
#line 2341
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2342
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
#line 2343
} else { 
#line 2344
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2345
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
#line 2346
} else { 
#line 2347
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2348
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
#line 2349
}  }  }  
#line 2350
(*retVal) = make_short1(tmp); 
#line 2351
} 
#endif
#line 2353 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2354
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2366
::exit(___);}
#if 0
#line 2354
{ 
#line 2355
unsigned short tmp; 
#line 2356
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2357
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
#line 2358
} else { 
#line 2359
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2360
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
#line 2361
} else { 
#line 2362
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2363
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
#line 2364
}  }  }  
#line 2365
(*retVal) = tmp; 
#line 2366
} 
#endif
#line 2368 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2369
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2381
::exit(___);}
#if 0
#line 2369
{ 
#line 2370
unsigned short tmp; 
#line 2371
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2372
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layer, x, y); 
#line 2373
} else { 
#line 2374
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2375
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layer, x, y); 
#line 2376
} else { 
#line 2377
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2378
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layer, x, y); 
#line 2379
}  }  }  
#line 2380
(*retVal) = make_ushort1(tmp); 
#line 2381
} 
#endif
#line 2383 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2384
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2396
::exit(___);}
#if 0
#line 2384
{ 
#line 2385
int tmp; 
#line 2386
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2387
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
#line 2388
} else { 
#line 2389
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2390
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
#line 2391
} else { 
#line 2392
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2393
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
#line 2394
}  }  }  
#line 2395
(*retVal) = tmp; 
#line 2396
} 
#endif
#line 2398 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2399
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2411
::exit(___);}
#if 0
#line 2399
{ 
#line 2400
int tmp; 
#line 2401
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2402
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
#line 2403
} else { 
#line 2404
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2405
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
#line 2406
} else { 
#line 2407
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2408
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
#line 2409
}  }  }  
#line 2410
(*retVal) = make_int1(tmp); 
#line 2411
} 
#endif
#line 2413 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2414
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2426
::exit(___);}
#if 0
#line 2414
{ 
#line 2415
unsigned tmp; 
#line 2416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2417
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
#line 2418
} else { 
#line 2419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2420
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
#line 2421
} else { 
#line 2422
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2423
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
#line 2424
}  }  }  
#line 2425
(*retVal) = tmp; 
#line 2426
} 
#endif
#line 2428 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2429
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2441
::exit(___);}
#if 0
#line 2429
{ 
#line 2430
unsigned tmp; 
#line 2431
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2432
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
#line 2433
} else { 
#line 2434
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2435
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
#line 2436
} else { 
#line 2437
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2438
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
#line 2439
}  }  }  
#line 2440
(*retVal) = make_uint1(tmp); 
#line 2441
} 
#endif
#line 2443 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2444
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2456
::exit(___);}
#if 0
#line 2444
{ 
#line 2445
__int64 tmp; 
#line 2446
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2447
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2448
} else { 
#line 2449
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2450
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2451
} else { 
#line 2452
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2453
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2454
}  }  }  
#line 2455
(*retVal) = tmp; 
#line 2456
} 
#endif
#line 2458 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2459
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2471
::exit(___);}
#if 0
#line 2459
{ 
#line 2460
__int64 tmp; 
#line 2461
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2462
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2463
} else { 
#line 2464
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2465
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2466
} else { 
#line 2467
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2468
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2469
}  }  }  
#line 2470
(*retVal) = make_longlong1(tmp); 
#line 2471
} 
#endif
#line 2473 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2474
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2486
::exit(___);}
#if 0
#line 2474
{ 
#line 2475
unsigned __int64 tmp; 
#line 2476
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2477
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2478
} else { 
#line 2479
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2480
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2481
} else { 
#line 2482
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2483
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2484
}  }  }  
#line 2485
(*retVal) = tmp; 
#line 2486
} 
#endif
#line 2488 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2489
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2501
::exit(___);}
#if 0
#line 2489
{ 
#line 2490
unsigned __int64 tmp; 
#line 2491
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2492
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2493
} else { 
#line 2494
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2495
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2496
} else { 
#line 2497
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2498
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layer, x, y); 
#line 2499
}  }  }  
#line 2500
(*retVal) = make_ulonglong1(tmp); 
#line 2501
} 
#endif
#line 2503 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2504
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2516
::exit(___);}
#if 0
#line 2504
{ 
#line 2505
float tmp; 
#line 2506
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2507
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
#line 2508
} else { 
#line 2509
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2510
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
#line 2511
} else { 
#line 2512
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2513
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
#line 2514
}  }  }  
#line 2515
(*retVal) = tmp; 
#line 2516
} 
#endif
#line 2518 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2519
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2531
::exit(___);}
#if 0
#line 2519
{ 
#line 2520
float tmp; 
#line 2521
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2522
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layer, x, y); 
#line 2523
} else { 
#line 2524
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2525
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layer, x, y); 
#line 2526
} else { 
#line 2527
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2528
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layer, x, y); 
#line 2529
}  }  }  
#line 2530
(*retVal) = make_float1(tmp); 
#line 2531
} 
#endif
#line 2539 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2540
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2552
::exit(___);}
#if 0
#line 2540
{ 
#line 2541
char2 tmp; 
#line 2542
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2543
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2544
} else { 
#line 2545
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2546
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2547
} else { 
#line 2548
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2549
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2550
}  }  }  
#line 2551
(*retVal) = tmp; 
#line 2552
} 
#endif
#line 2554 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2555
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2567
::exit(___);}
#if 0
#line 2555
{ 
#line 2556
uchar2 tmp; 
#line 2557
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2558
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2559
} else { 
#line 2560
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2561
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2562
} else { 
#line 2563
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2564
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2565
}  }  }  
#line 2566
(*retVal) = tmp; 
#line 2567
} 
#endif
#line 2569 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2570
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2582
::exit(___);}
#if 0
#line 2570
{ 
#line 2571
short2 tmp; 
#line 2572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2573
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2574
} else { 
#line 2575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2576
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2577
} else { 
#line 2578
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2579
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2580
}  }  }  
#line 2581
(*retVal) = tmp; 
#line 2582
} 
#endif
#line 2584 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2585
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2597
::exit(___);}
#if 0
#line 2585
{ 
#line 2586
ushort2 tmp; 
#line 2587
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2588
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2589
} else { 
#line 2590
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2591
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2592
} else { 
#line 2593
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2594
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2595
}  }  }  
#line 2596
(*retVal) = tmp; 
#line 2597
} 
#endif
#line 2599 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2600
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2612
::exit(___);}
#if 0
#line 2600
{ 
#line 2601
int2 tmp; 
#line 2602
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2603
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2604
} else { 
#line 2605
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2606
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2607
} else { 
#line 2608
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2609
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2610
}  }  }  
#line 2611
(*retVal) = tmp; 
#line 2612
} 
#endif
#line 2614 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2615
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2627
::exit(___);}
#if 0
#line 2615
{ 
#line 2616
uint2 tmp; 
#line 2617
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2618
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2619
} else { 
#line 2620
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2621
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2622
} else { 
#line 2623
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2624
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2625
}  }  }  
#line 2626
(*retVal) = tmp; 
#line 2627
} 
#endif
#line 2629 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2630
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2642
::exit(___);}
#if 0
#line 2630
{ 
#line 2631
longlong2 tmp; 
#line 2632
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2633
__suld_2d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2634
} else { 
#line 2635
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2636
__suld_2d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2637
} else { 
#line 2638
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2639
__suld_2d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2640
}  }  }  
#line 2641
(*retVal) = tmp; 
#line 2642
} 
#endif
#line 2644 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2645
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2657
::exit(___);}
#if 0
#line 2645
{ 
#line 2646
ulonglong2 tmp; 
#line 2647
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2648
__suld_2d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2649
} else { 
#line 2650
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2651
__suld_2d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2652
} else { 
#line 2653
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2654
__suld_2d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2655
}  }  }  
#line 2656
(*retVal) = tmp; 
#line 2657
} 
#endif
#line 2659 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2660
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2672
::exit(___);}
#if 0
#line 2660
{ 
#line 2661
float2 tmp; 
#line 2662
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2663
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2664
} else { 
#line 2665
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2666
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2667
} else { 
#line 2668
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2669
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layer, x, y); 
#line 2670
}  }  }  
#line 2671
(*retVal) = tmp; 
#line 2672
} 
#endif
#line 2680 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2681
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2693
::exit(___);}
#if 0
#line 2681
{ 
#line 2682
char4 tmp; 
#line 2683
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2684
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2685
} else { 
#line 2686
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2687
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2688
} else { 
#line 2689
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2690
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2691
}  }  }  
#line 2692
(*retVal) = tmp; 
#line 2693
} 
#endif
#line 2695 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2696
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2708
::exit(___);}
#if 0
#line 2696
{ 
#line 2697
uchar4 tmp; 
#line 2698
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2699
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2700
} else { 
#line 2701
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2702
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2703
} else { 
#line 2704
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2705
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2706
}  }  }  
#line 2707
(*retVal) = tmp; 
#line 2708
} 
#endif
#line 2710 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2711
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2723
::exit(___);}
#if 0
#line 2711
{ 
#line 2712
short4 tmp; 
#line 2713
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2714
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2715
} else { 
#line 2716
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2717
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2718
} else { 
#line 2719
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2720
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2721
}  }  }  
#line 2722
(*retVal) = tmp; 
#line 2723
} 
#endif
#line 2725 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2726
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2738
::exit(___);}
#if 0
#line 2726
{ 
#line 2727
ushort4 tmp; 
#line 2728
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2729
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2730
} else { 
#line 2731
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2732
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2733
} else { 
#line 2734
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2735
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2736
}  }  }  
#line 2737
(*retVal) = tmp; 
#line 2738
} 
#endif
#line 2740 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2741
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2753
::exit(___);}
#if 0
#line 2741
{ 
#line 2742
int4 tmp; 
#line 2743
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2744
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2745
} else { 
#line 2746
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2747
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2748
} else { 
#line 2749
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2750
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2751
}  }  }  
#line 2752
(*retVal) = tmp; 
#line 2753
} 
#endif
#line 2755 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2756
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2768
::exit(___);}
#if 0
#line 2756
{ 
#line 2757
uint4 tmp; 
#line 2758
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2759
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2760
} else { 
#line 2761
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2762
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2763
} else { 
#line 2764
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2765
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2766
}  }  }  
#line 2767
(*retVal) = tmp; 
#line 2768
} 
#endif
#line 2770 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 2771
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 2783
::exit(___);}
#if 0
#line 2771
{ 
#line 2772
float4 tmp; 
#line 2773
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2774
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2775
} else { 
#line 2776
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2777
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2778
} else { 
#line 2779
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2780
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layer, x, y); 
#line 2781
}  }  }  
#line 2782
(*retVal) = tmp; 
#line 2783
} 
#endif
#line 2791 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2792
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2804
::exit(___);}
#if 0
#line 2792
{ 
#line 2793
char tmp; 
#line 2794
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2795
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
#line 2796
} else { 
#line 2797
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2798
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
#line 2799
} else { 
#line 2800
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2801
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
#line 2802
}  }  }  
#line 2803
(*retVal) = tmp; 
#line 2804
} 
#endif
#line 2806 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2807
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2819
::exit(___);}
#if 0
#line 2807
{ 
#line 2808
signed char tmp; 
#line 2809
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2810
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
#line 2811
} else { 
#line 2812
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2813
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
#line 2814
} else { 
#line 2815
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2816
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
#line 2817
}  }  }  
#line 2818
(*retVal) = tmp; 
#line 2819
} 
#endif
#line 2821 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2822
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2834
::exit(___);}
#if 0
#line 2822
{ 
#line 2823
char tmp; 
#line 2824
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2825
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
#line 2826
} else { 
#line 2827
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2828
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
#line 2829
} else { 
#line 2830
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2831
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
#line 2832
}  }  }  
#line 2833
(*retVal) = make_char1(tmp); 
#line 2834
} 
#endif
#line 2836 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2837
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2849
::exit(___);}
#if 0
#line 2837
{ 
#line 2838
unsigned char tmp; 
#line 2839
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2840
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
#line 2841
} else { 
#line 2842
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2843
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
#line 2844
} else { 
#line 2845
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2846
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
#line 2847
}  }  }  
#line 2848
(*retVal) = tmp; 
#line 2849
} 
#endif
#line 2851 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2852
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2864
::exit(___);}
#if 0
#line 2852
{ 
#line 2853
unsigned char tmp; 
#line 2854
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2855
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, face, x, y); 
#line 2856
} else { 
#line 2857
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2858
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, face, x, y); 
#line 2859
} else { 
#line 2860
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2861
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, face, x, y); 
#line 2862
}  }  }  
#line 2863
(*retVal) = make_uchar1(tmp); 
#line 2864
} 
#endif
#line 2866 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2867
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2879
::exit(___);}
#if 0
#line 2867
{ 
#line 2868
short tmp; 
#line 2869
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2870
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
#line 2871
} else { 
#line 2872
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2873
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
#line 2874
} else { 
#line 2875
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2876
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
#line 2877
}  }  }  
#line 2878
(*retVal) = tmp; 
#line 2879
} 
#endif
#line 2881 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2882
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2894
::exit(___);}
#if 0
#line 2882
{ 
#line 2883
short tmp; 
#line 2884
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2885
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
#line 2886
} else { 
#line 2887
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2888
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
#line 2889
} else { 
#line 2890
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2891
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
#line 2892
}  }  }  
#line 2893
(*retVal) = make_short1(tmp); 
#line 2894
} 
#endif
#line 2896 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2897
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2909
::exit(___);}
#if 0
#line 2897
{ 
#line 2898
unsigned short tmp; 
#line 2899
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2900
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
#line 2901
} else { 
#line 2902
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2903
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
#line 2904
} else { 
#line 2905
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2906
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
#line 2907
}  }  }  
#line 2908
(*retVal) = tmp; 
#line 2909
} 
#endif
#line 2911 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2912
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2924
::exit(___);}
#if 0
#line 2912
{ 
#line 2913
unsigned short tmp; 
#line 2914
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2915
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, face, x, y); 
#line 2916
} else { 
#line 2917
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2918
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, face, x, y); 
#line 2919
} else { 
#line 2920
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2921
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, face, x, y); 
#line 2922
}  }  }  
#line 2923
(*retVal) = make_ushort1(tmp); 
#line 2924
} 
#endif
#line 2926 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2927
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2939
::exit(___);}
#if 0
#line 2927
{ 
#line 2928
int tmp; 
#line 2929
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2930
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
#line 2931
} else { 
#line 2932
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2933
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
#line 2934
} else { 
#line 2935
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2936
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
#line 2937
}  }  }  
#line 2938
(*retVal) = tmp; 
#line 2939
} 
#endif
#line 2941 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2942
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2954
::exit(___);}
#if 0
#line 2942
{ 
#line 2943
int tmp; 
#line 2944
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2945
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
#line 2946
} else { 
#line 2947
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2948
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
#line 2949
} else { 
#line 2950
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2951
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
#line 2952
}  }  }  
#line 2953
(*retVal) = make_int1(tmp); 
#line 2954
} 
#endif
#line 2956 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2957
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2969
::exit(___);}
#if 0
#line 2957
{ 
#line 2958
unsigned tmp; 
#line 2959
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2960
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
#line 2961
} else { 
#line 2962
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2963
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
#line 2964
} else { 
#line 2965
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2966
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
#line 2967
}  }  }  
#line 2968
(*retVal) = tmp; 
#line 2969
} 
#endif
#line 2971 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2972
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2984
::exit(___);}
#if 0
#line 2972
{ 
#line 2973
unsigned tmp; 
#line 2974
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2975
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
#line 2976
} else { 
#line 2977
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2978
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
#line 2979
} else { 
#line 2980
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2981
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
#line 2982
}  }  }  
#line 2983
(*retVal) = make_uint1(tmp); 
#line 2984
} 
#endif
#line 2986 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 2987
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 2999
::exit(___);}
#if 0
#line 2987
{ 
#line 2988
__int64 tmp; 
#line 2989
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 2990
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, face, x, y); 
#line 2991
} else { 
#line 2992
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 2993
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, face, x, y); 
#line 2994
} else { 
#line 2995
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 2996
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, face, x, y); 
#line 2997
}  }  }  
#line 2998
(*retVal) = tmp; 
#line 2999
} 
#endif
#line 3001 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3002
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3014
::exit(___);}
#if 0
#line 3002
{ 
#line 3003
__int64 tmp; 
#line 3004
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3005
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3006
} else { 
#line 3007
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3008
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3009
} else { 
#line 3010
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3011
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3012
}  }  }  
#line 3013
(*retVal) = make_longlong1(tmp); 
#line 3014
} 
#endif
#line 3016 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3017
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3029
::exit(___);}
#if 0
#line 3017
{ 
#line 3018
unsigned __int64 tmp; 
#line 3019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3020
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3021
} else { 
#line 3022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3023
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3024
} else { 
#line 3025
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3026
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3027
}  }  }  
#line 3028
(*retVal) = tmp; 
#line 3029
} 
#endif
#line 3031 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3032
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3044
::exit(___);}
#if 0
#line 3032
{ 
#line 3033
unsigned __int64 tmp; 
#line 3034
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3035
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3036
} else { 
#line 3037
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3038
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3039
} else { 
#line 3040
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3041
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, face, x, y); 
#line 3042
}  }  }  
#line 3043
(*retVal) = make_ulonglong1(tmp); 
#line 3044
} 
#endif
#line 3046 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3047
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3059
::exit(___);}
#if 0
#line 3047
{ 
#line 3048
float tmp; 
#line 3049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3050
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
#line 3051
} else { 
#line 3052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3053
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
#line 3054
} else { 
#line 3055
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3056
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
#line 3057
}  }  }  
#line 3058
(*retVal) = tmp; 
#line 3059
} 
#endif
#line 3061 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3062
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3074
::exit(___);}
#if 0
#line 3062
{ 
#line 3063
float tmp; 
#line 3064
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3065
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, face, x, y); 
#line 3066
} else { 
#line 3067
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3068
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, face, x, y); 
#line 3069
} else { 
#line 3070
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3071
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, face, x, y); 
#line 3072
}  }  }  
#line 3073
(*retVal) = make_float1(tmp); 
#line 3074
} 
#endif
#line 3082 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3083
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3095
::exit(___);}
#if 0
#line 3083
{ 
#line 3084
char2 tmp; 
#line 3085
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3086
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
#line 3087
} else { 
#line 3088
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3089
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
#line 3090
} else { 
#line 3091
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3092
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
#line 3093
}  }  }  
#line 3094
(*retVal) = tmp; 
#line 3095
} 
#endif
#line 3097 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3098
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3110
::exit(___);}
#if 0
#line 3098
{ 
#line 3099
uchar2 tmp; 
#line 3100
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3101
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
#line 3102
} else { 
#line 3103
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3104
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
#line 3105
} else { 
#line 3106
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3107
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, face, x, y); 
#line 3108
}  }  }  
#line 3109
(*retVal) = tmp; 
#line 3110
} 
#endif
#line 3112 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3113
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3125
::exit(___);}
#if 0
#line 3113
{ 
#line 3114
short2 tmp; 
#line 3115
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3116
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
#line 3117
} else { 
#line 3118
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3119
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
#line 3120
} else { 
#line 3121
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3122
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
#line 3123
}  }  }  
#line 3124
(*retVal) = tmp; 
#line 3125
} 
#endif
#line 3127 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3128
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3140
::exit(___);}
#if 0
#line 3128
{ 
#line 3129
ushort2 tmp; 
#line 3130
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3131
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
#line 3132
} else { 
#line 3133
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3134
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
#line 3135
} else { 
#line 3136
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3137
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, face, x, y); 
#line 3138
}  }  }  
#line 3139
(*retVal) = tmp; 
#line 3140
} 
#endif
#line 3142 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3143
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3155
::exit(___);}
#if 0
#line 3143
{ 
#line 3144
int2 tmp; 
#line 3145
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3146
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3147
} else { 
#line 3148
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3149
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3150
} else { 
#line 3151
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3152
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3153
}  }  }  
#line 3154
(*retVal) = tmp; 
#line 3155
} 
#endif
#line 3157 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3158
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3170
::exit(___);}
#if 0
#line 3158
{ 
#line 3159
uint2 tmp; 
#line 3160
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3161
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3162
} else { 
#line 3163
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3164
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3165
} else { 
#line 3166
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3167
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3168
}  }  }  
#line 3169
(*retVal) = tmp; 
#line 3170
} 
#endif
#line 3172 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3173
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3185
::exit(___);}
#if 0
#line 3173
{ 
#line 3174
longlong2 tmp; 
#line 3175
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3176
__suld_2d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, face, x, y); 
#line 3177
} else { 
#line 3178
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3179
__suld_2d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, face, x, y); 
#line 3180
} else { 
#line 3181
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3182
__suld_2d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, face, x, y); 
#line 3183
}  }  }  
#line 3184
(*retVal) = tmp; 
#line 3185
} 
#endif
#line 3187 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3188
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3200
::exit(___);}
#if 0
#line 3188
{ 
#line 3189
ulonglong2 tmp; 
#line 3190
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3191
__suld_2d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, face, x, y); 
#line 3192
} else { 
#line 3193
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3194
__suld_2d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, face, x, y); 
#line 3195
} else { 
#line 3196
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3197
__suld_2d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, face, x, y); 
#line 3198
}  }  }  
#line 3199
(*retVal) = tmp; 
#line 3200
} 
#endif
#line 3202 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3203
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3215
::exit(___);}
#if 0
#line 3203
{ 
#line 3204
float2 tmp; 
#line 3205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3206
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3207
} else { 
#line 3208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3209
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3210
} else { 
#line 3211
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3212
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, face, x, y); 
#line 3213
}  }  }  
#line 3214
(*retVal) = tmp; 
#line 3215
} 
#endif
#line 3223 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3224
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3236
::exit(___);}
#if 0
#line 3224
{ 
#line 3225
char4 tmp; 
#line 3226
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3227
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
#line 3228
} else { 
#line 3229
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3230
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
#line 3231
} else { 
#line 3232
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3233
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
#line 3234
}  }  }  
#line 3235
(*retVal) = tmp; 
#line 3236
} 
#endif
#line 3238 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3239
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3251
::exit(___);}
#if 0
#line 3239
{ 
#line 3240
uchar4 tmp; 
#line 3241
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3242
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
#line 3243
} else { 
#line 3244
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3245
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
#line 3246
} else { 
#line 3247
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3248
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, face, x, y); 
#line 3249
}  }  }  
#line 3250
(*retVal) = tmp; 
#line 3251
} 
#endif
#line 3253 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3254
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3266
::exit(___);}
#if 0
#line 3254
{ 
#line 3255
short4 tmp; 
#line 3256
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3257
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
#line 3258
} else { 
#line 3259
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3260
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
#line 3261
} else { 
#line 3262
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3263
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
#line 3264
}  }  }  
#line 3265
(*retVal) = tmp; 
#line 3266
} 
#endif
#line 3268 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3269
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3281
::exit(___);}
#if 0
#line 3269
{ 
#line 3270
ushort4 tmp; 
#line 3271
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3272
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
#line 3273
} else { 
#line 3274
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3275
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
#line 3276
} else { 
#line 3277
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3278
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, face, x, y); 
#line 3279
}  }  }  
#line 3280
(*retVal) = tmp; 
#line 3281
} 
#endif
#line 3283 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3284
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3296
::exit(___);}
#if 0
#line 3284
{ 
#line 3285
int4 tmp; 
#line 3286
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3287
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3288
} else { 
#line 3289
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3290
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3291
} else { 
#line 3292
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3293
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3294
}  }  }  
#line 3295
(*retVal) = tmp; 
#line 3296
} 
#endif
#line 3298 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3299
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3311
::exit(___);}
#if 0
#line 3299
{ 
#line 3300
uint4 tmp; 
#line 3301
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3302
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3303
} else { 
#line 3304
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3305
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3306
} else { 
#line 3307
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3308
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3309
}  }  }  
#line 3310
(*retVal) = tmp; 
#line 3311
} 
#endif
#line 3313 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 3314
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 3326
::exit(___);}
#if 0
#line 3314
{ 
#line 3315
float4 tmp; 
#line 3316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3317
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3318
} else { 
#line 3319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3320
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3321
} else { 
#line 3322
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3323
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, face, x, y); 
#line 3324
}  }  }  
#line 3325
(*retVal) = tmp; 
#line 3326
} 
#endif
#line 3334 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3335
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3347
::exit(___);}
#if 0
#line 3335
{ 
#line 3336
char tmp; 
#line 3337
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3338
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
#line 3339
} else { 
#line 3340
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3341
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
#line 3342
} else { 
#line 3343
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3344
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
#line 3345
}  }  }  
#line 3346
(*retVal) = tmp; 
#line 3347
} 
#endif
#line 3349 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(signed char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3350
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3362
::exit(___);}
#if 0
#line 3350
{ 
#line 3351
signed char tmp; 
#line 3352
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3353
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
#line 3354
} else { 
#line 3355
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3356
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
#line 3357
} else { 
#line 3358
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3359
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
#line 3360
}  }  }  
#line 3361
(*retVal) = tmp; 
#line 3362
} 
#endif
#line 3364 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(char1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3365
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3377
::exit(___);}
#if 0
#line 3365
{ 
#line 3366
char tmp; 
#line 3367
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3368
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
#line 3369
} else { 
#line 3370
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3371
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
#line 3372
} else { 
#line 3373
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3374
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
#line 3375
}  }  }  
#line 3376
(*retVal) = make_char1(tmp); 
#line 3377
} 
#endif
#line 3379 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(unsigned char *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3380
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3392
::exit(___);}
#if 0
#line 3380
{ 
#line 3381
unsigned char tmp; 
#line 3382
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3383
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
#line 3384
} else { 
#line 3385
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3386
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
#line 3387
} else { 
#line 3388
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3389
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
#line 3390
}  }  }  
#line 3391
(*retVal) = tmp; 
#line 3392
} 
#endif
#line 3394 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(uchar1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3395
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3407
::exit(___);}
#if 0
#line 3395
{ 
#line 3396
unsigned char tmp; 
#line 3397
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3398
__suld_2d_array_i8_trap((char *)(&tmp), surfObject, layerface, x, y); 
#line 3399
} else { 
#line 3400
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3401
__suld_2d_array_i8_clamp((char *)(&tmp), surfObject, layerface, x, y); 
#line 3402
} else { 
#line 3403
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3404
__suld_2d_array_i8_zero((char *)(&tmp), surfObject, layerface, x, y); 
#line 3405
}  }  }  
#line 3406
(*retVal) = make_uchar1(tmp); 
#line 3407
} 
#endif
#line 3409 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3410
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3422
::exit(___);}
#if 0
#line 3410
{ 
#line 3411
short tmp; 
#line 3412
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3413
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
#line 3414
} else { 
#line 3415
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3416
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
#line 3417
} else { 
#line 3418
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3419
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
#line 3420
}  }  }  
#line 3421
(*retVal) = tmp; 
#line 3422
} 
#endif
#line 3424 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(short1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3425
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3437
::exit(___);}
#if 0
#line 3425
{ 
#line 3426
short tmp; 
#line 3427
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3428
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
#line 3429
} else { 
#line 3430
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3431
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
#line 3432
} else { 
#line 3433
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3434
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
#line 3435
}  }  }  
#line 3436
(*retVal) = make_short1(tmp); 
#line 3437
} 
#endif
#line 3439 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(unsigned short *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3440
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3452
::exit(___);}
#if 0
#line 3440
{ 
#line 3441
unsigned short tmp; 
#line 3442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3443
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
#line 3444
} else { 
#line 3445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3446
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
#line 3447
} else { 
#line 3448
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3449
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
#line 3450
}  }  }  
#line 3451
(*retVal) = tmp; 
#line 3452
} 
#endif
#line 3454 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(ushort1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3455
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3467
::exit(___);}
#if 0
#line 3455
{ 
#line 3456
unsigned short tmp; 
#line 3457
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3458
__suld_2d_array_i16_trap((short *)(&tmp), surfObject, layerface, x, y); 
#line 3459
} else { 
#line 3460
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3461
__suld_2d_array_i16_clamp((short *)(&tmp), surfObject, layerface, x, y); 
#line 3462
} else { 
#line 3463
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3464
__suld_2d_array_i16_zero((short *)(&tmp), surfObject, layerface, x, y); 
#line 3465
}  }  }  
#line 3466
(*retVal) = make_ushort1(tmp); 
#line 3467
} 
#endif
#line 3469 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(int *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3470
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3482
::exit(___);}
#if 0
#line 3470
{ 
#line 3471
int tmp; 
#line 3472
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3473
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
#line 3474
} else { 
#line 3475
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3476
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
#line 3477
} else { 
#line 3478
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3479
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
#line 3480
}  }  }  
#line 3481
(*retVal) = tmp; 
#line 3482
} 
#endif
#line 3484 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(int1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3485
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3497
::exit(___);}
#if 0
#line 3485
{ 
#line 3486
int tmp; 
#line 3487
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3488
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
#line 3489
} else { 
#line 3490
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3491
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
#line 3492
} else { 
#line 3493
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3494
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
#line 3495
}  }  }  
#line 3496
(*retVal) = make_int1(tmp); 
#line 3497
} 
#endif
#line 3499 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(unsigned *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3500
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3512
::exit(___);}
#if 0
#line 3500
{ 
#line 3501
unsigned tmp; 
#line 3502
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3503
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
#line 3504
} else { 
#line 3505
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3506
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
#line 3507
} else { 
#line 3508
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3509
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
#line 3510
}  }  }  
#line 3511
(*retVal) = tmp; 
#line 3512
} 
#endif
#line 3514 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(uint1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3515
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3527
::exit(___);}
#if 0
#line 3515
{ 
#line 3516
unsigned tmp; 
#line 3517
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3518
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
#line 3519
} else { 
#line 3520
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3521
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
#line 3522
} else { 
#line 3523
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3524
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
#line 3525
}  }  }  
#line 3526
(*retVal) = make_uint1(tmp); 
#line 3527
} 
#endif
#line 3529 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(__int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3530
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3542
::exit(___);}
#if 0
#line 3530
{ 
#line 3531
__int64 tmp; 
#line 3532
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3533
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3534
} else { 
#line 3535
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3536
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3537
} else { 
#line 3538
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3539
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3540
}  }  }  
#line 3541
(*retVal) = tmp; 
#line 3542
} 
#endif
#line 3544 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(longlong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3545
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3557
::exit(___);}
#if 0
#line 3545
{ 
#line 3546
__int64 tmp; 
#line 3547
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3548
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3549
} else { 
#line 3550
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3551
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3552
} else { 
#line 3553
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3554
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3555
}  }  }  
#line 3556
(*retVal) = make_longlong1(tmp); 
#line 3557
} 
#endif
#line 3559 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(unsigned __int64 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3560
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3572
::exit(___);}
#if 0
#line 3560
{ 
#line 3561
unsigned __int64 tmp; 
#line 3562
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3563
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3564
} else { 
#line 3565
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3566
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3567
} else { 
#line 3568
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3569
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3570
}  }  }  
#line 3571
(*retVal) = tmp; 
#line 3572
} 
#endif
#line 3574 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(ulonglong1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3575
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3587
::exit(___);}
#if 0
#line 3575
{ 
#line 3576
unsigned __int64 tmp; 
#line 3577
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3578
__suld_2d_array_i64_trap((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3579
} else { 
#line 3580
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3581
__suld_2d_array_i64_clamp((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3582
} else { 
#line 3583
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3584
__suld_2d_array_i64_zero((__int64 *)(&tmp), surfObject, layerface, x, y); 
#line 3585
}  }  }  
#line 3586
(*retVal) = make_ulonglong1(tmp); 
#line 3587
} 
#endif
#line 3589 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(float *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3590
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3602
::exit(___);}
#if 0
#line 3590
{ 
#line 3591
float tmp; 
#line 3592
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3593
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
#line 3594
} else { 
#line 3595
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3596
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
#line 3597
} else { 
#line 3598
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3599
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
#line 3600
}  }  }  
#line 3601
(*retVal) = tmp; 
#line 3602
} 
#endif
#line 3604 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(float1 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3605
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3617
::exit(___);}
#if 0
#line 3605
{ 
#line 3606
float tmp; 
#line 3607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3608
__suld_2d_array_i32_trap((int *)(&tmp), surfObject, layerface, x, y); 
#line 3609
} else { 
#line 3610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3611
__suld_2d_array_i32_clamp((int *)(&tmp), surfObject, layerface, x, y); 
#line 3612
} else { 
#line 3613
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3614
__suld_2d_array_i32_zero((int *)(&tmp), surfObject, layerface, x, y); 
#line 3615
}  }  }  
#line 3616
(*retVal) = make_float1(tmp); 
#line 3617
} 
#endif
#line 3625 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(char2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3626
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3638
::exit(___);}
#if 0
#line 3626
{ 
#line 3627
char2 tmp; 
#line 3628
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3629
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3630
} else { 
#line 3631
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3632
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3633
} else { 
#line 3634
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3635
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3636
}  }  }  
#line 3637
(*retVal) = tmp; 
#line 3638
} 
#endif
#line 3640 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(uchar2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3641
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3653
::exit(___);}
#if 0
#line 3641
{ 
#line 3642
uchar2 tmp; 
#line 3643
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3644
__suld_2d_array_v2i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3645
} else { 
#line 3646
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3647
__suld_2d_array_v2i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3648
} else { 
#line 3649
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3650
__suld_2d_array_v2i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3651
}  }  }  
#line 3652
(*retVal) = tmp; 
#line 3653
} 
#endif
#line 3655 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(short2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3656
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3668
::exit(___);}
#if 0
#line 3656
{ 
#line 3657
short2 tmp; 
#line 3658
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3659
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3660
} else { 
#line 3661
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3662
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3663
} else { 
#line 3664
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3665
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3666
}  }  }  
#line 3667
(*retVal) = tmp; 
#line 3668
} 
#endif
#line 3670 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(ushort2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3671
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3683
::exit(___);}
#if 0
#line 3671
{ 
#line 3672
ushort2 tmp; 
#line 3673
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3674
__suld_2d_array_v2i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3675
} else { 
#line 3676
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3677
__suld_2d_array_v2i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3678
} else { 
#line 3679
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3680
__suld_2d_array_v2i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3681
}  }  }  
#line 3682
(*retVal) = tmp; 
#line 3683
} 
#endif
#line 3685 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(int2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3686
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3698
::exit(___);}
#if 0
#line 3686
{ 
#line 3687
int2 tmp; 
#line 3688
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3689
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3690
} else { 
#line 3691
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3692
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3693
} else { 
#line 3694
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3695
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3696
}  }  }  
#line 3697
(*retVal) = tmp; 
#line 3698
} 
#endif
#line 3700 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(uint2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3701
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3713
::exit(___);}
#if 0
#line 3701
{ 
#line 3702
uint2 tmp; 
#line 3703
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3704
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3705
} else { 
#line 3706
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3707
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3708
} else { 
#line 3709
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3710
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3711
}  }  }  
#line 3712
(*retVal) = tmp; 
#line 3713
} 
#endif
#line 3715 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(longlong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3716
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3728
::exit(___);}
#if 0
#line 3716
{ 
#line 3717
longlong2 tmp; 
#line 3718
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3719
__suld_2d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3720
} else { 
#line 3721
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3722
__suld_2d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3723
} else { 
#line 3724
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3725
__suld_2d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3726
}  }  }  
#line 3727
(*retVal) = tmp; 
#line 3728
} 
#endif
#line 3730 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(ulonglong2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3731
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3743
::exit(___);}
#if 0
#line 3731
{ 
#line 3732
ulonglong2 tmp; 
#line 3733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3734
__suld_2d_array_v2i64_trap((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3735
} else { 
#line 3736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3737
__suld_2d_array_v2i64_clamp((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3738
} else { 
#line 3739
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3740
__suld_2d_array_v2i64_zero((__int64 *)(&(tmp.x)), (__int64 *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3741
}  }  }  
#line 3742
(*retVal) = tmp; 
#line 3743
} 
#endif
#line 3745 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(float2 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3746
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3758
::exit(___);}
#if 0
#line 3746
{ 
#line 3747
float2 tmp; 
#line 3748
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3749
__suld_2d_array_v2i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3750
} else { 
#line 3751
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3752
__suld_2d_array_v2i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3753
} else { 
#line 3754
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3755
__suld_2d_array_v2i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), surfObject, layerface, x, y); 
#line 3756
}  }  }  
#line 3757
(*retVal) = tmp; 
#line 3758
} 
#endif
#line 3766 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(char4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3767
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3779
::exit(___);}
#if 0
#line 3767
{ 
#line 3768
char4 tmp; 
#line 3769
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3770
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3771
} else { 
#line 3772
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3773
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3774
} else { 
#line 3775
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3776
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3777
}  }  }  
#line 3778
(*retVal) = tmp; 
#line 3779
} 
#endif
#line 3781 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(uchar4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3782
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3794
::exit(___);}
#if 0
#line 3782
{ 
#line 3783
uchar4 tmp; 
#line 3784
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3785
__suld_2d_array_v4i8_trap((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3786
} else { 
#line 3787
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3788
__suld_2d_array_v4i8_clamp((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3789
} else { 
#line 3790
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3791
__suld_2d_array_v4i8_zero((char *)(&(tmp.x)), (char *)(&(tmp.y)), (char *)(&(tmp.z)), (char *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3792
}  }  }  
#line 3793
(*retVal) = tmp; 
#line 3794
} 
#endif
#line 3796 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(short4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3797
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3809
::exit(___);}
#if 0
#line 3797
{ 
#line 3798
short4 tmp; 
#line 3799
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3800
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3801
} else { 
#line 3802
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3803
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3804
} else { 
#line 3805
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3806
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3807
}  }  }  
#line 3808
(*retVal) = tmp; 
#line 3809
} 
#endif
#line 3811 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(ushort4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3812
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3824
::exit(___);}
#if 0
#line 3812
{ 
#line 3813
ushort4 tmp; 
#line 3814
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3815
__suld_2d_array_v4i16_trap((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3816
} else { 
#line 3817
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3818
__suld_2d_array_v4i16_clamp((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3819
} else { 
#line 3820
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3821
__suld_2d_array_v4i16_zero((short *)(&(tmp.x)), (short *)(&(tmp.y)), (short *)(&(tmp.z)), (short *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3822
}  }  }  
#line 3823
(*retVal) = tmp; 
#line 3824
} 
#endif
#line 3826 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(int4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3827
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3839
::exit(___);}
#if 0
#line 3827
{ 
#line 3828
int4 tmp; 
#line 3829
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3830
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3831
} else { 
#line 3832
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3833
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3834
} else { 
#line 3835
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3836
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3837
}  }  }  
#line 3838
(*retVal) = tmp; 
#line 3839
} 
#endif
#line 3841 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(uint4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3842
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3854
::exit(___);}
#if 0
#line 3842
{ 
#line 3843
uint4 tmp; 
#line 3844
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3845
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3846
} else { 
#line 3847
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3848
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3849
} else { 
#line 3850
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3851
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3852
}  }  }  
#line 3853
(*retVal) = tmp; 
#line 3854
} 
#endif
#line 3856 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredread(float4 *retVal, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 3857
{int volatile ___ = 1;(void)retVal;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 3869
::exit(___);}
#if 0
#line 3857
{ 
#line 3858
float4 tmp; 
#line 3859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3860
__suld_2d_array_v4i32_trap((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3861
} else { 
#line 3862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3863
__suld_2d_array_v4i32_clamp((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3864
} else { 
#line 3865
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3866
__suld_2d_array_v4i32_zero((int *)(&(tmp.x)), (int *)(&(tmp.y)), (int *)(&(tmp.z)), (int *)(&(tmp.w)), surfObject, layerface, x, y); 
#line 3867
}  }  }  
#line 3868
(*retVal) = tmp; 
#line 3869
} 
#endif
#line 3877 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3878
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3888
::exit(___);}
#if 0
#line 3878
{ 
#line 3879
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3880
__sust_b_1d_i8_trap(surfObject, x, data); 
#line 3881
} else { 
#line 3882
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3883
__sust_b_1d_i8_clamp(surfObject, x, data); 
#line 3884
} else { 
#line 3885
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3886
__sust_b_1d_i8_zero(surfObject, x, data); 
#line 3887
}  }  }  
#line 3888
} 
#endif
#line 3890 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3891
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3901
::exit(___);}
#if 0
#line 3891
{ 
#line 3892
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3893
__sust_b_1d_i8_trap(surfObject, x, data); 
#line 3894
} else { 
#line 3895
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3896
__sust_b_1d_i8_clamp(surfObject, x, data); 
#line 3897
} else { 
#line 3898
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3899
__sust_b_1d_i8_zero(surfObject, x, data); 
#line 3900
}  }  }  
#line 3901
} 
#endif
#line 3903 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3904
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3914
::exit(___);}
#if 0
#line 3904
{ 
#line 3905
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3906
__sust_b_1d_i8_trap(surfObject, x, data.x); 
#line 3907
} else { 
#line 3908
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3909
__sust_b_1d_i8_clamp(surfObject, x, data.x); 
#line 3910
} else { 
#line 3911
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3912
__sust_b_1d_i8_zero(surfObject, x, data.x); 
#line 3913
}  }  }  
#line 3914
} 
#endif
#line 3916 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3917
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3927
::exit(___);}
#if 0
#line 3917
{ 
#line 3918
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3919
__sust_b_1d_i8_trap(surfObject, x, data); 
#line 3920
} else { 
#line 3921
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3922
__sust_b_1d_i8_clamp(surfObject, x, data); 
#line 3923
} else { 
#line 3924
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3925
__sust_b_1d_i8_zero(surfObject, x, data); 
#line 3926
}  }  }  
#line 3927
} 
#endif
#line 3929 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3930
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3940
::exit(___);}
#if 0
#line 3930
{ 
#line 3931
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3932
__sust_b_1d_i8_trap(surfObject, x, data.x); 
#line 3933
} else { 
#line 3934
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3935
__sust_b_1d_i8_clamp(surfObject, x, data.x); 
#line 3936
} else { 
#line 3937
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3938
__sust_b_1d_i8_zero(surfObject, x, data.x); 
#line 3939
}  }  }  
#line 3940
} 
#endif
#line 3942 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3943
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3953
::exit(___);}
#if 0
#line 3943
{ 
#line 3944
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3945
__sust_b_1d_i16_trap(surfObject, x, data); 
#line 3946
} else { 
#line 3947
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3948
__sust_b_1d_i16_clamp(surfObject, x, data); 
#line 3949
} else { 
#line 3950
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3951
__sust_b_1d_i16_zero(surfObject, x, data); 
#line 3952
}  }  }  
#line 3953
} 
#endif
#line 3955 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3956
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3966
::exit(___);}
#if 0
#line 3956
{ 
#line 3957
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3958
__sust_b_1d_i16_trap(surfObject, x, data.x); 
#line 3959
} else { 
#line 3960
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3961
__sust_b_1d_i16_clamp(surfObject, x, data.x); 
#line 3962
} else { 
#line 3963
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3964
__sust_b_1d_i16_zero(surfObject, x, data.x); 
#line 3965
}  }  }  
#line 3966
} 
#endif
#line 3968 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3969
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3979
::exit(___);}
#if 0
#line 3969
{ 
#line 3970
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3971
__sust_b_1d_i16_trap(surfObject, x, data); 
#line 3972
} else { 
#line 3973
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3974
__sust_b_1d_i16_clamp(surfObject, x, data); 
#line 3975
} else { 
#line 3976
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3977
__sust_b_1d_i16_zero(surfObject, x, data); 
#line 3978
}  }  }  
#line 3979
} 
#endif
#line 3981 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3982
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 3992
::exit(___);}
#if 0
#line 3982
{ 
#line 3983
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3984
__sust_b_1d_i16_trap(surfObject, x, data.x); 
#line 3985
} else { 
#line 3986
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 3987
__sust_b_1d_i16_clamp(surfObject, x, data.x); 
#line 3988
} else { 
#line 3989
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 3990
__sust_b_1d_i16_zero(surfObject, x, data.x); 
#line 3991
}  }  }  
#line 3992
} 
#endif
#line 3994 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(int data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 3995
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4005
::exit(___);}
#if 0
#line 3995
{ 
#line 3996
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 3997
__sust_b_1d_i32_trap(surfObject, x, data); 
#line 3998
} else { 
#line 3999
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4000
__sust_b_1d_i32_clamp(surfObject, x, data); 
#line 4001
} else { 
#line 4002
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4003
__sust_b_1d_i32_zero(surfObject, x, data); 
#line 4004
}  }  }  
#line 4005
} 
#endif
#line 4007 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4008
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4018
::exit(___);}
#if 0
#line 4008
{ 
#line 4009
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4010
__sust_b_1d_i32_trap(surfObject, x, data.x); 
#line 4011
} else { 
#line 4012
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4013
__sust_b_1d_i32_clamp(surfObject, x, data.x); 
#line 4014
} else { 
#line 4015
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4016
__sust_b_1d_i32_zero(surfObject, x, data.x); 
#line 4017
}  }  }  
#line 4018
} 
#endif
#line 4020 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4021
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4031
::exit(___);}
#if 0
#line 4021
{ 
#line 4022
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4023
__sust_b_1d_i32_trap(surfObject, x, data); 
#line 4024
} else { 
#line 4025
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4026
__sust_b_1d_i32_clamp(surfObject, x, data); 
#line 4027
} else { 
#line 4028
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4029
__sust_b_1d_i32_zero(surfObject, x, data); 
#line 4030
}  }  }  
#line 4031
} 
#endif
#line 4033 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4034
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4044
::exit(___);}
#if 0
#line 4034
{ 
#line 4035
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4036
__sust_b_1d_i32_trap(surfObject, x, data.x); 
#line 4037
} else { 
#line 4038
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4039
__sust_b_1d_i32_clamp(surfObject, x, data.x); 
#line 4040
} else { 
#line 4041
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4042
__sust_b_1d_i32_zero(surfObject, x, data.x); 
#line 4043
}  }  }  
#line 4044
} 
#endif
#line 4046 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4047
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4057
::exit(___);}
#if 0
#line 4047
{ 
#line 4048
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4049
__sust_b_1d_i64_trap(surfObject, x, data); 
#line 4050
} else { 
#line 4051
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4052
__sust_b_1d_i64_clamp(surfObject, x, data); 
#line 4053
} else { 
#line 4054
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4055
__sust_b_1d_i64_zero(surfObject, x, data); 
#line 4056
}  }  }  
#line 4057
} 
#endif
#line 4059 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4060
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4070
::exit(___);}
#if 0
#line 4060
{ 
#line 4061
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4062
__sust_b_1d_i64_trap(surfObject, x, data.x); 
#line 4063
} else { 
#line 4064
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4065
__sust_b_1d_i64_clamp(surfObject, x, data.x); 
#line 4066
} else { 
#line 4067
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4068
__sust_b_1d_i64_zero(surfObject, x, data.x); 
#line 4069
}  }  }  
#line 4070
} 
#endif
#line 4072 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4073
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4083
::exit(___);}
#if 0
#line 4073
{ 
#line 4074
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4075
__sust_b_1d_i64_trap(surfObject, x, data); 
#line 4076
} else { 
#line 4077
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4078
__sust_b_1d_i64_clamp(surfObject, x, data); 
#line 4079
} else { 
#line 4080
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4081
__sust_b_1d_i64_zero(surfObject, x, data); 
#line 4082
}  }  }  
#line 4083
} 
#endif
#line 4085 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4086
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4096
::exit(___);}
#if 0
#line 4086
{ 
#line 4087
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4088
__sust_b_1d_i64_trap(surfObject, x, data.x); 
#line 4089
} else { 
#line 4090
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4091
__sust_b_1d_i64_clamp(surfObject, x, data.x); 
#line 4092
} else { 
#line 4093
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4094
__sust_b_1d_i64_zero(surfObject, x, data.x); 
#line 4095
}  }  }  
#line 4096
} 
#endif
#line 4098 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(float data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4099
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4112
::exit(___);}
#if 0
#line 4099
{ 
#line 4100
union { float f; unsigned i; } cvt; 
#line 4101
(cvt.f) = data; 
#line 4103
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4104
__sust_b_1d_i32_trap(surfObject, x, cvt.i); 
#line 4105
} else { 
#line 4106
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4107
__sust_b_1d_i32_clamp(surfObject, x, cvt.i); 
#line 4108
} else { 
#line 4109
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4110
__sust_b_1d_i32_zero(surfObject, x, cvt.i); 
#line 4111
}  }  }  
#line 4112
} 
#endif
#line 4114 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4115
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4128
::exit(___);}
#if 0
#line 4115
{ 
#line 4116
union { float f; unsigned i; } cvt; 
#line 4117
(cvt.f) = (data.x); 
#line 4119
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4120
__sust_b_1d_i32_trap(surfObject, x, cvt.i); 
#line 4121
} else { 
#line 4122
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4123
__sust_b_1d_i32_clamp(surfObject, x, cvt.i); 
#line 4124
} else { 
#line 4125
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4126
__sust_b_1d_i32_zero(surfObject, x, cvt.i); 
#line 4127
}  }  }  
#line 4128
} 
#endif
#line 4136 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4137
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4147
::exit(___);}
#if 0
#line 4137
{ 
#line 4138
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4139
__sust_b_1d_v2i8_trap(surfObject, x, make_uchar2(data.x, data.y)); 
#line 4140
} else { 
#line 4141
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4142
__sust_b_1d_v2i8_clamp(surfObject, x, make_uchar2(data.x, data.y)); 
#line 4143
} else { 
#line 4144
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4145
__sust_b_1d_v2i8_zero(surfObject, x, make_uchar2(data.x, data.y)); 
#line 4146
}  }  }  
#line 4147
} 
#endif
#line 4149 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4150
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4160
::exit(___);}
#if 0
#line 4150
{ 
#line 4151
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4152
__sust_b_1d_v2i8_trap(surfObject, x, data); 
#line 4153
} else { 
#line 4154
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4155
__sust_b_1d_v2i8_clamp(surfObject, x, data); 
#line 4156
} else { 
#line 4157
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4158
__sust_b_1d_v2i8_zero(surfObject, x, data); 
#line 4159
}  }  }  
#line 4160
} 
#endif
#line 4162 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4163
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4173
::exit(___);}
#if 0
#line 4163
{ 
#line 4164
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4165
__sust_b_1d_v2i16_trap(surfObject, x, make_ushort2(data.x, data.y)); 
#line 4166
} else { 
#line 4167
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4168
__sust_b_1d_v2i16_clamp(surfObject, x, make_ushort2(data.x, data.y)); 
#line 4169
} else { 
#line 4170
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4171
__sust_b_1d_v2i16_zero(surfObject, x, make_ushort2(data.x, data.y)); 
#line 4172
}  }  }  
#line 4173
} 
#endif
#line 4175 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4176
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4186
::exit(___);}
#if 0
#line 4176
{ 
#line 4177
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4178
__sust_b_1d_v2i16_trap(surfObject, x, data); 
#line 4179
} else { 
#line 4180
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4181
__sust_b_1d_v2i16_clamp(surfObject, x, data); 
#line 4182
} else { 
#line 4183
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4184
__sust_b_1d_v2i16_zero(surfObject, x, data); 
#line 4185
}  }  }  
#line 4186
} 
#endif
#line 4188 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4189
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4199
::exit(___);}
#if 0
#line 4189
{ 
#line 4190
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4191
__sust_b_1d_v2i32_trap(surfObject, x, make_uint2(data.x, data.y)); 
#line 4192
} else { 
#line 4193
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4194
__sust_b_1d_v2i32_clamp(surfObject, x, make_uint2(data.x, data.y)); 
#line 4195
} else { 
#line 4196
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4197
__sust_b_1d_v2i32_zero(surfObject, x, make_uint2(data.x, data.y)); 
#line 4198
}  }  }  
#line 4199
} 
#endif
#line 4201 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4202
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4212
::exit(___);}
#if 0
#line 4202
{ 
#line 4203
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4204
__sust_b_1d_v2i32_trap(surfObject, x, data); 
#line 4205
} else { 
#line 4206
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4207
__sust_b_1d_v2i32_clamp(surfObject, x, data); 
#line 4208
} else { 
#line 4209
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4210
__sust_b_1d_v2i32_zero(surfObject, x, data); 
#line 4211
}  }  }  
#line 4212
} 
#endif
#line 4214 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4215
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4225
::exit(___);}
#if 0
#line 4215
{ 
#line 4216
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4217
__sust_b_1d_v2i64_trap(surfObject, x, make_ulonglong2(data.x, data.y)); 
#line 4218
} else { 
#line 4219
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4220
__sust_b_1d_v2i64_clamp(surfObject, x, make_ulonglong2(data.x, data.y)); 
#line 4221
} else { 
#line 4222
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4223
__sust_b_1d_v2i64_zero(surfObject, x, make_ulonglong2(data.x, data.y)); 
#line 4224
}  }  }  
#line 4225
} 
#endif
#line 4227 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4228
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4238
::exit(___);}
#if 0
#line 4228
{ 
#line 4229
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4230
__sust_b_1d_v2i64_trap(surfObject, x, data); 
#line 4231
} else { 
#line 4232
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4233
__sust_b_1d_v2i64_clamp(surfObject, x, data); 
#line 4234
} else { 
#line 4235
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4236
__sust_b_1d_v2i64_zero(surfObject, x, data); 
#line 4237
}  }  }  
#line 4238
} 
#endif
#line 4240 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4241
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4254
::exit(___);}
#if 0
#line 4241
{ 
#line 4242
union { float2 f; uint2 i; } cvt; 
#line 4243
(cvt.f) = data; 
#line 4245
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4246
__sust_b_1d_v2i32_trap(surfObject, x, cvt.i); 
#line 4247
} else { 
#line 4248
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4249
__sust_b_1d_v2i32_clamp(surfObject, x, cvt.i); 
#line 4250
} else { 
#line 4251
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4252
__sust_b_1d_v2i32_zero(surfObject, x, cvt.i); 
#line 4253
}  }  }  
#line 4254
} 
#endif
#line 4262 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4263
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4273
::exit(___);}
#if 0
#line 4263
{ 
#line 4264
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4265
__sust_b_1d_v4i8_trap(surfObject, x, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 4266
} else { 
#line 4267
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4268
__sust_b_1d_v4i8_clamp(surfObject, x, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 4269
} else { 
#line 4270
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4271
__sust_b_1d_v4i8_zero(surfObject, x, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 4272
}  }  }  
#line 4273
} 
#endif
#line 4275 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4276
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4286
::exit(___);}
#if 0
#line 4276
{ 
#line 4277
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4278
__sust_b_1d_v4i8_trap(surfObject, x, data); 
#line 4279
} else { 
#line 4280
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4281
__sust_b_1d_v4i8_clamp(surfObject, x, data); 
#line 4282
} else { 
#line 4283
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4284
__sust_b_1d_v4i8_zero(surfObject, x, data); 
#line 4285
}  }  }  
#line 4286
} 
#endif
#line 4288 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4289
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4299
::exit(___);}
#if 0
#line 4289
{ 
#line 4290
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4291
__sust_b_1d_v4i16_trap(surfObject, x, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 4292
} else { 
#line 4293
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4294
__sust_b_1d_v4i16_clamp(surfObject, x, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 4295
} else { 
#line 4296
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4297
__sust_b_1d_v4i16_zero(surfObject, x, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 4298
}  }  }  
#line 4299
} 
#endif
#line 4301 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4302
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4312
::exit(___);}
#if 0
#line 4302
{ 
#line 4303
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4304
__sust_b_1d_v4i16_trap(surfObject, x, data); 
#line 4305
} else { 
#line 4306
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4307
__sust_b_1d_v4i16_clamp(surfObject, x, data); 
#line 4308
} else { 
#line 4309
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4310
__sust_b_1d_v4i16_zero(surfObject, x, data); 
#line 4311
}  }  }  
#line 4312
} 
#endif
#line 4314 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4315
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4325
::exit(___);}
#if 0
#line 4315
{ 
#line 4316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4317
__sust_b_1d_v4i32_trap(surfObject, x, make_uint4(data.x, data.y, data.z, data.w)); 
#line 4318
} else { 
#line 4319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4320
__sust_b_1d_v4i32_clamp(surfObject, x, make_uint4(data.x, data.y, data.z, data.w)); 
#line 4321
} else { 
#line 4322
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4323
__sust_b_1d_v4i32_zero(surfObject, x, make_uint4(data.x, data.y, data.z, data.w)); 
#line 4324
}  }  }  
#line 4325
} 
#endif
#line 4327 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4328
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4338
::exit(___);}
#if 0
#line 4328
{ 
#line 4329
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4330
__sust_b_1d_v4i32_trap(surfObject, x, data); 
#line 4331
} else { 
#line 4332
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4333
__sust_b_1d_v4i32_clamp(surfObject, x, data); 
#line 4334
} else { 
#line 4335
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4336
__sust_b_1d_v4i32_zero(surfObject, x, data); 
#line 4337
}  }  }  
#line 4338
} 
#endif
#line 4340 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, cudaSurfaceBoundaryMode boundaryMode) 
#line 4341
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)boundaryMode;
#line 4354
::exit(___);}
#if 0
#line 4341
{ 
#line 4342
union { float4 f; uint4 i; } cvt; 
#line 4343
(cvt.f) = data; 
#line 4345
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4346
__sust_b_1d_v4i32_trap(surfObject, x, cvt.i); 
#line 4347
} else { 
#line 4348
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4349
__sust_b_1d_v4i32_clamp(surfObject, x, cvt.i); 
#line 4350
} else { 
#line 4351
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4352
__sust_b_1d_v4i32_zero(surfObject, x, cvt.i); 
#line 4353
}  }  }  
#line 4354
} 
#endif
#line 4362 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4363
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4373
::exit(___);}
#if 0
#line 4363
{ 
#line 4364
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4365
__sust_b_2d_i8_trap(surfObject, x, y, data); 
#line 4366
} else { 
#line 4367
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4368
__sust_b_2d_i8_clamp(surfObject, x, y, data); 
#line 4369
} else { 
#line 4370
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4371
__sust_b_2d_i8_zero(surfObject, x, y, data); 
#line 4372
}  }  }  
#line 4373
} 
#endif
#line 4375 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4376
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4386
::exit(___);}
#if 0
#line 4376
{ 
#line 4377
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4378
__sust_b_2d_i8_trap(surfObject, x, y, data); 
#line 4379
} else { 
#line 4380
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4381
__sust_b_2d_i8_clamp(surfObject, x, y, data); 
#line 4382
} else { 
#line 4383
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4384
__sust_b_2d_i8_zero(surfObject, x, y, data); 
#line 4385
}  }  }  
#line 4386
} 
#endif
#line 4388 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4389
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4399
::exit(___);}
#if 0
#line 4389
{ 
#line 4390
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4391
__sust_b_2d_i8_trap(surfObject, x, y, data.x); 
#line 4392
} else { 
#line 4393
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4394
__sust_b_2d_i8_clamp(surfObject, x, y, data.x); 
#line 4395
} else { 
#line 4396
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4397
__sust_b_2d_i8_zero(surfObject, x, y, data.x); 
#line 4398
}  }  }  
#line 4399
} 
#endif
#line 4401 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4402
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4412
::exit(___);}
#if 0
#line 4402
{ 
#line 4403
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4404
__sust_b_2d_i8_trap(surfObject, x, y, data); 
#line 4405
} else { 
#line 4406
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4407
__sust_b_2d_i8_clamp(surfObject, x, y, data); 
#line 4408
} else { 
#line 4409
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4410
__sust_b_2d_i8_zero(surfObject, x, y, data); 
#line 4411
}  }  }  
#line 4412
} 
#endif
#line 4414 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4415
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4425
::exit(___);}
#if 0
#line 4415
{ 
#line 4416
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4417
__sust_b_2d_i8_trap(surfObject, x, y, data.x); 
#line 4418
} else { 
#line 4419
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4420
__sust_b_2d_i8_clamp(surfObject, x, y, data.x); 
#line 4421
} else { 
#line 4422
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4423
__sust_b_2d_i8_zero(surfObject, x, y, data.x); 
#line 4424
}  }  }  
#line 4425
} 
#endif
#line 4427 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4428
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4438
::exit(___);}
#if 0
#line 4428
{ 
#line 4429
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4430
__sust_b_2d_i16_trap(surfObject, x, y, data); 
#line 4431
} else { 
#line 4432
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4433
__sust_b_2d_i16_clamp(surfObject, x, y, data); 
#line 4434
} else { 
#line 4435
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4436
__sust_b_2d_i16_zero(surfObject, x, y, data); 
#line 4437
}  }  }  
#line 4438
} 
#endif
#line 4440 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4441
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4451
::exit(___);}
#if 0
#line 4441
{ 
#line 4442
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4443
__sust_b_2d_i16_trap(surfObject, x, y, data.x); 
#line 4444
} else { 
#line 4445
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4446
__sust_b_2d_i16_clamp(surfObject, x, y, data.x); 
#line 4447
} else { 
#line 4448
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4449
__sust_b_2d_i16_zero(surfObject, x, y, data.x); 
#line 4450
}  }  }  
#line 4451
} 
#endif
#line 4453 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4454
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4464
::exit(___);}
#if 0
#line 4454
{ 
#line 4455
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4456
__sust_b_2d_i16_trap(surfObject, x, y, data); 
#line 4457
} else { 
#line 4458
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4459
__sust_b_2d_i16_clamp(surfObject, x, y, data); 
#line 4460
} else { 
#line 4461
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4462
__sust_b_2d_i16_zero(surfObject, x, y, data); 
#line 4463
}  }  }  
#line 4464
} 
#endif
#line 4466 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4467
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4477
::exit(___);}
#if 0
#line 4467
{ 
#line 4468
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4469
__sust_b_2d_i16_trap(surfObject, x, y, data.x); 
#line 4470
} else { 
#line 4471
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4472
__sust_b_2d_i16_clamp(surfObject, x, y, data.x); 
#line 4473
} else { 
#line 4474
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4475
__sust_b_2d_i16_zero(surfObject, x, y, data.x); 
#line 4476
}  }  }  
#line 4477
} 
#endif
#line 4479 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4480
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4490
::exit(___);}
#if 0
#line 4480
{ 
#line 4481
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4482
__sust_b_2d_i32_trap(surfObject, x, y, data); 
#line 4483
} else { 
#line 4484
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4485
__sust_b_2d_i32_clamp(surfObject, x, y, data); 
#line 4486
} else { 
#line 4487
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4488
__sust_b_2d_i32_zero(surfObject, x, y, data); 
#line 4489
}  }  }  
#line 4490
} 
#endif
#line 4492 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4493
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4503
::exit(___);}
#if 0
#line 4493
{ 
#line 4494
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4495
__sust_b_2d_i32_trap(surfObject, x, y, data.x); 
#line 4496
} else { 
#line 4497
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4498
__sust_b_2d_i32_clamp(surfObject, x, y, data.x); 
#line 4499
} else { 
#line 4500
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4501
__sust_b_2d_i32_zero(surfObject, x, y, data.x); 
#line 4502
}  }  }  
#line 4503
} 
#endif
#line 4505 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4506
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4516
::exit(___);}
#if 0
#line 4506
{ 
#line 4507
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4508
__sust_b_2d_i32_trap(surfObject, x, y, data); 
#line 4509
} else { 
#line 4510
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4511
__sust_b_2d_i32_clamp(surfObject, x, y, data); 
#line 4512
} else { 
#line 4513
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4514
__sust_b_2d_i32_zero(surfObject, x, y, data); 
#line 4515
}  }  }  
#line 4516
} 
#endif
#line 4518 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4519
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4529
::exit(___);}
#if 0
#line 4519
{ 
#line 4520
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4521
__sust_b_2d_i32_trap(surfObject, x, y, data.x); 
#line 4522
} else { 
#line 4523
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4524
__sust_b_2d_i32_clamp(surfObject, x, y, data.x); 
#line 4525
} else { 
#line 4526
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4527
__sust_b_2d_i32_zero(surfObject, x, y, data.x); 
#line 4528
}  }  }  
#line 4529
} 
#endif
#line 4531 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4532
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4542
::exit(___);}
#if 0
#line 4532
{ 
#line 4533
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4534
__sust_b_2d_i64_trap(surfObject, x, y, data); 
#line 4535
} else { 
#line 4536
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4537
__sust_b_2d_i64_clamp(surfObject, x, y, data); 
#line 4538
} else { 
#line 4539
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4540
__sust_b_2d_i64_zero(surfObject, x, y, data); 
#line 4541
}  }  }  
#line 4542
} 
#endif
#line 4544 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4545
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4555
::exit(___);}
#if 0
#line 4545
{ 
#line 4546
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4547
__sust_b_2d_i64_trap(surfObject, x, y, data.x); 
#line 4548
} else { 
#line 4549
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4550
__sust_b_2d_i64_clamp(surfObject, x, y, data.x); 
#line 4551
} else { 
#line 4552
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4553
__sust_b_2d_i64_zero(surfObject, x, y, data.x); 
#line 4554
}  }  }  
#line 4555
} 
#endif
#line 4557 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4558
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4568
::exit(___);}
#if 0
#line 4558
{ 
#line 4559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4560
__sust_b_2d_i64_trap(surfObject, x, y, data); 
#line 4561
} else { 
#line 4562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4563
__sust_b_2d_i64_clamp(surfObject, x, y, data); 
#line 4564
} else { 
#line 4565
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4566
__sust_b_2d_i64_zero(surfObject, x, y, data); 
#line 4567
}  }  }  
#line 4568
} 
#endif
#line 4570 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4581
::exit(___);}
#if 0
#line 4571
{ 
#line 4572
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4573
__sust_b_2d_i64_trap(surfObject, x, y, data.x); 
#line 4574
} else { 
#line 4575
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4576
__sust_b_2d_i64_clamp(surfObject, x, y, data.x); 
#line 4577
} else { 
#line 4578
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4579
__sust_b_2d_i64_zero(surfObject, x, y, data.x); 
#line 4580
}  }  }  
#line 4581
} 
#endif
#line 4583 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4584
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4597
::exit(___);}
#if 0
#line 4584
{ 
#line 4585
union { float f; unsigned i; } cvt; 
#line 4586
(cvt.f) = data; 
#line 4588
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4589
__sust_b_2d_i32_trap(surfObject, x, y, cvt.i); 
#line 4590
} else { 
#line 4591
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4592
__sust_b_2d_i32_clamp(surfObject, x, y, cvt.i); 
#line 4593
} else { 
#line 4594
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4595
__sust_b_2d_i32_zero(surfObject, x, y, cvt.i); 
#line 4596
}  }  }  
#line 4597
} 
#endif
#line 4599 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4600
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4613
::exit(___);}
#if 0
#line 4600
{ 
#line 4601
union { float f; unsigned i; } cvt; 
#line 4602
(cvt.f) = (data.x); 
#line 4604
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4605
__sust_b_2d_i32_trap(surfObject, x, y, cvt.i); 
#line 4606
} else { 
#line 4607
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4608
__sust_b_2d_i32_clamp(surfObject, x, y, cvt.i); 
#line 4609
} else { 
#line 4610
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4611
__sust_b_2d_i32_zero(surfObject, x, y, cvt.i); 
#line 4612
}  }  }  
#line 4613
} 
#endif
#line 4621 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4622
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4632
::exit(___);}
#if 0
#line 4622
{ 
#line 4623
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4624
__sust_b_2d_v2i8_trap(surfObject, x, y, make_uchar2(data.x, data.y)); 
#line 4625
} else { 
#line 4626
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4627
__sust_b_2d_v2i8_clamp(surfObject, x, y, make_uchar2(data.x, data.y)); 
#line 4628
} else { 
#line 4629
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4630
__sust_b_2d_v2i8_zero(surfObject, x, y, make_uchar2(data.x, data.y)); 
#line 4631
}  }  }  
#line 4632
} 
#endif
#line 4634 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4635
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4645
::exit(___);}
#if 0
#line 4635
{ 
#line 4636
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4637
__sust_b_2d_v2i8_trap(surfObject, x, y, data); 
#line 4638
} else { 
#line 4639
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4640
__sust_b_2d_v2i8_clamp(surfObject, x, y, data); 
#line 4641
} else { 
#line 4642
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4643
__sust_b_2d_v2i8_zero(surfObject, x, y, data); 
#line 4644
}  }  }  
#line 4645
} 
#endif
#line 4647 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4648
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4658
::exit(___);}
#if 0
#line 4648
{ 
#line 4649
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4650
__sust_b_2d_v2i16_trap(surfObject, x, y, make_ushort2(data.x, data.y)); 
#line 4651
} else { 
#line 4652
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4653
__sust_b_2d_v2i16_clamp(surfObject, x, y, make_ushort2(data.x, data.y)); 
#line 4654
} else { 
#line 4655
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4656
__sust_b_2d_v2i16_zero(surfObject, x, y, make_ushort2(data.x, data.y)); 
#line 4657
}  }  }  
#line 4658
} 
#endif
#line 4660 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4661
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4671
::exit(___);}
#if 0
#line 4661
{ 
#line 4662
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4663
__sust_b_2d_v2i16_trap(surfObject, x, y, data); 
#line 4664
} else { 
#line 4665
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4666
__sust_b_2d_v2i16_clamp(surfObject, x, y, data); 
#line 4667
} else { 
#line 4668
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4669
__sust_b_2d_v2i16_zero(surfObject, x, y, data); 
#line 4670
}  }  }  
#line 4671
} 
#endif
#line 4673 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4674
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4684
::exit(___);}
#if 0
#line 4674
{ 
#line 4675
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4676
__sust_b_2d_v2i32_trap(surfObject, x, y, make_uint2(data.x, data.y)); 
#line 4677
} else { 
#line 4678
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4679
__sust_b_2d_v2i32_clamp(surfObject, x, y, make_uint2(data.x, data.y)); 
#line 4680
} else { 
#line 4681
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4682
__sust_b_2d_v2i32_zero(surfObject, x, y, make_uint2(data.x, data.y)); 
#line 4683
}  }  }  
#line 4684
} 
#endif
#line 4686 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4687
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4697
::exit(___);}
#if 0
#line 4687
{ 
#line 4688
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4689
__sust_b_2d_v2i32_trap(surfObject, x, y, data); 
#line 4690
} else { 
#line 4691
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4692
__sust_b_2d_v2i32_clamp(surfObject, x, y, data); 
#line 4693
} else { 
#line 4694
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4695
__sust_b_2d_v2i32_zero(surfObject, x, y, data); 
#line 4696
}  }  }  
#line 4697
} 
#endif
#line 4699 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4700
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4710
::exit(___);}
#if 0
#line 4700
{ 
#line 4701
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4702
__sust_b_2d_v2i64_trap(surfObject, x, y, make_ulonglong2(data.x, data.y)); 
#line 4703
} else { 
#line 4704
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4705
__sust_b_2d_v2i64_clamp(surfObject, x, y, make_ulonglong2(data.x, data.y)); 
#line 4706
} else { 
#line 4707
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4708
__sust_b_2d_v2i64_zero(surfObject, x, y, make_ulonglong2(data.x, data.y)); 
#line 4709
}  }  }  
#line 4710
} 
#endif
#line 4712 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4713
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4723
::exit(___);}
#if 0
#line 4713
{ 
#line 4714
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4715
__sust_b_2d_v2i64_trap(surfObject, x, y, data); 
#line 4716
} else { 
#line 4717
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4718
__sust_b_2d_v2i64_clamp(surfObject, x, y, data); 
#line 4719
} else { 
#line 4720
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4721
__sust_b_2d_v2i64_zero(surfObject, x, y, data); 
#line 4722
}  }  }  
#line 4723
} 
#endif
#line 4725 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4726
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4739
::exit(___);}
#if 0
#line 4726
{ 
#line 4727
union { float2 f; uint2 i; } cvt; 
#line 4728
(cvt.f) = data; 
#line 4730
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4731
__sust_b_2d_v2i32_trap(surfObject, x, y, cvt.i); 
#line 4732
} else { 
#line 4733
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4734
__sust_b_2d_v2i32_clamp(surfObject, x, y, cvt.i); 
#line 4735
} else { 
#line 4736
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4737
__sust_b_2d_v2i32_zero(surfObject, x, y, cvt.i); 
#line 4738
}  }  }  
#line 4739
} 
#endif
#line 4747 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4748
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4758
::exit(___);}
#if 0
#line 4748
{ 
#line 4749
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4750
__sust_b_2d_v4i8_trap(surfObject, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 4751
} else { 
#line 4752
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4753
__sust_b_2d_v4i8_clamp(surfObject, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 4754
} else { 
#line 4755
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4756
__sust_b_2d_v4i8_zero(surfObject, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 4757
}  }  }  
#line 4758
} 
#endif
#line 4760 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4761
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4771
::exit(___);}
#if 0
#line 4761
{ 
#line 4762
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4763
__sust_b_2d_v4i8_trap(surfObject, x, y, data); 
#line 4764
} else { 
#line 4765
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4766
__sust_b_2d_v4i8_clamp(surfObject, x, y, data); 
#line 4767
} else { 
#line 4768
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4769
__sust_b_2d_v4i8_zero(surfObject, x, y, data); 
#line 4770
}  }  }  
#line 4771
} 
#endif
#line 4773 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4774
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4784
::exit(___);}
#if 0
#line 4774
{ 
#line 4775
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4776
__sust_b_2d_v4i16_trap(surfObject, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 4777
} else { 
#line 4778
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4779
__sust_b_2d_v4i16_clamp(surfObject, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 4780
} else { 
#line 4781
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4782
__sust_b_2d_v4i16_zero(surfObject, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 4783
}  }  }  
#line 4784
} 
#endif
#line 4786 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4787
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4797
::exit(___);}
#if 0
#line 4787
{ 
#line 4788
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4789
__sust_b_2d_v4i16_trap(surfObject, x, y, data); 
#line 4790
} else { 
#line 4791
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4792
__sust_b_2d_v4i16_clamp(surfObject, x, y, data); 
#line 4793
} else { 
#line 4794
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4795
__sust_b_2d_v4i16_zero(surfObject, x, y, data); 
#line 4796
}  }  }  
#line 4797
} 
#endif
#line 4799 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4800
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4810
::exit(___);}
#if 0
#line 4800
{ 
#line 4801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4802
__sust_b_2d_v4i32_trap(surfObject, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 4803
} else { 
#line 4804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4805
__sust_b_2d_v4i32_clamp(surfObject, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 4806
} else { 
#line 4807
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4808
__sust_b_2d_v4i32_zero(surfObject, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 4809
}  }  }  
#line 4810
} 
#endif
#line 4812 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4813
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4823
::exit(___);}
#if 0
#line 4813
{ 
#line 4814
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4815
__sust_b_2d_v4i32_trap(surfObject, x, y, data); 
#line 4816
} else { 
#line 4817
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4818
__sust_b_2d_v4i32_clamp(surfObject, x, y, data); 
#line 4819
} else { 
#line 4820
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4821
__sust_b_2d_v4i32_zero(surfObject, x, y, data); 
#line 4822
}  }  }  
#line 4823
} 
#endif
#line 4825 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, cudaSurfaceBoundaryMode boundaryMode) 
#line 4826
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)boundaryMode;
#line 4839
::exit(___);}
#if 0
#line 4826
{ 
#line 4827
union { float4 f; uint4 i; } cvt; 
#line 4828
(cvt.f) = data; 
#line 4830
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4831
__sust_b_2d_v4i32_trap(surfObject, x, y, cvt.i); 
#line 4832
} else { 
#line 4833
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4834
__sust_b_2d_v4i32_clamp(surfObject, x, y, cvt.i); 
#line 4835
} else { 
#line 4836
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4837
__sust_b_2d_v4i32_zero(surfObject, x, y, cvt.i); 
#line 4838
}  }  }  
#line 4839
} 
#endif
#line 4848 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4849
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4859
::exit(___);}
#if 0
#line 4849
{ 
#line 4850
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4851
__sust_b_3d_i8_trap(surfObject, x, y, z, data); 
#line 4852
} else { 
#line 4853
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4854
__sust_b_3d_i8_clamp(surfObject, x, y, z, data); 
#line 4855
} else { 
#line 4856
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4857
__sust_b_3d_i8_zero(surfObject, x, y, z, data); 
#line 4858
}  }  }  
#line 4859
} 
#endif
#line 4861 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4862
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4872
::exit(___);}
#if 0
#line 4862
{ 
#line 4863
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4864
__sust_b_3d_i8_trap(surfObject, x, y, z, data); 
#line 4865
} else { 
#line 4866
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4867
__sust_b_3d_i8_clamp(surfObject, x, y, z, data); 
#line 4868
} else { 
#line 4869
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4870
__sust_b_3d_i8_zero(surfObject, x, y, z, data); 
#line 4871
}  }  }  
#line 4872
} 
#endif
#line 4874 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4875
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4885
::exit(___);}
#if 0
#line 4875
{ 
#line 4876
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4877
__sust_b_3d_i8_trap(surfObject, x, y, z, data.x); 
#line 4878
} else { 
#line 4879
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4880
__sust_b_3d_i8_clamp(surfObject, x, y, z, data.x); 
#line 4881
} else { 
#line 4882
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4883
__sust_b_3d_i8_zero(surfObject, x, y, z, data.x); 
#line 4884
}  }  }  
#line 4885
} 
#endif
#line 4887 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4888
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4898
::exit(___);}
#if 0
#line 4888
{ 
#line 4889
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4890
__sust_b_3d_i8_trap(surfObject, x, y, z, data); 
#line 4891
} else { 
#line 4892
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4893
__sust_b_3d_i8_clamp(surfObject, x, y, z, data); 
#line 4894
} else { 
#line 4895
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4896
__sust_b_3d_i8_zero(surfObject, x, y, z, data); 
#line 4897
}  }  }  
#line 4898
} 
#endif
#line 4900 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4901
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4911
::exit(___);}
#if 0
#line 4901
{ 
#line 4902
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4903
__sust_b_3d_i8_trap(surfObject, x, y, z, data.x); 
#line 4904
} else { 
#line 4905
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4906
__sust_b_3d_i8_clamp(surfObject, x, y, z, data.x); 
#line 4907
} else { 
#line 4908
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4909
__sust_b_3d_i8_zero(surfObject, x, y, z, data.x); 
#line 4910
}  }  }  
#line 4911
} 
#endif
#line 4913 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4914
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4924
::exit(___);}
#if 0
#line 4914
{ 
#line 4915
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4916
__sust_b_3d_i16_trap(surfObject, x, y, z, data); 
#line 4917
} else { 
#line 4918
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4919
__sust_b_3d_i16_clamp(surfObject, x, y, z, data); 
#line 4920
} else { 
#line 4921
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4922
__sust_b_3d_i16_zero(surfObject, x, y, z, data); 
#line 4923
}  }  }  
#line 4924
} 
#endif
#line 4926 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4927
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4937
::exit(___);}
#if 0
#line 4927
{ 
#line 4928
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4929
__sust_b_3d_i16_trap(surfObject, x, y, z, data.x); 
#line 4930
} else { 
#line 4931
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4932
__sust_b_3d_i16_clamp(surfObject, x, y, z, data.x); 
#line 4933
} else { 
#line 4934
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4935
__sust_b_3d_i16_zero(surfObject, x, y, z, data.x); 
#line 4936
}  }  }  
#line 4937
} 
#endif
#line 4939 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4940
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4950
::exit(___);}
#if 0
#line 4940
{ 
#line 4941
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4942
__sust_b_3d_i16_trap(surfObject, x, y, z, data); 
#line 4943
} else { 
#line 4944
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4945
__sust_b_3d_i16_clamp(surfObject, x, y, z, data); 
#line 4946
} else { 
#line 4947
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4948
__sust_b_3d_i16_zero(surfObject, x, y, z, data); 
#line 4949
}  }  }  
#line 4950
} 
#endif
#line 4952 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4953
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4963
::exit(___);}
#if 0
#line 4953
{ 
#line 4954
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4955
__sust_b_3d_i16_trap(surfObject, x, y, z, data.x); 
#line 4956
} else { 
#line 4957
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4958
__sust_b_3d_i16_clamp(surfObject, x, y, z, data.x); 
#line 4959
} else { 
#line 4960
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4961
__sust_b_3d_i16_zero(surfObject, x, y, z, data.x); 
#line 4962
}  }  }  
#line 4963
} 
#endif
#line 4965 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4966
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4976
::exit(___);}
#if 0
#line 4966
{ 
#line 4967
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4968
__sust_b_3d_i32_trap(surfObject, x, y, z, data); 
#line 4969
} else { 
#line 4970
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4971
__sust_b_3d_i32_clamp(surfObject, x, y, z, data); 
#line 4972
} else { 
#line 4973
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4974
__sust_b_3d_i32_zero(surfObject, x, y, z, data); 
#line 4975
}  }  }  
#line 4976
} 
#endif
#line 4978 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4979
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 4989
::exit(___);}
#if 0
#line 4979
{ 
#line 4980
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4981
__sust_b_3d_i32_trap(surfObject, x, y, z, data.x); 
#line 4982
} else { 
#line 4983
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4984
__sust_b_3d_i32_clamp(surfObject, x, y, z, data.x); 
#line 4985
} else { 
#line 4986
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 4987
__sust_b_3d_i32_zero(surfObject, x, y, z, data.x); 
#line 4988
}  }  }  
#line 4989
} 
#endif
#line 4991 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 4992
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5002
::exit(___);}
#if 0
#line 4992
{ 
#line 4993
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 4994
__sust_b_3d_i32_trap(surfObject, x, y, z, data); 
#line 4995
} else { 
#line 4996
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 4997
__sust_b_3d_i32_clamp(surfObject, x, y, z, data); 
#line 4998
} else { 
#line 4999
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5000
__sust_b_3d_i32_zero(surfObject, x, y, z, data); 
#line 5001
}  }  }  
#line 5002
} 
#endif
#line 5004 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5005
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5015
::exit(___);}
#if 0
#line 5005
{ 
#line 5006
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5007
__sust_b_3d_i32_trap(surfObject, x, y, z, data.x); 
#line 5008
} else { 
#line 5009
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5010
__sust_b_3d_i32_clamp(surfObject, x, y, z, data.x); 
#line 5011
} else { 
#line 5012
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5013
__sust_b_3d_i32_zero(surfObject, x, y, z, data.x); 
#line 5014
}  }  }  
#line 5015
} 
#endif
#line 5017 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5018
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5028
::exit(___);}
#if 0
#line 5018
{ 
#line 5019
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5020
__sust_b_3d_i64_trap(surfObject, x, y, z, data); 
#line 5021
} else { 
#line 5022
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5023
__sust_b_3d_i64_clamp(surfObject, x, y, z, data); 
#line 5024
} else { 
#line 5025
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5026
__sust_b_3d_i64_zero(surfObject, x, y, z, data); 
#line 5027
}  }  }  
#line 5028
} 
#endif
#line 5030 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5031
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5041
::exit(___);}
#if 0
#line 5031
{ 
#line 5032
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5033
__sust_b_3d_i64_trap(surfObject, x, y, z, data.x); 
#line 5034
} else { 
#line 5035
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5036
__sust_b_3d_i64_clamp(surfObject, x, y, z, data.x); 
#line 5037
} else { 
#line 5038
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5039
__sust_b_3d_i64_zero(surfObject, x, y, z, data.x); 
#line 5040
}  }  }  
#line 5041
} 
#endif
#line 5043 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5044
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5054
::exit(___);}
#if 0
#line 5044
{ 
#line 5045
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5046
__sust_b_3d_i64_trap(surfObject, x, y, z, data); 
#line 5047
} else { 
#line 5048
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5049
__sust_b_3d_i64_clamp(surfObject, x, y, z, data); 
#line 5050
} else { 
#line 5051
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5052
__sust_b_3d_i64_zero(surfObject, x, y, z, data); 
#line 5053
}  }  }  
#line 5054
} 
#endif
#line 5056 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5057
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5067
::exit(___);}
#if 0
#line 5057
{ 
#line 5058
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5059
__sust_b_3d_i64_trap(surfObject, x, y, z, data.x); 
#line 5060
} else { 
#line 5061
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5062
__sust_b_3d_i64_clamp(surfObject, x, y, z, data.x); 
#line 5063
} else { 
#line 5064
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5065
__sust_b_3d_i64_zero(surfObject, x, y, z, data.x); 
#line 5066
}  }  }  
#line 5067
} 
#endif
#line 5069 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5070
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5083
::exit(___);}
#if 0
#line 5070
{ 
#line 5071
union { float f; unsigned i; } cvt; 
#line 5072
(cvt.f) = data; 
#line 5074
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5075
__sust_b_3d_i32_trap(surfObject, x, y, z, cvt.i); 
#line 5076
} else { 
#line 5077
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5078
__sust_b_3d_i32_clamp(surfObject, x, y, z, cvt.i); 
#line 5079
} else { 
#line 5080
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5081
__sust_b_3d_i32_zero(surfObject, x, y, z, cvt.i); 
#line 5082
}  }  }  
#line 5083
} 
#endif
#line 5085 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5086
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5099
::exit(___);}
#if 0
#line 5086
{ 
#line 5087
union { float f; unsigned i; } cvt; 
#line 5088
(cvt.f) = (data.x); 
#line 5090
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5091
__sust_b_3d_i32_trap(surfObject, x, y, z, cvt.i); 
#line 5092
} else { 
#line 5093
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5094
__sust_b_3d_i32_clamp(surfObject, x, y, z, cvt.i); 
#line 5095
} else { 
#line 5096
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5097
__sust_b_3d_i32_zero(surfObject, x, y, z, cvt.i); 
#line 5098
}  }  }  
#line 5099
} 
#endif
#line 5107 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5108
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5118
::exit(___);}
#if 0
#line 5108
{ 
#line 5109
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5110
__sust_b_3d_v2i8_trap(surfObject, x, y, z, make_uchar2(data.x, data.y)); 
#line 5111
} else { 
#line 5112
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5113
__sust_b_3d_v2i8_clamp(surfObject, x, y, z, make_uchar2(data.x, data.y)); 
#line 5114
} else { 
#line 5115
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5116
__sust_b_3d_v2i8_zero(surfObject, x, y, z, make_uchar2(data.x, data.y)); 
#line 5117
}  }  }  
#line 5118
} 
#endif
#line 5120 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5121
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5131
::exit(___);}
#if 0
#line 5121
{ 
#line 5122
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5123
__sust_b_3d_v2i8_trap(surfObject, x, y, z, data); 
#line 5124
} else { 
#line 5125
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5126
__sust_b_3d_v2i8_clamp(surfObject, x, y, z, data); 
#line 5127
} else { 
#line 5128
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5129
__sust_b_3d_v2i8_zero(surfObject, x, y, z, data); 
#line 5130
}  }  }  
#line 5131
} 
#endif
#line 5133 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5134
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5144
::exit(___);}
#if 0
#line 5134
{ 
#line 5135
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5136
__sust_b_3d_v2i16_trap(surfObject, x, y, z, make_ushort2(data.x, data.y)); 
#line 5137
} else { 
#line 5138
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5139
__sust_b_3d_v2i16_clamp(surfObject, x, y, z, make_ushort2(data.x, data.y)); 
#line 5140
} else { 
#line 5141
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5142
__sust_b_3d_v2i16_zero(surfObject, x, y, z, make_ushort2(data.x, data.y)); 
#line 5143
}  }  }  
#line 5144
} 
#endif
#line 5146 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5147
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5157
::exit(___);}
#if 0
#line 5147
{ 
#line 5148
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5149
__sust_b_3d_v2i16_trap(surfObject, x, y, z, data); 
#line 5150
} else { 
#line 5151
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5152
__sust_b_3d_v2i16_clamp(surfObject, x, y, z, data); 
#line 5153
} else { 
#line 5154
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5155
__sust_b_3d_v2i16_zero(surfObject, x, y, z, data); 
#line 5156
}  }  }  
#line 5157
} 
#endif
#line 5159 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5160
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5170
::exit(___);}
#if 0
#line 5160
{ 
#line 5161
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5162
__sust_b_3d_v2i32_trap(surfObject, x, y, z, make_uint2(data.x, data.y)); 
#line 5163
} else { 
#line 5164
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5165
__sust_b_3d_v2i32_clamp(surfObject, x, y, z, make_uint2(data.x, data.y)); 
#line 5166
} else { 
#line 5167
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5168
__sust_b_3d_v2i32_zero(surfObject, x, y, z, make_uint2(data.x, data.y)); 
#line 5169
}  }  }  
#line 5170
} 
#endif
#line 5172 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5173
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5183
::exit(___);}
#if 0
#line 5173
{ 
#line 5174
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5175
__sust_b_3d_v2i32_trap(surfObject, x, y, z, data); 
#line 5176
} else { 
#line 5177
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5178
__sust_b_3d_v2i32_clamp(surfObject, x, y, z, data); 
#line 5179
} else { 
#line 5180
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5181
__sust_b_3d_v2i32_zero(surfObject, x, y, z, data); 
#line 5182
}  }  }  
#line 5183
} 
#endif
#line 5185 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5186
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5196
::exit(___);}
#if 0
#line 5186
{ 
#line 5187
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5188
__sust_b_3d_v2i64_trap(surfObject, x, y, z, make_ulonglong2(data.x, data.y)); 
#line 5189
} else { 
#line 5190
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5191
__sust_b_3d_v2i64_clamp(surfObject, x, y, z, make_ulonglong2(data.x, data.y)); 
#line 5192
} else { 
#line 5193
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5194
__sust_b_3d_v2i64_zero(surfObject, x, y, z, make_ulonglong2(data.x, data.y)); 
#line 5195
}  }  }  
#line 5196
} 
#endif
#line 5198 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5199
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5209
::exit(___);}
#if 0
#line 5199
{ 
#line 5200
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5201
__sust_b_3d_v2i64_trap(surfObject, x, y, z, data); 
#line 5202
} else { 
#line 5203
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5204
__sust_b_3d_v2i64_clamp(surfObject, x, y, z, data); 
#line 5205
} else { 
#line 5206
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5207
__sust_b_3d_v2i64_zero(surfObject, x, y, z, data); 
#line 5208
}  }  }  
#line 5209
} 
#endif
#line 5211 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5212
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5225
::exit(___);}
#if 0
#line 5212
{ 
#line 5213
union { float2 f; uint2 i; } cvt; 
#line 5214
(cvt.f) = data; 
#line 5216
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5217
__sust_b_3d_v2i32_trap(surfObject, x, y, z, cvt.i); 
#line 5218
} else { 
#line 5219
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5220
__sust_b_3d_v2i32_clamp(surfObject, x, y, z, cvt.i); 
#line 5221
} else { 
#line 5222
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5223
__sust_b_3d_v2i32_zero(surfObject, x, y, z, cvt.i); 
#line 5224
}  }  }  
#line 5225
} 
#endif
#line 5233 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5234
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5244
::exit(___);}
#if 0
#line 5234
{ 
#line 5235
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5236
__sust_b_3d_v4i8_trap(surfObject, x, y, z, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 5237
} else { 
#line 5238
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5239
__sust_b_3d_v4i8_clamp(surfObject, x, y, z, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 5240
} else { 
#line 5241
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5242
__sust_b_3d_v4i8_zero(surfObject, x, y, z, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 5243
}  }  }  
#line 5244
} 
#endif
#line 5246 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5247
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5257
::exit(___);}
#if 0
#line 5247
{ 
#line 5248
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5249
__sust_b_3d_v4i8_trap(surfObject, x, y, z, data); 
#line 5250
} else { 
#line 5251
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5252
__sust_b_3d_v4i8_clamp(surfObject, x, y, z, data); 
#line 5253
} else { 
#line 5254
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5255
__sust_b_3d_v4i8_zero(surfObject, x, y, z, data); 
#line 5256
}  }  }  
#line 5257
} 
#endif
#line 5259 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5260
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5270
::exit(___);}
#if 0
#line 5260
{ 
#line 5261
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5262
__sust_b_3d_v4i16_trap(surfObject, x, y, z, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 5263
} else { 
#line 5264
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5265
__sust_b_3d_v4i16_clamp(surfObject, x, y, z, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 5266
} else { 
#line 5267
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5268
__sust_b_3d_v4i16_zero(surfObject, x, y, z, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 5269
}  }  }  
#line 5270
} 
#endif
#line 5272 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5273
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5283
::exit(___);}
#if 0
#line 5273
{ 
#line 5274
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5275
__sust_b_3d_v4i16_trap(surfObject, x, y, z, data); 
#line 5276
} else { 
#line 5277
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5278
__sust_b_3d_v4i16_clamp(surfObject, x, y, z, data); 
#line 5279
} else { 
#line 5280
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5281
__sust_b_3d_v4i16_zero(surfObject, x, y, z, data); 
#line 5282
}  }  }  
#line 5283
} 
#endif
#line 5285 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5286
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5296
::exit(___);}
#if 0
#line 5286
{ 
#line 5287
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5288
__sust_b_3d_v4i32_trap(surfObject, x, y, z, make_uint4(data.x, data.y, data.z, data.w)); 
#line 5289
} else { 
#line 5290
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5291
__sust_b_3d_v4i32_clamp(surfObject, x, y, z, make_uint4(data.x, data.y, data.z, data.w)); 
#line 5292
} else { 
#line 5293
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5294
__sust_b_3d_v4i32_zero(surfObject, x, y, z, make_uint4(data.x, data.y, data.z, data.w)); 
#line 5295
}  }  }  
#line 5296
} 
#endif
#line 5298 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5299
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5309
::exit(___);}
#if 0
#line 5299
{ 
#line 5300
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5301
__sust_b_3d_v4i32_trap(surfObject, x, y, z, data); 
#line 5302
} else { 
#line 5303
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5304
__sust_b_3d_v4i32_clamp(surfObject, x, y, z, data); 
#line 5305
} else { 
#line 5306
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5307
__sust_b_3d_v4i32_zero(surfObject, x, y, z, data); 
#line 5308
}  }  }  
#line 5309
} 
#endif
#line 5311 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf3Dwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int z, cudaSurfaceBoundaryMode boundaryMode) 
#line 5312
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)z;(void)boundaryMode;
#line 5325
::exit(___);}
#if 0
#line 5312
{ 
#line 5313
union { float4 f; uint4 i; } cvt; 
#line 5314
(cvt.f) = data; 
#line 5316
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5317
__sust_b_3d_v4i32_trap(surfObject, x, y, z, cvt.i); 
#line 5318
} else { 
#line 5319
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5320
__sust_b_3d_v4i32_clamp(surfObject, x, y, z, cvt.i); 
#line 5321
} else { 
#line 5322
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5323
__sust_b_3d_v4i32_zero(surfObject, x, y, z, cvt.i); 
#line 5324
}  }  }  
#line 5325
} 
#endif
#line 5333 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5334
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5344
::exit(___);}
#if 0
#line 5334
{ 
#line 5335
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5336
__sust_b_1d_array_i8_trap(surfObject, layer, x, data); 
#line 5337
} else { 
#line 5338
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5339
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data); 
#line 5340
} else { 
#line 5341
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5342
__sust_b_1d_array_i8_zero(surfObject, layer, x, data); 
#line 5343
}  }  }  
#line 5344
} 
#endif
#line 5346 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5347
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5357
::exit(___);}
#if 0
#line 5347
{ 
#line 5348
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5349
__sust_b_1d_array_i8_trap(surfObject, layer, x, data); 
#line 5350
} else { 
#line 5351
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5352
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data); 
#line 5353
} else { 
#line 5354
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5355
__sust_b_1d_array_i8_zero(surfObject, layer, x, data); 
#line 5356
}  }  }  
#line 5357
} 
#endif
#line 5359 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5360
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5370
::exit(___);}
#if 0
#line 5360
{ 
#line 5361
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5362
__sust_b_1d_array_i8_trap(surfObject, layer, x, data.x); 
#line 5363
} else { 
#line 5364
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5365
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data.x); 
#line 5366
} else { 
#line 5367
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5368
__sust_b_1d_array_i8_zero(surfObject, layer, x, data.x); 
#line 5369
}  }  }  
#line 5370
} 
#endif
#line 5372 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5373
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5383
::exit(___);}
#if 0
#line 5373
{ 
#line 5374
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5375
__sust_b_1d_array_i8_trap(surfObject, layer, x, data); 
#line 5376
} else { 
#line 5377
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5378
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data); 
#line 5379
} else { 
#line 5380
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5381
__sust_b_1d_array_i8_zero(surfObject, layer, x, data); 
#line 5382
}  }  }  
#line 5383
} 
#endif
#line 5385 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5386
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5396
::exit(___);}
#if 0
#line 5386
{ 
#line 5387
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5388
__sust_b_1d_array_i8_trap(surfObject, layer, x, data.x); 
#line 5389
} else { 
#line 5390
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5391
__sust_b_1d_array_i8_clamp(surfObject, layer, x, data.x); 
#line 5392
} else { 
#line 5393
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5394
__sust_b_1d_array_i8_zero(surfObject, layer, x, data.x); 
#line 5395
}  }  }  
#line 5396
} 
#endif
#line 5398 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5399
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5409
::exit(___);}
#if 0
#line 5399
{ 
#line 5400
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5401
__sust_b_1d_array_i16_trap(surfObject, layer, x, data); 
#line 5402
} else { 
#line 5403
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5404
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data); 
#line 5405
} else { 
#line 5406
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5407
__sust_b_1d_array_i16_zero(surfObject, layer, x, data); 
#line 5408
}  }  }  
#line 5409
} 
#endif
#line 5411 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5412
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5422
::exit(___);}
#if 0
#line 5412
{ 
#line 5413
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5414
__sust_b_1d_array_i16_trap(surfObject, layer, x, data.x); 
#line 5415
} else { 
#line 5416
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5417
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data.x); 
#line 5418
} else { 
#line 5419
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5420
__sust_b_1d_array_i16_zero(surfObject, layer, x, data.x); 
#line 5421
}  }  }  
#line 5422
} 
#endif
#line 5424 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5425
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5435
::exit(___);}
#if 0
#line 5425
{ 
#line 5426
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5427
__sust_b_1d_array_i16_trap(surfObject, layer, x, data); 
#line 5428
} else { 
#line 5429
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5430
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data); 
#line 5431
} else { 
#line 5432
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5433
__sust_b_1d_array_i16_zero(surfObject, layer, x, data); 
#line 5434
}  }  }  
#line 5435
} 
#endif
#line 5437 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5438
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5448
::exit(___);}
#if 0
#line 5438
{ 
#line 5439
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5440
__sust_b_1d_array_i16_trap(surfObject, layer, x, data.x); 
#line 5441
} else { 
#line 5442
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5443
__sust_b_1d_array_i16_clamp(surfObject, layer, x, data.x); 
#line 5444
} else { 
#line 5445
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5446
__sust_b_1d_array_i16_zero(surfObject, layer, x, data.x); 
#line 5447
}  }  }  
#line 5448
} 
#endif
#line 5450 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5451
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5461
::exit(___);}
#if 0
#line 5451
{ 
#line 5452
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5453
__sust_b_1d_array_i32_trap(surfObject, layer, x, data); 
#line 5454
} else { 
#line 5455
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5456
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data); 
#line 5457
} else { 
#line 5458
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5459
__sust_b_1d_array_i32_zero(surfObject, layer, x, data); 
#line 5460
}  }  }  
#line 5461
} 
#endif
#line 5463 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5464
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5474
::exit(___);}
#if 0
#line 5464
{ 
#line 5465
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5466
__sust_b_1d_array_i32_trap(surfObject, layer, x, data.x); 
#line 5467
} else { 
#line 5468
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5469
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data.x); 
#line 5470
} else { 
#line 5471
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5472
__sust_b_1d_array_i32_zero(surfObject, layer, x, data.x); 
#line 5473
}  }  }  
#line 5474
} 
#endif
#line 5476 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5477
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5487
::exit(___);}
#if 0
#line 5477
{ 
#line 5478
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5479
__sust_b_1d_array_i32_trap(surfObject, layer, x, data); 
#line 5480
} else { 
#line 5481
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5482
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data); 
#line 5483
} else { 
#line 5484
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5485
__sust_b_1d_array_i32_zero(surfObject, layer, x, data); 
#line 5486
}  }  }  
#line 5487
} 
#endif
#line 5489 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5490
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5500
::exit(___);}
#if 0
#line 5490
{ 
#line 5491
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5492
__sust_b_1d_array_i32_trap(surfObject, layer, x, data.x); 
#line 5493
} else { 
#line 5494
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5495
__sust_b_1d_array_i32_clamp(surfObject, layer, x, data.x); 
#line 5496
} else { 
#line 5497
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5498
__sust_b_1d_array_i32_zero(surfObject, layer, x, data.x); 
#line 5499
}  }  }  
#line 5500
} 
#endif
#line 5502 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5503
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5513
::exit(___);}
#if 0
#line 5503
{ 
#line 5504
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5505
__sust_b_1d_array_i64_trap(surfObject, layer, x, data); 
#line 5506
} else { 
#line 5507
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5508
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data); 
#line 5509
} else { 
#line 5510
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5511
__sust_b_1d_array_i64_zero(surfObject, layer, x, data); 
#line 5512
}  }  }  
#line 5513
} 
#endif
#line 5515 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5516
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5526
::exit(___);}
#if 0
#line 5516
{ 
#line 5517
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5518
__sust_b_1d_array_i64_trap(surfObject, layer, x, data.x); 
#line 5519
} else { 
#line 5520
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5521
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data.x); 
#line 5522
} else { 
#line 5523
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5524
__sust_b_1d_array_i64_zero(surfObject, layer, x, data.x); 
#line 5525
}  }  }  
#line 5526
} 
#endif
#line 5528 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5529
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5539
::exit(___);}
#if 0
#line 5529
{ 
#line 5530
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5531
__sust_b_1d_array_i64_trap(surfObject, layer, x, data); 
#line 5532
} else { 
#line 5533
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5534
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data); 
#line 5535
} else { 
#line 5536
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5537
__sust_b_1d_array_i64_zero(surfObject, layer, x, data); 
#line 5538
}  }  }  
#line 5539
} 
#endif
#line 5541 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5542
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5552
::exit(___);}
#if 0
#line 5542
{ 
#line 5543
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5544
__sust_b_1d_array_i64_trap(surfObject, layer, x, data.x); 
#line 5545
} else { 
#line 5546
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5547
__sust_b_1d_array_i64_clamp(surfObject, layer, x, data.x); 
#line 5548
} else { 
#line 5549
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5550
__sust_b_1d_array_i64_zero(surfObject, layer, x, data.x); 
#line 5551
}  }  }  
#line 5552
} 
#endif
#line 5554 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5555
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5568
::exit(___);}
#if 0
#line 5555
{ 
#line 5556
union { float f; unsigned i; } cvt; 
#line 5557
(cvt.f) = data; 
#line 5559
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5560
__sust_b_1d_array_i32_trap(surfObject, layer, x, cvt.i); 
#line 5561
} else { 
#line 5562
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5563
__sust_b_1d_array_i32_clamp(surfObject, layer, x, cvt.i); 
#line 5564
} else { 
#line 5565
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5566
__sust_b_1d_array_i32_zero(surfObject, layer, x, cvt.i); 
#line 5567
}  }  }  
#line 5568
} 
#endif
#line 5570 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5571
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5584
::exit(___);}
#if 0
#line 5571
{ 
#line 5572
union { float f; unsigned i; } cvt; 
#line 5573
(cvt.f) = (data.x); 
#line 5575
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5576
__sust_b_1d_array_i32_trap(surfObject, layer, x, cvt.i); 
#line 5577
} else { 
#line 5578
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5579
__sust_b_1d_array_i32_clamp(surfObject, layer, x, cvt.i); 
#line 5580
} else { 
#line 5581
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5582
__sust_b_1d_array_i32_zero(surfObject, layer, x, cvt.i); 
#line 5583
}  }  }  
#line 5584
} 
#endif
#line 5592 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5593
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5603
::exit(___);}
#if 0
#line 5593
{ 
#line 5594
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5595
__sust_b_1d_array_v2i8_trap(surfObject, layer, x, make_uchar2(data.x, data.y)); 
#line 5596
} else { 
#line 5597
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5598
__sust_b_1d_array_v2i8_clamp(surfObject, layer, x, make_uchar2(data.x, data.y)); 
#line 5599
} else { 
#line 5600
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5601
__sust_b_1d_array_v2i8_zero(surfObject, layer, x, make_uchar2(data.x, data.y)); 
#line 5602
}  }  }  
#line 5603
} 
#endif
#line 5605 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5606
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5616
::exit(___);}
#if 0
#line 5606
{ 
#line 5607
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5608
__sust_b_1d_array_v2i8_trap(surfObject, layer, x, data); 
#line 5609
} else { 
#line 5610
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5611
__sust_b_1d_array_v2i8_clamp(surfObject, layer, x, data); 
#line 5612
} else { 
#line 5613
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5614
__sust_b_1d_array_v2i8_zero(surfObject, layer, x, data); 
#line 5615
}  }  }  
#line 5616
} 
#endif
#line 5618 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5619
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5629
::exit(___);}
#if 0
#line 5619
{ 
#line 5620
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5621
__sust_b_1d_array_v2i16_trap(surfObject, layer, x, make_ushort2(data.x, data.y)); 
#line 5622
} else { 
#line 5623
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5624
__sust_b_1d_array_v2i16_clamp(surfObject, layer, x, make_ushort2(data.x, data.y)); 
#line 5625
} else { 
#line 5626
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5627
__sust_b_1d_array_v2i16_zero(surfObject, layer, x, make_ushort2(data.x, data.y)); 
#line 5628
}  }  }  
#line 5629
} 
#endif
#line 5631 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5632
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5642
::exit(___);}
#if 0
#line 5632
{ 
#line 5633
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5634
__sust_b_1d_array_v2i16_trap(surfObject, layer, x, data); 
#line 5635
} else { 
#line 5636
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5637
__sust_b_1d_array_v2i16_clamp(surfObject, layer, x, data); 
#line 5638
} else { 
#line 5639
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5640
__sust_b_1d_array_v2i16_zero(surfObject, layer, x, data); 
#line 5641
}  }  }  
#line 5642
} 
#endif
#line 5644 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5645
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5655
::exit(___);}
#if 0
#line 5645
{ 
#line 5646
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5647
__sust_b_1d_array_v2i32_trap(surfObject, layer, x, make_uint2(data.x, data.y)); 
#line 5648
} else { 
#line 5649
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5650
__sust_b_1d_array_v2i32_clamp(surfObject, layer, x, make_uint2(data.x, data.y)); 
#line 5651
} else { 
#line 5652
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5653
__sust_b_1d_array_v2i32_zero(surfObject, layer, x, make_uint2(data.x, data.y)); 
#line 5654
}  }  }  
#line 5655
} 
#endif
#line 5657 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5658
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5668
::exit(___);}
#if 0
#line 5658
{ 
#line 5659
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5660
__sust_b_1d_array_v2i32_trap(surfObject, layer, x, data); 
#line 5661
} else { 
#line 5662
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5663
__sust_b_1d_array_v2i32_clamp(surfObject, layer, x, data); 
#line 5664
} else { 
#line 5665
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5666
__sust_b_1d_array_v2i32_zero(surfObject, layer, x, data); 
#line 5667
}  }  }  
#line 5668
} 
#endif
#line 5670 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5671
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5681
::exit(___);}
#if 0
#line 5671
{ 
#line 5672
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5673
__sust_b_1d_array_v2i64_trap(surfObject, layer, x, make_ulonglong2(data.x, data.y)); 
#line 5674
} else { 
#line 5675
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5676
__sust_b_1d_array_v2i64_clamp(surfObject, layer, x, make_ulonglong2(data.x, data.y)); 
#line 5677
} else { 
#line 5678
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5679
__sust_b_1d_array_v2i64_zero(surfObject, layer, x, make_ulonglong2(data.x, data.y)); 
#line 5680
}  }  }  
#line 5681
} 
#endif
#line 5683 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5684
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5694
::exit(___);}
#if 0
#line 5684
{ 
#line 5685
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5686
__sust_b_1d_array_v2i64_trap(surfObject, layer, x, data); 
#line 5687
} else { 
#line 5688
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5689
__sust_b_1d_array_v2i64_clamp(surfObject, layer, x, data); 
#line 5690
} else { 
#line 5691
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5692
__sust_b_1d_array_v2i64_zero(surfObject, layer, x, data); 
#line 5693
}  }  }  
#line 5694
} 
#endif
#line 5696 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5697
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5710
::exit(___);}
#if 0
#line 5697
{ 
#line 5698
union { float2 f; uint2 i; } cvt; 
#line 5699
(cvt.f) = data; 
#line 5701
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5702
__sust_b_1d_array_v2i32_trap(surfObject, layer, x, cvt.i); 
#line 5703
} else { 
#line 5704
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5705
__sust_b_1d_array_v2i32_clamp(surfObject, layer, x, cvt.i); 
#line 5706
} else { 
#line 5707
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5708
__sust_b_1d_array_v2i32_zero(surfObject, layer, x, cvt.i); 
#line 5709
}  }  }  
#line 5710
} 
#endif
#line 5718 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5719
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5729
::exit(___);}
#if 0
#line 5719
{ 
#line 5720
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5721
__sust_b_1d_array_v4i8_trap(surfObject, layer, x, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 5722
} else { 
#line 5723
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5724
__sust_b_1d_array_v4i8_clamp(surfObject, layer, x, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 5725
} else { 
#line 5726
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5727
__sust_b_1d_array_v4i8_zero(surfObject, layer, x, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 5728
}  }  }  
#line 5729
} 
#endif
#line 5731 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5732
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5742
::exit(___);}
#if 0
#line 5732
{ 
#line 5733
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5734
__sust_b_1d_array_v4i8_trap(surfObject, layer, x, data); 
#line 5735
} else { 
#line 5736
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5737
__sust_b_1d_array_v4i8_clamp(surfObject, layer, x, data); 
#line 5738
} else { 
#line 5739
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5740
__sust_b_1d_array_v4i8_zero(surfObject, layer, x, data); 
#line 5741
}  }  }  
#line 5742
} 
#endif
#line 5744 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5745
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5755
::exit(___);}
#if 0
#line 5745
{ 
#line 5746
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5747
__sust_b_1d_array_v4i16_trap(surfObject, layer, x, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 5748
} else { 
#line 5749
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5750
__sust_b_1d_array_v4i16_clamp(surfObject, layer, x, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 5751
} else { 
#line 5752
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5753
__sust_b_1d_array_v4i16_zero(surfObject, layer, x, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 5754
}  }  }  
#line 5755
} 
#endif
#line 5757 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5758
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5768
::exit(___);}
#if 0
#line 5758
{ 
#line 5759
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5760
__sust_b_1d_array_v4i16_trap(surfObject, layer, x, data); 
#line 5761
} else { 
#line 5762
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5763
__sust_b_1d_array_v4i16_clamp(surfObject, layer, x, data); 
#line 5764
} else { 
#line 5765
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5766
__sust_b_1d_array_v4i16_zero(surfObject, layer, x, data); 
#line 5767
}  }  }  
#line 5768
} 
#endif
#line 5770 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5771
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5781
::exit(___);}
#if 0
#line 5771
{ 
#line 5772
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5773
__sust_b_1d_array_v4i32_trap(surfObject, layer, x, make_uint4(data.x, data.y, data.z, data.w)); 
#line 5774
} else { 
#line 5775
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5776
__sust_b_1d_array_v4i32_clamp(surfObject, layer, x, make_uint4(data.x, data.y, data.z, data.w)); 
#line 5777
} else { 
#line 5778
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5779
__sust_b_1d_array_v4i32_zero(surfObject, layer, x, make_uint4(data.x, data.y, data.z, data.w)); 
#line 5780
}  }  }  
#line 5781
} 
#endif
#line 5783 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5784
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5794
::exit(___);}
#if 0
#line 5784
{ 
#line 5785
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5786
__sust_b_1d_array_v4i32_trap(surfObject, layer, x, data); 
#line 5787
} else { 
#line 5788
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5789
__sust_b_1d_array_v4i32_clamp(surfObject, layer, x, data); 
#line 5790
} else { 
#line 5791
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5792
__sust_b_1d_array_v4i32_zero(surfObject, layer, x, data); 
#line 5793
}  }  }  
#line 5794
} 
#endif
#line 5796 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf1DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5797
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)layer;(void)boundaryMode;
#line 5810
::exit(___);}
#if 0
#line 5797
{ 
#line 5798
union { float4 f; uint4 i; } cvt; 
#line 5799
(cvt.f) = data; 
#line 5801
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5802
__sust_b_1d_array_v4i32_trap(surfObject, layer, x, cvt.i); 
#line 5803
} else { 
#line 5804
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5805
__sust_b_1d_array_v4i32_clamp(surfObject, layer, x, cvt.i); 
#line 5806
} else { 
#line 5807
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5808
__sust_b_1d_array_v4i32_zero(surfObject, layer, x, cvt.i); 
#line 5809
}  }  }  
#line 5810
} 
#endif
#line 5818 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5819
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5829
::exit(___);}
#if 0
#line 5819
{ 
#line 5820
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5821
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data); 
#line 5822
} else { 
#line 5823
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5824
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data); 
#line 5825
} else { 
#line 5826
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5827
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data); 
#line 5828
}  }  }  
#line 5829
} 
#endif
#line 5831 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5832
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5842
::exit(___);}
#if 0
#line 5832
{ 
#line 5833
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5834
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data); 
#line 5835
} else { 
#line 5836
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5837
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data); 
#line 5838
} else { 
#line 5839
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5840
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data); 
#line 5841
}  }  }  
#line 5842
} 
#endif
#line 5844 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5845
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5855
::exit(___);}
#if 0
#line 5845
{ 
#line 5846
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5847
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data.x); 
#line 5848
} else { 
#line 5849
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5850
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data.x); 
#line 5851
} else { 
#line 5852
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5853
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data.x); 
#line 5854
}  }  }  
#line 5855
} 
#endif
#line 5857 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5858
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5868
::exit(___);}
#if 0
#line 5858
{ 
#line 5859
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5860
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data); 
#line 5861
} else { 
#line 5862
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5863
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data); 
#line 5864
} else { 
#line 5865
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5866
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data); 
#line 5867
}  }  }  
#line 5868
} 
#endif
#line 5870 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5871
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5881
::exit(___);}
#if 0
#line 5871
{ 
#line 5872
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5873
__sust_b_2d_array_i8_trap(surfObject, layer, x, y, data.x); 
#line 5874
} else { 
#line 5875
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5876
__sust_b_2d_array_i8_clamp(surfObject, layer, x, y, data.x); 
#line 5877
} else { 
#line 5878
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5879
__sust_b_2d_array_i8_zero(surfObject, layer, x, y, data.x); 
#line 5880
}  }  }  
#line 5881
} 
#endif
#line 5883 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5884
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5894
::exit(___);}
#if 0
#line 5884
{ 
#line 5885
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5886
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data); 
#line 5887
} else { 
#line 5888
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5889
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data); 
#line 5890
} else { 
#line 5891
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5892
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data); 
#line 5893
}  }  }  
#line 5894
} 
#endif
#line 5896 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5897
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5907
::exit(___);}
#if 0
#line 5897
{ 
#line 5898
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5899
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data.x); 
#line 5900
} else { 
#line 5901
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5902
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data.x); 
#line 5903
} else { 
#line 5904
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5905
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data.x); 
#line 5906
}  }  }  
#line 5907
} 
#endif
#line 5909 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5910
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5920
::exit(___);}
#if 0
#line 5910
{ 
#line 5911
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5912
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data); 
#line 5913
} else { 
#line 5914
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5915
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data); 
#line 5916
} else { 
#line 5917
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5918
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data); 
#line 5919
}  }  }  
#line 5920
} 
#endif
#line 5922 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5923
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5933
::exit(___);}
#if 0
#line 5923
{ 
#line 5924
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5925
__sust_b_2d_array_i16_trap(surfObject, layer, x, y, data.x); 
#line 5926
} else { 
#line 5927
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5928
__sust_b_2d_array_i16_clamp(surfObject, layer, x, y, data.x); 
#line 5929
} else { 
#line 5930
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5931
__sust_b_2d_array_i16_zero(surfObject, layer, x, y, data.x); 
#line 5932
}  }  }  
#line 5933
} 
#endif
#line 5935 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5936
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5946
::exit(___);}
#if 0
#line 5936
{ 
#line 5937
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5938
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data); 
#line 5939
} else { 
#line 5940
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5941
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data); 
#line 5942
} else { 
#line 5943
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5944
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data); 
#line 5945
}  }  }  
#line 5946
} 
#endif
#line 5948 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5949
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5959
::exit(___);}
#if 0
#line 5949
{ 
#line 5950
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5951
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data.x); 
#line 5952
} else { 
#line 5953
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5954
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data.x); 
#line 5955
} else { 
#line 5956
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5957
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data.x); 
#line 5958
}  }  }  
#line 5959
} 
#endif
#line 5961 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5962
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5972
::exit(___);}
#if 0
#line 5962
{ 
#line 5963
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5964
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data); 
#line 5965
} else { 
#line 5966
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5967
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data); 
#line 5968
} else { 
#line 5969
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5970
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data); 
#line 5971
}  }  }  
#line 5972
} 
#endif
#line 5974 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5975
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5985
::exit(___);}
#if 0
#line 5975
{ 
#line 5976
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5977
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, data.x); 
#line 5978
} else { 
#line 5979
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5980
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, data.x); 
#line 5981
} else { 
#line 5982
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5983
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, data.x); 
#line 5984
}  }  }  
#line 5985
} 
#endif
#line 5987 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 5988
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 5998
::exit(___);}
#if 0
#line 5988
{ 
#line 5989
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 5990
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data); 
#line 5991
} else { 
#line 5992
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 5993
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data); 
#line 5994
} else { 
#line 5995
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 5996
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data); 
#line 5997
}  }  }  
#line 5998
} 
#endif
#line 6000 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6001
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6011
::exit(___);}
#if 0
#line 6001
{ 
#line 6002
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6003
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data.x); 
#line 6004
} else { 
#line 6005
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6006
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data.x); 
#line 6007
} else { 
#line 6008
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6009
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data.x); 
#line 6010
}  }  }  
#line 6011
} 
#endif
#line 6013 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6014
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6024
::exit(___);}
#if 0
#line 6014
{ 
#line 6015
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6016
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data); 
#line 6017
} else { 
#line 6018
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6019
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data); 
#line 6020
} else { 
#line 6021
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6022
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data); 
#line 6023
}  }  }  
#line 6024
} 
#endif
#line 6026 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6027
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6037
::exit(___);}
#if 0
#line 6027
{ 
#line 6028
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6029
__sust_b_2d_array_i64_trap(surfObject, layer, x, y, data.x); 
#line 6030
} else { 
#line 6031
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6032
__sust_b_2d_array_i64_clamp(surfObject, layer, x, y, data.x); 
#line 6033
} else { 
#line 6034
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6035
__sust_b_2d_array_i64_zero(surfObject, layer, x, y, data.x); 
#line 6036
}  }  }  
#line 6037
} 
#endif
#line 6039 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6040
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6053
::exit(___);}
#if 0
#line 6040
{ 
#line 6041
union { float f; unsigned i; } cvt; 
#line 6042
(cvt.f) = data; 
#line 6044
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6045
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, cvt.i); 
#line 6046
} else { 
#line 6047
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6048
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, cvt.i); 
#line 6049
} else { 
#line 6050
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6051
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, cvt.i); 
#line 6052
}  }  }  
#line 6053
} 
#endif
#line 6055 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6056
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6069
::exit(___);}
#if 0
#line 6056
{ 
#line 6057
union { float f; unsigned i; } cvt; 
#line 6058
(cvt.f) = (data.x); 
#line 6060
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6061
__sust_b_2d_array_i32_trap(surfObject, layer, x, y, cvt.i); 
#line 6062
} else { 
#line 6063
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6064
__sust_b_2d_array_i32_clamp(surfObject, layer, x, y, cvt.i); 
#line 6065
} else { 
#line 6066
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6067
__sust_b_2d_array_i32_zero(surfObject, layer, x, y, cvt.i); 
#line 6068
}  }  }  
#line 6069
} 
#endif
#line 6077 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6078
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6088
::exit(___);}
#if 0
#line 6078
{ 
#line 6079
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6080
__sust_b_2d_array_v2i8_trap(surfObject, layer, x, y, make_uchar2(data.x, data.y)); 
#line 6081
} else { 
#line 6082
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6083
__sust_b_2d_array_v2i8_clamp(surfObject, layer, x, y, make_uchar2(data.x, data.y)); 
#line 6084
} else { 
#line 6085
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6086
__sust_b_2d_array_v2i8_zero(surfObject, layer, x, y, make_uchar2(data.x, data.y)); 
#line 6087
}  }  }  
#line 6088
} 
#endif
#line 6090 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6091
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6101
::exit(___);}
#if 0
#line 6091
{ 
#line 6092
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6093
__sust_b_2d_array_v2i8_trap(surfObject, layer, x, y, data); 
#line 6094
} else { 
#line 6095
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6096
__sust_b_2d_array_v2i8_clamp(surfObject, layer, x, y, data); 
#line 6097
} else { 
#line 6098
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6099
__sust_b_2d_array_v2i8_zero(surfObject, layer, x, y, data); 
#line 6100
}  }  }  
#line 6101
} 
#endif
#line 6103 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6104
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6114
::exit(___);}
#if 0
#line 6104
{ 
#line 6105
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6106
__sust_b_2d_array_v2i16_trap(surfObject, layer, x, y, make_ushort2(data.x, data.y)); 
#line 6107
} else { 
#line 6108
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6109
__sust_b_2d_array_v2i16_clamp(surfObject, layer, x, y, make_ushort2(data.x, data.y)); 
#line 6110
} else { 
#line 6111
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6112
__sust_b_2d_array_v2i16_zero(surfObject, layer, x, y, make_ushort2(data.x, data.y)); 
#line 6113
}  }  }  
#line 6114
} 
#endif
#line 6116 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6117
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6127
::exit(___);}
#if 0
#line 6117
{ 
#line 6118
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6119
__sust_b_2d_array_v2i16_trap(surfObject, layer, x, y, data); 
#line 6120
} else { 
#line 6121
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6122
__sust_b_2d_array_v2i16_clamp(surfObject, layer, x, y, data); 
#line 6123
} else { 
#line 6124
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6125
__sust_b_2d_array_v2i16_zero(surfObject, layer, x, y, data); 
#line 6126
}  }  }  
#line 6127
} 
#endif
#line 6129 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6130
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6140
::exit(___);}
#if 0
#line 6130
{ 
#line 6131
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6132
__sust_b_2d_array_v2i32_trap(surfObject, layer, x, y, make_uint2(data.x, data.y)); 
#line 6133
} else { 
#line 6134
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6135
__sust_b_2d_array_v2i32_clamp(surfObject, layer, x, y, make_uint2(data.x, data.y)); 
#line 6136
} else { 
#line 6137
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6138
__sust_b_2d_array_v2i32_zero(surfObject, layer, x, y, make_uint2(data.x, data.y)); 
#line 6139
}  }  }  
#line 6140
} 
#endif
#line 6142 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6143
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6153
::exit(___);}
#if 0
#line 6143
{ 
#line 6144
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6145
__sust_b_2d_array_v2i32_trap(surfObject, layer, x, y, data); 
#line 6146
} else { 
#line 6147
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6148
__sust_b_2d_array_v2i32_clamp(surfObject, layer, x, y, data); 
#line 6149
} else { 
#line 6150
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6151
__sust_b_2d_array_v2i32_zero(surfObject, layer, x, y, data); 
#line 6152
}  }  }  
#line 6153
} 
#endif
#line 6155 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6156
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6166
::exit(___);}
#if 0
#line 6156
{ 
#line 6157
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6158
__sust_b_2d_array_v2i64_trap(surfObject, layer, x, y, make_ulonglong2(data.x, data.y)); 
#line 6159
} else { 
#line 6160
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6161
__sust_b_2d_array_v2i64_clamp(surfObject, layer, x, y, make_ulonglong2(data.x, data.y)); 
#line 6162
} else { 
#line 6163
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6164
__sust_b_2d_array_v2i64_zero(surfObject, layer, x, y, make_ulonglong2(data.x, data.y)); 
#line 6165
}  }  }  
#line 6166
} 
#endif
#line 6168 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6169
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6179
::exit(___);}
#if 0
#line 6169
{ 
#line 6170
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6171
__sust_b_2d_array_v2i64_trap(surfObject, layer, x, y, data); 
#line 6172
} else { 
#line 6173
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6174
__sust_b_2d_array_v2i64_clamp(surfObject, layer, x, y, data); 
#line 6175
} else { 
#line 6176
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6177
__sust_b_2d_array_v2i64_zero(surfObject, layer, x, y, data); 
#line 6178
}  }  }  
#line 6179
} 
#endif
#line 6181 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6182
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6195
::exit(___);}
#if 0
#line 6182
{ 
#line 6183
union { float2 f; uint2 i; } cvt; 
#line 6184
(cvt.f) = data; 
#line 6186
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6187
__sust_b_2d_array_v2i32_trap(surfObject, layer, x, y, cvt.i); 
#line 6188
} else { 
#line 6189
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6190
__sust_b_2d_array_v2i32_clamp(surfObject, layer, x, y, cvt.i); 
#line 6191
} else { 
#line 6192
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6193
__sust_b_2d_array_v2i32_zero(surfObject, layer, x, y, cvt.i); 
#line 6194
}  }  }  
#line 6195
} 
#endif
#line 6203 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6204
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6214
::exit(___);}
#if 0
#line 6204
{ 
#line 6205
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6206
__sust_b_2d_array_v4i8_trap(surfObject, layer, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 6207
} else { 
#line 6208
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6209
__sust_b_2d_array_v4i8_clamp(surfObject, layer, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 6210
} else { 
#line 6211
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6212
__sust_b_2d_array_v4i8_zero(surfObject, layer, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 6213
}  }  }  
#line 6214
} 
#endif
#line 6216 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6217
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6227
::exit(___);}
#if 0
#line 6217
{ 
#line 6218
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6219
__sust_b_2d_array_v4i8_trap(surfObject, layer, x, y, data); 
#line 6220
} else { 
#line 6221
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6222
__sust_b_2d_array_v4i8_clamp(surfObject, layer, x, y, data); 
#line 6223
} else { 
#line 6224
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6225
__sust_b_2d_array_v4i8_zero(surfObject, layer, x, y, data); 
#line 6226
}  }  }  
#line 6227
} 
#endif
#line 6229 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6230
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6240
::exit(___);}
#if 0
#line 6230
{ 
#line 6231
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6232
__sust_b_2d_array_v4i16_trap(surfObject, layer, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 6233
} else { 
#line 6234
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6235
__sust_b_2d_array_v4i16_clamp(surfObject, layer, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 6236
} else { 
#line 6237
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6238
__sust_b_2d_array_v4i16_zero(surfObject, layer, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 6239
}  }  }  
#line 6240
} 
#endif
#line 6242 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6243
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6253
::exit(___);}
#if 0
#line 6243
{ 
#line 6244
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6245
__sust_b_2d_array_v4i16_trap(surfObject, layer, x, y, data); 
#line 6246
} else { 
#line 6247
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6248
__sust_b_2d_array_v4i16_clamp(surfObject, layer, x, y, data); 
#line 6249
} else { 
#line 6250
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6251
__sust_b_2d_array_v4i16_zero(surfObject, layer, x, y, data); 
#line 6252
}  }  }  
#line 6253
} 
#endif
#line 6255 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6256
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6266
::exit(___);}
#if 0
#line 6256
{ 
#line 6257
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6258
__sust_b_2d_array_v4i32_trap(surfObject, layer, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 6259
} else { 
#line 6260
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6261
__sust_b_2d_array_v4i32_clamp(surfObject, layer, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 6262
} else { 
#line 6263
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6264
__sust_b_2d_array_v4i32_zero(surfObject, layer, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 6265
}  }  }  
#line 6266
} 
#endif
#line 6268 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6269
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6279
::exit(___);}
#if 0
#line 6269
{ 
#line 6270
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6271
__sust_b_2d_array_v4i32_trap(surfObject, layer, x, y, data); 
#line 6272
} else { 
#line 6273
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6274
__sust_b_2d_array_v4i32_clamp(surfObject, layer, x, y, data); 
#line 6275
} else { 
#line 6276
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6277
__sust_b_2d_array_v4i32_zero(surfObject, layer, x, y, data); 
#line 6278
}  }  }  
#line 6279
} 
#endif
#line 6281 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surf2DLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layer, cudaSurfaceBoundaryMode boundaryMode) 
#line 6282
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layer;(void)boundaryMode;
#line 6295
::exit(___);}
#if 0
#line 6282
{ 
#line 6283
union { float4 f; uint4 i; } cvt; 
#line 6284
(cvt.f) = data; 
#line 6286
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6287
__sust_b_2d_array_v4i32_trap(surfObject, layer, x, y, cvt.i); 
#line 6288
} else { 
#line 6289
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6290
__sust_b_2d_array_v4i32_clamp(surfObject, layer, x, y, cvt.i); 
#line 6291
} else { 
#line 6292
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6293
__sust_b_2d_array_v4i32_zero(surfObject, layer, x, y, cvt.i); 
#line 6294
}  }  }  
#line 6295
} 
#endif
#line 6303 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6304
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6314
::exit(___);}
#if 0
#line 6304
{ 
#line 6305
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6306
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data); 
#line 6307
} else { 
#line 6308
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6309
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data); 
#line 6310
} else { 
#line 6311
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6312
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data); 
#line 6313
}  }  }  
#line 6314
} 
#endif
#line 6316 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6317
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6327
::exit(___);}
#if 0
#line 6317
{ 
#line 6318
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6319
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data); 
#line 6320
} else { 
#line 6321
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6322
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data); 
#line 6323
} else { 
#line 6324
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6325
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data); 
#line 6326
}  }  }  
#line 6327
} 
#endif
#line 6329 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6330
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6340
::exit(___);}
#if 0
#line 6330
{ 
#line 6331
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6332
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data.x); 
#line 6333
} else { 
#line 6334
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6335
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data.x); 
#line 6336
} else { 
#line 6337
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6338
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data.x); 
#line 6339
}  }  }  
#line 6340
} 
#endif
#line 6342 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6343
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6353
::exit(___);}
#if 0
#line 6343
{ 
#line 6344
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6345
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data); 
#line 6346
} else { 
#line 6347
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6348
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data); 
#line 6349
} else { 
#line 6350
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6351
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data); 
#line 6352
}  }  }  
#line 6353
} 
#endif
#line 6355 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6356
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6366
::exit(___);}
#if 0
#line 6356
{ 
#line 6357
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6358
__sust_b_2d_array_i8_trap(surfObject, face, x, y, data.x); 
#line 6359
} else { 
#line 6360
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6361
__sust_b_2d_array_i8_clamp(surfObject, face, x, y, data.x); 
#line 6362
} else { 
#line 6363
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6364
__sust_b_2d_array_i8_zero(surfObject, face, x, y, data.x); 
#line 6365
}  }  }  
#line 6366
} 
#endif
#line 6368 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6369
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6379
::exit(___);}
#if 0
#line 6369
{ 
#line 6370
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6371
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data); 
#line 6372
} else { 
#line 6373
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6374
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data); 
#line 6375
} else { 
#line 6376
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6377
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data); 
#line 6378
}  }  }  
#line 6379
} 
#endif
#line 6381 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6382
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6392
::exit(___);}
#if 0
#line 6382
{ 
#line 6383
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6384
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data.x); 
#line 6385
} else { 
#line 6386
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6387
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data.x); 
#line 6388
} else { 
#line 6389
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6390
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data.x); 
#line 6391
}  }  }  
#line 6392
} 
#endif
#line 6394 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6395
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6405
::exit(___);}
#if 0
#line 6395
{ 
#line 6396
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6397
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data); 
#line 6398
} else { 
#line 6399
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6400
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data); 
#line 6401
} else { 
#line 6402
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6403
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data); 
#line 6404
}  }  }  
#line 6405
} 
#endif
#line 6407 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6408
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6418
::exit(___);}
#if 0
#line 6408
{ 
#line 6409
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6410
__sust_b_2d_array_i16_trap(surfObject, face, x, y, data.x); 
#line 6411
} else { 
#line 6412
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6413
__sust_b_2d_array_i16_clamp(surfObject, face, x, y, data.x); 
#line 6414
} else { 
#line 6415
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6416
__sust_b_2d_array_i16_zero(surfObject, face, x, y, data.x); 
#line 6417
}  }  }  
#line 6418
} 
#endif
#line 6420 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6421
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6431
::exit(___);}
#if 0
#line 6421
{ 
#line 6422
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6423
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data); 
#line 6424
} else { 
#line 6425
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6426
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data); 
#line 6427
} else { 
#line 6428
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6429
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data); 
#line 6430
}  }  }  
#line 6431
} 
#endif
#line 6433 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6434
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6444
::exit(___);}
#if 0
#line 6434
{ 
#line 6435
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6436
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data.x); 
#line 6437
} else { 
#line 6438
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6439
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data.x); 
#line 6440
} else { 
#line 6441
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6442
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data.x); 
#line 6443
}  }  }  
#line 6444
} 
#endif
#line 6446 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6447
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6457
::exit(___);}
#if 0
#line 6447
{ 
#line 6448
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6449
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data); 
#line 6450
} else { 
#line 6451
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6452
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data); 
#line 6453
} else { 
#line 6454
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6455
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data); 
#line 6456
}  }  }  
#line 6457
} 
#endif
#line 6459 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6460
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6470
::exit(___);}
#if 0
#line 6460
{ 
#line 6461
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6462
__sust_b_2d_array_i32_trap(surfObject, face, x, y, data.x); 
#line 6463
} else { 
#line 6464
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6465
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, data.x); 
#line 6466
} else { 
#line 6467
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6468
__sust_b_2d_array_i32_zero(surfObject, face, x, y, data.x); 
#line 6469
}  }  }  
#line 6470
} 
#endif
#line 6472 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6473
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6483
::exit(___);}
#if 0
#line 6473
{ 
#line 6474
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6475
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data); 
#line 6476
} else { 
#line 6477
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6478
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data); 
#line 6479
} else { 
#line 6480
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6481
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data); 
#line 6482
}  }  }  
#line 6483
} 
#endif
#line 6485 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6486
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6496
::exit(___);}
#if 0
#line 6486
{ 
#line 6487
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6488
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data.x); 
#line 6489
} else { 
#line 6490
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6491
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data.x); 
#line 6492
} else { 
#line 6493
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6494
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data.x); 
#line 6495
}  }  }  
#line 6496
} 
#endif
#line 6498 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6499
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6509
::exit(___);}
#if 0
#line 6499
{ 
#line 6500
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6501
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data); 
#line 6502
} else { 
#line 6503
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6504
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data); 
#line 6505
} else { 
#line 6506
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6507
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data); 
#line 6508
}  }  }  
#line 6509
} 
#endif
#line 6511 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6512
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6522
::exit(___);}
#if 0
#line 6512
{ 
#line 6513
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6514
__sust_b_2d_array_i64_trap(surfObject, face, x, y, data.x); 
#line 6515
} else { 
#line 6516
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6517
__sust_b_2d_array_i64_clamp(surfObject, face, x, y, data.x); 
#line 6518
} else { 
#line 6519
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6520
__sust_b_2d_array_i64_zero(surfObject, face, x, y, data.x); 
#line 6521
}  }  }  
#line 6522
} 
#endif
#line 6524 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6525
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6538
::exit(___);}
#if 0
#line 6525
{ 
#line 6526
union { float f; unsigned i; } cvt; 
#line 6527
(cvt.f) = data; 
#line 6529
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6530
__sust_b_2d_array_i32_trap(surfObject, face, x, y, cvt.i); 
#line 6531
} else { 
#line 6532
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6533
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, cvt.i); 
#line 6534
} else { 
#line 6535
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6536
__sust_b_2d_array_i32_zero(surfObject, face, x, y, cvt.i); 
#line 6537
}  }  }  
#line 6538
} 
#endif
#line 6540 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6541
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6554
::exit(___);}
#if 0
#line 6541
{ 
#line 6542
union { float f; unsigned i; } cvt; 
#line 6543
(cvt.f) = (data.x); 
#line 6545
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6546
__sust_b_2d_array_i32_trap(surfObject, face, x, y, cvt.i); 
#line 6547
} else { 
#line 6548
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6549
__sust_b_2d_array_i32_clamp(surfObject, face, x, y, cvt.i); 
#line 6550
} else { 
#line 6551
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6552
__sust_b_2d_array_i32_zero(surfObject, face, x, y, cvt.i); 
#line 6553
}  }  }  
#line 6554
} 
#endif
#line 6562 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6563
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6573
::exit(___);}
#if 0
#line 6563
{ 
#line 6564
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6565
__sust_b_2d_array_v2i8_trap(surfObject, face, x, y, make_uchar2(data.x, data.y)); 
#line 6566
} else { 
#line 6567
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6568
__sust_b_2d_array_v2i8_clamp(surfObject, face, x, y, make_uchar2(data.x, data.y)); 
#line 6569
} else { 
#line 6570
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6571
__sust_b_2d_array_v2i8_zero(surfObject, face, x, y, make_uchar2(data.x, data.y)); 
#line 6572
}  }  }  
#line 6573
} 
#endif
#line 6575 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6576
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6586
::exit(___);}
#if 0
#line 6576
{ 
#line 6577
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6578
__sust_b_2d_array_v2i8_trap(surfObject, face, x, y, data); 
#line 6579
} else { 
#line 6580
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6581
__sust_b_2d_array_v2i8_clamp(surfObject, face, x, y, data); 
#line 6582
} else { 
#line 6583
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6584
__sust_b_2d_array_v2i8_zero(surfObject, face, x, y, data); 
#line 6585
}  }  }  
#line 6586
} 
#endif
#line 6588 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6589
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6599
::exit(___);}
#if 0
#line 6589
{ 
#line 6590
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6591
__sust_b_2d_array_v2i16_trap(surfObject, face, x, y, make_ushort2(data.x, data.y)); 
#line 6592
} else { 
#line 6593
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6594
__sust_b_2d_array_v2i16_clamp(surfObject, face, x, y, make_ushort2(data.x, data.y)); 
#line 6595
} else { 
#line 6596
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6597
__sust_b_2d_array_v2i16_zero(surfObject, face, x, y, make_ushort2(data.x, data.y)); 
#line 6598
}  }  }  
#line 6599
} 
#endif
#line 6601 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6602
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6612
::exit(___);}
#if 0
#line 6602
{ 
#line 6603
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6604
__sust_b_2d_array_v2i16_trap(surfObject, face, x, y, data); 
#line 6605
} else { 
#line 6606
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6607
__sust_b_2d_array_v2i16_clamp(surfObject, face, x, y, data); 
#line 6608
} else { 
#line 6609
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6610
__sust_b_2d_array_v2i16_zero(surfObject, face, x, y, data); 
#line 6611
}  }  }  
#line 6612
} 
#endif
#line 6614 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6615
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6625
::exit(___);}
#if 0
#line 6615
{ 
#line 6616
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6617
__sust_b_2d_array_v2i32_trap(surfObject, face, x, y, make_uint2(data.x, data.y)); 
#line 6618
} else { 
#line 6619
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6620
__sust_b_2d_array_v2i32_clamp(surfObject, face, x, y, make_uint2(data.x, data.y)); 
#line 6621
} else { 
#line 6622
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6623
__sust_b_2d_array_v2i32_zero(surfObject, face, x, y, make_uint2(data.x, data.y)); 
#line 6624
}  }  }  
#line 6625
} 
#endif
#line 6627 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6628
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6638
::exit(___);}
#if 0
#line 6628
{ 
#line 6629
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6630
__sust_b_2d_array_v2i32_trap(surfObject, face, x, y, data); 
#line 6631
} else { 
#line 6632
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6633
__sust_b_2d_array_v2i32_clamp(surfObject, face, x, y, data); 
#line 6634
} else { 
#line 6635
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6636
__sust_b_2d_array_v2i32_zero(surfObject, face, x, y, data); 
#line 6637
}  }  }  
#line 6638
} 
#endif
#line 6640 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6641
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6651
::exit(___);}
#if 0
#line 6641
{ 
#line 6642
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6643
__sust_b_2d_array_v2i64_trap(surfObject, face, x, y, make_ulonglong2(data.x, data.y)); 
#line 6644
} else { 
#line 6645
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6646
__sust_b_2d_array_v2i64_clamp(surfObject, face, x, y, make_ulonglong2(data.x, data.y)); 
#line 6647
} else { 
#line 6648
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6649
__sust_b_2d_array_v2i64_zero(surfObject, face, x, y, make_ulonglong2(data.x, data.y)); 
#line 6650
}  }  }  
#line 6651
} 
#endif
#line 6653 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6654
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6664
::exit(___);}
#if 0
#line 6654
{ 
#line 6655
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6656
__sust_b_2d_array_v2i64_trap(surfObject, face, x, y, data); 
#line 6657
} else { 
#line 6658
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6659
__sust_b_2d_array_v2i64_clamp(surfObject, face, x, y, data); 
#line 6660
} else { 
#line 6661
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6662
__sust_b_2d_array_v2i64_zero(surfObject, face, x, y, data); 
#line 6663
}  }  }  
#line 6664
} 
#endif
#line 6666 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6667
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6680
::exit(___);}
#if 0
#line 6667
{ 
#line 6668
union { float2 f; uint2 i; } cvt; 
#line 6669
(cvt.f) = data; 
#line 6671
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6672
__sust_b_2d_array_v2i32_trap(surfObject, face, x, y, cvt.i); 
#line 6673
} else { 
#line 6674
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6675
__sust_b_2d_array_v2i32_clamp(surfObject, face, x, y, cvt.i); 
#line 6676
} else { 
#line 6677
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6678
__sust_b_2d_array_v2i32_zero(surfObject, face, x, y, cvt.i); 
#line 6679
}  }  }  
#line 6680
} 
#endif
#line 6688 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6689
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6699
::exit(___);}
#if 0
#line 6689
{ 
#line 6690
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6691
__sust_b_2d_array_v4i8_trap(surfObject, face, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 6692
} else { 
#line 6693
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6694
__sust_b_2d_array_v4i8_clamp(surfObject, face, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 6695
} else { 
#line 6696
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6697
__sust_b_2d_array_v4i8_zero(surfObject, face, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 6698
}  }  }  
#line 6699
} 
#endif
#line 6701 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6702
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6712
::exit(___);}
#if 0
#line 6702
{ 
#line 6703
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6704
__sust_b_2d_array_v4i8_trap(surfObject, face, x, y, data); 
#line 6705
} else { 
#line 6706
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6707
__sust_b_2d_array_v4i8_clamp(surfObject, face, x, y, data); 
#line 6708
} else { 
#line 6709
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6710
__sust_b_2d_array_v4i8_zero(surfObject, face, x, y, data); 
#line 6711
}  }  }  
#line 6712
} 
#endif
#line 6714 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6715
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6725
::exit(___);}
#if 0
#line 6715
{ 
#line 6716
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6717
__sust_b_2d_array_v4i16_trap(surfObject, face, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 6718
} else { 
#line 6719
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6720
__sust_b_2d_array_v4i16_clamp(surfObject, face, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 6721
} else { 
#line 6722
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6723
__sust_b_2d_array_v4i16_zero(surfObject, face, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 6724
}  }  }  
#line 6725
} 
#endif
#line 6727 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6728
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6738
::exit(___);}
#if 0
#line 6728
{ 
#line 6729
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6730
__sust_b_2d_array_v4i16_trap(surfObject, face, x, y, data); 
#line 6731
} else { 
#line 6732
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6733
__sust_b_2d_array_v4i16_clamp(surfObject, face, x, y, data); 
#line 6734
} else { 
#line 6735
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6736
__sust_b_2d_array_v4i16_zero(surfObject, face, x, y, data); 
#line 6737
}  }  }  
#line 6738
} 
#endif
#line 6740 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6741
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6751
::exit(___);}
#if 0
#line 6741
{ 
#line 6742
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6743
__sust_b_2d_array_v4i32_trap(surfObject, face, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 6744
} else { 
#line 6745
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6746
__sust_b_2d_array_v4i32_clamp(surfObject, face, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 6747
} else { 
#line 6748
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6749
__sust_b_2d_array_v4i32_zero(surfObject, face, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 6750
}  }  }  
#line 6751
} 
#endif
#line 6753 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6754
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6764
::exit(___);}
#if 0
#line 6754
{ 
#line 6755
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6756
__sust_b_2d_array_v4i32_trap(surfObject, face, x, y, data); 
#line 6757
} else { 
#line 6758
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6759
__sust_b_2d_array_v4i32_clamp(surfObject, face, x, y, data); 
#line 6760
} else { 
#line 6761
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6762
__sust_b_2d_array_v4i32_zero(surfObject, face, x, y, data); 
#line 6763
}  }  }  
#line 6764
} 
#endif
#line 6766 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int face, cudaSurfaceBoundaryMode boundaryMode) 
#line 6767
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)face;(void)boundaryMode;
#line 6780
::exit(___);}
#if 0
#line 6767
{ 
#line 6768
union { float4 f; uint4 i; } cvt; 
#line 6769
(cvt.f) = data; 
#line 6771
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6772
__sust_b_2d_array_v4i32_trap(surfObject, face, x, y, cvt.i); 
#line 6773
} else { 
#line 6774
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6775
__sust_b_2d_array_v4i32_clamp(surfObject, face, x, y, cvt.i); 
#line 6776
} else { 
#line 6777
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6778
__sust_b_2d_array_v4i32_zero(surfObject, face, x, y, cvt.i); 
#line 6779
}  }  }  
#line 6780
} 
#endif
#line 6788 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6789
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6799
::exit(___);}
#if 0
#line 6789
{ 
#line 6790
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6791
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data); 
#line 6792
} else { 
#line 6793
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6794
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data); 
#line 6795
} else { 
#line 6796
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6797
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data); 
#line 6798
}  }  }  
#line 6799
} 
#endif
#line 6801 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(signed char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6802
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6812
::exit(___);}
#if 0
#line 6802
{ 
#line 6803
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6804
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data); 
#line 6805
} else { 
#line 6806
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6807
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data); 
#line 6808
} else { 
#line 6809
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6810
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data); 
#line 6811
}  }  }  
#line 6812
} 
#endif
#line 6814 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6815
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6825
::exit(___);}
#if 0
#line 6815
{ 
#line 6816
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6817
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data.x); 
#line 6818
} else { 
#line 6819
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6820
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data.x); 
#line 6821
} else { 
#line 6822
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6823
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data.x); 
#line 6824
}  }  }  
#line 6825
} 
#endif
#line 6827 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned char data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6828
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6838
::exit(___);}
#if 0
#line 6828
{ 
#line 6829
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6830
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data); 
#line 6831
} else { 
#line 6832
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6833
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data); 
#line 6834
} else { 
#line 6835
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6836
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data); 
#line 6837
}  }  }  
#line 6838
} 
#endif
#line 6840 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uchar1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6841
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6851
::exit(___);}
#if 0
#line 6841
{ 
#line 6842
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6843
__sust_b_2d_array_i8_trap(surfObject, layerface, x, y, data.x); 
#line 6844
} else { 
#line 6845
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6846
__sust_b_2d_array_i8_clamp(surfObject, layerface, x, y, data.x); 
#line 6847
} else { 
#line 6848
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6849
__sust_b_2d_array_i8_zero(surfObject, layerface, x, y, data.x); 
#line 6850
}  }  }  
#line 6851
} 
#endif
#line 6853 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6854
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6864
::exit(___);}
#if 0
#line 6854
{ 
#line 6855
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6856
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data); 
#line 6857
} else { 
#line 6858
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6859
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data); 
#line 6860
} else { 
#line 6861
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6862
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data); 
#line 6863
}  }  }  
#line 6864
} 
#endif
#line 6866 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6867
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6877
::exit(___);}
#if 0
#line 6867
{ 
#line 6868
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6869
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data.x); 
#line 6870
} else { 
#line 6871
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6872
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data.x); 
#line 6873
} else { 
#line 6874
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6875
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data.x); 
#line 6876
}  }  }  
#line 6877
} 
#endif
#line 6879 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned short data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6880
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6890
::exit(___);}
#if 0
#line 6880
{ 
#line 6881
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6882
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data); 
#line 6883
} else { 
#line 6884
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6885
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data); 
#line 6886
} else { 
#line 6887
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6888
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data); 
#line 6889
}  }  }  
#line 6890
} 
#endif
#line 6892 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ushort1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6893
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6903
::exit(___);}
#if 0
#line 6893
{ 
#line 6894
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6895
__sust_b_2d_array_i16_trap(surfObject, layerface, x, y, data.x); 
#line 6896
} else { 
#line 6897
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6898
__sust_b_2d_array_i16_clamp(surfObject, layerface, x, y, data.x); 
#line 6899
} else { 
#line 6900
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6901
__sust_b_2d_array_i16_zero(surfObject, layerface, x, y, data.x); 
#line 6902
}  }  }  
#line 6903
} 
#endif
#line 6905 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6906
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6916
::exit(___);}
#if 0
#line 6906
{ 
#line 6907
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6908
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data); 
#line 6909
} else { 
#line 6910
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6911
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data); 
#line 6912
} else { 
#line 6913
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6914
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data); 
#line 6915
}  }  }  
#line 6916
} 
#endif
#line 6918 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6919
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6929
::exit(___);}
#if 0
#line 6919
{ 
#line 6920
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6921
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data.x); 
#line 6922
} else { 
#line 6923
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6924
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data.x); 
#line 6925
} else { 
#line 6926
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6927
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data.x); 
#line 6928
}  }  }  
#line 6929
} 
#endif
#line 6931 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6932
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6942
::exit(___);}
#if 0
#line 6932
{ 
#line 6933
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6934
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data); 
#line 6935
} else { 
#line 6936
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6937
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data); 
#line 6938
} else { 
#line 6939
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6940
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data); 
#line 6941
}  }  }  
#line 6942
} 
#endif
#line 6944 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uint1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6945
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6955
::exit(___);}
#if 0
#line 6945
{ 
#line 6946
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6947
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, data.x); 
#line 6948
} else { 
#line 6949
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6950
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, data.x); 
#line 6951
} else { 
#line 6952
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6953
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, data.x); 
#line 6954
}  }  }  
#line 6955
} 
#endif
#line 6957 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(__int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6958
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6968
::exit(___);}
#if 0
#line 6958
{ 
#line 6959
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6960
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data); 
#line 6961
} else { 
#line 6962
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6963
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data); 
#line 6964
} else { 
#line 6965
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6966
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data); 
#line 6967
}  }  }  
#line 6968
} 
#endif
#line 6970 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(longlong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6971
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6981
::exit(___);}
#if 0
#line 6971
{ 
#line 6972
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6973
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data.x); 
#line 6974
} else { 
#line 6975
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6976
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data.x); 
#line 6977
} else { 
#line 6978
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6979
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data.x); 
#line 6980
}  }  }  
#line 6981
} 
#endif
#line 6983 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(unsigned __int64 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6984
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 6994
::exit(___);}
#if 0
#line 6984
{ 
#line 6985
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6986
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data); 
#line 6987
} else { 
#line 6988
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 6989
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data); 
#line 6990
} else { 
#line 6991
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 6992
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data); 
#line 6993
}  }  }  
#line 6994
} 
#endif
#line 6996 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulonglong1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 6997
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7007
::exit(___);}
#if 0
#line 6997
{ 
#line 6998
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 6999
__sust_b_2d_array_i64_trap(surfObject, layerface, x, y, data.x); 
#line 7000
} else { 
#line 7001
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7002
__sust_b_2d_array_i64_clamp(surfObject, layerface, x, y, data.x); 
#line 7003
} else { 
#line 7004
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7005
__sust_b_2d_array_i64_zero(surfObject, layerface, x, y, data.x); 
#line 7006
}  }  }  
#line 7007
} 
#endif
#line 7009 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7010
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7023
::exit(___);}
#if 0
#line 7010
{ 
#line 7011
union { float f; unsigned i; } cvt; 
#line 7012
(cvt.f) = data; 
#line 7014
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7015
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, cvt.i); 
#line 7016
} else { 
#line 7017
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7018
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, cvt.i); 
#line 7019
} else { 
#line 7020
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7021
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, cvt.i); 
#line 7022
}  }  }  
#line 7023
} 
#endif
#line 7025 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float1 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7026
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7039
::exit(___);}
#if 0
#line 7026
{ 
#line 7027
union { float f; unsigned i; } cvt; 
#line 7028
(cvt.f) = (data.x); 
#line 7030
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7031
__sust_b_2d_array_i32_trap(surfObject, layerface, x, y, cvt.i); 
#line 7032
} else { 
#line 7033
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7034
__sust_b_2d_array_i32_clamp(surfObject, layerface, x, y, cvt.i); 
#line 7035
} else { 
#line 7036
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7037
__sust_b_2d_array_i32_zero(surfObject, layerface, x, y, cvt.i); 
#line 7038
}  }  }  
#line 7039
} 
#endif
#line 7047 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7048
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7058
::exit(___);}
#if 0
#line 7048
{ 
#line 7049
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7050
__sust_b_2d_array_v2i8_trap(surfObject, layerface, x, y, make_uchar2(data.x, data.y)); 
#line 7051
} else { 
#line 7052
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7053
__sust_b_2d_array_v2i8_clamp(surfObject, layerface, x, y, make_uchar2(data.x, data.y)); 
#line 7054
} else { 
#line 7055
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7056
__sust_b_2d_array_v2i8_zero(surfObject, layerface, x, y, make_uchar2(data.x, data.y)); 
#line 7057
}  }  }  
#line 7058
} 
#endif
#line 7060 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uchar2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7061
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7071
::exit(___);}
#if 0
#line 7061
{ 
#line 7062
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7063
__sust_b_2d_array_v2i8_trap(surfObject, layerface, x, y, data); 
#line 7064
} else { 
#line 7065
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7066
__sust_b_2d_array_v2i8_clamp(surfObject, layerface, x, y, data); 
#line 7067
} else { 
#line 7068
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7069
__sust_b_2d_array_v2i8_zero(surfObject, layerface, x, y, data); 
#line 7070
}  }  }  
#line 7071
} 
#endif
#line 7073 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7074
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7084
::exit(___);}
#if 0
#line 7074
{ 
#line 7075
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7076
__sust_b_2d_array_v2i16_trap(surfObject, layerface, x, y, make_ushort2(data.x, data.y)); 
#line 7077
} else { 
#line 7078
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7079
__sust_b_2d_array_v2i16_clamp(surfObject, layerface, x, y, make_ushort2(data.x, data.y)); 
#line 7080
} else { 
#line 7081
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7082
__sust_b_2d_array_v2i16_zero(surfObject, layerface, x, y, make_ushort2(data.x, data.y)); 
#line 7083
}  }  }  
#line 7084
} 
#endif
#line 7086 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ushort2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7087
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7097
::exit(___);}
#if 0
#line 7087
{ 
#line 7088
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7089
__sust_b_2d_array_v2i16_trap(surfObject, layerface, x, y, data); 
#line 7090
} else { 
#line 7091
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7092
__sust_b_2d_array_v2i16_clamp(surfObject, layerface, x, y, data); 
#line 7093
} else { 
#line 7094
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7095
__sust_b_2d_array_v2i16_zero(surfObject, layerface, x, y, data); 
#line 7096
}  }  }  
#line 7097
} 
#endif
#line 7099 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7100
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7110
::exit(___);}
#if 0
#line 7100
{ 
#line 7101
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7102
__sust_b_2d_array_v2i32_trap(surfObject, layerface, x, y, make_uint2(data.x, data.y)); 
#line 7103
} else { 
#line 7104
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7105
__sust_b_2d_array_v2i32_clamp(surfObject, layerface, x, y, make_uint2(data.x, data.y)); 
#line 7106
} else { 
#line 7107
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7108
__sust_b_2d_array_v2i32_zero(surfObject, layerface, x, y, make_uint2(data.x, data.y)); 
#line 7109
}  }  }  
#line 7110
} 
#endif
#line 7112 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uint2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7113
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7123
::exit(___);}
#if 0
#line 7113
{ 
#line 7114
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7115
__sust_b_2d_array_v2i32_trap(surfObject, layerface, x, y, data); 
#line 7116
} else { 
#line 7117
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7118
__sust_b_2d_array_v2i32_clamp(surfObject, layerface, x, y, data); 
#line 7119
} else { 
#line 7120
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7121
__sust_b_2d_array_v2i32_zero(surfObject, layerface, x, y, data); 
#line 7122
}  }  }  
#line 7123
} 
#endif
#line 7125 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(longlong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7126
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7136
::exit(___);}
#if 0
#line 7126
{ 
#line 7127
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7128
__sust_b_2d_array_v2i64_trap(surfObject, layerface, x, y, make_ulonglong2(data.x, data.y)); 
#line 7129
} else { 
#line 7130
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7131
__sust_b_2d_array_v2i64_clamp(surfObject, layerface, x, y, make_ulonglong2(data.x, data.y)); 
#line 7132
} else { 
#line 7133
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7134
__sust_b_2d_array_v2i64_zero(surfObject, layerface, x, y, make_ulonglong2(data.x, data.y)); 
#line 7135
}  }  }  
#line 7136
} 
#endif
#line 7138 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ulonglong2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7139
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7149
::exit(___);}
#if 0
#line 7139
{ 
#line 7140
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7141
__sust_b_2d_array_v2i64_trap(surfObject, layerface, x, y, data); 
#line 7142
} else { 
#line 7143
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7144
__sust_b_2d_array_v2i64_clamp(surfObject, layerface, x, y, data); 
#line 7145
} else { 
#line 7146
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7147
__sust_b_2d_array_v2i64_zero(surfObject, layerface, x, y, data); 
#line 7148
}  }  }  
#line 7149
} 
#endif
#line 7151 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float2 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7152
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7165
::exit(___);}
#if 0
#line 7152
{ 
#line 7153
union { float2 f; uint2 i; } cvt; 
#line 7154
(cvt.f) = data; 
#line 7156
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7157
__sust_b_2d_array_v2i32_trap(surfObject, layerface, x, y, cvt.i); 
#line 7158
} else { 
#line 7159
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7160
__sust_b_2d_array_v2i32_clamp(surfObject, layerface, x, y, cvt.i); 
#line 7161
} else { 
#line 7162
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7163
__sust_b_2d_array_v2i32_zero(surfObject, layerface, x, y, cvt.i); 
#line 7164
}  }  }  
#line 7165
} 
#endif
#line 7173 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(char4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7174
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7184
::exit(___);}
#if 0
#line 7174
{ 
#line 7175
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7176
__sust_b_2d_array_v4i8_trap(surfObject, layerface, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 7177
} else { 
#line 7178
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7179
__sust_b_2d_array_v4i8_clamp(surfObject, layerface, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 7180
} else { 
#line 7181
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7182
__sust_b_2d_array_v4i8_zero(surfObject, layerface, x, y, make_uchar4(data.x, data.y, data.z, data.w)); 
#line 7183
}  }  }  
#line 7184
} 
#endif
#line 7186 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uchar4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7187
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7197
::exit(___);}
#if 0
#line 7187
{ 
#line 7188
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7189
__sust_b_2d_array_v4i8_trap(surfObject, layerface, x, y, data); 
#line 7190
} else { 
#line 7191
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7192
__sust_b_2d_array_v4i8_clamp(surfObject, layerface, x, y, data); 
#line 7193
} else { 
#line 7194
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7195
__sust_b_2d_array_v4i8_zero(surfObject, layerface, x, y, data); 
#line 7196
}  }  }  
#line 7197
} 
#endif
#line 7199 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(short4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7200
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7210
::exit(___);}
#if 0
#line 7200
{ 
#line 7201
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7202
__sust_b_2d_array_v4i16_trap(surfObject, layerface, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 7203
} else { 
#line 7204
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7205
__sust_b_2d_array_v4i16_clamp(surfObject, layerface, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 7206
} else { 
#line 7207
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7208
__sust_b_2d_array_v4i16_zero(surfObject, layerface, x, y, make_ushort4(data.x, data.y, data.z, data.w)); 
#line 7209
}  }  }  
#line 7210
} 
#endif
#line 7212 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(ushort4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7213
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7223
::exit(___);}
#if 0
#line 7213
{ 
#line 7214
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7215
__sust_b_2d_array_v4i16_trap(surfObject, layerface, x, y, data); 
#line 7216
} else { 
#line 7217
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7218
__sust_b_2d_array_v4i16_clamp(surfObject, layerface, x, y, data); 
#line 7219
} else { 
#line 7220
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7221
__sust_b_2d_array_v4i16_zero(surfObject, layerface, x, y, data); 
#line 7222
}  }  }  
#line 7223
} 
#endif
#line 7225 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(int4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7226
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7236
::exit(___);}
#if 0
#line 7226
{ 
#line 7227
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7228
__sust_b_2d_array_v4i32_trap(surfObject, layerface, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 7229
} else { 
#line 7230
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7231
__sust_b_2d_array_v4i32_clamp(surfObject, layerface, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 7232
} else { 
#line 7233
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7234
__sust_b_2d_array_v4i32_zero(surfObject, layerface, x, y, make_uint4(data.x, data.y, data.z, data.w)); 
#line 7235
}  }  }  
#line 7236
} 
#endif
#line 7238 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(uint4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7239
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7249
::exit(___);}
#if 0
#line 7239
{ 
#line 7240
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7241
__sust_b_2d_array_v4i32_trap(surfObject, layerface, x, y, data); 
#line 7242
} else { 
#line 7243
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7244
__sust_b_2d_array_v4i32_clamp(surfObject, layerface, x, y, data); 
#line 7245
} else { 
#line 7246
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7247
__sust_b_2d_array_v4i32_zero(surfObject, layerface, x, y, data); 
#line 7248
}  }  }  
#line 7249
} 
#endif
#line 7251 "e:\\cudatoolkit\\include\\surface_indirect_functions.hpp"
static __forceinline void surfCubemapLayeredwrite(float4 data, cudaSurfaceObject_t surfObject, int x, int y, int layerface, cudaSurfaceBoundaryMode boundaryMode) 
#line 7252
{int volatile ___ = 1;(void)data;(void)surfObject;(void)x;(void)y;(void)layerface;(void)boundaryMode;
#line 7265
::exit(___);}
#if 0
#line 7252
{ 
#line 7253
union { float4 f; uint4 i; } cvt; 
#line 7254
(cvt.f) = data; 
#line 7256
if (boundaryMode == (cudaBoundaryModeTrap)) { 
#line 7257
__sust_b_2d_array_v4i32_trap(surfObject, layerface, x, y, cvt.i); 
#line 7258
} else { 
#line 7259
if (boundaryMode == (cudaBoundaryModeClamp)) { 
#line 7260
__sust_b_2d_array_v4i32_clamp(surfObject, layerface, x, y, cvt.i); 
#line 7261
} else { 
#line 7262
if (boundaryMode == (cudaBoundaryModeZero)) { 
#line 7263
__sust_b_2d_array_v4i32_zero(surfObject, layerface, x, y, cvt.i); 
#line 7264
}  }  }  
#line 7265
} 
#endif
#line 71 "e:\\cudatoolkit\\include\\device_launch_parameters.h"
extern "C" const uint3 __device_builtin_variable_threadIdx; 
#line 72
extern "C" const uint3 __device_builtin_variable_blockIdx; 
#line 73
extern "C" const dim3 __device_builtin_variable_blockDim; 
#line 74
extern "C" const dim3 __device_builtin_variable_gridDim; 
#line 75
extern "C" const int __device_builtin_variable_warpSize; 
#line 172 "E:/CudaToolKit/include\\cuda_runtime.h"
template< class T> static __inline ::cudaError_t 
#line 173
cudaLaunchKernel(const T *
#line 174
func, ::dim3 
#line 175
gridDim, ::dim3 
#line 176
blockDim, void **
#line 177
args, ::size_t 
#line 178
sharedMem = 0, ::cudaStream_t 
#line 179
stream = 0) 
#line 181
{ 
#line 182
return ::cudaLaunchKernel((const void *)func, gridDim, blockDim, args, sharedMem, stream); 
#line 183
} 
#line 210
template< class T> static __inline ::cudaError_t 
#line 211
cudaSetupArgument(T 
#line 212
arg, ::size_t 
#line 213
offset) 
#line 215
{ 
#line 216
return ::cudaSetupArgument((const void *)(&arg), sizeof(T), offset); 
#line 217
} 
#line 249
static __inline cudaError_t cudaEventCreate(cudaEvent_t *
#line 250
event, unsigned 
#line 251
flags) 
#line 253
{ 
#line 254
return ::cudaEventCreateWithFlags(event, flags); 
#line 255
} 
#line 312
static __inline cudaError_t cudaMallocHost(void **
#line 313
ptr, size_t 
#line 314
size, unsigned 
#line 315
flags) 
#line 317
{ 
#line 318
return ::cudaHostAlloc(ptr, size, flags); 
#line 319
} 
#line 321
template< class T> static __inline ::cudaError_t 
#line 322
cudaHostAlloc(T **
#line 323
ptr, ::size_t 
#line 324
size, unsigned 
#line 325
flags) 
#line 327
{ 
#line 328
return ::cudaHostAlloc((void **)((void *)ptr), size, flags); 
#line 329
} 
#line 331
template< class T> static __inline ::cudaError_t 
#line 332
cudaHostGetDevicePointer(T **
#line 333
pDevice, void *
#line 334
pHost, unsigned 
#line 335
flags) 
#line 337
{ 
#line 338
return ::cudaHostGetDevicePointer((void **)((void *)pDevice), pHost, flags); 
#line 339
} 
#line 410
template< class T> static __inline ::cudaError_t 
#line 411
cudaMallocManaged(T **
#line 412
devPtr, ::size_t 
#line 413
size, unsigned 
#line 414
flags = 1) 
#line 416
{ 
#line 417
return ::cudaMallocManaged((void **)((void *)devPtr), size, flags); 
#line 418
} 
#line 486
template< class T> static __inline ::cudaError_t 
#line 487
cudaStreamAttachMemAsync(::cudaStream_t 
#line 488
stream, T *
#line 489
devPtr, ::size_t 
#line 490
length = 0, unsigned 
#line 491
flags = 4) 
#line 493
{ 
#line 494
return ::cudaStreamAttachMemAsync(stream, (void *)devPtr, length, flags); 
#line 495
} 
#line 497
template< class T> __inline ::cudaError_t 
#line 498
cudaMalloc(T **
#line 499
devPtr, ::size_t 
#line 500
size) 
#line 502
{ 
#line 503
return ::cudaMalloc((void **)((void *)devPtr), size); 
#line 504
} 
#line 506
template< class T> static __inline ::cudaError_t 
#line 507
cudaMallocHost(T **
#line 508
ptr, ::size_t 
#line 509
size, unsigned 
#line 510
flags = 0) 
#line 512
{ 
#line 513
return cudaMallocHost((void **)((void *)ptr), size, flags); 
#line 514
} 
#line 516
template< class T> static __inline ::cudaError_t 
#line 517
cudaMallocPitch(T **
#line 518
devPtr, ::size_t *
#line 519
pitch, ::size_t 
#line 520
width, ::size_t 
#line 521
height) 
#line 523
{ 
#line 524
return ::cudaMallocPitch((void **)((void *)devPtr), pitch, width, height); 
#line 525
} 
#line 562
template< class T> static __inline ::cudaError_t 
#line 563
cudaMemcpyToSymbol(const T &
#line 564
symbol, const void *
#line 565
src, ::size_t 
#line 566
count, ::size_t 
#line 567
offset = 0, ::cudaMemcpyKind 
#line 568
kind = cudaMemcpyHostToDevice) 
#line 570
{ 
#line 571
return ::cudaMemcpyToSymbol((const void *)(&symbol), src, count, offset, kind); 
#line 572
} 
#line 614
template< class T> static __inline ::cudaError_t 
#line 615
cudaMemcpyToSymbolAsync(const T &
#line 616
symbol, const void *
#line 617
src, ::size_t 
#line 618
count, ::size_t 
#line 619
offset = 0, ::cudaMemcpyKind 
#line 620
kind = cudaMemcpyHostToDevice, ::cudaStream_t 
#line 621
stream = 0) 
#line 623
{ 
#line 624
return ::cudaMemcpyToSymbolAsync((const void *)(&symbol), src, count, offset, kind, stream); 
#line 625
} 
#line 660
template< class T> static __inline ::cudaError_t 
#line 661
cudaMemcpyFromSymbol(void *
#line 662
dst, const T &
#line 663
symbol, ::size_t 
#line 664
count, ::size_t 
#line 665
offset = 0, ::cudaMemcpyKind 
#line 666
kind = cudaMemcpyDeviceToHost) 
#line 668
{ 
#line 669
return ::cudaMemcpyFromSymbol(dst, (const void *)(&symbol), count, offset, kind); 
#line 670
} 
#line 712
template< class T> static __inline ::cudaError_t 
#line 713
cudaMemcpyFromSymbolAsync(void *
#line 714
dst, const T &
#line 715
symbol, ::size_t 
#line 716
count, ::size_t 
#line 717
offset = 0, ::cudaMemcpyKind 
#line 718
kind = cudaMemcpyDeviceToHost, ::cudaStream_t 
#line 719
stream = 0) 
#line 721
{ 
#line 722
return ::cudaMemcpyFromSymbolAsync(dst, (const void *)(&symbol), count, offset, kind, stream); 
#line 723
} 
#line 745
template< class T> static __inline ::cudaError_t 
#line 746
cudaGetSymbolAddress(void **
#line 747
devPtr, const T &
#line 748
symbol) 
#line 750
{ 
#line 751
return ::cudaGetSymbolAddress(devPtr, (const void *)(&symbol)); 
#line 752
} 
#line 774
template< class T> static __inline ::cudaError_t 
#line 775
cudaGetSymbolSize(::size_t *
#line 776
size, const T &
#line 777
symbol) 
#line 779
{ 
#line 780
return ::cudaGetSymbolSize(size, (const void *)(&symbol)); 
#line 781
} 
#line 817
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 818
cudaBindTexture(::size_t *
#line 819
offset, const texture< T, dim, readMode>  &
#line 820
tex, const void *
#line 821
devPtr, const ::cudaChannelFormatDesc &
#line 822
desc, ::size_t 
#line 823
size = 4294967295U) 
#line 825
{ 
#line 826
return ::cudaBindTexture(offset, &tex, devPtr, &desc, size); 
#line 827
} 
#line 862
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 863
cudaBindTexture(::size_t *
#line 864
offset, const texture< T, dim, readMode>  &
#line 865
tex, const void *
#line 866
devPtr, ::size_t 
#line 867
size = 4294967295U) 
#line 869
{ 
#line 870
return cudaBindTexture(offset, tex, devPtr, (tex.channelDesc), size); 
#line 871
} 
#line 918
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 919
cudaBindTexture2D(::size_t *
#line 920
offset, const texture< T, dim, readMode>  &
#line 921
tex, const void *
#line 922
devPtr, const ::cudaChannelFormatDesc &
#line 923
desc, ::size_t 
#line 924
width, ::size_t 
#line 925
height, ::size_t 
#line 926
pitch) 
#line 928
{ 
#line 929
return ::cudaBindTexture2D(offset, &tex, devPtr, &desc, width, height, pitch); 
#line 930
} 
#line 976
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 977
cudaBindTexture2D(::size_t *
#line 978
offset, const texture< T, dim, readMode>  &
#line 979
tex, const void *
#line 980
devPtr, ::size_t 
#line 981
width, ::size_t 
#line 982
height, ::size_t 
#line 983
pitch) 
#line 985
{ 
#line 986
return ::cudaBindTexture2D(offset, &tex, devPtr, &(tex.channelDesc), width, height, pitch); 
#line 987
} 
#line 1018
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1019
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1020
tex, ::cudaArray_const_t 
#line 1021
array, const ::cudaChannelFormatDesc &
#line 1022
desc) 
#line 1024
{ 
#line 1025
return ::cudaBindTextureToArray(&tex, array, &desc); 
#line 1026
} 
#line 1056
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1057
cudaBindTextureToArray(const texture< T, dim, readMode>  &
#line 1058
tex, ::cudaArray_const_t 
#line 1059
array) 
#line 1061
{ 
#line 1062
::cudaChannelFormatDesc desc; 
#line 1063
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1065
return (err == (cudaSuccess)) ? cudaBindTextureToArray(tex, array, desc) : err; 
#line 1066
} 
#line 1097
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1098
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1099
tex, ::cudaMipmappedArray_const_t 
#line 1100
mipmappedArray, const ::cudaChannelFormatDesc &
#line 1101
desc) 
#line 1103
{ 
#line 1104
return ::cudaBindTextureToMipmappedArray(&tex, mipmappedArray, &desc); 
#line 1105
} 
#line 1135
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1136
cudaBindTextureToMipmappedArray(const texture< T, dim, readMode>  &
#line 1137
tex, ::cudaMipmappedArray_const_t 
#line 1138
mipmappedArray) 
#line 1140
{ 
#line 1141
::cudaChannelFormatDesc desc; 
#line 1142
::cudaArray_t levelArray; 
#line 1143
::cudaError_t err = ::cudaGetMipmappedArrayLevel(&levelArray, mipmappedArray, 0); 
#line 1145
if (err != (cudaSuccess)) { 
#line 1146
return err; 
#line 1147
}  
#line 1148
err = ::cudaGetChannelDesc(&desc, levelArray); 
#line 1150
return (err == (cudaSuccess)) ? cudaBindTextureToMipmappedArray(tex, mipmappedArray, desc) : err; 
#line 1151
} 
#line 1174
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1175
cudaUnbindTexture(const texture< T, dim, readMode>  &
#line 1176
tex) 
#line 1178
{ 
#line 1179
return ::cudaUnbindTexture(&tex); 
#line 1180
} 
#line 1208
template< class T, int dim, cudaTextureReadMode readMode> static __inline ::cudaError_t 
#line 1209
cudaGetTextureAlignmentOffset(::size_t *
#line 1210
offset, const texture< T, dim, readMode>  &
#line 1211
tex) 
#line 1213
{ 
#line 1214
return ::cudaGetTextureAlignmentOffset(offset, &tex); 
#line 1215
} 
#line 1260
template< class T> static __inline ::cudaError_t 
#line 1261
cudaFuncSetCacheConfig(T *
#line 1262
func, ::cudaFuncCache 
#line 1263
cacheConfig) 
#line 1265
{ 
#line 1266
return ::cudaFuncSetCacheConfig((const void *)func, cacheConfig); 
#line 1267
} 
#line 1269
template< class T> static __inline ::cudaError_t 
#line 1270
cudaFuncSetSharedMemConfig(T *
#line 1271
func, ::cudaSharedMemConfig 
#line 1272
config) 
#line 1274
{ 
#line 1275
return ::cudaFuncSetSharedMemConfig((const void *)func, config); 
#line 1276
} 
#line 1305
template< class T> __inline ::cudaError_t 
#line 1306
cudaOccupancyMaxActiveBlocksPerMultiprocessor(int *
#line 1307
numBlocks, T 
#line 1308
func, int 
#line 1309
blockSize, ::size_t 
#line 1310
dynamicSMemSize) 
#line 1311
{ 
#line 1312
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, 0); 
#line 1313
} 
#line 1356
template< class T> __inline ::cudaError_t 
#line 1357
cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(int *
#line 1358
numBlocks, T 
#line 1359
func, int 
#line 1360
blockSize, ::size_t 
#line 1361
dynamicSMemSize, unsigned 
#line 1362
flags) 
#line 1363
{ 
#line 1364
return ::cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(numBlocks, (const void *)func, blockSize, dynamicSMemSize, flags); 
#line 1365
} 
#line 1370
class __cudaOccupancyB2DHelper { 
#line 1371
size_t n; 
#line 1373
public: __cudaOccupancyB2DHelper(size_t n_) : n(n_) { } 
#line 1374
size_t operator()(int) 
#line 1375
{ 
#line 1376
return n; 
#line 1377
} 
#line 1378
}; 
#line 1380
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1381
cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(int *
#line 1382
minGridSize, int *
#line 1383
blockSize, T 
#line 1384
func, UnaryFunction 
#line 1385
blockSizeToDynamicSMemSize, int 
#line 1386
blockSizeLimit = 0, unsigned 
#line 1387
flags = 0) 
#line 1388
{ 
#line 1389
::cudaError_t status; 
#line 1392
int device; 
#line 1393
::cudaFuncAttributes attr; 
#line 1396
int maxThreadsPerMultiProcessor; 
#line 1397
int warpSize; 
#line 1398
int devMaxThreadsPerBlock; 
#line 1399
int multiProcessorCount; 
#line 1400
int funcMaxThreadsPerBlock; 
#line 1401
int occupancyLimit; 
#line 1402
int granularity; 
#line 1405
int maxBlockSize = 0; 
#line 1406
int numBlocks = 0; 
#line 1407
int maxOccupancy = 0; 
#line 1410
int blockSizeToTryAligned; 
#line 1411
int blockSizeToTry; 
#line 1412
int blockSizeLimitAligned; 
#line 1413
int occupancyInBlocks; 
#line 1414
int occupancyInThreads; 
#line 1415
int dynamicSMemSize; 
#line 1421
if (((!minGridSize) || (!blockSize)) || (!func)) { 
#line 1422
return cudaErrorInvalidValue; 
#line 1423
}  
#line 1429
status = ::cudaGetDevice(&device); 
#line 1430
if (status != (cudaSuccess)) { 
#line 1431
return status; 
#line 1432
}  
#line 1434
status = cudaDeviceGetAttribute(&maxThreadsPerMultiProcessor, cudaDevAttrMaxThreadsPerMultiProcessor, device); 
#line 1438
if (status != (cudaSuccess)) { 
#line 1439
return status; 
#line 1440
}  
#line 1442
status = cudaDeviceGetAttribute(&warpSize, cudaDevAttrWarpSize, device); 
#line 1446
if (status != (cudaSuccess)) { 
#line 1447
return status; 
#line 1448
}  
#line 1450
status = cudaDeviceGetAttribute(&devMaxThreadsPerBlock, cudaDevAttrMaxThreadsPerBlock, device); 
#line 1454
if (status != (cudaSuccess)) { 
#line 1455
return status; 
#line 1456
}  
#line 1458
status = cudaDeviceGetAttribute(&multiProcessorCount, cudaDevAttrMultiProcessorCount, device); 
#line 1462
if (status != (cudaSuccess)) { 
#line 1463
return status; 
#line 1464
}  
#line 1466
status = cudaFuncGetAttributes(&attr, func); 
#line 1467
if (status != (cudaSuccess)) { 
#line 1468
return status; 
#line 1469
}  
#line 1471
funcMaxThreadsPerBlock = (attr.maxThreadsPerBlock); 
#line 1477
occupancyLimit = maxThreadsPerMultiProcessor; 
#line 1478
granularity = warpSize; 
#line 1480
if (blockSizeLimit == 0) { 
#line 1481
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1482
}  
#line 1484
if (devMaxThreadsPerBlock < blockSizeLimit) { 
#line 1485
blockSizeLimit = devMaxThreadsPerBlock; 
#line 1486
}  
#line 1488
if (funcMaxThreadsPerBlock < blockSizeLimit) { 
#line 1489
blockSizeLimit = funcMaxThreadsPerBlock; 
#line 1490
}  
#line 1492
blockSizeLimitAligned = (((blockSizeLimit + (granularity - 1)) / granularity) * granularity); 
#line 1494
for (blockSizeToTryAligned = blockSizeLimitAligned; blockSizeToTryAligned > 0; blockSizeToTryAligned -= granularity) { 
#line 1498
if (blockSizeLimit < blockSizeToTryAligned) { 
#line 1499
blockSizeToTry = blockSizeLimit; 
#line 1500
} else { 
#line 1501
blockSizeToTry = blockSizeToTryAligned; 
#line 1502
}  
#line 1504
dynamicSMemSize = blockSizeToDynamicSMemSize(blockSizeToTry); 
#line 1506
status = cudaOccupancyMaxActiveBlocksPerMultiprocessorWithFlags(&occupancyInBlocks, func, blockSizeToTry, dynamicSMemSize, flags); 
#line 1513
if (status != (cudaSuccess)) { 
#line 1514
return status; 
#line 1515
}  
#line 1517
occupancyInThreads = (blockSizeToTry * occupancyInBlocks); 
#line 1519
if (occupancyInThreads > maxOccupancy) { 
#line 1520
maxBlockSize = blockSizeToTry; 
#line 1521
numBlocks = occupancyInBlocks; 
#line 1522
maxOccupancy = occupancyInThreads; 
#line 1523
}  
#line 1527
if (occupancyLimit == maxOccupancy) { 
#line 1528
break; 
#line 1529
}  
#line 1530
}  
#line 1538
(*minGridSize) = (numBlocks * multiProcessorCount); 
#line 1539
(*blockSize) = maxBlockSize; 
#line 1541
return status; 
#line 1542
} 
#line 1575
template< class UnaryFunction, class T> static __inline ::cudaError_t 
#line 1576
cudaOccupancyMaxPotentialBlockSizeVariableSMem(int *
#line 1577
minGridSize, int *
#line 1578
blockSize, T 
#line 1579
func, UnaryFunction 
#line 1580
blockSizeToDynamicSMemSize, int 
#line 1581
blockSizeLimit = 0) 
#line 1582
{ 
#line 1583
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, blockSizeToDynamicSMemSize, blockSizeLimit, 0); 
#line 1584
} 
#line 1620
template< class T> static __inline ::cudaError_t 
#line 1621
cudaOccupancyMaxPotentialBlockSize(int *
#line 1622
minGridSize, int *
#line 1623
blockSize, T 
#line 1624
func, ::size_t 
#line 1625
dynamicSMemSize = 0, int 
#line 1626
blockSizeLimit = 0) 
#line 1627
{ 
#line 1628
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, 0); 
#line 1629
} 
#line 1679
template< class T> static __inline ::cudaError_t 
#line 1680
cudaOccupancyMaxPotentialBlockSizeWithFlags(int *
#line 1681
minGridSize, int *
#line 1682
blockSize, T 
#line 1683
func, ::size_t 
#line 1684
dynamicSMemSize = 0, int 
#line 1685
blockSizeLimit = 0, unsigned 
#line 1686
flags = 0) 
#line 1687
{ 
#line 1688
return cudaOccupancyMaxPotentialBlockSizeVariableSMemWithFlags(minGridSize, blockSize, func, ((::__cudaOccupancyB2DHelper)(dynamicSMemSize)), blockSizeLimit, flags); 
#line 1689
} 
#line 1772
template< class T> static __inline ::cudaError_t 
#line 1773
cudaLaunch(T *
#line 1774
func) 
#line 1776
{ 
#line 1777
return ::cudaLaunch((const void *)func); 
#line 1778
} 
#line 1809
template< class T> __inline ::cudaError_t 
#line 1810
cudaFuncGetAttributes(::cudaFuncAttributes *
#line 1811
attr, T *
#line 1812
entry) 
#line 1814
{ 
#line 1815
return ::cudaFuncGetAttributes(attr, (const void *)entry); 
#line 1816
} 
#line 1838
template< class T, int dim> static __inline ::cudaError_t 
#line 1839
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1840
surf, ::cudaArray_const_t 
#line 1841
array, const ::cudaChannelFormatDesc &
#line 1842
desc) 
#line 1844
{ 
#line 1845
return ::cudaBindSurfaceToArray(&surf, array, &desc); 
#line 1846
} 
#line 1867
template< class T, int dim> static __inline ::cudaError_t 
#line 1868
cudaBindSurfaceToArray(const surface< T, dim>  &
#line 1869
surf, ::cudaArray_const_t 
#line 1870
array) 
#line 1872
{ 
#line 1873
::cudaChannelFormatDesc desc; 
#line 1874
::cudaError_t err = ::cudaGetChannelDesc(&desc, array); 
#line 1876
return (err == (cudaSuccess)) ? cudaBindSurfaceToArray(surf, array, desc) : err; 
#line 1877
} 
#line 1891 "E:/CudaToolKit/include\\cuda_runtime.h"
#pragma warning(pop)
#line 26 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
#pragma pack ( push, 8 )
#line 63 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { struct _iobuf { 
#line 64
char *_ptr; 
#line 65
int _cnt; 
#line 66
char *_base; 
#line 67
int _flag; 
#line 68
int _file; 
#line 69
int _charbuf; 
#line 70
int _bufsiz; 
#line 71
char *_tmpfname; 
#line 72
}; }
#line 73
extern "C" { typedef _iobuf FILE; }
#line 137 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl __iob_func(); } 
#line 144 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { typedef __int64 fpos_t; }
#line 175 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _filbuf(FILE * _File); } 
#line 176
extern "C" { __declspec(dllimport) int __cdecl _flsbuf(int _Ch, FILE * _File); } 
#line 178
extern "C" { __declspec(dllimport) FILE *__cdecl _fsopen(const char * _Filename, const char * _Mode, int _ShFlag); } 
#line 180
extern "C" { __declspec(dllimport) void __cdecl clearerr(FILE * _File); } 
#line 182
extern "C" { __declspec(dllimport) errno_t __cdecl clearerr_s(FILE * _File); } 
#line 184 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fclose(FILE * _File); } 
#line 185
extern "C" { __declspec(dllimport) int __cdecl _fcloseall(); } 
#line 187
extern "C" { __declspec(dllimport) FILE *__cdecl _fdopen(int _FileHandle, const char * _Mode); } 
#line 189
extern "C" { __declspec(dllimport) int __cdecl feof(FILE * _File); } 
#line 190
extern "C" { __declspec(dllimport) int __cdecl ferror(FILE * _File); } 
#line 191
extern "C" { __declspec(dllimport) int __cdecl fflush(FILE * _File); } 
#line 192
extern "C" { __declspec(dllimport) int __cdecl fgetc(FILE * _File); } 
#line 193
extern "C" { __declspec(dllimport) int __cdecl _fgetchar(); } 
#line 194
extern "C" { __declspec(dllimport) int __cdecl fgetpos(FILE * _File, fpos_t * _Pos); } 
#line 195
extern "C" { __declspec(dllimport) char *__cdecl fgets(char * _Buf, int _MaxCount, FILE * _File); } 
#line 197
extern "C" { __declspec(dllimport) int __cdecl _fileno(FILE * _File); } 
#line 204 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) char *__cdecl _tempnam(const char * _DirName, const char * _FilePrefix); } 
#line 210 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _flushall(); } 
#line 211
extern "C" { __declspec(dllimport) FILE *__cdecl fopen(const char * _Filename, const char * _Mode); } 
#line 213
extern "C" { __declspec(dllimport) errno_t __cdecl fopen_s(FILE ** _File, const char * _Filename, const char * _Mode); } 
#line 215 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fprintf(FILE * _File, const char * _Format, ...); } 
#line 217
extern "C" { __declspec(dllimport) int __cdecl fprintf_s(FILE * _File, const char * _Format, ...); } 
#line 219 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fputc(int _Ch, FILE * _File); } 
#line 220
extern "C" { __declspec(dllimport) int __cdecl _fputchar(int _Ch); } 
#line 221
extern "C" { __declspec(dllimport) int __cdecl fputs(const char * _Str, FILE * _File); } 
#line 222
extern "C" { __declspec(dllimport) size_t __cdecl fread(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File); } 
#line 224
extern "C" { __declspec(dllimport) size_t __cdecl fread_s(void * _DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE * _File); } 
#line 226 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl freopen(const char * _Filename, const char * _Mode, FILE * _File); } 
#line 228
extern "C" { __declspec(dllimport) errno_t __cdecl freopen_s(FILE ** _File, const char * _Filename, const char * _Mode, FILE * _OldFile); } 
#line 230 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fscanf(FILE * _File, const char * _Format, ...); } 
#line 231
extern "C" { __declspec(dllimport) int __cdecl _fscanf_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 235
extern "C" { __declspec(dllimport) int __cdecl fscanf_s(FILE * _File, const char * _Format, ...); } 
#line 237 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _fscanf_s_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl fsetpos(FILE * _File, const fpos_t * _Pos); } 
#line 240
extern "C" { __declspec(dllimport) int __cdecl fseek(FILE * _File, long _Offset, int _Origin); } 
#line 241
extern "C" { __declspec(dllimport) long __cdecl ftell(FILE * _File); } 
#line 243
extern "C" { __declspec(dllimport) int __cdecl _fseeki64(FILE * _File, __int64 _Offset, int _Origin); } 
#line 244
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64(FILE * _File); } 
#line 246
extern "C" { __declspec(dllimport) size_t __cdecl fwrite(const void * _Str, size_t _Size, size_t _Count, FILE * _File); } 
#line 247
extern "C" { __declspec(dllimport) int __cdecl getc(FILE * _File); } 
#line 248
extern "C" { __declspec(dllimport) int __cdecl getchar(); } 
#line 249
extern "C" { __declspec(dllimport) int __cdecl _getmaxstdio(); } 
#line 251
extern "C" { __declspec(dllimport) char *__cdecl gets_s(char * _Buf, rsize_t _Size); } 
#line 253 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
template < size_t _Size > inline char * __cdecl gets_s ( char ( & _Buffer ) [ _Size ] ) throw ( ) { return gets_s ( _Buffer, _Size ); }
#line 254
extern "C" { __declspec(dllimport) char *__cdecl gets(char * _Buffer); } 
#line 255
extern "C" { int __cdecl _getw(FILE * _File); } 
#line 261
extern "C" { __declspec(dllimport) int __cdecl _pclose(FILE * _File); } 
#line 262
extern "C" { __declspec(dllimport) FILE *__cdecl _popen(const char * _Command, const char * _Mode); } 
#line 264 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl printf(const char * _Format, ...); } 
#line 266
extern "C" { __declspec(dllimport) int __cdecl printf_s(const char * _Format, ...); } 
#line 268 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl putc(int _Ch, FILE * _File); } 
#line 269
extern "C" { __declspec(dllimport) int __cdecl putchar(int _Ch); } 
#line 270
extern "C" { __declspec(dllimport) int __cdecl puts(const char * _Str); } 
#line 271
extern "C" { __declspec(dllimport) int __cdecl _putw(int _Word, FILE * _File); } 
#line 274
extern "C" { __declspec(dllimport) int __cdecl remove(const char * _Filename); } 
#line 275
extern "C" { __declspec(dllimport) int __cdecl rename(const char * _OldFilename, const char * _NewFilename); } 
#line 276
extern "C" { __declspec(dllimport) int __cdecl _unlink(const char * _Filename); } 
#line 278
extern "C" { __declspec(dllimport) int __cdecl unlink(const char * _Filename); } 
#line 281 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl rewind(FILE * _File); } 
#line 282
extern "C" { __declspec(dllimport) int __cdecl _rmtmp(); } 
#line 283
extern "C" { __declspec(dllimport) int __cdecl scanf(const char * _Format, ...); } 
#line 284
extern "C" { __declspec(dllimport) int __cdecl _scanf_l(const char * _Format, _locale_t _Locale, ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 288
extern "C" { __declspec(dllimport) int __cdecl scanf_s(const char * _Format, ...); } 
#line 290 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _scanf_s_l(const char * _Format, _locale_t _Locale, ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) void __cdecl setbuf(FILE * _File, char * _Buffer); } 
#line 293
extern "C" { __declspec(dllimport) int __cdecl _setmaxstdio(int _Max); } 
#line 294
extern "C" { __declspec(dllimport) unsigned __cdecl _set_output_format(unsigned _Format); } 
#line 295
extern "C" { __declspec(dllimport) unsigned __cdecl _get_output_format(); } 
#line 296
extern "C" { __declspec(dllimport) int __cdecl setvbuf(FILE * _File, char * _Buf, int _Mode, size_t _Size); } 
#line 297
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s(char * _DstBuf, size_t _SizeInBytes, size_t _MaxCount, const char * _Format, ...); } 
#line 298
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 300
extern "C" { __declspec(dllimport) int __cdecl sprintf_s(char * _DstBuf, size_t _SizeInBytes, const char * _Format, ...); } 
#line 302 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl sprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vsprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 303
extern "C" { __declspec(dllimport) int __cdecl _scprintf(const char * _Format, ...); } 
#line 304
extern "C" { __declspec(dllimport) int __cdecl sscanf(const char * _Src, const char * _Format, ...); } 
#line 305
extern "C" { __declspec(dllimport) int __cdecl _sscanf_l(const char * _Src, const char * _Format, _locale_t _Locale, ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 309
extern "C" { __declspec(dllimport) int __cdecl sscanf_s(const char * _Src, const char * _Format, ...); } 
#line 311 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _sscanf_s_l(const char * _Src, const char * _Format, _locale_t _Locale, ...); } 
#line 312
extern "C" { __declspec(dllimport) int __cdecl _snscanf(const char * _Src, size_t _MaxCount, const char * _Format, ...); } 
#line 313
extern "C" { __declspec(dllimport) int __cdecl _snscanf_l(const char * _Src, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
#line 314
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s(const char * _Src, size_t _MaxCount, const char * _Format, ...); } 
#line 315
extern "C" { __declspec(dllimport) int __cdecl _snscanf_s_l(const char * _Src, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) FILE *__cdecl tmpfile(); } 
#line 319
extern "C" { __declspec(dllimport) errno_t __cdecl tmpfile_s(FILE ** _File); } 
#line 320
extern "C" { __declspec(dllimport) errno_t __cdecl tmpnam_s(char * _Buf, rsize_t _Size); } 
#line 322 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
template < size_t _Size > inline errno_t __cdecl tmpnam_s ( char ( & _Buf ) [ _Size ] ) throw ( ) { return tmpnam_s ( _Buf, _Size ); }
#line 323
extern "C" { __declspec(dllimport) char *__cdecl tmpnam(char * _Buffer); } 
#line 324
extern "C" { __declspec(dllimport) int __cdecl ungetc(int _Ch, FILE * _File); } 
#line 325
extern "C" { __declspec(dllimport) int __cdecl vfprintf(FILE * _File, const char * _Format, va_list _ArgList); } 
#line 326
extern "C" { __declspec(dllimport) int __cdecl vfscanf(FILE * _File, const char * _Format, va_list _ArgList); } 
#line 328
extern "C" { __declspec(dllimport) int __cdecl vfprintf_s(FILE * _File, const char * _Format, va_list _ArgList); } 
#line 329
extern "C" { __declspec(dllimport) int __cdecl vfscanf_s(FILE * _File, const char * _Format, va_list _ArgList); } 
#line 331 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vprintf(const char * _Format, va_list _ArgList); } 
#line 332
extern "C" { __declspec(dllimport) int __cdecl vscanf(const char * _Format, va_list _ArgList); } 
#line 334
extern "C" { __declspec(dllimport) int __cdecl vprintf_s(const char * _Format, va_list _ArgList); } 
#line 335
extern "C" { __declspec(dllimport) int __cdecl vscanf_s(const char * _Format, va_list _ArgList); } 
#line 337 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vsnprintf(char * _DstBuf, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
#line 339
extern "C" { __declspec(dllimport) int __cdecl vsnprintf_s(char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
#line 340
template < size_t _Size > inline int __cdecl vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#line 342 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s(char * _DstBuf, size_t _SizeInBytes, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
#line 343
template < size_t _Size > inline int __cdecl _vsnprintf_s ( char ( & _Dest ) [ _Size ], size_t _MaxCount, const char * _Format, va_list _Args ) throw ( ) { return _vsnprintf_s ( _Dest, _Size, _MaxCount, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl _snprintf(char * _Dest, size_t _Count, const char * _Format, ...); } extern "C" { __declspec(dllimport) int __cdecl _vsnprintf(char * _Dest, size_t _Count, const char * _Format, va_list _Args); } 
#pragma warning(pop)
#line 349
extern "C" { __declspec(dllimport) int __cdecl vsprintf_s(char * _DstBuf, size_t _SizeInBytes, const char * _Format, va_list _ArgList); } 
#line 350
template < size_t _Size > inline int __cdecl vsprintf_s ( char ( & _Dest ) [ _Size ], const char * _Format, va_list _Args ) throw ( ) { return vsprintf_s ( _Dest, _Size, _Format, _Args ); }
#line 351
extern "C" { __declspec(dllimport) int __cdecl vsscanf_s(const char * _Src, const char * _Format, va_list _ArgList); } 
#line 352
template < size_t _Size > inline int __cdecl vsscanf_s ( const char ( & _Src ) [ _Size ], const char * _Format, va_list _Args ) throw ( ) { return vsscanf_s ( _Src, _Size, _Format, _Args ); }
#line 354 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl sprintf(char * _Dest, const char * _Format, ...); } extern "C" { __declspec(dllimport) int __cdecl vsprintf(char * _Dest, const char * _Format, va_list _Args); } 
#line 357
extern "C" { __declspec(dllimport) int __cdecl vsscanf(const char * _srcBuf, const char * _Format, va_list _ArgList); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) int __cdecl _vscprintf(const char * _Format, va_list _ArgList); } 
#line 360
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c(char * _DstBuf, size_t _MaxCount, const char * _Format, ...); } 
#line 361
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c(char * _DstBuf, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
#line 363
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p(FILE * _File, const char * _Format, ...); } 
#line 364
extern "C" { __declspec(dllimport) int __cdecl _printf_p(const char * _Format, ...); } 
#line 365
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p(char * _Dst, size_t _MaxCount, const char * _Format, ...); } 
#line 366
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p(FILE * _File, const char * _Format, va_list _ArgList); } 
#line 367
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p(const char * _Format, va_list _ArgList); } 
#line 368
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p(char * _Dst, size_t _MaxCount, const char * _Format, va_list _ArgList); } 
#line 369
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p(const char * _Format, ...); } 
#line 370
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p(const char * _Format, va_list _ArgList); } 
#line 371
extern "C" { __declspec(dllimport) int __cdecl _set_printf_count_output(int _Value); } 
#line 372
extern "C" { __declspec(dllimport) int __cdecl _get_printf_count_output(); } 
#line 374
extern "C" { __declspec(dllimport) int __cdecl _printf_l(const char * _Format, _locale_t _Locale, ...); } 
#line 375
extern "C" { __declspec(dllimport) int __cdecl _printf_p_l(const char * _Format, _locale_t _Locale, ...); } 
#line 376
extern "C" { __declspec(dllimport) int __cdecl _printf_s_l(const char * _Format, _locale_t _Locale, ...); } 
#line 377
extern "C" { __declspec(dllimport) int __cdecl _vprintf_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 378
extern "C" { __declspec(dllimport) int __cdecl _vprintf_p_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 379
extern "C" { __declspec(dllimport) int __cdecl _vprintf_s_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 381
extern "C" { __declspec(dllimport) int __cdecl _fprintf_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
#line 382
extern "C" { __declspec(dllimport) int __cdecl _fprintf_p_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
#line 383
extern "C" { __declspec(dllimport) int __cdecl _fprintf_s_l(FILE * _File, const char * _Format, _locale_t _Locale, ...); } 
#line 384
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_l(FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 385
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_p_l(FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 386
extern "C" { __declspec(dllimport) int __cdecl _vfprintf_s_l(FILE * _File, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 388
extern "C" { __declspec(dllimport) int __cdecl _sprintf_l(char * _DstBuf, const char * _Format, _locale_t _Locale, ...); } 
#line 389
extern "C" { __declspec(dllimport) int __cdecl _sprintf_p_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
#line 390
extern "C" { __declspec(dllimport) int __cdecl _sprintf_s_l(char * _DstBuf, size_t _DstSize, const char * _Format, _locale_t _Locale, ...); } 
#line 391
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_l(char * _DstBuf, const char * _Format, _locale_t, va_list _ArgList); } 
#line 392
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_p_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 393
extern "C" { __declspec(dllimport) int __cdecl _vsprintf_s_l(char * _DstBuf, size_t _DstSize, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 395
extern "C" { __declspec(dllimport) int __cdecl _scprintf_l(const char * _Format, _locale_t _Locale, ...); } 
#line 396
extern "C" { __declspec(dllimport) int __cdecl _scprintf_p_l(const char * _Format, _locale_t _Locale, ...); } 
#line 397
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 398
extern "C" { __declspec(dllimport) int __cdecl _vscprintf_p_l(const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 400
extern "C" { __declspec(dllimport) int __cdecl _snprintf_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
#line 401
extern "C" { __declspec(dllimport) int __cdecl _snprintf_c_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
#line 402
extern "C" { __declspec(dllimport) int __cdecl _snprintf_s_l(char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, _locale_t _Locale, ...); } 
#line 403
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_l(char * _DstBuf, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 404
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_c_l(char * _DstBuf, size_t _MaxCount, const char *, _locale_t _Locale, va_list _ArgList); } 
#line 405
extern "C" { __declspec(dllimport) int __cdecl _vsnprintf_s_l(char * _DstBuf, size_t _DstSize, size_t _MaxCount, const char * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 415 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) FILE *__cdecl _wfsopen(const __wchar_t * _Filename, const __wchar_t * _Mode, int _ShFlag); } 
#line 417
extern "C" { __declspec(dllimport) wint_t __cdecl fgetwc(FILE * _File); } 
#line 418
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwchar(); } 
#line 419
extern "C" { __declspec(dllimport) wint_t __cdecl fputwc(__wchar_t _Ch, FILE * _File); } 
#line 420
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwchar(__wchar_t _Ch); } 
#line 421
extern "C" { __declspec(dllimport) wint_t __cdecl getwc(FILE * _File); } 
#line 422
extern "C" { __declspec(dllimport) inline wint_t __cdecl getwchar(); } 
#line 423
extern "C" { __declspec(dllimport) wint_t __cdecl putwc(__wchar_t _Ch, FILE * _File); } 
#line 424
extern "C" { __declspec(dllimport) inline wint_t __cdecl putwchar(__wchar_t _Ch); } 
#line 425
extern "C" { __declspec(dllimport) wint_t __cdecl ungetwc(wint_t _Ch, FILE * _File); } 
#line 427
extern "C" { __declspec(dllimport) __wchar_t *__cdecl fgetws(__wchar_t * _Dst, int _SizeInWords, FILE * _File); } 
#line 428
extern "C" { __declspec(dllimport) int __cdecl fputws(const __wchar_t * _Str, FILE * _File); } 
#line 429
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws_s(__wchar_t * _Str, size_t _SizeInWords); } 
#line 430
template < size_t _Size > inline wchar_t * __cdecl _getws_s ( wchar_t ( & _String ) [ _Size ] ) throw ( ) { return _getws_s ( _String, _Size ); }
#line 431
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _getws(__wchar_t * _String); } 
#line 432
extern "C" { __declspec(dllimport) int __cdecl _putws(const __wchar_t * _Str); } 
#line 434
extern "C" { __declspec(dllimport) int __cdecl fwprintf(FILE * _File, const __wchar_t * _Format, ...); } 
#line 436
extern "C" { __declspec(dllimport) int __cdecl fwprintf_s(FILE * _File, const __wchar_t * _Format, ...); } 
#line 438 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl wprintf(const __wchar_t * _Format, ...); } 
#line 440
extern "C" { __declspec(dllimport) int __cdecl wprintf_s(const __wchar_t * _Format, ...); } 
#line 442 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _scwprintf(const __wchar_t * _Format, ...); } 
#line 443
extern "C" { __declspec(dllimport) int __cdecl vfwprintf(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 
#line 444
extern "C" { __declspec(dllimport) int __cdecl vfwscanf(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 
#line 446
extern "C" { __declspec(dllimport) int __cdecl vfwprintf_s(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 
#line 447
extern "C" { __declspec(dllimport) int __cdecl vfwscanf_s(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 
#line 449 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl vwprintf(const __wchar_t * _Format, va_list _ArgList); } 
#line 450
extern "C" { __declspec(dllimport) int __cdecl vwscanf(const __wchar_t * _Format, va_list _ArgList); } 
#line 452
extern "C" { __declspec(dllimport) int __cdecl vwprintf_s(const __wchar_t * _Format, va_list _ArgList); } 
#line 453
extern "C" { __declspec(dllimport) int __cdecl vwscanf_s(const __wchar_t * _Format, va_list _ArgList); } 
#line 457 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl swprintf_s(__wchar_t * _Dst, size_t _SizeInWords, const __wchar_t * _Format, ...); } 
#line 459 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl swprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return vswprintf_s ( _Dest, _Size, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 461
extern "C" { __declspec(dllimport) int __cdecl vswprintf_s(__wchar_t * _Dst, size_t _SizeInWords, const __wchar_t * _Format, va_list _ArgList); } 
#line 462
extern "C" { __declspec(dllimport) int __cdecl vswscanf_s(const __wchar_t * _Src, const __wchar_t * _Format, va_list _ArgList); } 
#line 464 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
template < size_t _Size > inline int __cdecl vswprintf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, va_list _Args ) throw ( ) { return vswprintf_s ( _Dest, _Size, _Format, _Args ); }
#line 465
template < size_t _Size > inline int __cdecl vswscanf_s ( wchar_t ( & _Dest ) [ _Size ], const wchar_t * _Format, va_list _Args ) throw ( ) { return vswscanf_s ( _Dest, _Size, _Format, _Args ); }
#line 466
extern "C" { __declspec(dllimport) int __cdecl vswscanf(const __wchar_t * _srcBuf, const __wchar_t * _Format, va_list _ArgList); } 
#line 468
extern "C" { __declspec(dllimport) int __cdecl _swprintf_c(__wchar_t * _DstBuf, size_t _SizeInWords, const __wchar_t * _Format, ...); } 
#line 469
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c(__wchar_t * _DstBuf, size_t _SizeInWords, const __wchar_t * _Format, va_list _ArgList); } 
#line 471
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s(__wchar_t * _DstBuf, size_t _SizeInWords, size_t _MaxCount, const __wchar_t * _Format, ...); } 
#line 472
__pragma( warning(push)) __pragma( warning(disable: 4793)) template < size_t _Size > inline int __cdecl _snwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, ... ) throw ( ) { va_list _ArgList; ( _ArgList = ( va_list ) ( & reinterpret_cast < const char & > ( _Format ) ) + ( ( sizeof ( _Format ) + sizeof ( int ) - 1 ) & ~ ( sizeof ( int ) - 1 ) ) ); return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _ArgList ); }__pragma( warning(pop)) 
#line 473
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s(__wchar_t * _DstBuf, size_t _SizeInWords, size_t _MaxCount, const __wchar_t * _Format, va_list _ArgList); } 
#line 474
template < size_t _Size > inline int __cdecl _vsnwprintf_s ( wchar_t ( & _Dest ) [ _Size ], size_t _Count, const wchar_t * _Format, va_list _Args ) throw ( ) { return _vsnwprintf_s ( _Dest, _Size, _Count, _Format, _Args ); }
#pragma warning(push)
#pragma warning(disable:4793)
extern "C" { __declspec(dllimport) int __cdecl _snwprintf(__wchar_t * _Dest, size_t _Count, const __wchar_t * _Format, ...); } extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf(__wchar_t * _Dest, size_t _Count, const __wchar_t * _Format, va_list _Args); } 
#pragma warning(pop)
#line 480
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p(FILE * _File, const __wchar_t * _Format, ...); } 
#line 481
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p(const __wchar_t * _Format, ...); } 
#line 482
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p(FILE * _File, const __wchar_t * _Format, va_list _ArgList); } 
#line 483
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p(const __wchar_t * _Format, va_list _ArgList); } 
#line 484
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, ...); } 
#line 485
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, va_list _ArgList); } 
#line 486
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p(const __wchar_t * _Format, ...); } 
#line 487
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p(const __wchar_t * _Format, va_list _ArgList); } 
#line 489
extern "C" { __declspec(dllimport) int __cdecl _wprintf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 490
extern "C" { __declspec(dllimport) int __cdecl _wprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 491
extern "C" { __declspec(dllimport) int __cdecl _wprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 492
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 493
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 494
extern "C" { __declspec(dllimport) int __cdecl _vwprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 496
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 497
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_p_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 498
extern "C" { __declspec(dllimport) int __cdecl _fwprintf_s_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 499
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 500
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_p_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 501
extern "C" { __declspec(dllimport) int __cdecl _vfwprintf_s_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 503
extern "C" { __declspec(dllimport) int __cdecl _swprintf_c_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 504
extern "C" { __declspec(dllimport) int __cdecl _swprintf_p_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 505
extern "C" { __declspec(dllimport) int __cdecl _swprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 506
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_c_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 507
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_p_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 508
extern "C" { __declspec(dllimport) int __cdecl _vswprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 510
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 511
extern "C" { __declspec(dllimport) int __cdecl _scwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 512
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 514
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 515
extern "C" { __declspec(dllimport) int __cdecl _snwprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 516
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_l(__wchar_t * _DstBuf, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 517
extern "C" { __declspec(dllimport) int __cdecl _vsnwprintf_s_l(__wchar_t * _DstBuf, size_t _DstSize, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 531 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
#pragma warning(push)
#pragma warning(disable:4141 4996 4793)
extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _swprintf(__wchar_t * _Dest, const __wchar_t * _Format, ...); } extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl _vswprintf(__wchar_t * _Dest, const __wchar_t * _Format, va_list _Args); } 
#line 534
extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __swprintf_l(__wchar_t * _Dest, const __wchar_t * _Format, _locale_t _Plocinfo, ...); } extern "C" { __declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(dllimport) int __cdecl __vswprintf_l(__wchar_t * _Dest, const __wchar_t * _Format, _locale_t _Plocinfo, va_list _Args); } 
#pragma warning(pop)
#line 34 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int swprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, ...) 
#line 37
{ 
#line 38
va_list _Arglist; 
#line 39
int _Ret; 
#line 40
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Format)))) + (((sizeof _Format + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 41
_Ret = _vswprintf_c_l(_String, _Count, _Format, 0, _Arglist); 
#line 42
_Arglist = ((va_list)0); 
#line 43
return _Ret; 
#line 44
} } 
#pragma warning( pop )
#line 47
#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl vswprintf(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, va_list _Ap) 
#line 50
{ 
#line 51
return _vswprintf_c_l(_String, _Count, _Format, 0, _Ap); 
#line 52
} } 
#pragma warning( pop )
#line 58 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\swprintf.inl"
#pragma warning( push )
#pragma warning( disable : 4793 4412 )
extern "C" { static __inline int _swprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
#line 61
{ 
#line 62
va_list _Arglist; 
#line 63
int _Ret; 
#line 64
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Plocinfo)))) + (((sizeof _Plocinfo + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 65
_Ret = _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Arglist); 
#line 66
_Arglist = ((va_list)0); 
#line 67
return _Ret; 
#line 68
} } 
#pragma warning( pop )
#line 71
#pragma warning( push )
#pragma warning( disable : 4412 )
extern "C" { static __inline int __cdecl _vswprintf_l(__wchar_t *_String, size_t _Count, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
#line 74
{ 
#line 75
return _vswprintf_c_l(_String, _Count, _Format, _Plocinfo, _Ap); 
#line 76
} } 
#pragma warning( pop )
#line 80
#pragma warning( push )
#pragma warning( disable : 4996 )
#line 83
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int swprintf(__wchar_t *_String, const __wchar_t *_Format, ...) 
#line 86
{ 
#line 87
va_list _Arglist; 
#line 88
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Format)))) + (((sizeof _Format + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 89
int _Ret = _vswprintf(_String, _Format, _Arglist); 
#line 90
_Arglist = ((va_list)0); 
#line 91
return _Ret; 
#line 92
} 
#pragma warning( pop )
#line 95
#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int __cdecl vswprintf(__wchar_t *_String, const __wchar_t *_Format, va_list _Ap) 
#line 98
{ 
#line 99
return _vswprintf(_String, _Format, _Ap); 
#line 100
} 
#pragma warning( pop )
#line 103
#pragma warning( push )
#pragma warning( disable : 4793 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int _swprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, ...) 
#line 106
{ 
#line 107
va_list _Arglist; 
#line 108
_Arglist = (((va_list)(&(reinterpret_cast< const char &>(_Plocinfo)))) + (((sizeof _Plocinfo + sizeof(int)) - (1)) & (~(sizeof(int) - (1))))); 
#line 109
int _Ret = __vswprintf_l(_String, _Format, _Plocinfo, _Arglist); 
#line 110
_Arglist = ((va_list)0); 
#line 111
return _Ret; 
#line 112
} 
#pragma warning( pop )
#line 115
#pragma warning( push )
#pragma warning( disable : 4141 )
__declspec(deprecated("swprintf has been changed to conform with the ISO C standard, adding an extra character count parameter. To use traditional Micr" "osoft swprintf, set _CRT_NON_CONFORMING_SWPRINTFS.")) __inline int __cdecl _vswprintf_l(__wchar_t *_String, const __wchar_t *_Format, _locale_t _Plocinfo, va_list _Ap) 
#line 118
{ 
#line 119
return __vswprintf_l(_String, _Format, _Plocinfo, _Ap); 
#line 120
} 
#pragma warning( pop )
#line 123
#pragma warning( pop )
#line 555 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtempnam(const __wchar_t * _Directory, const __wchar_t * _FilePrefix); } 
#line 561 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf(const __wchar_t * _Format, va_list _ArgList); } 
#line 562
extern "C" { __declspec(dllimport) int __cdecl _vscwprintf_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 563
extern "C" { __declspec(dllimport) int __cdecl fwscanf(FILE * _File, const __wchar_t * _Format, ...); } 
#line 564
extern "C" { __declspec(dllimport) int __cdecl _fwscanf_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#pragma warning(push)
#pragma warning(disable:6530)
#line 568
extern "C" { __declspec(dllimport) int __cdecl fwscanf_s(FILE * _File, const __wchar_t * _Format, ...); } 
#line 570 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _fwscanf_s_l(FILE * _File, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 571
extern "C" { __declspec(dllimport) int __cdecl swscanf(const __wchar_t * _Src, const __wchar_t * _Format, ...); } 
#line 572
extern "C" { __declspec(dllimport) int __cdecl _swscanf_l(const __wchar_t * _Src, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 574
extern "C" { __declspec(dllimport) int __cdecl swscanf_s(const __wchar_t * _Src, const __wchar_t * _Format, ...); } 
#line 576 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _swscanf_s_l(const __wchar_t * _Src, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 577
extern "C" { __declspec(dllimport) int __cdecl _snwscanf(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, ...); } 
#line 578
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_l(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 579
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, ...); } 
#line 580
extern "C" { __declspec(dllimport) int __cdecl _snwscanf_s_l(const __wchar_t * _Src, size_t _MaxCount, const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 581
extern "C" { __declspec(dllimport) int __cdecl wscanf(const __wchar_t * _Format, ...); } 
#line 582
extern "C" { __declspec(dllimport) int __cdecl _wscanf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 584
extern "C" { __declspec(dllimport) int __cdecl wscanf_s(const __wchar_t * _Format, ...); } 
#line 586 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _wscanf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#pragma warning(pop)
#line 589
extern "C" { __declspec(dllimport) FILE *__cdecl _wfdopen(int _FileHandle, const __wchar_t * _Mode); } 
#line 590
extern "C" { __declspec(dllimport) FILE *__cdecl _wfopen(const __wchar_t * _Filename, const __wchar_t * _Mode); } 
#line 591
extern "C" { __declspec(dllimport) errno_t __cdecl _wfopen_s(FILE ** _File, const __wchar_t * _Filename, const __wchar_t * _Mode); } 
#line 592
extern "C" { __declspec(dllimport) FILE *__cdecl _wfreopen(const __wchar_t * _Filename, const __wchar_t * _Mode, FILE * _OldFile); } 
#line 593
extern "C" { __declspec(dllimport) errno_t __cdecl _wfreopen_s(FILE ** _File, const __wchar_t * _Filename, const __wchar_t * _Mode, FILE * _OldFile); } 
#line 600
extern "C" { __declspec(dllimport) FILE *__cdecl _wpopen(const __wchar_t * _Command, const __wchar_t * _Mode); } 
#line 602 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl _wremove(const __wchar_t * _Filename); } 
#line 603
extern "C" { __declspec(dllimport) errno_t __cdecl _wtmpnam_s(__wchar_t * _DstBuf, size_t _SizeInWords); } 
#line 604
template < size_t _Size > inline errno_t __cdecl _wtmpnam_s ( wchar_t ( & _Buffer ) [ _Size ] ) throw ( ) { return _wtmpnam_s ( _Buffer, _Size ); }
#line 605
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wtmpnam(__wchar_t * _Buffer); } 
#line 607
extern "C" { __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * _File); } 
#line 608
extern "C" { __declspec(dllimport) wint_t __cdecl _fputwc_nolock(__wchar_t _Ch, FILE * _File); } 
#line 609
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t _Ch, FILE * _File); } 
#line 621 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { inline wint_t __cdecl getwchar() 
#line 622
{ return fgetwc(&(__iob_func()[0])); } } 
#line 623
extern "C" { inline wint_t __cdecl putwchar(__wchar_t _C) 
#line 624
{ return fputwc(_C, &(__iob_func()[1])); } } 
#line 670 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) void __cdecl _lock_file(FILE * _File); } 
#line 671
extern "C" { __declspec(dllimport) void __cdecl _unlock_file(FILE * _File); } 
#line 673
extern "C" { __declspec(dllimport) int __cdecl _fclose_nolock(FILE * _File); } 
#line 674
extern "C" { __declspec(dllimport) int __cdecl _fflush_nolock(FILE * _File); } 
#line 675
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock(void * _DstBuf, size_t _ElementSize, size_t _Count, FILE * _File); } 
#line 676
extern "C" { __declspec(dllimport) size_t __cdecl _fread_nolock_s(void * _DstBuf, size_t _DstSize, size_t _ElementSize, size_t _Count, FILE * _File); } 
#line 677
extern "C" { __declspec(dllimport) int __cdecl _fseek_nolock(FILE * _File, long _Offset, int _Origin); } 
#line 678
extern "C" { __declspec(dllimport) long __cdecl _ftell_nolock(FILE * _File); } 
#line 679
extern "C" { __declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * _File, __int64 _Offset, int _Origin); } 
#line 680
extern "C" { __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * _File); } 
#line 681
extern "C" { __declspec(dllimport) size_t __cdecl _fwrite_nolock(const void * _DstBuf, size_t _Size, size_t _Count, FILE * _File); } 
#line 682
extern "C" { __declspec(dllimport) int __cdecl _ungetc_nolock(int _Ch, FILE * _File); } 
#line 709 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) char *__cdecl tempnam(const char * _Directory, const char * _FilePrefix); } 
#line 715 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
extern "C" { __declspec(dllimport) int __cdecl fcloseall(); } 
#line 716
extern "C" { __declspec(dllimport) FILE *__cdecl fdopen(int _FileHandle, const char * _Format); } 
#line 717
extern "C" { __declspec(dllimport) int __cdecl fgetchar(); } 
#line 718
extern "C" { __declspec(dllimport) int __cdecl fileno(FILE * _File); } 
#line 719
extern "C" { __declspec(dllimport) int __cdecl flushall(); } 
#line 720
extern "C" { __declspec(dllimport) int __cdecl fputchar(int _Ch); } 
#line 721
extern "C" { __declspec(dllimport) int __cdecl getw(FILE * _File); } 
#line 722
extern "C" { __declspec(dllimport) int __cdecl putw(int _Ch, FILE * _File); } 
#line 723
extern "C" { __declspec(dllimport) int __cdecl rmtmp(); } 
#line 731 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdio.h"
#pragma pack ( pop )
#line 32 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cstdio"
typedef FILE _iobuf; 
#line 35
namespace std { 
#line 36
using ::_iobuf;using ::_Mbstatet;
#line 38
using ::fpos_t;using ::FILE;
#line 39
using ::clearerr;using ::fclose;using ::feof;
#line 40
using ::ferror;using ::fflush;using ::fgetc;
#line 41
using ::fgetpos;using ::fgets;using ::fopen;
#line 42
using ::fprintf;using ::fputc;using ::fputs;
#line 43
using ::fread;using ::freopen;using ::fscanf;
#line 44
using ::fseek;using ::fsetpos;using ::ftell;
#line 45
using ::fwrite;using ::getc;using ::getchar;
#line 46
using ::gets;using ::perror;
#line 47
using ::putc;using ::putchar;
#line 48
using ::printf;using ::puts;using ::remove;
#line 49
using ::rename;using ::rewind;using ::scanf;
#line 50
using ::setbuf;using ::setvbuf;using ::sprintf;
#line 51
using ::sscanf;using ::tmpfile;using ::tmpnam;
#line 52
using ::ungetc;using ::vfprintf;using ::vprintf;
#line 53
using ::vsprintf;
#line 55
using ::vsnprintf;
#line 56
using ::vfscanf;using ::vscanf;using ::vsscanf;
#line 57
}
#line 17 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cstring"
namespace std { 
#line 18
using ::memchr;using ::memcmp;
#line 19
using ::memcpy;using ::memmove;using ::memset;
#line 20
using ::strcat;using ::strchr;using ::strcmp;
#line 21
using ::strcoll;using ::strcpy;using ::strcspn;
#line 22
using ::strerror;using ::strlen;using ::strncat;
#line 23
using ::strncmp;using ::strncpy;using ::strpbrk;
#line 24
using ::strrchr;using ::strspn;using ::strstr;
#line 25
using ::strtok;using ::strxfrm;
#line 26
}
#line 17 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cstddef"
namespace std { 
#line 18
using ::ptrdiff_t;
#line 19
}
#line 23 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cstddef"
namespace std { 
#line 24
typedef double max_align_t; 
#line 25
}
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\initializer_list"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 15
template < class _Elem >
 class initializer_list
 {
public :
 typedef _Elem value_type;
 typedef const _Elem & reference;
 typedef const _Elem & const_reference;
 typedef size_t size_type;

 typedef const _Elem * iterator;
 typedef const _Elem * const_iterator;

 initializer_list ( ) throw ( )
  : _First ( 0 ), _Last ( 0 )
  {
  }

 initializer_list ( const _Elem * _First_arg,
  const _Elem * _Last_arg ) throw ( )
  : _First ( _First_arg ), _Last ( _Last_arg )
  {
  }

 const _Elem * begin ( ) const throw ( )
  {
  return ( _First );
  }

 const _Elem * end ( ) const throw ( )
  {
  return ( _Last );
  }

 size_t size ( ) const throw ( )
  {
  return ( ( size_t ) ( _Last - _First ) );
  }

private :
 const _Elem * _First;
 const _Elem * _Last;
 };
#line 59
template < class _Elem > inline
 const _Elem * begin ( initializer_list < _Elem > _Ilist ) throw ( )
 {
 return ( _Ilist . begin ( ) );
 }
#line 66
template < class _Elem > inline
 const _Elem * end ( initializer_list < _Elem > _Ilist ) throw ( )
 {
 return ( _Ilist . end ( ) );
 }
#line 71
}
#line 74
#pragma warning(pop)
#line 13 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
#pragma warning(push,3)
#line 75 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\initializer_list"
#pragma pack ( pop )
#line 12 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
#pragma pack ( push, 8 )
#line 23 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
namespace std { 
#line 90 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
template < class _Ty > inline
 _Ty * addressof ( _Ty & _Val ) throw ( )
 {
 return ( reinterpret_cast < _Ty * > (
  ( & const_cast < char & > (
  reinterpret_cast < const volatile char & > ( _Val ) ) ) ) );
 }
#line 100
template< bool , class 
#line 101
_Ty1, class 
#line 102
_Ty2> 
#line 103
struct _If { 
#line 105
typedef _Ty2 type; 
#line 106
}; 
#line 108
template< class _Ty1, class 
#line 109
_Ty2> 
#line 110
struct _If< true, _Ty1, _Ty2>  { 
#line 112
typedef _Ty1 type; 
#line 113
}; 
#line 115
template< class _Ty> 
#line 116
struct _Always_false { 
#line 118
static const bool value = false; 
#line 119
}; 
#line 123
template< class _Arg, class 
#line 124
_Result> 
#line 125
struct unary_function { 
#line 127
typedef _Arg argument_type; 
#line 128
typedef _Result result_type; 
#line 129
}; 
#line 132
template< class _Arg1, class 
#line 133
_Arg2, class 
#line 134
_Result> 
#line 135
struct binary_function { 
#line 137
typedef _Arg1 first_argument_type; 
#line 138
typedef _Arg2 second_argument_type; 
#line 139
typedef _Result result_type; 
#line 140
}; 
#line 143
template < class _Ty = void >
 struct plus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left + _Right );
  }
 };
#line 154
template < class _Ty = void >
 struct minus
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left - _Right );
  }
 };
#line 165
template < class _Ty = void >
 struct multiplies
  : public binary_function < _Ty, _Ty, _Ty >
 {
 _Ty operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left * _Right );
  }
 };
#line 176
template < class _Ty = void >
 struct equal_to
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left == _Right );
  }
 };
#line 187
template < class _Ty = void >
 struct less
  : public binary_function < _Ty, _Ty, bool >
 {
 bool operator ( ) ( const _Ty & _Left, const _Ty & _Right ) const
  {
  return ( _Left < _Right );
  }
 };
#line 199
template<> struct plus< void>  { 
#line 201
template < class _Ty1,
  class _Ty2 >
  auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   + static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   + static_cast < _Ty2 && > ( _Right ) );
  }
#line 210
}; 
#line 214
template<> struct minus< void>  { 
#line 216
template < class _Ty1,
  class _Ty2 >
  auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   - static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   - static_cast < _Ty2 && > ( _Right ) );
  }
#line 225
}; 
#line 229
template<> struct multiplies< void>  { 
#line 231
template < class _Ty1,
  class _Ty2 >
  auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   * static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   * static_cast < _Ty2 && > ( _Right ) );
  }
#line 240
}; 
#line 244
template<> struct equal_to<>  { 
#line 246
template < class _Ty1,
  class _Ty2 >
  auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   == static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   == static_cast < _Ty2 && > ( _Right ) );
  }
#line 255
}; 
#line 259
template<> struct less< void>  { 
#line 261
template < class _Ty1,
  class _Ty2 >
  auto operator ( ) ( _Ty1 && _Left, _Ty2 && _Right ) const
  -> decltype ( static_cast < _Ty1 && > ( _Left )
   < static_cast < _Ty2 && > ( _Right ) )
  {
  return ( static_cast < _Ty1 && > ( _Left )
   < static_cast < _Ty2 && > ( _Right ) );
  }
#line 270
}; 
#line 273
}
#line 277
namespace std { 
#line 279
inline size_t _Hash_seq(const unsigned char *_First, size_t _Count) 
#line 280
{ 
#line 287 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
static_assert((sizeof(size_t) == (4)), "This code is for 32-bit size_t.");
#line 288
const size_t _FNV_offset_basis = 2166136261U; 
#line 289
const size_t _FNV_prime = 16777619U; 
#line 292 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
size_t _Val = _FNV_offset_basis; 
#line 293
for (size_t _Next = (0); _Next < _Count; ++_Next) 
#line 294
{ 
#line 295
_Val ^= ((size_t)(_First[_Next])); 
#line 296
_Val *= _FNV_prime; 
#line 297
}  
#line 304 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
static_assert((sizeof(size_t) == (4)), "This code is for 32-bit size_t.");
#line 307 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
return _Val; 
#line 308
} 
#line 311
template < class _Kty >
 struct _Bitwise_hash
  : public unary_function < _Kty, size_t >
 {
 size_t operator ( ) ( const _Kty & _Keyval ) const
  {
  return ( _Hash_seq ( ( const unsigned char * ) & _Keyval, sizeof ( _Kty ) ) );
  }
 };
#line 322
template< class _Kty> 
#line 323
struct hash : public _Bitwise_hash< _Kty>  { 
#line 326
static const bool _Value = __is_enum(_Kty); 
#line 327
static_assert(_Value, "The C++ Standard doesn\'t provide a hash for this type.");
#line 329
}; 
#line 331
template<> struct hash< bool>  : public _Bitwise_hash< bool>  { 
#line 334
}; 
#line 337
template<> struct hash< char>  : public _Bitwise_hash< char>  { 
#line 340
}; 
#line 343
template<> struct hash< signed char>  : public _Bitwise_hash< signed char>  { 
#line 346
}; 
#line 349
template<> struct hash< unsigned char>  : public _Bitwise_hash< unsigned char>  { 
#line 352
}; 
#line 370 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
template<> struct hash< __wchar_t>  : public _Bitwise_hash< __wchar_t>  { 
#line 373
}; 
#line 377 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
template<> struct hash< short>  : public _Bitwise_hash< short>  { 
#line 380
}; 
#line 383
template<> struct hash< unsigned short>  : public _Bitwise_hash< unsigned short>  { 
#line 386
}; 
#line 389
template<> struct hash< int>  : public _Bitwise_hash< int>  { 
#line 392
}; 
#line 395
template<> struct hash< unsigned>  : public _Bitwise_hash< unsigned>  { 
#line 398
}; 
#line 401
template<> struct hash< long>  : public _Bitwise_hash< long>  { 
#line 404
}; 
#line 407
template<> struct hash< unsigned long>  : public _Bitwise_hash< unsigned long>  { 
#line 410
}; 
#line 413
template<> struct hash< __int64>  : public _Bitwise_hash< __int64>  { 
#line 416
}; 
#line 419
template<> struct hash< unsigned __int64>  : public _Bitwise_hash< unsigned __int64>  { 
#line 422
}; 
#line 425
template<> struct hash< float>  : public _Bitwise_hash< float>  { 
#line 428
typedef float _Kty; 
#line 429
typedef std::_Bitwise_hash< float>  _Mybase; 
#line 431
size_t operator()(const _Kty &_Keyval) const 
#line 432
{ 
#line 433
return this->_Mybase::operator()((_Keyval == (0)) ? 0 : _Keyval); 
#line 435
} 
#line 436
}; 
#line 439
template<> struct hash< double>  : public _Bitwise_hash< double>  { 
#line 442
typedef double _Kty; 
#line 443
typedef std::_Bitwise_hash< double>  _Mybase; 
#line 445
size_t operator()(const _Kty &_Keyval) const 
#line 446
{ 
#line 447
return this->_Mybase::operator()((_Keyval == (0)) ? 0 : _Keyval); 
#line 449
} 
#line 450
}; 
#line 453
template<> struct hash< long double>  : public _Bitwise_hash< long double>  { 
#line 456
typedef long double _Kty; 
#line 457
typedef std::_Bitwise_hash< long double>  _Mybase; 
#line 459
size_t operator()(const _Kty &_Keyval) const 
#line 460
{ 
#line 461
return this->_Mybase::operator()((_Keyval == (0)) ? 0 : _Keyval); 
#line 463
} 
#line 464
}; 
#line 466
template< class _Ty> 
#line 467
struct hash< _Ty *>  : public _Bitwise_hash< _Ty *>  { 
#line 470
}; 
#line 471
}
#line 474 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
namespace std { 
#line 475
namespace tr1 { 
#line 476
using std::hash;
#line 477
}
#line 478
}
#line 568 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
#pragma warning(pop)
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
#pragma warning(push,3)
#line 569 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstddef"
#pragma pack ( pop )
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
#pragma pack ( push, 8 )
#line 23
namespace std { 
#line 36
}
#line 24 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\eh.h"
#pragma pack ( push, 8 )
#line 32
typedef void (__cdecl *terminate_function)(void); 
#line 33
typedef void (__cdecl *terminate_handler)(void); 
#line 34
typedef void (__cdecl *unexpected_function)(void); 
#line 35
typedef void (__cdecl *unexpected_handler)(void); 
#line 50 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\eh.h"
struct _EXCEPTION_POINTERS; 
#line 52
typedef void (__cdecl *_se_translator_function)(unsigned, _EXCEPTION_POINTERS *); 
#line 55 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\eh.h"
__declspec(dllimport) __declspec(noreturn) void __cdecl terminate(); 
#line 56
__declspec(dllimport) __declspec(noreturn) void __cdecl unexpected(); 
#line 58
__declspec(dllimport) int __cdecl _is_exception_typeof(const class type_info & _Type, _EXCEPTION_POINTERS * _ExceptionPtr); 
#line 62
__declspec(dllimport) terminate_function __cdecl set_terminate(terminate_function _NewPtFunc); 
#line 63
extern "C" __declspec(dllimport) terminate_function __cdecl _get_terminate(); 
#line 64
__declspec(dllimport) unexpected_function __cdecl set_unexpected(unexpected_function _NewPtFunc); 
#line 65
extern "C" __declspec(dllimport) unexpected_function __cdecl _get_unexpected(); 
#line 70 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\eh.h"
__declspec(dllimport) _se_translator_function __cdecl _set_se_translator(_se_translator_function _NewPtFunc); 
#line 72 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\eh.h"
__declspec(dllimport) bool __cdecl __uncaught_exception(); 
#line 82
#pragma pack ( pop )
#line 26 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
#pragma pack ( push, 8 )
#line 62 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { typedef 
#line 58
struct _heapinfo { 
#line 59
int *_pentry; 
#line 60
size_t _size; 
#line 61
int _useflag; 
#line 62
} _HEAPINFO; }
#line 143 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { __declspec(dllimport) int __cdecl _resetstkoflw(); } 
#line 148 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { __declspec(dllimport) unsigned long __cdecl _set_malloc_crt_max_wait(unsigned long _NewValue); } 
#line 158 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { __declspec(dllimport) void *__cdecl _expand(void * _Memory, size_t _NewSize); } 
#line 159
extern "C" { __declspec(dllimport) size_t __cdecl _msize(void * _Memory); } 
#line 166 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { void *__cdecl _alloca(size_t _Size); } 
#line 169
extern "C" { __declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * _EntryInfo); } 
#line 170
extern "C" { __declspec(dllimport) intptr_t __cdecl _get_heap_handle(); } 
#line 174 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { __declspec(dllimport) int __cdecl _heapadd(void * _Memory, size_t _Size); } 
#line 175
extern "C" { __declspec(dllimport) int __cdecl _heapchk(); } 
#line 176
extern "C" { __declspec(dllimport) int __cdecl _heapmin(); } 
#line 177
extern "C" { __declspec(dllimport) int __cdecl _heapset(unsigned _Fill); } 
#line 178
extern "C" { __declspec(dllimport) size_t __cdecl _heapused(size_t * _Used, size_t * _Commit); } 
#line 195 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
extern "C" { typedef char __static_assert_t[sizeof(unsigned) <= (8)]; }
#line 198
#pragma warning(push)
#pragma warning(disable:6540)
extern "C" { __inline void *_MarkAllocaS(void *_Ptr, unsigned _Marker) 
#line 201
{ 
#line 202
if (_Ptr) 
#line 203
{ 
#line 204
(*((unsigned *)_Ptr)) = _Marker; 
#line 205
_Ptr = (((char *)_Ptr) + 8); 
#line 206
}  
#line 207
return _Ptr; 
#line 208
} } 
#line 210
extern "C" { __inline int _MallocaIsSizeInRange(size_t size) 
#line 211
{ 
#line 212
return (size + (8)) > size; 
#line 213
} } 
#pragma warning(pop)
#line 253 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
__pragma( warning(push)) 
#line 254
__pragma( warning(disable: 6014)) 
#line 255
extern "C" { __declspec(noalias) __inline void __cdecl _freea(void *_Memory) 
#line 256
{ 
#line 257
unsigned _Marker; 
#line 258
if (_Memory) 
#line 259
{ 
#line 260
_Memory = (((char *)_Memory) - 8); 
#line 261
_Marker = (*((unsigned *)_Memory)); 
#line 262
if (_Marker == (56797)) 
#line 263
{ 
#line 264
free(_Memory); 
#line 265
}  
#line 273 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
}  
#line 274
} } 
#line 275
__pragma( warning(pop)) 
#line 292 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\malloc.h"
#pragma pack ( pop )
#line 80 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
namespace std { 
#line 89 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
class __declspec(dllimport) exception { 
#line 92
public: exception(); 
#line 93
explicit exception(const char *const &); 
#line 94
exception(const char *const &, int); 
#line 95
exception(const exception &); 
#line 96
exception &operator=(const exception &); 
#line 97
virtual ~exception() throw(); 
#line 98
virtual const char *what() const; 
#line 101
private: void _Copy_str(const char *); 
#line 102
void _Tidy(); 
#line 104
const char *_Mywhat; 
#line 105
bool _Mydofree; 
#line 106
}; 
#line 188
using ::set_terminate;using ::terminate_handler;using ::terminate;using ::set_unexpected;using ::unexpected_handler;using ::unexpected;
#line 190
typedef void (__cdecl *_Prhand)(const exception &); 
#line 192
__declspec(dllimport) bool __cdecl uncaught_exception(); 
#line 195
inline terminate_handler __cdecl get_terminate() 
#line 196
{ 
#line 197
return _get_terminate(); 
#line 198
} 
#line 200
inline unexpected_handler __cdecl get_unexpected() 
#line 201
{ 
#line 202
return _get_unexpected(); 
#line 203
} 
#line 206 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
}
#line 328 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
namespace std { 
#line 334 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
class bad_exception : public exception { 
#line 337
public: bad_exception(const char *_Message = "bad exception") throw() : exception(_Message) 
#line 340
{ 
#line 341
} 
#line 343
virtual ~bad_exception() throw() 
#line 344
{ 
#line 345
} 
#line 355 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
}; 
#line 358
class bad_alloc : public exception { 
#line 361
public: bad_alloc() throw() : exception("bad allocation", 1) 
#line 363
{ 
#line 364
} 
#line 366
virtual ~bad_alloc() throw() 
#line 367
{ 
#line 368
} 
#line 371
friend class bad_array_new_length; 
#line 373
private: bad_alloc(const char *_Message) throw() : exception(_Message, 1) 
#line 375
{ 
#line 376
} 
#line 386 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
}; 
#line 389
class bad_array_new_length : public bad_alloc { 
#line 394
public: bad_array_new_length() throw() : bad_alloc("bad array new length") 
#line 396
{ 
#line 397
} 
#line 398
}; 
#line 401
}
#line 413 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
__declspec(dllimport) void __cdecl __ExceptionPtrCreate(void *); 
#line 414
__declspec(dllimport) void __cdecl __ExceptionPtrDestroy(void *); 
#line 415
__declspec(dllimport) void __cdecl __ExceptionPtrCopy(void *, const void *); 
#line 416
__declspec(dllimport) void __cdecl __ExceptionPtrAssign(void *, const void *); 
#line 417
__declspec(dllimport) bool __cdecl __ExceptionPtrCompare(const void *, const void *); 
#line 418
__declspec(dllimport) bool __cdecl __ExceptionPtrToBool(const void *); 
#line 419
__declspec(dllimport) void __cdecl __ExceptionPtrSwap(void *, void *); 
#line 421
__declspec(dllimport) void __cdecl __ExceptionPtrCurrentException(void *); 
#line 422
__declspec(dllimport) void __cdecl __ExceptionPtrRethrow(const void *); 
#line 423
__declspec(dllimport) void __cdecl __ExceptionPtrCopyException(void *, const void *, const void *); 
#line 425
namespace std { 
#line 427
class exception_ptr { 
#line 430
public: exception_ptr() 
#line 431
{ 
#line 432
__ExceptionPtrCreate(this); 
#line 433
} 
#line 434
exception_ptr(nullptr_t) 
#line 435
{ 
#line 436
__ExceptionPtrCreate(this); 
#line 437
} 
#line 438
~exception_ptr() throw() 
#line 439
{ 
#line 440
__ExceptionPtrDestroy(this); 
#line 441
} 
#line 442
exception_ptr(const exception_ptr &_Rhs) 
#line 443
{ 
#line 444
__ExceptionPtrCopy(this, &_Rhs); 
#line 445
} 
#line 446
exception_ptr &operator=(const exception_ptr &_Rhs) 
#line 447
{ 
#line 448
__ExceptionPtrAssign(this, &_Rhs); 
#line 449
return *this; 
#line 450
} 
#line 451
exception_ptr &operator=(nullptr_t) 
#line 452
{ 
#line 453
exception_ptr _Ptr; 
#line 454
__ExceptionPtrAssign(this, &_Ptr); 
#line 455
return *this; 
#line 456
} 
#line 458
typedef exception_ptr _Myt; 
#line 460
explicit operator bool() const throw() 
#line 461
{ 
#line 462
return __ExceptionPtrToBool(this); 
#line 463
} 
#line 465
void _RethrowException() const 
#line 466
{ 
#line 467
__ExceptionPtrRethrow(this); 
#line 468
} 
#line 470
static exception_ptr _Current_exception() 
#line 471
{ 
#line 472
exception_ptr _Retval; 
#line 473
__ExceptionPtrCurrentException(&_Retval); 
#line 474
return _Retval; 
#line 475
} 
#line 476
static exception_ptr _Copy_exception(void *_Except, const void *_Ptr) 
#line 477
{ 
#line 478
exception_ptr _Retval = 0; 
#line 479
if (!_Ptr) 
#line 480
{ 
#line 482
return _Retval; 
#line 483
}  
#line 484
__ExceptionPtrCopyException(&_Retval, _Except, _Ptr); 
#line 485
return _Retval; 
#line 486
} 
#line 488
private: void *_Data1; 
#line 489
void *_Data2; 
#line 490
}; 
#line 492
inline void swap(exception_ptr &_Lhs, exception_ptr &_Rhs) 
#line 493
{ 
#line 494
__ExceptionPtrSwap(&_Lhs, &_Rhs); 
#line 495
} 
#line 497
inline bool operator==(const exception_ptr &_Lhs, const exception_ptr &_Rhs) 
#line 498
{ 
#line 499
return __ExceptionPtrCompare(&_Lhs, &_Rhs); 
#line 500
} 
#line 502
inline bool operator==(nullptr_t, const exception_ptr &_Rhs) 
#line 503
{ 
#line 504
return !_Rhs; 
#line 505
} 
#line 507
inline bool operator==(const exception_ptr &_Lhs, nullptr_t) 
#line 508
{ 
#line 509
return !_Lhs; 
#line 510
} 
#line 512
inline bool operator!=(const exception_ptr &_Lhs, const exception_ptr &_Rhs) 
#line 513
{ 
#line 514
return !((_Lhs == _Rhs)); 
#line 515
} 
#line 517
inline bool operator!=(nullptr_t _Lhs, const exception_ptr &_Rhs) 
#line 518
{ 
#line 519
return !((_Lhs == _Rhs)); 
#line 520
} 
#line 522
inline bool operator!=(const exception_ptr &_Lhs, nullptr_t _Rhs) 
#line 523
{ 
#line 524
return !((_Lhs == _Rhs)); 
#line 525
} 
#line 527
inline exception_ptr current_exception() 
#line 528
{ 
#line 529
return exception_ptr::_Current_exception(); 
#line 530
} 
#line 532
inline void rethrow_exception(exception_ptr _P) 
#line 533
{ 
#line 534
_P._RethrowException(); 
#line 535
} 
#line 537
template< class _E> void *__GetExceptionInfo(_E); 
#line 539
template < class _E > exception_ptr make_exception_ptr ( _E _Except )
 {
 return exception_ptr :: _Copy_exception ( :: std :: addressof ( _Except ), __GetExceptionInfo ( _Except ) );
 }
#line 543
}
#line 552
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ymath.h"
#pragma warning(push,3)
#line 553 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\exception"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ymath.h"
#pragma pack ( push, 8 )
#line 33 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ymath.h"
extern "C" { void __cdecl _Feraise(int); } 
#line 41
extern "C" { typedef 
#line 36
union { 
#line 37
unsigned short _Word[8]; 
#line 38
float _Float; 
#line 39
double _Double; 
#line 40
long double _Long_double; 
#line 41
} _Dconst; }
#line 44
extern "C" { __declspec(dllimport) double __cdecl _Cosh(double, double); } 
#line 45
extern "C" { __declspec(dllimport) double __cdecl _Divide(double, double); } 
#line 46
extern "C" { __declspec(dllimport) short __cdecl _Dtest(double *); } 
#line 47
extern "C" { __declspec(dllimport) double __cdecl _Log(double, int); } 
#line 48
extern "C" { __declspec(dllimport) double __cdecl _Recip(double); } 
#line 49
extern "C" { __declspec(dllimport) double __cdecl _Sin(double, unsigned); } 
#line 50
extern "C" { __declspec(dllimport) double __cdecl _Sinx(double, unsigned, int); } 
#line 51
extern "C" { __declspec(dllimport) double __cdecl _Sinh(double, double); } 
#line 53
extern "C" { __declspec(dllimport) short __cdecl _Exp(double *, double, short); } 
#line 54
extern "C" __declspec(dllimport) _Dconst _Denorm, _Hugeval, _Inf, 
#line 55
_Nan, _Snan; 
#line 58
extern "C" { __declspec(dllimport) float __cdecl _FCosh(float, float); } 
#line 59
extern "C" { __declspec(dllimport) float __cdecl _FDivide(float, float); } 
#line 60
extern "C" { __declspec(dllimport) short __cdecl _FDtest(float *); } 
#line 61
extern "C" { __declspec(dllimport) float __cdecl _FLog(float, int); } 
#line 62
extern "C" { __declspec(dllimport) float __cdecl _FRecip(float); } 
#line 63
extern "C" { __declspec(dllimport) float __cdecl _FSin(float, unsigned); } 
#line 64
extern "C" { __declspec(dllimport) float __cdecl _FSinx(float, unsigned, int); } 
#line 65
extern "C" { __declspec(dllimport) float __cdecl _FSinh(float, float); } 
#line 67
extern "C" { __declspec(dllimport) short __cdecl _FExp(float *, float, short); } 
#line 68
extern "C" __declspec(dllimport) _Dconst _FDenorm, _FInf, _FNan, _FSnan; 
#line 71
extern "C" { __declspec(dllimport) long double __cdecl _LCosh(long double, long double); } 
#line 72
extern "C" { __declspec(dllimport) long double __cdecl _LDivide(long double, long double); } 
#line 73
extern "C" { __declspec(dllimport) short __cdecl _LDtest(long double *); } 
#line 74
extern "C" { __declspec(dllimport) long double __cdecl _LLog(long double, int); } 
#line 75
extern "C" { __declspec(dllimport) long double __cdecl _LRecip(long double); } 
#line 76
extern "C" { __declspec(dllimport) long double __cdecl _LSin(long double, unsigned); } 
#line 77
extern "C" { __declspec(dllimport) long double __cdecl _LSinx(long double, unsigned, int); } 
#line 78
extern "C" { __declspec(dllimport) long double __cdecl _LSinh(long double, long double); } 
#line 80
extern "C" { __declspec(dllimport) short __cdecl _LExp(long double *, long double, short); } 
#line 81
extern "C" __declspec(dllimport) _Dconst _LDenorm, _LInf, _LNan, _LSnan; 
#line 90 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ymath.h"
#pragma warning(pop)
#pragma pack ( pop )
#line 117 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\float.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _clearfp(); } 
#pragma warning(push)
#pragma warning(disable: 4141)
extern "C" { __declspec(dllimport) unsigned __cdecl _controlfp(unsigned _NewValue, unsigned _Mask); } 
#pragma warning(pop)
extern "C" { __declspec(dllimport) void __cdecl _set_controlfp(unsigned _NewValue, unsigned _Mask); } 
#line 123
extern "C" { __declspec(dllimport) errno_t __cdecl _controlfp_s(unsigned * _CurrentState, unsigned _NewValue, unsigned _Mask); } 
#line 124
extern "C" { __declspec(dllimport) unsigned __cdecl _statusfp(); } 
#line 125
extern "C" { __declspec(dllimport) void __cdecl _fpreset(); } 
#line 128
extern "C" { __declspec(dllimport) void __cdecl _statusfp2(unsigned * _X86_status, unsigned * _SSE2_status); } 
#line 202 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\float.h"
extern "C" { __declspec(dllimport) unsigned __cdecl _control87(unsigned _NewValue, unsigned _Mask); } 
#line 204
extern "C" { __declspec(dllimport) int __cdecl __control87_2(unsigned _NewValue, unsigned _Mask, unsigned * _X86_cw, unsigned * _Sse2_cw); } 
#line 210 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\float.h"
extern "C" { __declspec(dllimport) extern int *__cdecl __fpecode(); } 
#line 241
extern "C" { __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign); } 
#line 242
extern "C" { __declspec(dllimport) double __cdecl _chgsign(double _X); } 
#line 243
extern "C" { __declspec(dllimport) double __cdecl _scalb(double _X, long _Y); } 
#line 244
extern "C" { __declspec(dllimport) double __cdecl _logb(double _X); } 
#line 245
extern "C" { __declspec(dllimport) double __cdecl _nextafter(double _X, double _Y); } 
#line 246
extern "C" { __declspec(dllimport) int __cdecl _finite(double _X); } 
#line 247
extern "C" { __declspec(dllimport) int __cdecl _isnan(double _X); } 
#line 248
extern "C" { __declspec(dllimport) int __cdecl _fpclass(double _X); } 
#line 274
extern "C" { __declspec(dllimport) void __cdecl fpreset(); } 
#line 25 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
#pragma pack ( push, 8 )
#line 93 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { typedef unsigned long _fsize_t; }
#line 99 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { struct _wfinddata32_t { 
#line 100
unsigned attrib; 
#line 101
__time32_t time_create; 
#line 102
__time32_t time_access; 
#line 103
__time32_t time_write; 
#line 104
_fsize_t size; 
#line 105
__wchar_t name[260]; 
#line 106
}; }
#line 108
extern "C" { struct _wfinddata32i64_t { 
#line 109
unsigned attrib; 
#line 110
__time32_t time_create; 
#line 111
__time32_t time_access; 
#line 112
__time32_t time_write; 
#line 113
__int64 size; 
#line 114
__wchar_t name[260]; 
#line 115
}; }
#line 117
extern "C" { struct _wfinddata64i32_t { 
#line 118
unsigned attrib; 
#line 119
__time64_t time_create; 
#line 120
__time64_t time_access; 
#line 121
__time64_t time_write; 
#line 122
_fsize_t size; 
#line 123
__wchar_t name[260]; 
#line 124
}; }
#line 126
extern "C" { struct _wfinddata64_t { 
#line 127
unsigned attrib; 
#line 128
__time64_t time_create; 
#line 129
__time64_t time_access; 
#line 130
__time64_t time_write; 
#line 131
__int64 size; 
#line 132
__wchar_t name[260]; 
#line 133
}; }
#line 199 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) const unsigned short *__cdecl __pctype_func(); } 
#line 201
extern "C" __declspec(dllimport) const unsigned short *_pctype; 
#line 212 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" __declspec(dllimport) const unsigned short _wctype[]; 
#line 222 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) const wctype_t *__cdecl __pwctype_func(); } 
#line 224
extern "C" __declspec(dllimport) const wctype_t *_pwctype; 
#line 254 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl iswalpha(wint_t _C); } 
#line 255
extern "C" { __declspec(dllimport) int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale); } 
#line 256
extern "C" { __declspec(dllimport) int __cdecl iswupper(wint_t _C); } 
#line 257
extern "C" { __declspec(dllimport) int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale); } 
#line 258
extern "C" { __declspec(dllimport) int __cdecl iswlower(wint_t _C); } 
#line 259
extern "C" { __declspec(dllimport) int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale); } 
#line 260
extern "C" { __declspec(dllimport) int __cdecl iswdigit(wint_t _C); } 
#line 261
extern "C" { __declspec(dllimport) int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale); } 
#line 262
extern "C" { __declspec(dllimport) int __cdecl iswxdigit(wint_t _C); } 
#line 263
extern "C" { __declspec(dllimport) int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale); } 
#line 264
extern "C" { __declspec(dllimport) int __cdecl iswspace(wint_t _C); } 
#line 265
extern "C" { __declspec(dllimport) int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale); } 
#line 266
extern "C" { __declspec(dllimport) int __cdecl iswpunct(wint_t _C); } 
#line 267
extern "C" { __declspec(dllimport) int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale); } 
#line 268
extern "C" { __declspec(dllimport) int __cdecl iswblank(wint_t _C); } 
#line 269
extern "C" { __declspec(dllimport) int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale); } 
#line 270
extern "C" { __declspec(dllimport) int __cdecl iswalnum(wint_t _C); } 
#line 271
extern "C" { __declspec(dllimport) int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale); } 
#line 272
extern "C" { __declspec(dllimport) int __cdecl iswprint(wint_t _C); } 
#line 273
extern "C" { __declspec(dllimport) int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale); } 
#line 274
extern "C" { __declspec(dllimport) int __cdecl iswgraph(wint_t _C); } 
#line 275
extern "C" { __declspec(dllimport) int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale); } 
#line 276
extern "C" { __declspec(dllimport) int __cdecl iswcntrl(wint_t _C); } 
#line 277
extern "C" { __declspec(dllimport) int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale); } 
#line 278
extern "C" { __declspec(dllimport) int __cdecl iswascii(wint_t _C); } 
#line 281
extern "C" { __declspec(dllimport) int __cdecl isleadbyte(int _C); } 
#line 282
extern "C" { __declspec(dllimport) int __cdecl _isleadbyte_l(int _C, _locale_t _Locale); } 
#line 285 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) wint_t __cdecl towupper(wint_t _C); } 
#line 286
extern "C" { __declspec(dllimport) wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale); } 
#line 287
extern "C" { __declspec(dllimport) wint_t __cdecl towlower(wint_t _C); } 
#line 288
extern "C" { __declspec(dllimport) wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale); } 
#line 289
extern "C" { __declspec(dllimport) int __cdecl iswctype(wint_t _C, wctype_t _Type); } 
#line 290
extern "C" { __declspec(dllimport) int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale); } 
#line 292
extern "C" { __declspec(dllimport) int __cdecl __iswcsymf(wint_t _C); } 
#line 293
extern "C" { __declspec(dllimport) int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale); } 
#line 294
extern "C" { __declspec(dllimport) int __cdecl __iswcsym(wint_t _C); } 
#line 295
extern "C" { __declspec(dllimport) int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale); } 
#line 298
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using iswctype instea" "d. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t _C, wctype_t _Type); } 
#line 318 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetcwd(__wchar_t * _DstBuf, int _SizeInWords); } 
#line 319
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wgetdcwd(int _Drive, __wchar_t * _DstBuf, int _SizeInWords); } 
#line 327 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _wchdir(const __wchar_t * _Path); } 
#line 331 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _wmkdir(const __wchar_t * _Path); } 
#line 332
extern "C" { __declspec(dllimport) int __cdecl _wrmdir(const __wchar_t * _Path); } 
#line 339 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _waccess(const __wchar_t * _Filename, int _AccessMode); } 
#line 340
extern "C" { __declspec(dllimport) errno_t __cdecl _waccess_s(const __wchar_t * _Filename, int _AccessMode); } 
#line 341
extern "C" { __declspec(dllimport) int __cdecl _wchmod(const __wchar_t * _Filename, int _Mode); } 
#line 342
extern "C" { __declspec(dllimport) int __cdecl _wcreat(const __wchar_t * _Filename, int _PermissionMode); } 
#line 343
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst32(const __wchar_t * _Filename, _wfinddata32_t * _FindData); } 
#line 344
extern "C" { __declspec(dllimport) int __cdecl _wfindnext32(intptr_t _FindHandle, _wfinddata32_t * _FindData); } 
#line 345
extern "C" { __declspec(dllimport) int __cdecl _wunlink(const __wchar_t * _Filename); } 
#line 346
extern "C" { __declspec(dllimport) int __cdecl _wrename(const __wchar_t * _OldFilename, const __wchar_t * _NewFilename); } 
#line 347
extern "C" { __declspec(dllimport) errno_t __cdecl _wmktemp_s(__wchar_t * _TemplateName, size_t _SizeInWords); } 
#line 348
template < size_t _Size > inline errno_t __cdecl _wmktemp_s ( wchar_t ( & _TemplateName ) [ _Size ] ) throw ( ) { return _wmktemp_s ( _TemplateName, _Size ); }
#line 349
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wmktemp(__wchar_t * _TemplateName); } 
#line 351
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(const __wchar_t * _Filename, _wfinddata32i64_t * _FindData); } 
#line 352
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(const __wchar_t * _Filename, _wfinddata64i32_t * _FindData); } 
#line 353
extern "C" { __declspec(dllimport) intptr_t __cdecl _wfindfirst64(const __wchar_t * _Filename, _wfinddata64_t * _FindData); } 
#line 354
extern "C" { __declspec(dllimport) int __cdecl _wfindnext32i64(intptr_t _FindHandle, _wfinddata32i64_t * _FindData); } 
#line 355
extern "C" { __declspec(dllimport) int __cdecl _wfindnext64i32(intptr_t _FindHandle, _wfinddata64i32_t * _FindData); } 
#line 356
extern "C" { __declspec(dllimport) int __cdecl _wfindnext64(intptr_t _FindHandle, _wfinddata64_t * _FindData); } 
#line 358
extern "C" { __declspec(dllimport) errno_t __cdecl _wsopen_s(int * _FileHandle, const __wchar_t * _Filename, int _OpenFlag, int _ShareFlag, int _PermissionFlag); } 
#line 368 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
__declspec(dllimport) int __cdecl _wopen(const __wchar_t * _Filename, int _OpenFlag, int _PermissionMode = 0); 
#line 369
__declspec(dllimport) int __cdecl _wsopen(const __wchar_t * _Filename, int _OpenFlag, int _ShareFlag, int _PermissionMode = 0); 
#line 380 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _wsetlocale(int _Category, const __wchar_t * _Locale); } 
#line 381
extern "C" { __declspec(dllimport) _locale_t __cdecl _wcreate_locale(int _Category, const __wchar_t * _Locale); } 
#line 392 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecl(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 393
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecle(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 394
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexeclp(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 395
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexeclpe(const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 396
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecv(const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
#line 397
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecve(const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 
#line 399
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecvp(const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
#line 400
extern "C" { __declspec(dllimport) intptr_t __cdecl _wexecvpe(const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 
#line 402
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnl(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 403
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnle(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 404
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnlp(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 405
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnlpe(int _Mode, const __wchar_t * _Filename, const __wchar_t * _ArgList, ...); } 
#line 406
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnv(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
#line 407
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnve(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 
#line 409
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnvp(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList); } 
#line 410
extern "C" { __declspec(dllimport) intptr_t __cdecl _wspawnvpe(int _Mode, const __wchar_t * _Filename, const __wchar_t *const * _ArgList, const __wchar_t *const * _Env); } 
#line 473 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { typedef unsigned short _ino_t; }
#line 476
extern "C" { typedef unsigned short ino_t; }
#line 482 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { typedef unsigned _dev_t; }
#line 485
extern "C" { typedef unsigned dev_t; }
#line 491 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { typedef long _off_t; }
#line 494
extern "C" { typedef long off_t; }
#line 501 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { struct _stat32 { 
#line 502
_dev_t st_dev; 
#line 503
_ino_t st_ino; 
#line 504
unsigned short st_mode; 
#line 505
short st_nlink; 
#line 506
short st_uid; 
#line 507
short st_gid; 
#line 508
_dev_t st_rdev; 
#line 509
_off_t st_size; 
#line 510
__time32_t st_atime; 
#line 511
__time32_t st_mtime; 
#line 512
__time32_t st_ctime; 
#line 513
}; }
#line 517
extern "C" { struct stat { 
#line 518
_dev_t st_dev; 
#line 519
_ino_t st_ino; 
#line 520
unsigned short st_mode; 
#line 521
short st_nlink; 
#line 522
short st_uid; 
#line 523
short st_gid; 
#line 524
_dev_t st_rdev; 
#line 525
_off_t st_size; 
#line 526
time_t st_atime; 
#line 527
time_t st_mtime; 
#line 528
time_t st_ctime; 
#line 529
}; }
#line 533 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { struct _stat32i64 { 
#line 534
_dev_t st_dev; 
#line 535
_ino_t st_ino; 
#line 536
unsigned short st_mode; 
#line 537
short st_nlink; 
#line 538
short st_uid; 
#line 539
short st_gid; 
#line 540
_dev_t st_rdev; 
#line 541
__int64 st_size; 
#line 542
__time32_t st_atime; 
#line 543
__time32_t st_mtime; 
#line 544
__time32_t st_ctime; 
#line 545
}; }
#line 547
extern "C" { struct _stat64i32 { 
#line 548
_dev_t st_dev; 
#line 549
_ino_t st_ino; 
#line 550
unsigned short st_mode; 
#line 551
short st_nlink; 
#line 552
short st_uid; 
#line 553
short st_gid; 
#line 554
_dev_t st_rdev; 
#line 555
_off_t st_size; 
#line 556
__time64_t st_atime; 
#line 557
__time64_t st_mtime; 
#line 558
__time64_t st_ctime; 
#line 559
}; }
#line 561
extern "C" { struct _stat64 { 
#line 562
_dev_t st_dev; 
#line 563
_ino_t st_ino; 
#line 564
unsigned short st_mode; 
#line 565
short st_nlink; 
#line 566
short st_uid; 
#line 567
short st_gid; 
#line 568
_dev_t st_rdev; 
#line 569
__int64 st_size; 
#line 570
__time64_t st_atime; 
#line 571
__time64_t st_mtime; 
#line 572
__time64_t st_ctime; 
#line 573
}; }
#line 607 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) int __cdecl _wstat32(const __wchar_t * _Name, _stat32 * _Stat); } 
#line 609
extern "C" { __declspec(dllimport) int __cdecl _wstat32i64(const __wchar_t * _Name, _stat32i64 * _Stat); } 
#line 610
extern "C" { __declspec(dllimport) int __cdecl _wstat64i32(const __wchar_t * _Name, _stat64i32 * _Stat); } 
#line 611
extern "C" { __declspec(dllimport) int __cdecl _wstat64(const __wchar_t * _Name, _stat64 * _Stat); } 
#line 627 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __declspec(dllimport) errno_t __cdecl _cgetws_s(__wchar_t * _Buffer, size_t _SizeInWords, size_t * _SizeRead); } 
#line 628
template < size_t _Size > inline errno_t __cdecl _cgetws_s ( wchar_t ( & _Buffer ) [ _Size ], size_t * _SizeRead ) throw ( ) { return _cgetws_s ( _Buffer, _Size, _SizeRead ); }
#line 629
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _cgetws(__wchar_t * _Buffer); } 
#line 630
extern "C" { __declspec(dllimport) wint_t __cdecl _getwch(); } 
#line 631
extern "C" { __declspec(dllimport) wint_t __cdecl _getwche(); } 
#line 632
extern "C" { __declspec(dllimport) wint_t __cdecl _putwch(__wchar_t _WCh); } 
#line 633
extern "C" { __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _WCh); } 
#line 634
extern "C" { __declspec(dllimport) int __cdecl _cputws(const __wchar_t * _String); } 
#line 635
extern "C" { __declspec(dllimport) int __cdecl _cwprintf(const __wchar_t * _Format, ...); } 
#line 636
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_s(const __wchar_t * _Format, ...); } 
#line 637
extern "C" { __declspec(dllimport) int __cdecl _cwscanf(const __wchar_t * _Format, ...); } 
#line 638
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 639
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_s(const __wchar_t * _Format, ...); } 
#line 640
extern "C" { __declspec(dllimport) int __cdecl _cwscanf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 641
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf(const __wchar_t * _Format, va_list _ArgList); } 
#line 642
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_s(const __wchar_t * _Format, va_list _ArgList); } 
#line 644
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_p(const __wchar_t * _Format, ...); } 
#line 645
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_p(const __wchar_t * _Format, va_list _ArgList); } 
#line 647
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 648
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 649
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 650
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_s_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 651
extern "C" { __declspec(dllimport) int __cdecl _cwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, ...); } 
#line 652
extern "C" { __declspec(dllimport) int __cdecl _vcwprintf_p_l(const __wchar_t * _Format, _locale_t _Locale, va_list _ArgList); } 
#line 654
extern "C" { wint_t __cdecl _putwch_nolock(__wchar_t _WCh); } 
#line 655
extern "C" { wint_t __cdecl _getwch_nolock(); } 
#line 656
extern "C" { wint_t __cdecl _getwche_nolock(); } 
#line 657
extern "C" { wint_t __cdecl _ungetwch_nolock(wint_t _WCh); } 
#line 1219 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { typedef int mbstate_t; }
#line 1220
extern "C" { typedef __wchar_t _Wint_t; }
#line 1222
extern "C" { __declspec(dllimport) wint_t __cdecl btowc(int); } 
#line 1223
extern "C" { __declspec(dllimport) size_t __cdecl mbrlen(const char * _Ch, size_t _SizeInBytes, mbstate_t * _State); } 
#line 1225
extern "C" { __declspec(dllimport) size_t __cdecl mbrtowc(__wchar_t * _DstCh, const char * _SrcCh, size_t _SizeInBytes, mbstate_t * _State); } 
#line 1227
extern "C" { __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(size_t * _Retval, __wchar_t * _Dst, size_t _Size, const char ** _PSrc, size_t _N, mbstate_t * _State); } 
#line 1228
template < size_t _Size > inline errno_t __cdecl mbsrtowcs_s ( size_t * _Retval, wchar_t ( & _Dest ) [ _Size ], const char * * _PSource, size_t _Count, mbstate_t * _State ) throw ( ) { return mbsrtowcs_s ( _Retval, _Dest, _Size, _PSource, _Count, _State ); }
#line 1229
extern "C" { __declspec(dllimport) size_t __cdecl mbsrtowcs(__wchar_t * _Dest, const char ** _PSrc, size_t _Count, mbstate_t * _State); } 
#line 1231
extern "C" { __declspec(dllimport) errno_t __cdecl wcrtomb_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, __wchar_t _Ch, mbstate_t * _State); } 
#line 1233
template < size_t _Size > inline errno_t __cdecl wcrtomb_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], wchar_t _Source, mbstate_t * _State ) throw ( ) { return wcrtomb_s ( _Retval, _Dest, _Size, _Source, _State ); }
#line 1234
extern "C" { __declspec(dllimport) size_t __cdecl wcrtomb(char * _Dest, __wchar_t _Source, mbstate_t * _State); } 
#line 1235
extern "C" { __declspec(dllimport) errno_t __cdecl wcsrtombs_s(size_t * _Retval, char * _Dst, size_t _SizeInBytes, const __wchar_t ** _Src, size_t _Size, mbstate_t * _State); } 
#line 1237
template < size_t _Size > inline errno_t __cdecl wcsrtombs_s ( size_t * _Retval, char ( & _Dest ) [ _Size ], const wchar_t * * _PSrc, size_t _Count, mbstate_t * _State ) throw ( ) { return wcsrtombs_s ( _Retval, _Dest, _Size, _PSrc, _Count, _State ); }
#line 1238
extern "C" { __declspec(dllimport) size_t __cdecl wcsrtombs(char * _Dest, const __wchar_t ** _PSource, size_t _Count, mbstate_t * _State); } 
#line 1239
extern "C" { __declspec(dllimport) int __cdecl wctob(wint_t _WCh); } 
#line 1244
extern "C" { __declspec(dllimport) void *__cdecl memmove(void * _Dst, const void * _Src, size_t _Size); } 
#line 1248
extern "C" { void *__cdecl memcpy(void * _Dst, const void * _Src, size_t _Size); } 
#line 1250
extern "C" { __declspec(dllimport) errno_t __cdecl memcpy_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
#line 1251
extern "C" { __declspec(dllimport) errno_t __cdecl memmove_s(void * _Dst, rsize_t _DstSize, const void * _Src, rsize_t _MaxCount); } 
#line 1253 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __inline int __cdecl fwide(FILE *_F, int _M) 
#line 1254
{ (void)_F; return _M; } } 
#line 1255
extern "C" { __inline int __cdecl mbsinit(const mbstate_t *_P) 
#line 1256
{ return (_P == (0)) || ((*_P) == 0); } } 
#line 1257
extern "C" { __inline const __wchar_t *__cdecl wmemchr(const __wchar_t *_S, __wchar_t _C, size_t _N) 
#line 1258
{ for (; (0) < _N; (++_S), (--_N)) { 
#line 1259
if ((*_S) == _C) { 
#line 1260
return _S; }  }  
#line 1261
return 0; } } 
#line 1262
extern "C" { __inline int __cdecl wmemcmp(const __wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
#line 1263
{ for (; (0) < _N; ((++_S1), (++_S2)), (--_N)) { 
#line 1264
if ((*_S1) != (*_S2)) { 
#line 1265
return ((*_S1) < (*_S2)) ? -1 : (+1); }  }  
#line 1266
return 0; } } 
#line 1270
extern "C" { __inline __wchar_t *__cdecl wmemcpy(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
#line 1271
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
return (__wchar_t *)memcpy(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 
#line 1278
extern "C" { __inline __wchar_t *__cdecl wmemmove(__wchar_t *_S1, const __wchar_t *_S2, size_t _N) 
#line 1279
{ 
#pragma warning( push )
#pragma warning( disable : 4996 6386 )
#pragma warning( disable : 6387)
#line 1284
return (__wchar_t *)memmove(_S1, _S2, _N * sizeof(__wchar_t)); 
#pragma warning( pop )
} } 
#line 1289
extern "C" { errno_t __cdecl wmemcpy_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); } 
#line 1290
extern "C" { errno_t __cdecl wmemmove_s(__wchar_t * _S1, rsize_t _N1, const __wchar_t * _S2, rsize_t _N); } 
#line 1295 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
extern "C" { __inline __wchar_t *__cdecl wmemset(__wchar_t *_S, __wchar_t _C, size_t _N) 
#line 1296
{ 
#line 1297
__wchar_t *_Su = _S; 
#line 1298
for (; (0) < _N; (++_Su), (--_N)) 
#line 1299
{ 
#line 1300
(*_Su) = _C; 
#line 1301
}  
#line 1302
return _S; 
#line 1303
} } 
#line 1307
inline __wchar_t *__cdecl wmemchr(__wchar_t *_S, __wchar_t _C, size_t _N) 
#line 1308
{ return (__wchar_t *)wmemchr((const __wchar_t *)_S, _C, _N); } 
#line 1317 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wchar.h"
#pragma pack ( pop )
#line 16 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\cwchar"
typedef mbstate_t _Mbstatet; 
#line 19
namespace std { 
#line 22
using ::mbstate_t;using ::tm;using ::wint_t;
#line 24
using ::btowc;using ::fgetwc;using ::fgetws;using ::fputwc;
#line 25
using ::fputws;using ::fwide;using ::fwprintf;
#line 26
using ::fwscanf;using ::getwc;using ::getwchar;
#line 27
using ::mbrlen;using ::mbrtowc;using ::mbsrtowcs;
#line 28
using ::mbsinit;using ::putwc;using ::putwchar;
#line 29
using ::swprintf;using ::swscanf;using ::ungetwc;
#line 30
using ::vfwprintf;using ::vswprintf;using ::vwprintf;
#line 31
using ::wcrtomb;using ::wprintf;using ::wscanf;
#line 32
using ::wcsrtombs;using ::wcstol;using ::wcscat;
#line 33
using ::wcschr;using ::wcscmp;using ::wcscoll;
#line 34
using ::wcscpy;using ::wcscspn;using ::wcslen;
#line 35
using ::wcsncat;using ::wcsncmp;using ::wcsncpy;
#line 36
using ::wcspbrk;using ::wcsrchr;using ::wcsspn;
#line 37
using ::wcstod;using ::wcstoul;using ::wcsstr;
#line 38
using ::wcstok;using ::wcsxfrm;using ::wctob;
#line 39
using ::wmemchr;using ::wmemcmp;using ::wmemcpy;
#line 40
using ::wmemmove;using ::wmemset;using ::wcsftime;
#line 42
using ::vfwscanf;using ::vswscanf;using ::vwscanf;
#line 43
using ::wcstof;using ::wcstold;
#line 44
using ::wcstoll;using ::wcstoull;
#line 45
}
#line 14 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
#pragma warning(push,3)
#line 13
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 35
typedef 
#line 31
enum { 
#line 32
denorm_indeterminate = (-1), 
#line 33
denorm_absent = 0, 
#line 34
denorm_present
#line 35
} float_denorm_style; 
#line 45
typedef 
#line 39
enum { 
#line 40
round_indeterminate = (-1), 
#line 41
round_toward_zero = 0, 
#line 42
round_to_nearest, 
#line 43
round_toward_infinity, 
#line 44
round_toward_neg_infinity
#line 45
} float_round_style; 
#line 48
struct _Num_base { 
#line 50
static const float_denorm_style has_denorm = ((float_denorm_style)denorm_absent); 
#line 51
static const bool has_denorm_loss = ((bool)false); 
#line 52
static const bool has_infinity = ((bool)false); 
#line 53
static const bool has_quiet_NaN = ((bool)false); 
#line 54
static const bool has_signaling_NaN = ((bool)false); 
#line 55
static const bool is_bounded = ((bool)false); 
#line 56
static const bool is_exact = ((bool)false); 
#line 57
static const bool is_iec559 = ((bool)false); 
#line 58
static const bool is_integer = ((bool)false); 
#line 59
static const bool is_modulo = ((bool)false); 
#line 60
static const bool is_signed = ((bool)false); 
#line 61
static const bool is_specialized = ((bool)false); 
#line 62
static const bool tinyness_before = ((bool)false); 
#line 63
static const bool traps = ((bool)false); 
#line 64
static const float_round_style round_style = ((float_round_style)round_toward_zero); 
#line 65
static const int digits = ((int)0); 
#line 66
static const int digits10 = ((int)0); 
#line 68
static const int max_digits10 = ((int)0); 
#line 70
static const int max_exponent = ((int)0); 
#line 71
static const int max_exponent10 = ((int)0); 
#line 72
static const int min_exponent = ((int)0); 
#line 73
static const int min_exponent10 = ((int)0); 
#line 74
static const int radix = ((int)0); 
#line 75
}; 
#line 78
template < class _Ty >
 class numeric_limits
  : public _Num_base
 {
public :
 static _Ty ( min ) ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty ( max ) ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty lowest ( ) throw ( )
  {
  return ( ( min ) ( ) );
  }

 static _Ty epsilon ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty round_error ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty denorm_min ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty infinity ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty quiet_NaN ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }

 static _Ty signaling_NaN ( ) throw ( )
  {
  return ( _Ty ( 0 ) );
  }
 };
#line 129
template< class _Ty> 
#line 130
class numeric_limits< const _Ty>  : public numeric_limits< _Ty>  { 
#line 133
}; 
#line 135
template< class _Ty> 
#line 136
class numeric_limits< volatile _Ty>  : public numeric_limits< _Ty>  { 
#line 139
}; 
#line 141
template< class _Ty> 
#line 142
class numeric_limits< const volatile _Ty>  : public numeric_limits< _Ty>  { 
#line 145
}; 
#line 148
struct _Num_int_base : public _Num_base { 
#line 151
static const bool is_bounded = ((bool)true); 
#line 152
static const bool is_exact = ((bool)true); 
#line 153
static const bool is_integer = ((bool)true); 
#line 154
static const bool is_modulo = ((bool)true); 
#line 155
static const bool is_specialized = ((bool)true); 
#line 156
static const int radix = ((int)2); 
#line 157
}; 
#line 160
struct _Num_float_base : public _Num_base { 
#line 163
static const float_denorm_style has_denorm = ((float_denorm_style)denorm_present); 
#line 164
static const bool has_denorm_loss = ((bool)true); 
#line 165
static const bool has_infinity = ((bool)true); 
#line 166
static const bool has_quiet_NaN = ((bool)true); 
#line 167
static const bool has_signaling_NaN = ((bool)true); 
#line 168
static const bool is_bounded = ((bool)true); 
#line 169
static const bool is_exact = ((bool)false); 
#line 170
static const bool is_iec559 = ((bool)true); 
#line 171
static const bool is_integer = ((bool)false); 
#line 172
static const bool is_modulo = ((bool)false); 
#line 173
static const bool is_signed = ((bool)true); 
#line 174
static const bool is_specialized = ((bool)true); 
#line 175
static const bool tinyness_before = ((bool)true); 
#line 176
static const bool traps = ((bool)false); 
#line 177
static const float_round_style round_style = ((float_round_style)round_to_nearest); 
#line 178
static const int radix = ((int)2); 
#line 179
}; 
#line 182
template<> class numeric_limits< char>  : public _Num_int_base { 
#line 186
public: typedef char _Ty; 
#line 188
static _Ty min() throw() 
#line 189
{ 
#line 190
return -128; 
#line 191
} 
#line 193
static _Ty max() throw() 
#line 194
{ 
#line 195
return 127; 
#line 196
} 
#line 198
static _Ty lowest() throw() 
#line 199
{ 
#line 200
return min(); 
#line 201
} 
#line 203
static _Ty epsilon() throw() 
#line 204
{ 
#line 205
return 0; 
#line 206
} 
#line 208
static _Ty round_error() throw() 
#line 209
{ 
#line 210
return 0; 
#line 211
} 
#line 213
static _Ty denorm_min() throw() 
#line 214
{ 
#line 215
return 0; 
#line 216
} 
#line 218
static _Ty infinity() throw() 
#line 219
{ 
#line 220
return 0; 
#line 221
} 
#line 223
static _Ty quiet_NaN() throw() 
#line 224
{ 
#line 225
return 0; 
#line 226
} 
#line 228
static _Ty signaling_NaN() throw() 
#line 229
{ 
#line 230
return 0; 
#line 231
} 
#line 233
static const bool is_signed = ((bool)((-128) != 0)); 
#line 234
static const int digits = ((int)(8 - (((-128) != 0) ? 1 : 0))); 
#line 235
static const int digits10 = ((int)(((8 - (((-128) != 0) ? 1 : 0)) * 301L) / (1000))); 
#line 237 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 240
template<> class numeric_limits< __wchar_t>  : public _Num_int_base { 
#line 244
public: typedef __wchar_t _Ty; 
#line 246
static _Ty min() throw() 
#line 247
{ 
#line 248
return (_Ty)0; 
#line 249
} 
#line 251
static _Ty max() throw() 
#line 252
{ 
#line 253
return (_Ty)65535; 
#line 254
} 
#line 256
static _Ty lowest() throw() 
#line 257
{ 
#line 258
return min(); 
#line 259
} 
#line 261
static _Ty epsilon() throw() 
#line 262
{ 
#line 263
return 0; 
#line 264
} 
#line 266
static _Ty round_error() throw() 
#line 267
{ 
#line 268
return 0; 
#line 269
} 
#line 271
static _Ty denorm_min() throw() 
#line 272
{ 
#line 273
return 0; 
#line 274
} 
#line 276
static _Ty infinity() throw() 
#line 277
{ 
#line 278
return 0; 
#line 279
} 
#line 281
static _Ty quiet_NaN() throw() 
#line 282
{ 
#line 283
return 0; 
#line 284
} 
#line 286
static _Ty signaling_NaN() throw() 
#line 287
{ 
#line 288
return 0; 
#line 289
} 
#line 291
static const bool is_signed = ((bool)(0 != 0)); 
#line 292
static const int digits = ((int)(((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0))); 
#line 294 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
static const int digits10 = ((int)(((((8) * sizeof(__wchar_t)) - ((0 != 0) ? 1 : 0)) * (301L)) / (1000))); 
#line 296 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 299
template<> class numeric_limits< bool>  : public _Num_int_base { 
#line 303
public: typedef bool _Ty; 
#line 305
static _Ty min() throw() 
#line 306
{ 
#line 307
return false; 
#line 308
} 
#line 310
static _Ty max() throw() 
#line 311
{ 
#line 312
return true; 
#line 313
} 
#line 315
static _Ty lowest() throw() 
#line 316
{ 
#line 317
return min(); 
#line 318
} 
#line 320
static _Ty epsilon() throw() 
#line 321
{ 
#line 322
return 0; 
#line 323
} 
#line 325
static _Ty round_error() throw() 
#line 326
{ 
#line 327
return 0; 
#line 328
} 
#line 330
static _Ty denorm_min() throw() 
#line 331
{ 
#line 332
return 0; 
#line 333
} 
#line 335
static _Ty infinity() throw() 
#line 336
{ 
#line 337
return 0; 
#line 338
} 
#line 340
static _Ty quiet_NaN() throw() 
#line 341
{ 
#line 342
return 0; 
#line 343
} 
#line 345
static _Ty signaling_NaN() throw() 
#line 346
{ 
#line 347
return 0; 
#line 348
} 
#line 350
static const bool is_modulo = ((bool)false); 
#line 351
static const bool is_signed = ((bool)false); 
#line 352
static const int digits = ((int)1); 
#line 353
static const int digits10 = ((int)0); 
#line 354
}; 
#line 357
template<> class numeric_limits< signed char>  : public _Num_int_base { 
#line 361
public: typedef signed char _Ty; 
#line 363
static _Ty min() throw() 
#line 364
{ 
#line 365
return -128; 
#line 366
} 
#line 368
static _Ty max() throw() 
#line 369
{ 
#line 370
return 127; 
#line 371
} 
#line 373
static _Ty lowest() throw() 
#line 374
{ 
#line 375
return min(); 
#line 376
} 
#line 378
static _Ty epsilon() throw() 
#line 379
{ 
#line 380
return 0; 
#line 381
} 
#line 383
static _Ty round_error() throw() 
#line 384
{ 
#line 385
return 0; 
#line 386
} 
#line 388
static _Ty denorm_min() throw() 
#line 389
{ 
#line 390
return 0; 
#line 391
} 
#line 393
static _Ty infinity() throw() 
#line 394
{ 
#line 395
return 0; 
#line 396
} 
#line 398
static _Ty quiet_NaN() throw() 
#line 399
{ 
#line 400
return 0; 
#line 401
} 
#line 403
static _Ty signaling_NaN() throw() 
#line 404
{ 
#line 405
return 0; 
#line 406
} 
#line 408
static const bool is_signed = ((bool)true); 
#line 409
static const int digits = ((int)(8 - 1)); 
#line 410
static const int digits10 = ((int)(((8 - 1) * 301L) / (1000))); 
#line 411
}; 
#line 414
template<> class numeric_limits< unsigned char>  : public _Num_int_base { 
#line 418
public: typedef unsigned char _Ty; 
#line 420
static _Ty min() throw() 
#line 421
{ 
#line 422
return 0; 
#line 423
} 
#line 425
static _Ty max() throw() 
#line 426
{ 
#line 427
return 255; 
#line 428
} 
#line 430
static _Ty lowest() throw() 
#line 431
{ 
#line 432
return min(); 
#line 433
} 
#line 435
static _Ty epsilon() throw() 
#line 436
{ 
#line 437
return 0; 
#line 438
} 
#line 440
static _Ty round_error() throw() 
#line 441
{ 
#line 442
return 0; 
#line 443
} 
#line 445
static _Ty denorm_min() throw() 
#line 446
{ 
#line 447
return 0; 
#line 448
} 
#line 450
static _Ty infinity() throw() 
#line 451
{ 
#line 452
return 0; 
#line 453
} 
#line 455
static _Ty quiet_NaN() throw() 
#line 456
{ 
#line 457
return 0; 
#line 458
} 
#line 460
static _Ty signaling_NaN() throw() 
#line 461
{ 
#line 462
return 0; 
#line 463
} 
#line 465
static const bool is_signed = ((bool)false); 
#line 466
static const int digits = ((int)8); 
#line 467
static const int digits10 = ((int)(((8) * 301L) / (1000))); 
#line 468
}; 
#line 471
template<> class numeric_limits< short>  : public _Num_int_base { 
#line 475
public: typedef short _Ty; 
#line 477
static _Ty min() throw() 
#line 478
{ 
#line 479
return -32768; 
#line 480
} 
#line 482
static _Ty max() throw() 
#line 483
{ 
#line 484
return 32767; 
#line 485
} 
#line 487
static _Ty lowest() throw() 
#line 488
{ 
#line 489
return min(); 
#line 490
} 
#line 492
static _Ty epsilon() throw() 
#line 493
{ 
#line 494
return 0; 
#line 495
} 
#line 497
static _Ty round_error() throw() 
#line 498
{ 
#line 499
return 0; 
#line 500
} 
#line 502
static _Ty denorm_min() throw() 
#line 503
{ 
#line 504
return 0; 
#line 505
} 
#line 507
static _Ty infinity() throw() 
#line 508
{ 
#line 509
return 0; 
#line 510
} 
#line 512
static _Ty quiet_NaN() throw() 
#line 513
{ 
#line 514
return 0; 
#line 515
} 
#line 517
static _Ty signaling_NaN() throw() 
#line 518
{ 
#line 519
return 0; 
#line 520
} 
#line 522
static const bool is_signed = ((bool)true); 
#line 523
static const int digits = ((int)(((8) * sizeof(short)) - (1))); 
#line 524
static const int digits10 = ((int)(((((8) * sizeof(short)) - (1)) * (301L)) / (1000))); 
#line 526 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 530
template<> class numeric_limits< unsigned short>  : public _Num_int_base { 
#line 534
public: typedef unsigned short _Ty; 
#line 536
static _Ty min() throw() 
#line 537
{ 
#line 538
return 0; 
#line 539
} 
#line 541
static _Ty max() throw() 
#line 542
{ 
#line 543
return 65535; 
#line 544
} 
#line 546
static _Ty lowest() throw() 
#line 547
{ 
#line 548
return min(); 
#line 549
} 
#line 551
static _Ty epsilon() throw() 
#line 552
{ 
#line 553
return 0; 
#line 554
} 
#line 556
static _Ty round_error() throw() 
#line 557
{ 
#line 558
return 0; 
#line 559
} 
#line 561
static _Ty denorm_min() throw() 
#line 562
{ 
#line 563
return 0; 
#line 564
} 
#line 566
static _Ty infinity() throw() 
#line 567
{ 
#line 568
return 0; 
#line 569
} 
#line 571
static _Ty quiet_NaN() throw() 
#line 572
{ 
#line 573
return 0; 
#line 574
} 
#line 576
static _Ty signaling_NaN() throw() 
#line 577
{ 
#line 578
return 0; 
#line 579
} 
#line 581
static const bool is_signed = ((bool)false); 
#line 582
static const int digits = ((int)((8) * sizeof(unsigned short))); 
#line 583
static const int digits10 = ((int)((((8) * sizeof(unsigned short)) * (301L)) / (1000))); 
#line 585 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 649 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
template<> class numeric_limits< int>  : public _Num_int_base { 
#line 653
public: typedef int _Ty; 
#line 655
static _Ty min() throw() 
#line 656
{ 
#line 657
return (-2147483647) - 1; 
#line 658
} 
#line 660
static _Ty max() throw() 
#line 661
{ 
#line 662
return 2147483647; 
#line 663
} 
#line 665
static _Ty lowest() throw() 
#line 666
{ 
#line 667
return min(); 
#line 668
} 
#line 670
static _Ty epsilon() throw() 
#line 671
{ 
#line 672
return 0; 
#line 673
} 
#line 675
static _Ty round_error() throw() 
#line 676
{ 
#line 677
return 0; 
#line 678
} 
#line 680
static _Ty denorm_min() throw() 
#line 681
{ 
#line 682
return 0; 
#line 683
} 
#line 685
static _Ty infinity() throw() 
#line 686
{ 
#line 687
return 0; 
#line 688
} 
#line 690
static _Ty quiet_NaN() throw() 
#line 691
{ 
#line 692
return 0; 
#line 693
} 
#line 695
static _Ty signaling_NaN() throw() 
#line 696
{ 
#line 697
return 0; 
#line 698
} 
#line 700
static const bool is_signed = ((bool)true); 
#line 701
static const int digits = ((int)(((8) * sizeof(int)) - (1))); 
#line 702
static const int digits10 = ((int)(((((8) * sizeof(int)) - (1)) * (301L)) / (1000))); 
#line 704 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 707
template<> class numeric_limits< unsigned>  : public _Num_int_base { 
#line 711
public: typedef unsigned _Ty; 
#line 713
static _Ty min() throw() 
#line 714
{ 
#line 715
return 0; 
#line 716
} 
#line 718
static _Ty max() throw() 
#line 719
{ 
#line 720
return 4294967295U; 
#line 721
} 
#line 723
static _Ty lowest() throw() 
#line 724
{ 
#line 725
return min(); 
#line 726
} 
#line 728
static _Ty epsilon() throw() 
#line 729
{ 
#line 730
return 0; 
#line 731
} 
#line 733
static _Ty round_error() throw() 
#line 734
{ 
#line 735
return 0; 
#line 736
} 
#line 738
static _Ty denorm_min() throw() 
#line 739
{ 
#line 740
return 0; 
#line 741
} 
#line 743
static _Ty infinity() throw() 
#line 744
{ 
#line 745
return 0; 
#line 746
} 
#line 748
static _Ty quiet_NaN() throw() 
#line 749
{ 
#line 750
return 0; 
#line 751
} 
#line 753
static _Ty signaling_NaN() throw() 
#line 754
{ 
#line 755
return 0; 
#line 756
} 
#line 758
static const bool is_signed = ((bool)false); 
#line 759
static const int digits = ((int)((8) * sizeof(unsigned))); 
#line 760
static const int digits10 = ((int)((((8) * sizeof(unsigned)) * (301L)) / (1000))); 
#line 762 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 765
template<> class numeric_limits< long>  : public _Num_int_base { 
#line 769
public: typedef long _Ty; 
#line 771
static _Ty min() throw() 
#line 772
{ 
#line 773
return (-2147483647L) - (1); 
#line 774
} 
#line 776
static _Ty max() throw() 
#line 777
{ 
#line 778
return 2147483647L; 
#line 779
} 
#line 781
static _Ty lowest() throw() 
#line 782
{ 
#line 783
return min(); 
#line 784
} 
#line 786
static _Ty epsilon() throw() 
#line 787
{ 
#line 788
return 0; 
#line 789
} 
#line 791
static _Ty round_error() throw() 
#line 792
{ 
#line 793
return 0; 
#line 794
} 
#line 796
static _Ty denorm_min() throw() 
#line 797
{ 
#line 798
return 0; 
#line 799
} 
#line 801
static _Ty infinity() throw() 
#line 802
{ 
#line 803
return 0; 
#line 804
} 
#line 806
static _Ty quiet_NaN() throw() 
#line 807
{ 
#line 808
return 0; 
#line 809
} 
#line 811
static _Ty signaling_NaN() throw() 
#line 812
{ 
#line 813
return 0; 
#line 814
} 
#line 816
static const bool is_signed = ((bool)true); 
#line 817
static const int digits = ((int)(((8) * sizeof(long)) - (1))); 
#line 818
static const int digits10 = ((int)(((((8) * sizeof(long)) - (1)) * (301L)) / (1000))); 
#line 820 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 823
template<> class numeric_limits< unsigned long>  : public _Num_int_base { 
#line 827
public: typedef unsigned long _Ty; 
#line 829
static _Ty min() throw() 
#line 830
{ 
#line 831
return 0; 
#line 832
} 
#line 834
static _Ty max() throw() 
#line 835
{ 
#line 836
return 4294967295UL; 
#line 837
} 
#line 839
static _Ty lowest() throw() 
#line 840
{ 
#line 841
return min(); 
#line 842
} 
#line 844
static _Ty epsilon() throw() 
#line 845
{ 
#line 846
return 0; 
#line 847
} 
#line 849
static _Ty round_error() throw() 
#line 850
{ 
#line 851
return 0; 
#line 852
} 
#line 854
static _Ty denorm_min() throw() 
#line 855
{ 
#line 856
return 0; 
#line 857
} 
#line 859
static _Ty infinity() throw() 
#line 860
{ 
#line 861
return 0; 
#line 862
} 
#line 864
static _Ty quiet_NaN() throw() 
#line 865
{ 
#line 866
return 0; 
#line 867
} 
#line 869
static _Ty signaling_NaN() throw() 
#line 870
{ 
#line 871
return 0; 
#line 872
} 
#line 874
static const bool is_signed = ((bool)false); 
#line 875
static const int digits = ((int)((8) * sizeof(unsigned long))); 
#line 876
static const int digits10 = ((int)((((8) * sizeof(unsigned long)) * (301L)) / (1000))); 
#line 878 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 942 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
template<> class numeric_limits< __int64>  : public _Num_int_base { 
#line 946
public: typedef __int64 _Ty; 
#line 948
static _Ty min() throw() 
#line 949
{ 
#line 950
return (-9223372036854775807i64) - (1); 
#line 951
} 
#line 953
static _Ty max() throw() 
#line 954
{ 
#line 955
return 9223372036854775807i64; 
#line 956
} 
#line 958
static _Ty lowest() throw() 
#line 959
{ 
#line 960
return min(); 
#line 961
} 
#line 963
static _Ty epsilon() throw() 
#line 964
{ 
#line 965
return 0; 
#line 966
} 
#line 968
static _Ty round_error() throw() 
#line 969
{ 
#line 970
return 0; 
#line 971
} 
#line 973
static _Ty denorm_min() throw() 
#line 974
{ 
#line 975
return 0; 
#line 976
} 
#line 978
static _Ty infinity() throw() 
#line 979
{ 
#line 980
return 0; 
#line 981
} 
#line 983
static _Ty quiet_NaN() throw() 
#line 984
{ 
#line 985
return 0; 
#line 986
} 
#line 988
static _Ty signaling_NaN() throw() 
#line 989
{ 
#line 990
return 0; 
#line 991
} 
#line 993
static const bool is_signed = ((bool)true); 
#line 994
static const int digits = ((int)(((8) * sizeof(__int64)) - (1))); 
#line 995
static const int digits10 = ((int)(((((8) * sizeof(__int64)) - (1)) * (301L)) / (1000))); 
#line 997 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 1000
template<> class numeric_limits< unsigned __int64>  : public _Num_int_base { 
#line 1004
public: typedef unsigned __int64 _Ty; 
#line 1006
static _Ty min() throw() 
#line 1007
{ 
#line 1008
return 0; 
#line 1009
} 
#line 1011
static _Ty max() throw() 
#line 1012
{ 
#line 1013
return 18446744073709551615Ui64; 
#line 1014
} 
#line 1016
static _Ty lowest() throw() 
#line 1017
{ 
#line 1018
return min(); 
#line 1019
} 
#line 1021
static _Ty epsilon() throw() 
#line 1022
{ 
#line 1023
return 0; 
#line 1024
} 
#line 1026
static _Ty round_error() throw() 
#line 1027
{ 
#line 1028
return 0; 
#line 1029
} 
#line 1031
static _Ty denorm_min() throw() 
#line 1032
{ 
#line 1033
return 0; 
#line 1034
} 
#line 1036
static _Ty infinity() throw() 
#line 1037
{ 
#line 1038
return 0; 
#line 1039
} 
#line 1041
static _Ty quiet_NaN() throw() 
#line 1042
{ 
#line 1043
return 0; 
#line 1044
} 
#line 1046
static _Ty signaling_NaN() throw() 
#line 1047
{ 
#line 1048
return 0; 
#line 1049
} 
#line 1051
static const bool is_signed = ((bool)false); 
#line 1052
static const int digits = ((int)((8) * sizeof(unsigned __int64))); 
#line 1053
static const int digits10 = ((int)((((8) * sizeof(unsigned __int64)) * (301L)) / (1000))); 
#line 1055 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}; 
#line 1059 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
template<> class numeric_limits< float>  : public _Num_float_base { 
#line 1063
public: typedef float _Ty; 
#line 1065
static _Ty min() throw() 
#line 1066
{ 
#line 1067
return (1.175494351e-038F); 
#line 1068
} 
#line 1070
static _Ty max() throw() 
#line 1071
{ 
#line 1072
return (3.402823466e+038F); 
#line 1073
} 
#line 1075
static _Ty lowest() throw() 
#line 1076
{ 
#line 1077
return -max(); 
#line 1078
} 
#line 1080
static _Ty epsilon() throw() 
#line 1081
{ 
#line 1082
return (1.192092896e-007F); 
#line 1083
} 
#line 1085
static _Ty round_error() throw() 
#line 1086
{ 
#line 1087
return (0.5); 
#line 1088
} 
#line 1090
static _Ty denorm_min() throw() 
#line 1091
{ 
#line 1092
return ::_FDenorm._Float; 
#line 1093
} 
#line 1095
static _Ty infinity() throw() 
#line 1096
{ 
#line 1097
return ::_FInf._Float; 
#line 1098
} 
#line 1100
static _Ty quiet_NaN() throw() 
#line 1101
{ 
#line 1102
return ::_FNan._Float; 
#line 1103
} 
#line 1105
static _Ty signaling_NaN() throw() 
#line 1106
{ 
#line 1107
return ::_FSnan._Float; 
#line 1108
} 
#line 1110
static const int digits = ((int)24); 
#line 1111
static const int digits10 = ((int)6); 
#line 1113
static const int max_digits10 = ((int)((2) + (((24) * 301L) / (1000)))); 
#line 1115
static const int max_exponent = ((int)((int)128)); 
#line 1116
static const int max_exponent10 = ((int)((int)38)); 
#line 1117
static const int min_exponent = ((int)((int)(-125))); 
#line 1118
static const int min_exponent10 = ((int)((int)(-37))); 
#line 1119
}; 
#line 1122
template<> class numeric_limits< double>  : public _Num_float_base { 
#line 1126
public: typedef double _Ty; 
#line 1128
static _Ty min() throw() 
#line 1129
{ 
#line 1130
return (2.2250738585072014e-308); 
#line 1131
} 
#line 1133
static _Ty max() throw() 
#line 1134
{ 
#line 1135
return (1.7976931348623157e+308); 
#line 1136
} 
#line 1138
static _Ty lowest() throw() 
#line 1139
{ 
#line 1140
return -max(); 
#line 1141
} 
#line 1143
static _Ty epsilon() throw() 
#line 1144
{ 
#line 1145
return (2.2204460492503131e-016); 
#line 1146
} 
#line 1148
static _Ty round_error() throw() 
#line 1149
{ 
#line 1150
return (0.5); 
#line 1151
} 
#line 1153
static _Ty denorm_min() throw() 
#line 1154
{ 
#line 1155
return ::_Denorm._Double; 
#line 1156
} 
#line 1158
static _Ty infinity() throw() 
#line 1159
{ 
#line 1160
return ::_Inf._Double; 
#line 1161
} 
#line 1163
static _Ty quiet_NaN() throw() 
#line 1164
{ 
#line 1165
return ::_Nan._Double; 
#line 1166
} 
#line 1168
static _Ty signaling_NaN() throw() 
#line 1169
{ 
#line 1170
return ::_Snan._Double; 
#line 1171
} 
#line 1173
static const int digits = ((int)53); 
#line 1174
static const int digits10 = ((int)15); 
#line 1176
static const int max_digits10 = ((int)((2) + (((53) * 301L) / (1000)))); 
#line 1178
static const int max_exponent = ((int)((int)1024)); 
#line 1179
static const int max_exponent10 = ((int)((int)308)); 
#line 1180
static const int min_exponent = ((int)((int)(-1021))); 
#line 1181
static const int min_exponent10 = ((int)((int)(-307))); 
#line 1182
}; 
#line 1185
template<> class numeric_limits< long double>  : public _Num_float_base { 
#line 1189
public: typedef long double _Ty; 
#line 1191
static _Ty min() throw() 
#line 1192
{ 
#line 1193
return (2.2250738585072014e-308); 
#line 1194
} 
#line 1196
static _Ty max() throw() 
#line 1197
{ 
#line 1198
return (1.7976931348623157e+308); 
#line 1199
} 
#line 1201
static _Ty lowest() throw() 
#line 1202
{ 
#line 1203
return -max(); 
#line 1204
} 
#line 1206
static _Ty epsilon() throw() 
#line 1207
{ 
#line 1208
return (2.2204460492503131e-016); 
#line 1209
} 
#line 1211
static _Ty round_error() throw() 
#line 1212
{ 
#line 1213
return (0.5); 
#line 1214
} 
#line 1216
static _Ty denorm_min() throw() 
#line 1217
{ 
#line 1218
return ::_LDenorm._Long_double; 
#line 1219
} 
#line 1221
static _Ty infinity() throw() 
#line 1222
{ 
#line 1223
return ::_LInf._Long_double; 
#line 1224
} 
#line 1226
static _Ty quiet_NaN() throw() 
#line 1227
{ 
#line 1228
return ::_LNan._Long_double; 
#line 1229
} 
#line 1231
static _Ty signaling_NaN() throw() 
#line 1232
{ 
#line 1233
return ::_LSnan._Long_double; 
#line 1234
} 
#line 1236
static const int digits = ((int)53); 
#line 1237
static const int digits10 = ((int)15); 
#line 1239
static const int max_digits10 = ((int)((2) + (((53) * 301L) / (1000)))); 
#line 1241
static const int max_exponent = ((int)((int)1024)); 
#line 1242
static const int max_exponent10 = ((int)((int)308)); 
#line 1243
static const int min_exponent = ((int)((int)(-1021))); 
#line 1244
static const int min_exponent10 = ((int)((int)(-307))); 
#line 1245
}; 
#line 1454 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
}
#line 1456
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
#pragma warning(push,3)
#line 1457 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\limits"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
#pragma pack ( push, 8 )
#line 23 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
namespace std { 
#line 31
typedef void (__cdecl *new_handler)(void); 
#line 36 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
struct nothrow_t { 
#line 38
}; 
#line 40
extern const nothrow_t nothrow; 
#line 44 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
__declspec(dllimport) new_handler __cdecl set_new_handler(new_handler) throw(); 
#line 47
__declspec(dllimport) new_handler __cdecl get_new_handler() throw(); 
#line 49
}
#line 52
void __cdecl operator delete(void *) throw(); 
#pragma warning (suppress: 4985)
void *__cdecl operator new(size_t _Size); 
#line 58
inline void *__cdecl operator new(size_t, void *_Where) throw() 
#line 59
{ 
#line 60
return _Where; 
#line 61
} 
#line 63
inline void __cdecl operator delete(void *, void *) throw() 
#line 64
{ 
#line 65
} 
#line 70 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
inline void *__cdecl operator new[](size_t, void *_Where) throw() 
#line 71
{ 
#line 72
return _Where; 
#line 73
} 
#line 75
inline void __cdecl operator delete[](void *, void *) throw() 
#line 76
{ 
#line 77
} 
#line 80 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
void __cdecl operator delete[](void *) throw(); 
#line 82
void *__cdecl operator new[](size_t _Size); 
#line 87
void *__cdecl operator new(size_t _Size, const std::nothrow_t &) throw(); 
#line 90
void *__cdecl operator new[](size_t _Size, const std::nothrow_t &) throw(); 
#line 93
void __cdecl operator delete(void *, const std::nothrow_t &) throw(); 
#line 96
void __cdecl operator delete[](void *, const std::nothrow_t &) throw(); 
#line 102 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
using std::new_handler;
#line 106 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\new"
#pragma warning(pop)
#pragma pack ( pop )
#line 20 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
#pragma pack ( push, 8 )
#line 44 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
extern "C" { typedef void *_HFILE; }
#line 71 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOK)(int, char *, int *); }
#line 72
extern "C" { typedef int (__cdecl *_CRT_REPORT_HOOKW)(int, __wchar_t *, int *); }
#line 103 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
extern "C" { typedef int (__cdecl *_CRT_ALLOC_HOOK)(int, void *, size_t, int, long, const unsigned char *, int); }
#line 164 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
extern "C" { typedef void (__cdecl *_CRT_DUMP_CLIENT)(void *, size_t); }
#line 172 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
struct _CrtMemBlockHeader; 
#line 180
extern "C" { typedef 
#line 173
struct _CrtMemState { 
#line 175
_CrtMemBlockHeader *pBlockHeader; 
#line 176
size_t lCounts[5]; 
#line 177
size_t lSizes[5]; 
#line 178
size_t lHighWaterCount; 
#line 179
size_t lTotalCount; 
#line 180
} _CrtMemState; }
#line 1035 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
#pragma warning(suppress: 4985)
void *__cdecl operator new[](size_t _Size); 
#line 1039
void *__cdecl operator new(size_t _Size, int, const char *, int); 
#line 1046
#pragma warning(suppress: 4985)
void *__cdecl operator new[](size_t _Size, int, const char *, int); 
#line 1054
void __cdecl operator delete[](void *); 
#line 1055
void __cdecl operator delete(void * _P, int, const char *, int); 
#line 1056
void __cdecl operator delete[](void * _P, int, const char *, int); 
#line 14 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
#pragma warning(push,3)
#line 1120 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\crtdbg.h"
#pragma pack ( pop )
#line 13 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 21
typedef _Longlong streamoff; 
#line 22
typedef _Longlong streamsize; 
#line 31
__declspec(dllimport) extern const streamoff _BADOFF; 
#line 35 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
template < class _Statetype >
 class fpos
 {
 typedef fpos < _Statetype > _Myt;

public :
  fpos ( streamoff _Off = 0 )
  : _Myoff ( _Off ), _Fpos ( 0 ), _Mystate ( )
  {
  }

  fpos ( _Statetype _State, fpos_t _Fileposition )
  : _Myoff ( 0 ), _Fpos ( _Fileposition ), _Mystate ( _State )
  {
  }

 _Statetype state ( ) const
  {
  return ( _Mystate );
  }

 void state ( _Statetype _State )
  {
  _Mystate = _State;
  }

 fpos_t seekpos ( ) const
  {
  return ( _Fpos );
  }

  operator streamoff ( ) const
  {
  return ( ( streamoff ) ( _Myoff + ( ( long long ) ( _Fpos ) ) ) );
  }

 streamoff operator - ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this - ( streamoff ) _Right );
  }

 _Myt & operator += ( streamoff _Off )
  {
  _Myoff += _Off;
  return ( * this );
  }

 _Myt & operator -= ( streamoff _Off )
  {
  _Myoff -= _Off;
  return ( * this );
  }

 _Myt operator + ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt operator - ( streamoff _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( ( streamoff ) * this == ( streamoff ) _Right );
  }

 bool operator == ( streamoff _Right ) const
  {
  return ( ( streamoff ) * this == _Right );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

private :
 streamoff _Myoff;
 fpos_t _Fpos;
 _Statetype _Mystate;
 };
#line 126
typedef fpos< int>  streampos; 
#line 128
typedef streampos wstreampos; 
#line 131
template < class _Elem,
 class _Int_type >
 struct _Char_traits
 {
 typedef _Elem char_type;
 typedef _Int_type int_type;
 typedef streampos pos_type;
 typedef streamoff off_type;
 typedef _Mbstatet state_type;

 static int __cdecl compare (
    const _Elem * _First1,
    const _Elem * _First2, size_t _Count )
  {
  for (; 0 < _Count; -- _Count, ++ _First1, ++ _First2 )
   if ( ! eq ( * _First1, * _First2 ) )
    return ( lt ( * _First1, * _First2 ) ? - 1 : + 1 );
  return ( 0 );
  }

 static size_t __cdecl length ( const _Elem * _First )
  {
  size_t _Count;
  for ( _Count = 0; ! eq ( * _First, _Elem ( ) ); ++ _First )
   ++ _Count;
  return ( _Count );
  }

 static _Elem * __cdecl copy (
    _Elem * _First1,
    const _Elem * _First2, size_t _Count )
  {
  _Elem * _Next = _First1;
  for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
   assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl _Copy_s (
    _Elem * _First1, size_t _Dest_size,
    const _Elem * _First2, size_t _Count )
  {
  { if ( ! ( _Count <= _Dest_size ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); return ( 0 ); } };
  return ( copy ( _First1, _First2, _Count ) );
  }

 static const _Elem * __cdecl find (
    const _Elem * _First,
  size_t _Count, const _Elem & _Ch )
  {
  for (; 0 < _Count; -- _Count, ++ _First )
   if ( eq ( * _First, _Ch ) )
    return ( _First );
  return ( 0 );
  }

 static _Elem * __cdecl move (
    _Elem * _First1,
    const _Elem * _First2, size_t _Count )
  {
  _Elem * _Next = _First1;
  if ( _First2 < _Next && _Next < _First2 + _Count )
   for ( _Next += _Count, _First2 += _Count; 0 < _Count; -- _Count )
    assign ( * -- _Next, * -- _First2 );
  else
   for (; 0 < _Count; -- _Count, ++ _Next, ++ _First2 )
    assign ( * _Next, * _First2 );
  return ( _First1 );
  }

 static _Elem * __cdecl assign (
    _Elem * _First,
  size_t _Count, _Elem _Ch )
  {
  _Elem * _Next = _First;
  for (; 0 < _Count; -- _Count, ++ _Next )
   assign ( * _Next, _Ch );
  return ( _First );
  }

 static void __cdecl assign ( _Elem & _Left, const _Elem & _Right ) throw ( )
  {
  _Left = _Right;
  }

 static bool __cdecl eq ( const _Elem & _Left,
  const _Elem & _Right ) throw ( )
  {
  return ( _Left == _Right );
  }

 static bool __cdecl lt ( const _Elem & _Left,
  const _Elem & _Right ) throw ( )
  {
  return ( _Left < _Right );
  }

 static _Elem __cdecl to_char_type (
  const int_type & _Meta ) throw ( )
  {
  return ( ( _Elem ) _Meta );
  }

 static int_type __cdecl to_int_type (
  const _Elem & _Ch ) throw ( )
  {
  return ( ( int_type ) _Ch );
  }

 static bool __cdecl eq_int_type ( const int_type & _Left,
  const int_type & _Right ) throw ( )
  {
  return ( _Left == _Right );
  }

 static int_type __cdecl not_eof (
  const int_type & _Meta ) throw ( )
  {
  return ( _Meta != eof ( ) ? ( int_type ) _Meta : ( int_type ) ! eof ( ) );
  }

 static int_type __cdecl eof ( ) throw ( )
  {
  return ( ( int_type ) ( - 1 ) );
  }
 };
#line 259
template< class _Elem> 
#line 260
struct char_traits : public _Char_traits< _Elem, long>  { 
#line 263
}; 
#line 287 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
template<> struct char_traits< __wchar_t>  { 
#line 289
typedef __wchar_t _Elem; 
#line 290
typedef _Elem char_type; 
#line 291
typedef wint_t int_type; 
#line 292
typedef streampos pos_type; 
#line 293
typedef streamoff off_type; 
#line 294
typedef _Mbstatet state_type; 
#line 296
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 297
_Count) 
#line 298
{ 
#line 299
return (_Count == (0)) ? 0 : ::wmemcmp(_First1, _First2, _Count); 
#line 301
} 
#line 303
static size_t __cdecl length(const _Elem *_First) 
#line 304
{ 
#line 305
return ((*_First) == 0) ? 0 : ::wcslen(_First); 
#line 307
} 
#line 309
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 310
_Count) 
#line 311
{ 
#line 312
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemcpy(_First1, _First2, _Count)); 
#line 314
} 
#line 316
static _Elem *__cdecl _Copy_s(_Elem *
#line 317
_First1, size_t _Size_in_words, const _Elem *
#line 318
_First2, size_t _Count) 
#line 319
{ 
#line 320
if ((0) < _Count) { 
#line 321
::wmemcpy_s(_First1, _Size_in_words, _First2, _Count); }  
#line 322
return _First1; 
#line 323
} 
#line 325
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 326
_Ch) 
#line 327
{ 
#line 328
return (_Count == (0)) ? (const _Elem *)0 : ((const _Elem *)::wmemchr(_First, _Ch, _Count)); 
#line 330
} 
#line 332
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 333
_Count) 
#line 334
{ 
#line 335
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemmove(_First1, _First2, _Count)); 
#line 337
} 
#line 339
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem 
#line 340
_Ch) 
#line 341
{ 
#line 342
return (_Elem *)::wmemset(_First, _Ch, _Count); 
#line 343
} 
#line 345
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) throw() 
#line 346
{ 
#line 347
_Left = _Right; 
#line 348
} 
#line 350
static bool __cdecl eq(const _Elem &_Left, const _Elem &
#line 351
_Right) throw() 
#line 352
{ 
#line 353
return _Left == _Right; 
#line 354
} 
#line 356
static bool __cdecl lt(const _Elem &_Left, const _Elem &
#line 357
_Right) throw() 
#line 358
{ 
#line 359
return _Left < _Right; 
#line 360
} 
#line 362
static _Elem __cdecl to_char_type(const int_type &
#line 363
_Meta) throw() 
#line 364
{ 
#line 365
return _Meta; 
#line 366
} 
#line 368
static int_type __cdecl to_int_type(const _Elem &
#line 369
_Ch) throw() 
#line 370
{ 
#line 371
return _Ch; 
#line 372
} 
#line 374
static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 375
_Right) throw() 
#line 376
{ 
#line 377
return _Left == _Right; 
#line 378
} 
#line 380
static int_type __cdecl not_eof(const int_type &
#line 381
_Meta) throw() 
#line 382
{ 
#line 383
return (_Meta != (eof())) ? _Meta : (!(eof())); 
#line 384
} 
#line 386
static int_type __cdecl eof() throw() 
#line 387
{ 
#line 388
return (wint_t)65535; 
#line 389
} 
#line 390
}; 
#line 395
template<> struct char_traits< unsigned short>  { 
#line 397
typedef unsigned short _Elem; 
#line 398
typedef _Elem char_type; 
#line 399
typedef wint_t int_type; 
#line 400
typedef streampos pos_type; 
#line 401
typedef streamoff off_type; 
#line 402
typedef _Mbstatet state_type; 
#line 404
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 405
_Count) 
#line 406
{ 
#line 407
return (_Count == (0)) ? 0 : ::wmemcmp((const __wchar_t *)_First1, (const __wchar_t *)_First2, _Count); 
#line 410
} 
#line 412
static size_t __cdecl length(const _Elem *_First) 
#line 413
{ 
#line 414
return ((*_First) == 0) ? 0 : ::wcslen((const __wchar_t *)_First); 
#line 416
} 
#line 418
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 419
_Count) 
#line 420
{ 
#line 421
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemcpy((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 
#line 424
} 
#line 426
static _Elem *__cdecl _Copy_s(_Elem *
#line 427
_First1, size_t _Size_in_words, const _Elem *
#line 428
_First2, size_t _Count) 
#line 429
{ 
#line 430
if ((0) < _Count) { 
#line 431
::wmemcpy_s((__wchar_t *)_First1, _Size_in_words, (const __wchar_t *)_First2, _Count); }  
#line 433 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
return _First1; 
#line 434
} 
#line 436
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 437
_Ch) 
#line 438
{ 
#line 439
return (_Count == (0)) ? (const _Elem *)0 : ((const _Elem *)::wmemchr((const __wchar_t *)_First, _Ch, _Count)); 
#line 442
} 
#line 444
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 445
_Count) 
#line 446
{ 
#line 447
return (_Count == (0)) ? _First1 : ((_Elem *)::wmemmove((__wchar_t *)_First1, (const __wchar_t *)_First2, _Count)); 
#line 450
} 
#line 452
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem 
#line 453
_Ch) 
#line 454
{ 
#line 455
return (_Elem *)::wmemset((__wchar_t *)_First, _Ch, _Count); 
#line 456
} 
#line 458
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) throw() 
#line 459
{ 
#line 460
_Left = _Right; 
#line 461
} 
#line 463
static bool __cdecl eq(const _Elem &_Left, const _Elem &
#line 464
_Right) throw() 
#line 465
{ 
#line 466
return _Left == _Right; 
#line 467
} 
#line 469
static bool __cdecl lt(const _Elem &_Left, const _Elem &
#line 470
_Right) throw() 
#line 471
{ 
#line 472
return _Left < _Right; 
#line 473
} 
#line 475
static _Elem __cdecl to_char_type(const int_type &_Meta) throw() 
#line 476
{ 
#line 477
return _Meta; 
#line 478
} 
#line 480
static int_type __cdecl to_int_type(const _Elem &_Ch) throw() 
#line 481
{ 
#line 482
return _Ch; 
#line 483
} 
#line 485
static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 486
_Right) throw() 
#line 487
{ 
#line 488
return _Left == _Right; 
#line 489
} 
#line 491
static int_type __cdecl not_eof(const int_type &_Meta) throw() 
#line 492
{ 
#line 493
return (_Meta != (eof())) ? _Meta : (!(eof())); 
#line 494
} 
#line 496
static int_type __cdecl eof() throw() 
#line 497
{ 
#line 498
return (wint_t)65535; 
#line 499
} 
#line 500
}; 
#line 504 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
template<> struct char_traits< char>  { 
#line 506
typedef char _Elem; 
#line 507
typedef _Elem char_type; 
#line 508
typedef int int_type; 
#line 509
typedef streampos pos_type; 
#line 510
typedef streamoff off_type; 
#line 511
typedef _Mbstatet state_type; 
#line 513
static int __cdecl compare(const _Elem *_First1, const _Elem *_First2, size_t 
#line 514
_Count) 
#line 515
{ 
#line 516
return (_Count == (0)) ? 0 : ::memcmp(_First1, _First2, _Count); 
#line 518
} 
#line 520
static size_t __cdecl length(const _Elem *_First) 
#line 521
{ 
#line 522
return ((*_First) == 0) ? 0 : ::strlen(_First); 
#line 524
} 
#line 526
static _Elem *__cdecl copy(_Elem *_First1, const _Elem *_First2, size_t 
#line 527
_Count) 
#line 528
{ 
#line 529
return (_Count == (0)) ? _First1 : ((_Elem *)::memcpy(_First1, _First2, _Count)); 
#line 531
} 
#line 533
static _Elem *__cdecl _Copy_s(_Elem *
#line 534
_First1, size_t _Size_in_bytes, const _Elem *
#line 535
_First2, size_t _Count) 
#line 536
{ 
#line 537
if ((0) < _Count) { 
#line 538
::memcpy_s(_First1, _Size_in_bytes, _First2, _Count); }  
#line 539
return _First1; 
#line 540
} 
#line 542
static const _Elem *__cdecl find(const _Elem *_First, size_t _Count, const _Elem &
#line 543
_Ch) 
#line 544
{ 
#line 545
return (_Count == (0)) ? (const _Elem *)0 : ((const _Elem *)::memchr(_First, _Ch, _Count)); 
#line 547
} 
#line 549
static _Elem *__cdecl move(_Elem *_First1, const _Elem *_First2, size_t 
#line 550
_Count) 
#line 551
{ 
#line 552
return (_Count == (0)) ? _First1 : ((_Elem *)::memmove(_First1, _First2, _Count)); 
#line 554
} 
#line 556
static _Elem *__cdecl assign(_Elem *_First, size_t _Count, _Elem 
#line 557
_Ch) 
#line 558
{ 
#line 559
return (_Elem *)::memset(_First, _Ch, _Count); 
#line 560
} 
#line 562
static void __cdecl assign(_Elem &_Left, const _Elem &_Right) throw() 
#line 563
{ 
#line 564
_Left = _Right; 
#line 565
} 
#line 567
static bool __cdecl eq(const _Elem &_Left, const _Elem &
#line 568
_Right) throw() 
#line 569
{ 
#line 570
return _Left == _Right; 
#line 571
} 
#line 573
static bool __cdecl lt(const _Elem &_Left, const _Elem &
#line 574
_Right) throw() 
#line 575
{ 
#line 576
return ((unsigned char)_Left) < ((unsigned char)_Right); 
#line 577
} 
#line 579
static _Elem __cdecl to_char_type(const int_type &
#line 580
_Meta) throw() 
#line 581
{ 
#line 582
return (_Elem)_Meta; 
#line 583
} 
#line 585
static int_type __cdecl to_int_type(const _Elem &
#line 586
_Ch) throw() 
#line 587
{ 
#line 588
return (unsigned char)_Ch; 
#line 589
} 
#line 591
static bool __cdecl eq_int_type(const int_type &_Left, const int_type &
#line 592
_Right) throw() 
#line 593
{ 
#line 594
return _Left == _Right; 
#line 595
} 
#line 597
static int_type __cdecl not_eof(const int_type &
#line 598
_Meta) throw() 
#line 599
{ 
#line 600
return (_Meta != eof()) ? _Meta : (!(eof())); 
#line 601
} 
#line 603
static int_type __cdecl eof() throw() 
#line 604
{ 
#line 605
return -1; 
#line 606
} 
#line 607
}; 
#line 610
template < class _Ty >
 class allocator;
#line 612
class ios_base; 
#line 613
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ios;
#line 616
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class istreambuf_iterator;
#line 619
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class ostreambuf_iterator;
#line 622
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_streambuf;
#line 625
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_istream;
#line 628
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_ostream;
#line 631
template < class _Elem,
 class _Traits = char_traits < _Elem > >
 class basic_iostream;
#line 634
template< class _Elem, class 
#line 635
_Traits = char_traits< _Elem> , class 
#line 636
_Alloc = allocator< _Elem> > class basic_stringbuf; 
#line 638
template< class _Elem, class 
#line 639
_Traits = char_traits< _Elem> , class 
#line 640
_Alloc = allocator< _Elem> > class basic_istringstream; 
#line 642
template< class _Elem, class 
#line 643
_Traits = char_traits< _Elem> , class 
#line 644
_Alloc = allocator< _Elem> > class basic_ostringstream; 
#line 646
template< class _Elem, class 
#line 647
_Traits = char_traits< _Elem> , class 
#line 648
_Alloc = allocator< _Elem> > class basic_stringstream; 
#line 650
template< class _Elem, class 
#line 651
_Traits = char_traits< _Elem> > class basic_filebuf; 
#line 653
template< class _Elem, class 
#line 654
_Traits = char_traits< _Elem> > class basic_ifstream; 
#line 656
template< class _Elem, class 
#line 657
_Traits = char_traits< _Elem> > class basic_ofstream; 
#line 659
template< class _Elem, class 
#line 660
_Traits = char_traits< _Elem> > class basic_fstream; 
#line 664
template < class _Elem,
 class _InIt >
 class num_get;
#line 667
template < class _Elem,
 class _OutIt >
 class num_put;
#line 670
template< class _Elem> class collate; 
#line 675 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
typedef basic_ios< char, char_traits< char> >  ios; 
#line 676
typedef basic_streambuf< char, char_traits< char> >  streambuf; 
#line 677
typedef basic_istream< char, char_traits< char> >  istream; 
#line 678
typedef basic_ostream< char, char_traits< char> >  ostream; 
#line 679
typedef basic_iostream< char, char_traits< char> >  iostream; 
#line 681
typedef basic_stringbuf< char, char_traits< char> , allocator< char> >  stringbuf; 
#line 683
typedef basic_istringstream< char, char_traits< char> , allocator< char> >  istringstream; 
#line 685
typedef basic_ostringstream< char, char_traits< char> , allocator< char> >  ostringstream; 
#line 687
typedef basic_stringstream< char, char_traits< char> , allocator< char> >  stringstream; 
#line 688
typedef basic_filebuf< char, char_traits< char> >  filebuf; 
#line 689
typedef basic_ifstream< char, char_traits< char> >  ifstream; 
#line 690
typedef basic_ofstream< char, char_traits< char> >  ofstream; 
#line 691
typedef basic_fstream< char, char_traits< char> >  fstream; 
#line 694
typedef basic_ios< __wchar_t, char_traits< __wchar_t> >  wios; 
#line 696
typedef basic_streambuf< __wchar_t, char_traits< __wchar_t> >  wstreambuf; 
#line 697
typedef basic_istream< __wchar_t, char_traits< __wchar_t> >  wistream; 
#line 698
typedef basic_ostream< __wchar_t, char_traits< __wchar_t> >  wostream; 
#line 699
typedef basic_iostream< __wchar_t, char_traits< __wchar_t> >  wiostream; 
#line 701
typedef basic_stringbuf< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringbuf; 
#line 703
typedef basic_istringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wistringstream; 
#line 705
typedef basic_ostringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wostringstream; 
#line 707
typedef basic_stringstream< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstringstream; 
#line 708
typedef basic_filebuf< __wchar_t, char_traits< __wchar_t> >  wfilebuf; 
#line 709
typedef basic_ifstream< __wchar_t, char_traits< __wchar_t> >  wifstream; 
#line 710
typedef basic_ofstream< __wchar_t, char_traits< __wchar_t> >  wofstream; 
#line 711
typedef basic_fstream< __wchar_t, char_traits< __wchar_t> >  wfstream; 
#line 737
typedef num_get< char, istreambuf_iterator< char, char_traits< char> > >  numget; 
#line 739
typedef num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumget; 
#line 741
typedef num_put< char, ostreambuf_iterator< char, char_traits< char> > >  numput; 
#line 743
typedef num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > >  wnumput; 
#line 744
typedef collate< char>  ncollate; 
#line 745
typedef collate< __wchar_t>  wcollate; 
#line 747 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
}
#line 750
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\type_traits"
#pragma warning(push,3)
#line 12
#pragma warning(disable: 4180 4296)
#line 751 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iosfwd"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\type_traits"
#pragma pack ( push, 8 )
#line 66
namespace std { 
#line 68
template< class _Ty> 
#line 69
struct _Ptr_traits { 
#line 71
}; 
#line 73
template< class _Ty> 
#line 74
struct _Ptr_traits< _Ty *>  { 
#line 76
static const bool _Is_const = false; 
#line 77
static const bool _Is_volatile = false; 
#line 78
}; 
#line 80
template< class _Ty> 
#line 81
struct _Ptr_traits< const _Ty *>  { 
#line 83
static const bool _Is_const = true; 
#line 84
static const bool _Is_volatile = false; 
#line 85
}; 
#line 87
template< class _Ty> 
#line 88
struct _Ptr_traits< volatile _Ty *>  { 
#line 90
static const bool _Is_const = false; 
#line 91
static const bool _Is_volatile = true; 
#line 92
}; 
#line 94
template< class _Ty> 
#line 95
struct _Ptr_traits< const volatile _Ty *>  { 
#line 97
static const bool _Is_const = true; 
#line 98
static const bool _Is_volatile = true; 
#line 99
}; 
#line 101
template< class _Ty> 
#line 102
struct _Is_funptr : public false_type { 
#line 105
}; 
#line 107
template< class _Ty> 
#line 108
struct _Is_memfunptr : public false_type { 
#line 111
}; 
#line 121
template< class _Ret, class ..._Types> struct _Is_funptr< _Ret (__cdecl *)(_Types ...)>  : public true_type { }; template< class _Ret, class ..._Types> struct _Is_funptr< _Ret (__stdcall *)(_Types ...)>  : public true_type { }; template< class _Ret, class ..._Types> struct _Is_funptr< _Ret (__fastcall *)(_Types ...)>  : public true_type { }; 
#line 133
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__thiscall _Arg0::*)(_Types ...)>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...)>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__stdcall _Arg0::*)(_Types ...)>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__fastcall _Arg0::*)(_Types ...)>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__thiscall _Arg0::*)(_Types ...) const>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__stdcall _Arg0::*)(_Types ...) const>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__fastcall _Arg0::*)(_Types ...) const>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__thiscall _Arg0::*)(_Types ...) volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__stdcall _Arg0::*)(_Types ...) volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__fastcall _Arg0::*)(_Types ...) volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__thiscall _Arg0::*)(_Types ...) const volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__cdecl _Arg0::*)(_Types ...) const volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__stdcall _Arg0::*)(_Types ...) const volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (__fastcall _Arg0::*)(_Types ...) const volatile>  : public true_type { }; 
#line 136
template< class _Ret, class ...
#line 137
_Types> 
#line 138
struct _Is_funptr< _Ret (*)(_Types ..., ...)>  : public true_type { 
#line 141
}; 
#line 152
template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...)>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) volatile>  : public true_type { }; template< class _Ret, class _Arg0, class ..._Types> struct _Is_memfunptr< _Ret (_Arg0::*)(_Types ..., ...) const volatile>  : public true_type { }; 
#line 157
template< class _Ty> 
#line 158
struct add_const { 
#line 160
typedef const _Ty type; 
#line 161
}; 
#line 164
template< class _Ty> 
#line 165
struct add_volatile { 
#line 167
typedef volatile _Ty type; 
#line 168
}; 
#line 171
template< class _Ty> 
#line 172
struct add_cv { 
#line 174
typedef const volatile _Ty type; 
#line 175
}; 
#line 178
template< class _Ty> 
#line 179
struct add_reference { 
#line 181
typedef _Ty &type; 
#line 182
}; 
#line 191
template<> struct add_reference< void>  { typedef void type; }; template<> struct add_reference< const void>  { typedef const void type; }; template<> struct add_reference< volatile void>  { typedef volatile void type; }; template<> struct add_reference< const volatile void>  { typedef const volatile void type; }; 
#line 195
template< class _Ty> 
#line 196
struct add_lvalue_reference { 
#line 198
typedef typename add_reference< _Ty> ::type type; 
#line 199
}; 
#line 203
template< class _Ty> 
#line 204
struct add_rvalue_reference { 
#line 206
typedef _Ty &&type; 
#line 207
}; 
#line 216
template<> struct add_rvalue_reference< void>  { typedef void type; }; template<> struct add_rvalue_reference< const void>  { typedef const void type; }; template<> struct add_rvalue_reference< volatile void>  { typedef volatile void type; }; template<> struct add_rvalue_reference< const volatile void>  { typedef const volatile void type; }; 
#line 220
template< class _Ty> typename add_rvalue_reference< _Ty> ::type declval() throw(); 
#line 225
template< class _Ty> 
#line 226
struct remove_extent { 
#line 228
typedef _Ty type; 
#line 229
}; 
#line 231
template< class _Ty, unsigned _Ix> 
#line 232
struct remove_extent< _Ty [_Ix]>  { 
#line 234
typedef _Ty type; 
#line 235
}; 
#line 237
template< class _Ty> 
#line 238
struct remove_extent< _Ty []>  { 
#line 240
typedef _Ty type; 
#line 241
}; 
#line 244
template< class _Ty> 
#line 245
struct remove_all_extents { 
#line 247
typedef _Ty type; 
#line 248
}; 
#line 250
template< class _Ty, unsigned _Ix> 
#line 251
struct remove_all_extents< _Ty [_Ix]>  { 
#line 253
typedef typename std::remove_all_extents< _Ty> ::type type; 
#line 254
}; 
#line 256
template< class _Ty> 
#line 257
struct remove_all_extents< _Ty []>  { 
#line 259
typedef typename std::remove_all_extents< _Ty> ::type type; 
#line 260
}; 
#line 263
template< class _Ty> 
#line 264
struct remove_pointer { 
#line 266
typedef _Ty type; 
#line 267
}; 
#line 276
template< class _Ty> struct remove_pointer< _Ty *>  { typedef _Ty type; }; template< class _Ty> struct remove_pointer< _Ty *const>  { typedef _Ty type; }; template< class _Ty> struct remove_pointer< _Ty *volatile>  { typedef _Ty type; }; template< class _Ty> struct remove_pointer< _Ty *const volatile>  { typedef _Ty type; }; 
#line 280
template< class _Ty> 
#line 281
struct add_pointer { 
#line 283
typedef typename remove_reference< _Ty> ::type *type; 
#line 284
}; 
#line 288
template< class _Ty> 
#line 289
struct _Is_void : public false_type { 
#line 292
}; 
#line 295
template<> struct _Is_void< void>  : public true_type { 
#line 298
}; 
#line 300
template< class _Ty> 
#line 301
struct is_void : public _Is_void< typename remove_cv< _Ty> ::type>  { 
#line 304
}; 
#line 307
template< class _Ty> 
#line 308
struct is_array : public false_type { 
#line 311
}; 
#line 313
template< class _Ty, size_t _Nx> 
#line 314
struct is_array< _Ty [_Nx]>  : public true_type { 
#line 317
}; 
#line 319
template< class _Ty> 
#line 320
struct is_array< _Ty []>  : public true_type { 
#line 323
}; 
#line 326
template< class _Ty> 
#line 327
struct is_lvalue_reference : public false_type { 
#line 330
}; 
#line 332
template< class _Ty> 
#line 333
struct is_lvalue_reference< _Ty &>  : public true_type { 
#line 336
}; 
#line 339
template< class _Ty> 
#line 340
struct is_rvalue_reference : public false_type { 
#line 343
}; 
#line 345
template< class _Ty> 
#line 346
struct is_rvalue_reference< _Ty &&>  : public true_type { 
#line 349
}; 
#line 352
template< class _Ty> 
#line 353
struct is_reference : public _Cat_base< is_lvalue_reference< _Ty> ::value || is_rvalue_reference< _Ty> ::value>  { 
#line 357
}; 
#line 361
template< class _Ty> 
#line 362
struct _Is_member_object_pointer : public false_type { 
#line 365
}; 
#line 367
template< class _Ty1, class _Ty2> 
#line 368
struct _Is_member_object_pointer< _Ty1 _Ty2::*>  : public _Cat_base< !_Is_memfunptr< _Ty1 _Ty2::*> ::value>  { 
#line 371
}; 
#line 373
template< class _Ty> 
#line 374
struct is_member_object_pointer : public _Is_member_object_pointer< typename remove_cv< _Ty> ::type>  { 
#line 377
}; 
#line 380
template< class _Ty> 
#line 381
struct is_member_function_pointer : public _Cat_base< _Is_memfunptr< typename remove_cv< _Ty> ::type> ::value>  { 
#line 384
}; 
#line 387
template< class _Ty> 
#line 388
struct _Is_pointer : public false_type { 
#line 391
}; 
#line 393
template< class _Ty> 
#line 394
struct _Is_pointer< _Ty *>  : public _Cat_base< (!is_member_object_pointer< _Ty *> ::value) && (!is_member_function_pointer< _Ty *> ::value)>  { 
#line 398
}; 
#line 400
template< class _Ty> 
#line 401
struct is_pointer : public _Is_pointer< typename remove_cv< _Ty> ::type>  { 
#line 404
}; 
#line 408
template< class _Ty> 
#line 409
struct _Is_nullptr_t : public _Cat_base< is_same< typename remove_cv< _Ty> ::type, std::nullptr_t> ::value>  { 
#line 412
}; 
#line 415
template< class _Ty> 
#line 416
struct is_union : public _Cat_base< __is_union(_Ty)>  { 
#line 418
}; 
#line 421
template< class _Ty> 
#line 422
struct is_class : public _Cat_base< __is_class(_Ty)>  { 
#line 424
}; 
#line 427
template< class _Ty> 
#line 428
struct is_function : public _Cat_base< _Is_funptr< typename remove_cv< _Ty> ::type *> ::value>  { 
#line 431
}; 
#line 433
template< class _Ty> 
#line 434
struct is_function< _Ty &>  : public false_type { 
#line 437
}; 
#line 439
template< class _Ty> 
#line 440
struct is_function< _Ty &&>  : public false_type { 
#line 443
}; 
#line 446
template< class _Ty> 
#line 447
struct is_arithmetic : public _Cat_base< is_integral< _Ty> ::value || is_floating_point< _Ty> ::value>  { 
#line 451
}; 
#line 454
template< class _Ty> 
#line 455
struct is_fundamental : public _Cat_base< (is_arithmetic< _Ty> ::value || is_void< _Ty> ::value) || _Is_nullptr_t< _Ty> ::value>  { 
#line 460
}; 
#line 463
template< class _Ty> 
#line 464
struct is_object : public _Cat_base< ((!is_function< _Ty> ::value) && (!is_reference< _Ty> ::value)) && (!is_void< _Ty> ::value)>  { 
#line 469
}; 
#line 473
template< class _From, class _To> 
#line 474
struct is_convertible : public _Cat_base< __is_convertible_to(_From, _To)>  { 
#line 477
}; 
#line 480
template< class _Ty> 
#line 481
struct is_enum : public _Cat_base< __is_enum(_Ty)>  { 
#line 484
}; 
#line 487
template< class _Ty> 
#line 488
struct is_compound : public _Cat_base< !is_fundamental< _Ty> ::value>  { 
#line 491
}; 
#line 494
template< class _Ty> 
#line 495
struct is_member_pointer : public _Cat_base< is_member_object_pointer< _Ty> ::value || is_member_function_pointer< _Ty> ::value>  { 
#line 499
}; 
#line 502
template< class _Ty> 
#line 503
struct is_scalar : public _Cat_base< (((is_arithmetic< _Ty> ::value || is_enum< _Ty> ::value) || is_pointer< _Ty> ::value) || is_member_pointer< _Ty> ::value) || _Is_nullptr_t< _Ty> ::value>  { 
#line 510
}; 
#line 513
template< class _Ty> 
#line 514
struct is_const : public _Cat_base< _Ptr_traits< _Ty *> ::_Is_const && (!is_function< _Ty> ::value)>  { 
#line 518
}; 
#line 520
template< class _Ty, unsigned _Nx> 
#line 521
struct is_const< _Ty [_Nx]>  : public false_type { 
#line 524
}; 
#line 526
template< class _Ty, unsigned _Nx> 
#line 527
struct is_const< const _Ty [_Nx]>  : public true_type { 
#line 530
}; 
#line 532
template< class _Ty> 
#line 533
struct is_const< _Ty &>  : public false_type { 
#line 536
}; 
#line 538
template< class _Ty> 
#line 539
struct is_const< _Ty &&>  : public false_type { 
#line 542
}; 
#line 545
template< class _Ty> 
#line 546
struct is_volatile : public _Cat_base< _Ptr_traits< _Ty *> ::_Is_volatile && (!is_function< _Ty> ::value)>  { 
#line 550
}; 
#line 552
template< class _Ty> 
#line 553
struct is_volatile< _Ty &>  : public false_type { 
#line 556
}; 
#line 558
template< class _Ty> 
#line 559
struct is_volatile< _Ty &&>  : public false_type { 
#line 562
}; 
#line 565
template< class _Ty> 
#line 566
struct is_pod : public _Cat_base< __is_pod(_Ty)>  { 
#line 568
}; 
#line 571
template< class _Ty> 
#line 572
struct is_empty : public _Cat_base< __is_empty(_Ty)>  { 
#line 574
}; 
#line 577
template< class _Ty> 
#line 578
struct is_polymorphic : public _Cat_base< __is_polymorphic(_Ty)>  { 
#line 580
}; 
#line 583
template< class _Ty> 
#line 584
struct is_abstract : public _Cat_base< __is_abstract(_Ty)>  { 
#line 586
}; 
#line 589
template< class _Ty> 
#line 590
struct is_standard_layout : public _Cat_base< __is_standard_layout(_Ty)>  { 
#line 592
}; 
#line 595
template< class _Ty> 
#line 596
struct is_literal_type : public _Cat_base< __is_literal_type(_Ty)>  { 
#line 598
}; 
#line 601
template< class _Ty> 
#line 602
struct is_trivial : public _Cat_base< __is_trivial(_Ty)>  { 
#line 604
}; 
#line 607
template< class _Ty> 
#line 608
struct has_virtual_destructor : public _Cat_base< __has_virtual_destructor(_Ty)>  { 
#line 611
}; 
#line 617
template< class _Ty, class ...
#line 618
_Args> 
#line 619
struct is_constructible : public _Cat_base< __is_constructible(_Ty, _Args...)>  { 
#line 622
}; 
#line 627
template< class _Ty> 
#line 628
struct is_copy_constructible : public is_constructible< _Ty, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 636
}; 
#line 639
template< class _Ty> 
#line 640
struct has_copy_constructor : public is_copy_constructible< _Ty> ::type { 
#line 643
}; 
#line 646
template< class _Ty> 
#line 647
struct is_default_constructible : public is_constructible< _Ty> ::type { 
#line 650
}; 
#line 653
template< class _Ty> 
#line 654
struct has_default_constructor : public is_default_constructible< _Ty> ::type { 
#line 657
}; 
#line 660
template< class _Ty> 
#line 661
struct is_move_constructible : public is_constructible< _Ty, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 669
}; 
#line 672
template< class _Ty> 
#line 673
struct has_move_constructor : public is_move_constructible< _Ty> ::type { 
#line 676
}; 
#line 680
template< class _To, class 
#line 681
_From> 
#line 682
struct _Is_assignable { 
#line 684
template< class _Dest, class 
#line 685
_Src> static auto 
#line 684
_Fn(int)->decltype(((std::declval< _Dest> () = std::declval< _Src> ()), (true_type()))); 
#line 690
template< class _Dest, class 
#line 691
_Src> static auto 
#line 690
_Fn(_Wrap_int)->false_type; 
#line 695
typedef decltype((_Fn< _To, _From> (0))) type; 
#line 696
}; 
#line 698
template< class _To, class 
#line 699
_From> 
#line 700
struct is_assignable : public _Is_assignable< _To, _From> ::type { 
#line 704
}; 
#line 708
template< class _Ty> 
#line 709
struct is_copy_assignable : public is_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 717
}; 
#line 720
template< class _Ty> 
#line 721
struct has_copy_assign : public is_copy_assignable< _Ty> ::type { 
#line 724
}; 
#line 728
template< class _Ty> 
#line 729
struct is_move_assignable : public is_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 735
}; 
#line 737
template< class _Ty> 
#line 738
struct has_move_assign : public is_move_assignable< _Ty> ::type { 
#line 741
}; 
#line 744
template< class _Ty> 
#line 745
struct is_destructible : public _Cat_base< __is_destructible(_Ty)>  { 
#line 748
}; 
#line 754
template< class _Ty, class ...
#line 755
_Args> 
#line 756
struct is_trivially_constructible : public _Cat_base< __is_trivially_constructible(_Ty, _Args...)>  { 
#line 759
}; 
#line 763
template< class _Ty> 
#line 764
struct is_trivially_copy_constructible : public is_trivially_constructible< _Ty, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 774
}; 
#line 777
template< class _Ty> 
#line 778
struct is_trivially_copyable : public is_trivially_copy_constructible< _Ty> ::type { 
#line 781
}; 
#line 784
template< class _Ty> 
#line 785
struct has_trivial_copy_constructor : public is_trivially_copy_constructible< _Ty> ::type { 
#line 788
}; 
#line 791
template< class _Ty> 
#line 792
struct is_trivially_default_constructible : public is_trivially_constructible< _Ty> ::type { 
#line 795
}; 
#line 798
template< class _Ty> 
#line 799
struct has_trivial_default_constructor : public is_trivially_default_constructible< _Ty> ::type { 
#line 802
}; 
#line 805
template< class _Ty> 
#line 806
struct is_trivially_move_constructible : public is_trivially_constructible< _Ty, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 814
}; 
#line 817
template< class _Ty> 
#line 818
struct has_trivial_move_constructor : public is_trivially_move_constructible< _Ty> ::type { 
#line 821
}; 
#line 824
template< class _To, class 
#line 825
_From> 
#line 826
struct is_trivially_assignable : public _Cat_base< __is_trivially_assignable(_To, _From)>  { 
#line 831
}; 
#line 834
template< class _Ty> 
#line 835
struct is_trivially_copy_assignable : public is_trivially_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 845
}; 
#line 848
template< class _Ty> 
#line 849
struct has_trivial_copy_assign : public is_trivially_copy_assignable< _Ty> ::type { 
#line 852
}; 
#line 855
template< class _Ty> 
#line 856
struct is_trivially_move_assignable : public is_trivially_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 864
}; 
#line 867
template< class _Ty> 
#line 868
struct has_trivial_move_assign : public is_trivially_move_assignable< _Ty> ::type { 
#line 871
}; 
#line 874
template< class _Ty> 
#line 875
struct is_trivially_destructible : public _Cat_base< __has_trivial_destructor(_Ty)>  { 
#line 878
}; 
#line 884
template< class _Ty, class ...
#line 885
_Args> 
#line 886
struct is_nothrow_constructible : public _Cat_base< __is_nothrow_constructible(_Ty, _Args...)>  { 
#line 889
}; 
#line 894
template< class _Ty> 
#line 895
struct is_nothrow_copy_constructible : public is_nothrow_constructible< _Ty, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 903
}; 
#line 906
template< class _Ty> 
#line 907
struct has_nothrow_copy_constructor : public is_nothrow_copy_constructible< _Ty> ::type { 
#line 912
}; 
#line 915
template< class _Ty> 
#line 916
struct is_nothrow_default_constructible : public is_nothrow_constructible< _Ty> ::type { 
#line 919
}; 
#line 922
template< class _Ty> 
#line 923
struct has_nothrow_default_constructor : public is_nothrow_default_constructible< _Ty> ::type { 
#line 926
}; 
#line 930
template< class _Ty> 
#line 931
struct is_nothrow_move_constructible : public is_nothrow_constructible< _Ty, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 937
}; 
#line 940
template< class _Ty> 
#line 941
struct has_nothrow_move_constructor : public is_nothrow_move_constructible< _Ty> ::type { 
#line 944
}; 
#line 947
template< class _To, class 
#line 948
_From> 
#line 949
struct is_nothrow_assignable : public _Cat_base< __is_nothrow_assignable(_To, _From)>  { 
#line 954
}; 
#line 957
template< class _Ty> 
#line 958
struct is_nothrow_copy_assignable : public is_nothrow_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_lvalue_reference< typename add_const< _Ty> ::type> ::type> ::type { 
#line 968
}; 
#line 971
template< class _Ty> 
#line 972
struct has_nothrow_copy_assign : public is_nothrow_copy_assignable< _Ty> ::type { 
#line 975
}; 
#line 978
template< class _Ty> 
#line 979
struct is_nothrow_move_assignable : public is_nothrow_assignable< typename add_lvalue_reference< _Ty> ::type, typename add_rvalue_reference< _Ty> ::type> ::type { 
#line 987
}; 
#line 990
template< class _Ty> 
#line 991
struct has_nothrow_move_assign : public is_nothrow_move_assignable< _Ty> ::type { 
#line 994
}; 
#line 997
template< class _Ty> 
#line 998
struct is_nothrow_destructible : public _Cat_base< __is_nothrow_destructible(_Ty)>  { 
#line 1003
}; 
#line 1006
template< class _Ty> 
#line 1007
struct has_trivial_constructor : public is_trivially_default_constructible< _Ty> ::type { 
#line 1012
}; 
#line 1015
template< class _Ty> 
#line 1016
struct has_trivial_copy : public is_trivially_copy_constructible< _Ty> ::type { 
#line 1021
}; 
#line 1024
template< class _Ty> 
#line 1025
struct has_trivial_assign : public is_trivially_copy_assignable< _Ty> ::type { 
#line 1030
}; 
#line 1033
template< class _Ty> 
#line 1034
struct has_trivial_destructor : public is_trivially_destructible< _Ty> ::type { 
#line 1039
}; 
#line 1042
template< class _Ty> 
#line 1043
struct has_nothrow_constructor : public is_nothrow_default_constructible< _Ty> ::type { 
#line 1048
}; 
#line 1051
template< class _Ty> 
#line 1052
struct has_nothrow_copy : public is_nothrow_copy_constructible< _Ty> ::type { 
#line 1057
}; 
#line 1060
template< class _Ty> 
#line 1061
struct has_nothrow_assign : public is_nothrow_copy_assignable< _Ty> ::type { 
#line 1066
}; 
#line 1069
template< class _Ty> 
#line 1070
struct _Has_signed_vals : public _Cat_base< (((typename remove_cv< _Ty> ::type)(-1)) < ((typename remove_cv< _Ty> ::type)0))>  { 
#line 1074
}; 
#line 1076
template< class _Ty> 
#line 1077
struct is_signed : public _Cat_base< is_floating_point< _Ty> ::value || (is_integral< _Ty> ::value && _Has_signed_vals< typename _If< is_integral< _Ty> ::value, _Ty, int> ::type> ::value)>  { 
#line 1082
}; 
#line 1085
template< class _Ty> 
#line 1086
struct is_unsigned : public _Cat_base< is_integral< _Ty> ::value && (!_Has_signed_vals< typename _If< is_integral< _Ty> ::value, _Ty, int> ::type> ::value)>  { 
#line 1091
}; 
#line 1094
template< class _Ty> 
#line 1095
struct _Change_sign { 
#line 1097
static_assert(((is_integral< _Ty> ::value || is_enum< _Ty> ::value) && (!is_same< _Ty, bool> ::value)), "make_signed<T>/make_unsigned<T> require that T shall be a (possibly cv-qualified) integral type or enumeration but not a bool ty" "pe.");
#line 1120
typedef typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type _Signed; 
#line 1129
typedef typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, signed char> ::value, unsigned char, typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, short> ::value, unsigned short, typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, int> ::value, unsigned, typename _If< is_same< typename _If< is_same< _Ty, signed char> ::value || is_same< _Ty, unsigned char> ::value, signed char, typename _If< is_same< _Ty, short> ::value || is_same< _Ty, unsigned short> ::value, short, typename _If< is_same< _Ty, int> ::value || is_same< _Ty, unsigned> ::value, int, typename _If< is_same< _Ty, long> ::value || is_same< _Ty, unsigned long> ::value, long, typename _If< is_same< _Ty, __int64> ::value || is_same< _Ty, unsigned __int64> ::value, __int64, typename _If< sizeof(_Ty) == sizeof(signed char), signed char, typename _If< sizeof(_Ty) == sizeof(short), short, typename _If< sizeof(_Ty) == sizeof(int), int, typename _If< sizeof(_Ty) == sizeof(long), long, __int64> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type> ::type, long> ::value, unsigned long, unsigned __int64> ::type> ::type> ::type> ::type _Unsigned; 
#line 1130
}; 
#line 1132
template< class _Ty> 
#line 1133
struct _Change_sign< const _Ty>  { 
#line 1135
typedef const typename std::_Change_sign< _Ty> ::_Signed _Signed; 
#line 1136
typedef const typename std::_Change_sign< _Ty> ::_Unsigned _Unsigned; 
#line 1137
}; 
#line 1139
template< class _Ty> 
#line 1140
struct _Change_sign< volatile _Ty>  { 
#line 1142
typedef volatile typename std::_Change_sign< _Ty> ::_Signed _Signed; 
#line 1143
typedef volatile typename std::_Change_sign< _Ty> ::_Unsigned _Unsigned; 
#line 1144
}; 
#line 1146
template< class _Ty> 
#line 1147
struct _Change_sign< const volatile _Ty>  { 
#line 1149
typedef const volatile typename std::_Change_sign< _Ty> ::_Signed _Signed; 
#line 1150
typedef const volatile typename std::_Change_sign< _Ty> ::_Unsigned _Unsigned; 
#line 1151
}; 
#line 1154
template< class _Ty> 
#line 1155
struct make_signed { 
#line 1157
typedef typename _Change_sign< _Ty> ::_Signed type; 
#line 1158
}; 
#line 1161
template< class _Ty> 
#line 1162
struct make_unsigned { 
#line 1164
typedef typename _Change_sign< _Ty> ::_Unsigned type; 
#line 1165
}; 
#line 1169
template< class _Ty> 
#line 1170
struct _Get_align { 
#line 1172
_Ty _Elt0; 
#line 1173
char _Elt1; 
#line 1174
_Ty _Elt2; 
#line 1176
_Get_align(); 
#line 1177
~_Get_align(); 
#line 1178
}; 
#line 1183 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\type_traits"
template< class _Ty> 
#line 1184
struct alignment_of : public integral_constant< unsigned __w64, sizeof(_Get_align< typename remove_reference< _Ty> ::type> ) - ((2) * sizeof(typename remove_reference< _Ty> ::type))>  { 
#line 1187
}; 
#line 1194
template< class _Ty, size_t 
#line 1195
_Len> 
#line 1196
union _Align_type { 
#line 1198
_Ty _Val; 
#line 1199
char _Pad[_Len]; 
#line 1200
}; 
#line 1202
template< size_t _Len, size_t 
#line 1203
_Align, class 
#line 1204
_Ty, bool 
#line 1205
_Ok> struct _Aligned; 
#line 1208
template< size_t _Len, size_t 
#line 1209
_Align, class 
#line 1210
_Ty> 
#line 1211
struct _Aligned< _Len, _Align, _Ty, true>  { 
#line 1213
typedef _Align_type< _Ty, _Len>  type; 
#line 1214
}; 
#line 1216
template< size_t _Len, size_t 
#line 1217
_Align> 
#line 1218
struct _Aligned< _Len, _Align, double, false>  { 
#line 1220
typedef _Align_type< double, _Len>  type; 
#line 1221
}; 
#line 1223
template< size_t _Len, size_t 
#line 1224
_Align> 
#line 1225
struct _Aligned< _Len, _Align, int, false>  { 
#line 1227
typedef typename std::_Aligned< _Len, _Align, double, _Align <= integral_constant< unsigned __w64, sizeof(_Get_align< double> ) - ((2) * sizeof(double))> ::value> ::type type; 
#line 1228
}; 
#line 1230
template< size_t _Len, size_t 
#line 1231
_Align> 
#line 1232
struct _Aligned< _Len, _Align, short, false>  { 
#line 1234
typedef typename std::_Aligned< _Len, _Align, int, _Align <= integral_constant< unsigned __w64, sizeof(_Get_align< int> ) - ((2) * sizeof(int))> ::value> ::type type; 
#line 1235
}; 
#line 1237
template< size_t _Len, size_t 
#line 1238
_Align> 
#line 1239
struct _Aligned< _Len, _Align, char, false>  { 
#line 1241
typedef typename std::_Aligned< _Len, _Align, short, _Align <= integral_constant< unsigned __w64, sizeof(_Get_align< short> ) - ((2) * sizeof(short))> ::value> ::type type; 
#line 1242
}; 
#line 1244
template< size_t _Len, size_t 
#line 1245
_Align = 8U> 
#line 1246
struct aligned_storage { 
#line 1248
typedef typename _Aligned< _Len, _Align, char, _Align <= integral_constant< unsigned __w64, sizeof(_Get_align< char> ) - ((2) * sizeof(char))> ::value> ::type type; 
#line 1249
}; 
#line 1255
template< size_t ..._Vals> struct _Maximum; 
#line 1259
template<> struct _Maximum< >  { 
#line 1261
static const size_t value = (0); 
#line 1262
}; 
#line 1264
template< size_t _Val> 
#line 1265
struct _Maximum< _Val>  { 
#line 1267
static const size_t value = _Val; 
#line 1268
}; 
#line 1270
template< size_t _First, size_t 
#line 1271
_Second, size_t ...
#line 1272
_Rest> 
#line 1273
struct _Maximum< _First, _Second, _Rest...>  : public _Maximum< (((_First) < _Second) ? _Second : _First), _Rest...>  { 
#line 1276
}; 
#line 1278
template< size_t _Len, class ...
#line 1279
_Types> 
#line 1280
struct aligned_union { 
#line 1282
static const size_t _Max_len = (_Maximum< _Len, sizeof(_Types)...> ::value); 
#line 1284
static const size_t alignment_value = (_Maximum< alignment_of< _Types> ::value...> ::value); 
#line 1286
typedef typename aligned_storage< _Max_len, alignment_value> ::type type; 
#line 1287
}; 
#line 1290
template< class _Ty> 
#line 1291
struct underlying_type { 
#line 1293
typedef __underlying_type(_Ty) type; 
#line 1294
}; 
#line 1297
template< class _Ty> 
#line 1298
struct rank : public integral_constant< unsigned __w64, 0U>  { 
#line 1301
}; 
#line 1303
template< class _Ty, unsigned _Ix> 
#line 1304
struct rank< _Ty [_Ix]>  : public integral_constant< unsigned __w64, rank< _Ty> ::value + 1>  { 
#line 1307
}; 
#line 1309
template< class _Ty> 
#line 1310
struct rank< _Ty []>  : public integral_constant< unsigned __w64, rank< _Ty> ::value + 1>  { 
#line 1313
}; 
#line 1316
template< class _Ty, unsigned _Nx> 
#line 1317
struct _Extent : public integral_constant< unsigned __w64, 0U>  { 
#line 1320
}; 
#line 1322
template< class _Ty, unsigned _Ix> 
#line 1323
struct _Extent< _Ty [_Ix], 0>  : public integral_constant< unsigned __w64, _Ix>  { 
#line 1326
}; 
#line 1328
template< class _Ty, unsigned _Nx, unsigned _Ix> 
#line 1329
struct _Extent< _Ty [_Ix], _Nx>  : public _Extent< _Ty, _Nx - (1)>  { 
#line 1332
}; 
#line 1334
template< class _Ty, unsigned _Nx> 
#line 1335
struct _Extent< _Ty [], _Nx>  : public _Extent< _Ty, _Nx - (1)>  { 
#line 1338
}; 
#line 1340
template< class _Ty, unsigned _Nx = 0U> 
#line 1341
struct extent : public _Extent< _Ty, _Nx>  { 
#line 1344
}; 
#line 1347
template< class _Base, class _Der> 
#line 1348
struct is_base_of : public _Cat_base< __is_base_of(_Base, _Der)>  { 
#line 1350
}; 
#line 1353
template< class _Ty> 
#line 1354
struct decay { 
#line 1356
typedef typename remove_reference< _Ty> ::type _Ty1; 
#line 1362
typedef typename _If< is_array< typename remove_reference< _Ty> ::type> ::value, typename remove_extent< typename remove_reference< _Ty> ::type> ::type *, typename _If< is_function< typename remove_reference< _Ty> ::type> ::value, typename add_pointer< typename remove_reference< _Ty> ::type> ::type, typename remove_cv< typename remove_reference< _Ty> ::type> ::type> ::type> ::type type; 
#line 1363
}; 
#line 1365
namespace tr1 { 
#line 1366
using std::add_const;
#line 1367
using std::add_cv;
#line 1368
using std::add_pointer;
#line 1369
using std::add_reference;
#line 1370
using std::add_volatile;
#line 1371
using std::aligned_storage;
#line 1372
using std::alignment_of;
#line 1373
using std::conditional;
#line 1374
using std::decay;
#line 1375
using std::enable_if;
#line 1376
using std::extent;
#line 1377
using std::false_type;
#line 1378
using std::has_nothrow_assign;
#line 1379
using std::has_nothrow_constructor;
#line 1380
using std::has_nothrow_copy;
#line 1381
using std::has_trivial_assign;
#line 1382
using std::has_trivial_constructor;
#line 1383
using std::has_trivial_copy;
#line 1384
using std::has_trivial_destructor;
#line 1385
using std::has_virtual_destructor;
#line 1386
using std::integral_constant;
#line 1387
using std::is_abstract;
#line 1388
using std::is_arithmetic;
#line 1389
using std::is_array;
#line 1390
using std::is_base_of;
#line 1391
using std::is_class;
#line 1392
using std::is_compound;
#line 1393
using std::is_const;
#line 1394
using std::is_convertible;
#line 1395
using std::is_empty;
#line 1396
using std::is_enum;
#line 1397
using std::is_floating_point;
#line 1398
using std::is_function;
#line 1399
using std::is_fundamental;
#line 1400
using std::is_integral;
#line 1401
using std::is_member_function_pointer;
#line 1402
using std::is_member_object_pointer;
#line 1403
using std::is_member_pointer;
#line 1404
using std::is_object;
#line 1405
using std::is_pod;
#line 1406
using std::is_pointer;
#line 1407
using std::is_polymorphic;
#line 1408
using std::is_reference;
#line 1409
using std::is_same;
#line 1410
using std::is_scalar;
#line 1411
using std::is_signed;
#line 1412
using std::is_union;
#line 1413
using std::is_unsigned;
#line 1414
using std::is_void;
#line 1415
using std::is_volatile;
#line 1416
using std::make_signed;
#line 1417
using std::make_unsigned;
#line 1418
using std::rank;
#line 1419
using std::remove_all_extents;
#line 1420
using std::remove_const;
#line 1421
using std::remove_cv;
#line 1422
using std::remove_extent;
#line 1423
using std::remove_pointer;
#line 1424
using std::remove_reference;
#line 1425
using std::remove_volatile;
#line 1426
using std::true_type;
#line 1427
}
#line 1430
template< class ..._Ty> struct common_type; 
#line 1433
template< class _Ty> 
#line 1434
struct common_type< _Ty>  { 
#line 1436
typedef typename decay< _Ty> ::type type; 
#line 1437
}; 
#line 1439
template< class _Ty0, class 
#line 1440
_Ty1> 
#line 1441
struct common_type< _Ty0, _Ty1>  { 
#line 1447
typedef typename decay< decltype(((_Always_false< _Ty0> ::value) ? std::declval< _Ty0> () : std::declval< _Ty1> ()))> ::type type; 
#line 1448
}; 
#line 1450
template< class _Ty0, class 
#line 1451
_Ty1, class ...
#line 1452
_Ty> 
#line 1453
struct common_type< _Ty0, _Ty1, _Ty...>  { 
#line 1457
typedef typename std::common_type< typename std::common_type< _Ty0, _Ty1> ::type, _Ty...> ::type type; 
#line 1458
}; 
#line 1461
template< size_t ..._Indexes> 
#line 1462
struct _Arg_idx { 
#line 1464
}; 
#line 1467
template < class _Ty >
 class reference_wrapper;
#line 1470
template< class _Ty> 
#line 1471
struct _Unrefwrap_helper { 
#line 1473
typedef _Ty type; 
#line 1474
}; 
#line 1476
template< class _Ty> 
#line 1477
struct _Unrefwrap_helper< reference_wrapper< _Ty> >  { 
#line 1479
typedef _Ty &type; 
#line 1480
}; 
#line 1482
template< class _Ty> 
#line 1483
struct _Unrefwrap { 
#line 1485
typedef typename decay< _Ty> ::type _Ty1; 
#line 1486
typedef typename _Unrefwrap_helper< typename decay< _Ty> ::type> ::type type; 
#line 1487
}; 
#line 1490
template < class _Ty >
 struct identity
 {
 typedef _Ty type;

 const _Ty & operator ( ) ( const _Ty & _Left ) const
  {
  return ( _Left );
  }
 };
#line 1502
template< class _Ty> inline _Ty &&
#line 1503
forward(typename remove_reference< _Ty> ::type &_Arg) 
#line 1504
{ 
#line 1505
return static_cast< _Ty &&>(_Arg); 
#line 1506
} 
#line 1508
template< class _Ty> inline _Ty &&
#line 1509
forward(typename remove_reference< _Ty> ::type &&_Arg) throw() 
#line 1510
{ 
#line 1511
static_assert((!is_lvalue_reference< _Ty> ::value), "bad forward call");
#line 1512
return static_cast< _Ty &&>(_Arg); 
#line 1513
} 
#line 1516
template< class _Ty> inline typename remove_reference< _Ty> ::type &&
#line 1518
move(_Ty &&_Arg) throw() 
#line 1519
{ 
#line 1520
return (typename remove_reference< _Ty> ::type &&)_Arg; 
#line 1521
} 
#line 1524
template < class _Ty > inline
 typename remove_reference < _Ty > :: type &&
  _Move ( _Ty && _Arg ) throw ( )
 {
 return ( ( typename remove_reference < _Ty > :: type && ) _Arg );
 }
#line 1532
template < class _Ty > inline
 typename _If < ! has_nothrow_move_constructor < _Ty > :: value
  && has_copy_constructor < _Ty > :: value,
   const _Ty &, _Ty && > :: type
 move_if_noexcept ( _Ty & _Arg ) throw ( )
 {
 return ( :: std :: move ( _Arg ) );
 }
#line 1542
template < class _Ty > inline
 typename decay < _Ty > :: type _Decay_copy ( _Ty && _Arg )
 {
 return ( :: std :: forward < _Ty > ( _Arg ) );
 }
#line 1547
}
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xrefwrap"
#pragma warning(push,3)
#line 14
#pragma warning(disable: 4180)
#line 9
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 17
template< class _Ty> class reference_wrapper; 
#line 21
template< class _Ret, class ...
#line 22
_Types> 
#line 23
struct _Fun_class_base { 
#line 25
}; 
#line 27
template< class _Ret, class 
#line 28
_Farg0> 
#line 29
struct _Fun_class_base< _Ret, _Farg0>  : public unary_function< _Farg0, _Ret>  { 
#line 32
}; 
#line 34
template< class _Ret, class 
#line 35
_Farg0, class 
#line 36
_Farg1> 
#line 37
struct _Fun_class_base< _Ret, _Farg0, _Farg1>  : public binary_function< _Farg0, _Farg1, _Ret>  { 
#line 40
}; 
#line 42
template< class _Ret, class 
#line 43
_Farg0, class 
#line 44
_Farg1, class ...
#line 45
_Types> 
#line 46
struct _Fun_class_base< _Ret, _Farg0, _Farg1, _Types...>  { 
#line 48
}; 
#line 53
template< class _Fty, class ...
#line 54
_Args> 
#line 55
struct _Result_of { 
#line 58
typedef decltype((std::declval< _Fty> ()(std::declval< _Args> ()...))) type; 
#line 59
}; 
#line 74
template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*const)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*const)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*const)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*const)(_Mfargs ...), _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*const)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*const)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*const)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*const)(_Mfargs ...) const, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*const)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*const)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*const)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*const)(_Mfargs ...) volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__thiscall _Ty::*const)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__cdecl _Ty::*const)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__stdcall _Ty::*const)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; template< class _Ret, class _Ty, class ..._Mfargs, class _Obj, class ..._Args> struct _Result_of< _Ret (__fastcall _Ty::*const)(_Mfargs ...) const volatile, _Obj, _Args...>  { typedef _Ret type; }; 
#line 77
template< class _Ret, class 
#line 78
_Ty, class 
#line 79
_Obj, class ...
#line 80
_Args> 
#line 81
struct _Result_of< _Ret _Ty::*, _Obj, _Args...>  { 
#line 86
typedef typename _Copy_cv< _Ret, typename remove_pointer< typename remove_reference< _Obj> ::type> ::type> ::type type; 
#line 87
}; 
#line 89
template< class _Ret, class 
#line 90
_Ty, class 
#line 91
_Obj, class ...
#line 92
_Args> 
#line 93
struct _Result_of< _Ret _Ty::*const, _Obj, _Args...>  { 
#line 98
typedef const typename _Copy_cv< _Ret, typename remove_pointer< typename remove_reference< _Obj> ::type> ::type> ::type type; 
#line 99
}; 
#line 101
template< class _Fty> struct result_of; 
#line 118
template< class _Fty, class ..._Args> struct result_of< _Fty __cdecl (_Args ...)>  { typedef typename _Result_of< _Fty, _Args...> ::type type; }; template< class _Fty, class ..._Args> struct result_of< reference_wrapper< _Fty>  __cdecl (_Args ...)>  { typedef typename _Result_of< _Fty, _Args...> ::type type; }; template< class _Fty, class ..._Args> struct result_of< _Fty __stdcall (_Args ...)>  { typedef typename _Result_of< _Fty, _Args...> ::type type; }; template< class _Fty, class ..._Args> struct result_of< reference_wrapper< _Fty>  __stdcall (_Args ...)>  { typedef typename _Result_of< _Fty, _Args...> ::type type; }; template< class _Fty, class ..._Args> struct result_of< _Fty __fastcall (_Args ...)>  { typedef typename _Result_of< _Fty, _Args...> ::type type; }; template< class _Fty, class ..._Args> struct result_of< reference_wrapper< _Fty>  __fastcall (_Args ...)>  { typedef typename _Result_of< _Fty, _Args...> ::type type; }; 
#line 125
template< class _Ret, class 
#line 126
_Arg0> 
#line 127
struct _Pmd_caller { 
#line 129
template < class _Pmd,
  class _Farg0 >
  static _Ret & _Call_pmd ( _Pmd _Pm, _Farg0 && _Fx0, true_type )
  {
  return ( ( _Ret & ) ( _Fx0 .* _Pm ) );
  }
#line 136
template < class _Pmd,
  class _Farg0 >
  static _Ret & _Call_pmd ( _Pmd _Pm, _Farg0 && _Fx0, false_type )
  {
  return ( ( _Ret & ) ( ( * _Fx0 ) .* _Pm ) );
  }
#line 143
template < class _Pmd,
  class _Farg0 >
  static _Ret & _Apply_pmd ( _Pmd _Pm, _Farg0 && _Fx0 )
  {
  typedef typename remove_cv <
   typename remove_reference < _Arg0 > :: type > :: type _Arg0_bare;
  typedef typename remove_cv <
   typename remove_reference < _Farg0 > :: type > :: type _Farg0_bare;
  typedef _Cat_base < is_same < _Arg0_bare, _Farg0_bare > :: value
   || ( is_base_of < _Arg0_bare, _Farg0_bare > :: value
    && is_same < typename add_reference < _Farg0_bare > :: type,
     _Farg0 > :: value ) > _Is_obj;

  return ( _Call_pmd < _Pmd, _Farg0 > ( _Pm,
   :: std :: forward < _Farg0 > ( _Fx0 ), _Is_obj ( ) ) );
  }
#line 159
}; 
#line 162
template< class _Ty, bool 
#line 163
_Indirect> struct _Callable_base; 
#line 166
template < class _Ty >
 struct _Callable_base < _Ty, false >
 {
 enum { _EEN_INDIRECT = 0 };
 typedef _Ty _MyTy;
 typedef const _Ty & _MyCnstTy;

 _Callable_base ( const _Ty & _Val )
  : _Object ( _Val )
  {
  }

 const _Ty & _Get ( ) const
  {
  return ( _Object );
  }

 _Ty & _Get ( )
  {
  return ( _Object );
  }

 void _Reset ( _Ty & _Val )
  {
  static_assert ( _Always_false < _Ty > :: value,
   "can\'t assign to reference_wrapper<T&>" );
  }

private :
 _Callable_base & operator = ( const _Callable_base & );

 _Ty _Object;
};
#line 200
template < class _Ty >
 struct _Callable_base < _Ty, true >
 {

 enum { _EEN_INDIRECT = 1 };
 typedef _Ty _MyTy;
 typedef _Ty & _MyCnstTy;

 _Callable_base ( _Ty & _Val )
  : _Ptr ( :: std :: addressof ( _Val ) )
  {
  }

 _MyCnstTy _Get ( ) const
  {
  return ( * _Ptr );
  }

 _Ty & _Get ( )
  {
  return ( * _Ptr );
  }

 void _Reset ( _Ty & _Val )
  {
  _Ptr = :: std :: addressof ( _Val );
  }

private :
 _Ty * _Ptr;
};
#line 233
template < class _Ty,
 class _Memty,
 bool _Indirect = false >
 struct _Callable_pmd
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_pmd ( const _Callable_pmd & _Right )
  : _Callable_base < _Ty, _Indirect > ( _Right . _Get ( ) )
  {
  }

 _Callable_pmd ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }

 template < class _Ret,
  class _Arg0 >
  _Ret & _ApplyX ( _Arg0 && _A0 ) const
  {
  return ( _Pmd_caller < _Ret, _Memty > ::
   _Apply_pmd ( this -> _Get ( ), :: std :: forward < _Arg0 > ( _A0 ) ) );
  }
 };
#line 259
template< class _Ty, bool 
#line 260
_Indirect = false> 
#line 261
struct _Callable_obj : public _Callable_base< _Ty, _Indirect>  { 
#line 264
typedef _Callable_base< _Ty, _Indirect>  _Mybase; 
#line 266
template < class _Ty2 >
  _Callable_obj ( _Ty2 && _Val )
  : _Mybase ( :: std :: forward < _Ty2 > ( _Val ) )
  {
  }
#line 272
template < class _Ret,
  class ... _Types >
  _Ret _ApplyX ( _Types && ... _Args ) const
  {
  return ( this -> _Get ( ) ( :: std :: forward < _Types > ( _Args ) ... ) );
  }
#line 279
template < class _Ret,
  class ... _Types >
  _Ret _ApplyX ( _Types && ... _Args )
  {
  return ( this -> _Get ( ) ( :: std :: forward < _Types > ( _Args ) ... ) );
  }
#line 286
}; 
#line 290
template< class _Ret, class 
#line 291
_Arg0> 
#line 292
struct _Pmf_caller { 
#line 294
template < class _Pmf,
  class _Farg0,
  class ... _Ftypes >
  static _Ret _Call_pmf ( _Pmf _Pm, _Farg0 && _Fx0, true_type,
   _Ftypes && ... _Fargs )
  {
  typedef typename _Copy_cv < _Arg0, _Farg0 > :: type
   _Funobj_cv;
  return ( ( ( _Funobj_cv ) _Fx0 .* _Pm ) ( :: std :: forward < _Ftypes > ( _Fargs ) ... ) );
  }
#line 305
template < class _Pmf,
  class _Farg0,
  class ... _Ftypes >
  static _Ret _Call_pmf ( _Pmf _Pm, _Farg0 && _Fx0, false_type,
   _Ftypes && ... _Fargs )
  {
  return ( ( ( * _Fx0 ) .* _Pm ) ( :: std :: forward < _Ftypes > ( _Fargs ) ... ) );
  }
#line 314
template < class _Pmf,
  class _Farg0,
  class ... _Ftypes >
  static _Ret _Apply_pmf ( _Pmf _Pm, _Farg0 && _Fx0,
   _Ftypes && ... _Fargs )
  {
  typedef typename remove_reference < _Arg0 > :: type _Arg0_bare0;
  typedef typename remove_cv < _Arg0_bare0 > :: type _Arg0_bare;
  typedef typename remove_reference < _Farg0 > :: type _Farg0_bare;
  typedef _Cat_base < is_same < _Arg0_bare, _Farg0_bare > :: value
   || ( is_base_of < _Arg0_bare, _Farg0_bare > :: value
    && is_same < typename add_reference < _Farg0_bare > :: type,
     _Farg0 > :: value ) > _Is_obj;

  return ( _Call_pmf < _Pmf, _Farg0 &&, _Ftypes && ... > ( _Pm,
   :: std :: forward < _Farg0 > ( _Fx0 ), _Is_obj ( ),
    :: std :: forward < _Ftypes > ( _Fargs ) ... ) );
  }
#line 332
}; 
#line 336
template < class _Ty,
 class _Memty,
 bool _Indirect = false >
 struct _Callable_pmf
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_pmf ( const _Callable_pmf & _Right )
  : _Callable_base < _Ty, _Indirect > ( _Right . _Get ( ) )
  {
  }

 _Callable_pmf ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }

 template < class _Ret,
  class ... _Types >
  _Ret _ApplyX ( _Types && ... _Args ) const
  {
  return ( _Pmf_caller < _Ret, _Memty > ::
   _Apply_pmf ( this -> _Get ( ), :: std :: forward < _Types > ( _Args ) ... ) );
  }

 };
#line 363
template < class _Ty,
 bool _Indirect = false >
 struct _Callable_fun
  : _Callable_base < _Ty, _Indirect >
 {
 _Callable_fun ( const _Callable_fun & _Right )
  : _Callable_base < _Ty, _Indirect > ( _Right . _Get ( ) )
  {
  }

 _Callable_fun ( _Ty & _Val )
  : _Callable_base < _Ty, _Indirect > ( _Val )
  {
  }

 template < class _Ret,
  class ... _Types >
  _Ret _ApplyX ( _Types && ... _Args ) const
  {
  return ( this -> _Get ( ) ( :: std :: forward < _Types > ( _Args ) ... ) );
  }

 };
#line 388
template < class _Callable >
 struct _Call_wrapper_base
 {
 typedef typename _Callable :: _MyTy _MyTy;
 typedef typename _Callable :: _MyCnstTy _MyCnstTy;

 _Call_wrapper_base ( _MyTy & _Val )
  : _Callee ( _Val )
  {
  }

 void _Reset ( _MyTy & _Val )
  {
  _Callee . _Reset ( _Val );
  }

 _MyCnstTy _Get ( ) const
  {
  return ( _Callee . _Get ( ) );
  }

 _MyCnstTy _Get ( )
  {
  return ( _Callee . _Get ( ) );
  }

 _Callable _Callee;
 };
#line 418
template < class _Callable,
 bool _Is_abstract = false >
 struct _Call_wrapper
 : _Call_wrapper_base < _Callable >
 {
 typedef _Call_wrapper_base < _Callable > _Mybase;

 _Call_wrapper ( typename _Call_wrapper_base < _Callable > :: _MyTy & _Val )
  : _Call_wrapper_base < _Callable > ( _Val )
  {
  }

 template < class ... _Types >
  typename result_of <
   typename _Callable :: _MyTy ( _Types ... ) > :: type
   operator ( ) ( _Types && ... _Args ) const
  {
  typedef typename result_of <
   typename _Callable :: _MyTy ( _Types ... ) > :: type _Ret;
  return ( this -> _Callee . template _ApplyX < _Ret > (
   :: std :: forward < _Types > ( _Args ) ... ) );
  }

 };
#line 443
template < class _Callable >
 struct _Call_wrapper < _Callable, true >
 : _Call_wrapper_base < _Callable >
 {
 typedef _Call_wrapper_base < _Callable > _Mybase;

 _Call_wrapper ( typename _Call_wrapper_base < _Callable > :: _MyTy & _Val )
  : _Call_wrapper_base < _Callable > ( _Val )
  {
  }
 };
#line 456
template< class _Ty> 
#line 457
struct _Has_result_and_arg_type { 
#line 458
template< class _Uty> static auto _Fn(int, _Identity< typename _Uty::argument_type>  * = 0, _Identity< typename _Uty::result_type>  * = 0, _Identity< typename _Uty::result_type>  * = 0)->true_type; template< class _Uty> static auto _Fn(_Wrap_int)->false_type; typedef decltype((_Fn< _Ty> (0))) type; }; 
#line 461
template< class _Ty> 
#line 462
struct _Has_result_and_2arg_type { 
#line 463
template< class _Uty> static auto _Fn(int, _Identity< typename _Uty::first_argument_type>  * = 0, _Identity< typename _Uty::second_argument_type>  * = 0, _Identity< typename _Uty::result_type>  * = 0)->true_type; template< class _Uty> static auto _Fn(_Wrap_int)->false_type; typedef decltype((_Fn< _Ty> (0))) type; }; 
#line 466
template< class _Ty, bool 
#line 467
> 
#line 468
struct _Refwrap_result0 { 
#line 470
typedef typename _Ty::result_type result_type; 
#line 471
}; 
#line 473
template< class _Ty> 
#line 474
struct _Refwrap_result0< _Ty, false>  { 
#line 476
}; 
#line 479
template< class _Ty, bool 
#line 480
> 
#line 481
struct _Refwrap_result1_helper : public _Refwrap_result0< _Ty, _Has_result_type< _Ty> ::type::value>  { 
#line 484
}; 
#line 486
template< class _Ty> 
#line 487
struct _Refwrap_result1_helper< _Ty, true>  : public unary_function< typename _Ty::argument_type, typename _Ty::result_type>  { 
#line 491
}; 
#line 494
template< class _Ty, bool 
#line 495
> 
#line 496
struct _Refwrap_result1 : public _Refwrap_result0< _Ty, _Has_result_type< _Ty> ::type::value>  { 
#line 499
}; 
#line 501
template< class _Ty> 
#line 502
struct _Refwrap_result1< _Ty, true>  : public _Refwrap_result1_helper< _Ty, is_base_of< unary_function< typename _Ty::argument_type, typename _Ty::result_type> , _Ty> ::value>  { 
#line 508
}; 
#line 511
template< class _Ty, bool 
#line 512
> 
#line 513
struct _Refwrap_result2_helper : public _Refwrap_result1< _Ty, _Has_result_and_arg_type< _Ty> ::type::value>  { 
#line 516
}; 
#line 518
template< class _Ty> 
#line 519
struct _Refwrap_result2_helper< _Ty, true>  : public binary_function< typename _Ty::first_argument_type, typename _Ty::second_argument_type, typename _Ty::result_type> , public _Refwrap_result1< _Ty, _Has_result_and_arg_type< _Ty> ::type::value>  { 
#line 525
}; 
#line 528
template< class _Ty, bool 
#line 529
> 
#line 530
struct _Refwrap_result2 : public _Refwrap_result1< _Ty, _Has_result_and_arg_type< _Ty> ::type::value>  { 
#line 533
}; 
#line 535
template< class _Ty> 
#line 536
struct _Refwrap_result2< _Ty, true>  : public _Refwrap_result2_helper< _Ty, is_base_of< binary_function< typename _Ty::first_argument_type, typename _Ty::second_argument_type, typename _Ty::result_type> , _Ty> ::value>  { 
#line 543
}; 
#line 546
template < class _Ty >
 struct _Refwrap_impl
  : _Call_wrapper < _Callable_obj < _Ty, true >,
   is_abstract < _Ty > :: value >,
   _Refwrap_result2 < _Ty, _Has_result_and_2arg_type < _Ty > :: type :: value >
 {
 _Refwrap_impl ( _Ty & _Val )
  : _Call_wrapper < _Callable_obj < _Ty, true >,
   is_abstract < _Ty > :: value > ( _Val )
  {
  }
 };
#line 559
template < class _Rx,
 class _Arg0 >
 struct _Refwrap_impl < _Rx _Arg0 :: * >
  : _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: *, _Arg0, false > >
 {
 typedef _Rx _Arg0 :: * _Fty;
 typedef _Rx result_type;

 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmd < _Fty, _Arg0, false > > ( _Val )
  {
  }
 };
#line 573
template < class _Rx,
 class _Arg0 >
 struct _Refwrap_impl < _Rx _Arg0 :: * const >
  : _Call_wrapper < _Callable_pmd < _Rx _Arg0 :: * const, _Arg0, false > >
 {
 typedef _Rx _Arg0 :: * const _Fty;
 typedef _Rx result_type;
 _Refwrap_impl ( _Fty & _Val )
  : _Call_wrapper < _Callable_pmd < _Fty, _Arg0, false > > ( _Val )
  {
  }
 };
#line 603
template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx __cdecl ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __cdecl * ) ( _Types ... ), false > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __cdecl * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty _Val ) : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx __stdcall ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __stdcall * ) ( _Types ... ), false > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __stdcall * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty _Val ) : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx __fastcall ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __fastcall * ) ( _Types ... ), false > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __fastcall * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty _Val ) : _Call_wrapper < _Callable_fun < _Fty, false > > ( _Val ) { } };
#line 623
template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl * ) ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __cdecl * ) ( _Types ... ), true > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __cdecl * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall * ) ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __stdcall * ) ( _Types ... ), true > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __stdcall * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall * ) ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __fastcall * ) ( _Types ... ), true > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __fastcall * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl * const ) ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __cdecl * const ) ( _Types ... ), true > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __cdecl * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall * const ) ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __stdcall * const ) ( _Types ... ), true > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __stdcall * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val ) { } };template < class _Rx, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall * const ) ( _Types ... ) > : _Call_wrapper < _Callable_fun < _Rx ( __fastcall * const ) ( _Types ... ), true > >, _Fun_class_base < _Rx, _Types ... > { typedef _Rx ( __fastcall * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_fun < _Fty, true > > ( _Val ) { } };
#line 645
template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ), _Arg0, true > >, _Fun_class_base < _Rx, _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * const _Fty ) ( _Types ... ); typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * const _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * const _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) const > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) const, _Arg0, true > >, _Fun_class_base < _Rx, const _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * const _Fty ) ( _Types ... ) const; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * const _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * const _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) volatile, _Arg0, true > >, _Fun_class_base < _Rx, volatile _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * const _Fty ) ( _Types ... ) volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __thiscall _Arg0 :: * const ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __thiscall _Arg0 :: * const _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __cdecl _Arg0 :: * const ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __cdecl _Arg0 :: * const _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __stdcall _Arg0 :: * const ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __stdcall _Arg0 :: * const _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };template < class _Rx, class _Arg0, class ... _Types > struct _Refwrap_impl < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) const volatile > : _Call_wrapper < _Callable_pmf < _Rx ( __fastcall _Arg0 :: * const ) ( _Types ... ) const volatile, _Arg0, true > >, _Fun_class_base < _Rx, const volatile _Arg0 *, _Types ... > { typedef _Rx ( __fastcall _Arg0 :: * const _Fty ) ( _Types ... ) const volatile; typedef _Rx result_type; _Refwrap_impl ( _Fty & _Val ) : _Call_wrapper < _Callable_pmf < _Fty, _Arg0, true > > ( _Val ) { } };
#line 650
template < class _Ty >
 class reference_wrapper
 : public _Refwrap_impl < _Ty >
 {
public :
 typedef reference_wrapper < _Ty > _Myt;
 typedef _Refwrap_impl < _Ty > _Mybase;
 typedef _Ty type;

 reference_wrapper ( _Ty & _Val ) throw ( )
  : _Mybase ( _Val )
  {
  }

 reference_wrapper ( const _Myt & _Right ) throw ( )
  : _Mybase ( _Right . get ( ) )
  {
  }

 _Myt & operator = ( const _Myt & _Right ) throw ( )
  {
  this -> _Reset ( _Right . get ( ) );
  return ( * this );
  }

 operator _Ty & ( ) const throw ( )
  {
  return ( this -> _Get ( ) );
  }

 _Ty & get ( ) const throw ( )
  {
  return ( this -> _Get ( ) );
  }

 reference_wrapper ( _Ty && ) = delete;
 };
#line 689
template < class _Ty >
 reference_wrapper < _Ty >
  ref ( _Ty & _Val ) throw ( )
 {
 return ( reference_wrapper < _Ty > ( _Val ) );
 }
#line 696
template < class _Ty >
 void ref ( const _Ty && ) = delete;
#line 699
template < class _Ty >
 reference_wrapper < _Ty >
  ref ( reference_wrapper < _Ty > _Val ) throw ( )
 {
 return ( _Val );
 }
#line 706
template < class _Ty >
 reference_wrapper < const _Ty >
  cref ( const _Ty & _Val ) throw ( )
 {
 return ( reference_wrapper < const _Ty > ( _Val ) );
 }
#line 713
template < class _Ty >
 void cref ( const _Ty && ) = delete;
#line 716
template < class _Ty >
 reference_wrapper < const _Ty >
  cref ( reference_wrapper < _Ty > _Val ) throw ( )
 {
 return ( reference_wrapper < const _Ty > ( _Val . get ( ) ) );
 }
#line 723
namespace tr1 { 
#line 724
using std::cref;
#line 725
using std::ref;
#line 726
using std::reference_wrapper;
#line 727
using std::result_of;
#line 728
}
#line 729
}
#line 732
#pragma warning(pop)
#pragma pack ( pop )
#line 1551 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\type_traits"
namespace std { 
#line 1553
template< class _Ty> using remove_const_t = typename remove_const< _Ty> ::type; 
#line 1556
template< class _Ty> using remove_volatile_t = typename remove_volatile< _Ty> ::type; 
#line 1559
template< class _Ty> using remove_cv_t = typename remove_cv< _Ty> ::type; 
#line 1562
template< class _Ty> using add_const_t = typename add_const< _Ty> ::type; 
#line 1565
template< class _Ty> using add_volatile_t = typename add_volatile< _Ty> ::type; 
#line 1568
template< class _Ty> using add_cv_t = typename add_cv< _Ty> ::type; 
#line 1571
template< class _Ty> using remove_reference_t = typename remove_reference< _Ty> ::type; 
#line 1574
template< class _Ty> using add_lvalue_reference_t = typename add_lvalue_reference< _Ty> ::type; 
#line 1577
template< class _Ty> using add_rvalue_reference_t = typename add_rvalue_reference< _Ty> ::type; 
#line 1580
template< class _Ty> using make_signed_t = typename make_signed< _Ty> ::type; 
#line 1583
template< class _Ty> using make_unsigned_t = typename make_unsigned< _Ty> ::type; 
#line 1586
template< class _Ty> using remove_extent_t = typename remove_extent< _Ty> ::type; 
#line 1589
template< class _Ty> using remove_all_extents_t = typename remove_all_extents< _Ty> ::type; 
#line 1592
template< class _Ty> using remove_pointer_t = typename remove_pointer< _Ty> ::type; 
#line 1595
template< class _Ty> using add_pointer_t = typename add_pointer< _Ty> ::type; 
#line 1598
template< size_t _Len, size_t 
#line 1599
_Align = 8U> using aligned_storage_t = typename aligned_storage< _Len, _Align> ::type; 
#line 1602
template< size_t _Len, class ...
#line 1603
_Types> using aligned_union_t = typename aligned_union< _Len, _Types...> ::type; 
#line 1606
template< class _Ty> using decay_t = typename decay< _Ty> ::type; 
#line 1609
template< bool _Test, class 
#line 1610
_Ty = void> using enable_if_t = typename enable_if< _Test, _Ty> ::type; 
#line 1613
template< bool _Test, class 
#line 1614
_Ty1, class 
#line 1615
_Ty2> using conditional_t = typename conditional< _Test, _Ty1, _Ty2> ::type; 
#line 1618
template< class ..._Ty> using common_type_t = typename common_type< _Ty...> ::type; 
#line 1621
template< class _Ty> using underlying_type_t = typename underlying_type< _Ty> ::type; 
#line 1624
template< class _Ty> using result_of_t = typename result_of< _Ty> ::type; 
#line 1626
}
#line 1629
#pragma warning(pop)
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\utility"
#pragma warning(push,3)
#line 15
#pragma warning(disable: 4180 4512)
#line 1630 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\type_traits"
#pragma pack ( pop )
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\utility"
#pragma pack ( push, 8 )
#line 17
namespace std { 
#line 19
template < class _Ty > inline
 void swap ( _Ty &, _Ty & );
#line 24 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\utility"
template < class _FwdIt1,
 class _FwdIt2 > inline
 void iter_swap ( _FwdIt1 _Left, _FwdIt2 _Right )
 {
 swap ( * _Left, * _Right );
 }
#line 32
template < class _Ty,
 size_t _Size > inline
 void swap ( _Ty ( & _Left ) [ _Size ], _Ty ( & _Right ) [ _Size ] )

 {
 if ( & _Left != & _Right )
  {
  _Ty * _First1 = _Left;
  _Ty * _Last1 = _First1 + _Size;
  _Ty * _First2 = _Right;
  for (; _First1 != _Last1; ++ _First1, ++ _First2 )
   :: std :: iter_swap ( _First1, _First2 );
  }
 }
#line 47
template < class _Ty > inline
 void swap ( _Ty & _Left, _Ty & _Right )


 {
 _Ty _Tmp = _Move ( _Left );
 _Left = _Move ( _Right );
 _Right = _Move ( _Tmp );
 }
#line 58 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\utility"
template < class _Ty > inline
 void _Swap_adl ( _Ty & _Left, _Ty & _Right )
 {
 swap ( _Left, _Right );
 }
#line 65
struct piecewise_construct_t { 
#line 67
}; 
#line 69
const piecewise_construct_t piecewise_construct = piecewise_construct_t(); 
#line 74
template< class ...> class tuple; 
#line 78
template < class _Ty1,
 class _Ty2 >
 struct pair
 {
 typedef pair < _Ty1, _Ty2 > _Myt;
 typedef _Ty1 first_type;
 typedef _Ty2 second_type;

 pair ( )
  : first ( ), second ( )
  {
  }

 pair ( const _Ty1 & _Val1, const _Ty2 & _Val2 )
  : first ( _Val1 ), second ( _Val2 )
  {
  }

 template < class _Other1,
  class _Other2,
  class = typename enable_if < is_convertible < const _Other1 &, _Ty1 > :: value
   && is_convertible < const _Other2 &, _Ty2 > :: value,
   void > :: type >
  pair ( const pair < _Other1, _Other2 > & _Right )
  : first ( _Right . first ), second ( _Right . second )
  {
  }

 template < class _Other1,
  class _Other2 >
  _Myt & operator = ( const pair < _Other1, _Other2 > & _Right )
  {
  first = _Right . first;
  second = _Right . second;
  return ( * this );
  }


 template < class _Tuple1,
  class _Tuple2,
  size_t ... _Indexes1,
  size_t ... _Indexes2 > inline
  pair ( _Tuple1 & _Val1,
   _Tuple2 & _Val2,
   _Arg_idx < _Indexes1 ... >,
   _Arg_idx < _Indexes2 ... > );

 template < class ... _Types1,
  class ... _Types2 > inline
  pair ( piecewise_construct_t,
   tuple < _Types1 ... > _Val1,
   tuple < _Types2 ... > _Val2 )
   ;



 template < class _Other1,
  class _Other2,
  class = typename enable_if < is_convertible < _Other1, _Ty1 > :: value
   && is_convertible < _Other2, _Ty2 > :: value,
   void > :: type >
  pair ( _Other1 && _Val1, _Other2 && _Val2 )


  : first ( :: std :: forward < _Other1 > ( _Val1 ) ),
    second ( :: std :: forward < _Other2 > ( _Val2 ) )
  {
  }

 template < class _Other1,
  class _Other2,
  class = typename enable_if < is_convertible < _Other1, _Ty1 > :: value
   && is_convertible < _Other2, _Ty2 > :: value,
   void > :: type >
  pair ( pair < _Other1, _Other2 > && _Right )


  : first ( :: std :: forward < _Other1 > ( _Right . first ) ),
   second ( :: std :: forward < _Other2 > ( _Right . second ) )
  {
  }

 template < class _Other1,
  class _Other2 >
  _Myt & operator = ( pair < _Other1, _Other2 > && _Right )


  {
  first = :: std :: forward < _Other1 > ( _Right . first );
  second = :: std :: forward < _Other2 > ( _Right . second );
  return ( * this );
  }

 _Myt & operator = ( _Myt && _Right )


  {
  first = :: std :: forward < _Ty1 > ( _Right . first );
  second = :: std :: forward < _Ty2 > ( _Right . second );
  return ( * this );
  }

 void swap ( _Myt & _Right )


  {
  if ( this != & _Right )
   {
   _Swap_adl ( first, _Right . first );
   _Swap_adl ( second, _Right . second );
   }
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  first = _Right . first;
  second = _Right . second;
  return ( * this );
  }

 _Ty1 first;
 _Ty2 second;
 };
#line 204 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\utility"
template < class _Ty1,
 class _Ty2 > inline
 void swap ( pair < _Ty1, _Ty2 > & _Left, pair < _Ty1, _Ty2 > & _Right )

 {
 _Left . swap ( _Right );
 }
#line 212
template < class _Ty1,
 class _Ty2 > inline
 bool operator == ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first == _Right . first && _Left . second == _Right . second );
 }
#line 220
template < class _Ty1,
 class _Ty2 > inline
 bool operator != ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 228
template < class _Ty1,
 class _Ty2 > inline
 bool operator < ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Left . first < _Right . first ||
  ( ! ( _Right . first < _Left . first ) && _Left . second < _Right . second ) );
 }
#line 237
template < class _Ty1,
 class _Ty2 > inline
 bool operator > ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 245
template < class _Ty1,
 class _Ty2 > inline
 bool operator <= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 253
template < class _Ty1,
 class _Ty2 > inline
 bool operator >= ( const pair < _Ty1, _Ty2 > & _Left,
  const pair < _Ty1, _Ty2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 263
template < class _Ty1,
 class _Ty2 > inline
 pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type >
  make_pair ( _Ty1 && _Val1, _Ty2 && _Val2 )
 {
 typedef pair < typename _Unrefwrap < _Ty1 > :: type,
  typename _Unrefwrap < _Ty2 > :: type > _Mypair;
 return ( _Mypair ( :: std :: forward < _Ty1 > ( _Val1 ),
  :: std :: forward < _Ty2 > ( _Val2 ) ) );
 }
#line 276
namespace rel_ops { 
#line 278
template < class _Ty > inline
 bool operator != ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 284
template < class _Ty > inline
 bool operator > ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( _Right < _Left );
 }
#line 290
template < class _Ty > inline
 bool operator <= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 296
template < class _Ty > inline
 bool operator >= ( const _Ty & _Left, const _Ty & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 301
}
#line 302
}
#line 304
namespace std { 
#line 306
template< class _Tuple> 
#line 307
struct tuple_size { 
#line 309
static_assert((_Always_false< _Tuple> ::value), "The C++ Standard doesn\'t define tuple_size for this type.");
#line 311
}; 
#line 313
template< class _Ty1, class 
#line 314
_Ty2> 
#line 315
struct tuple_size< pair< _Ty1, _Ty2> >  : public integral_constant< unsigned __w64, 2U>  { 
#line 318
}; 
#line 320
template< class ..._Types> 
#line 321
struct tuple_size< tuple< _Types...> >  : public integral_constant< unsigned __w64, sizeof...(_Types)>  { 
#line 324
}; 
#line 327
template< class _Tuple> 
#line 328
struct tuple_size< const _Tuple>  : public tuple_size< _Tuple>  { 
#line 331
}; 
#line 333
template< class _Tuple> 
#line 334
struct tuple_size< volatile _Tuple>  : public tuple_size< _Tuple>  { 
#line 337
}; 
#line 339
template< class _Tuple> 
#line 340
struct tuple_size< const volatile _Tuple>  : public tuple_size< _Tuple>  { 
#line 343
}; 
#line 346
template< size_t _Idx, class 
#line 347
_Tuple> struct tuple_element; 
#line 350
template< int _Idx, class 
#line 351
_Ty> struct _Pair_data; 
#line 354
template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 0, pair < _Ty1, _Ty2 > >
 {
 typedef typename add_lvalue_reference < const _Ty1 > :: type _Ctype;
 typedef typename add_lvalue_reference < _Ty1 > :: type _Rtype;
 typedef typename add_rvalue_reference < _Ty1 > :: type _RRtype;

 static _Rtype _Val ( pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }

 static _Ctype _Val ( const pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . first );
  }

 static _RRtype _Val ( pair < _Ty1, _Ty2 > && _Pr )
  {
  return ( :: std :: forward < _Ty1 > ( _Pr . first ) );
  }
 };
#line 378
template < class _Ty1,
 class _Ty2 >
 struct _Pair_data < 1, pair < _Ty1, _Ty2 > >
 {
 typedef typename add_lvalue_reference < const _Ty2 > :: type _Ctype;
 typedef typename add_lvalue_reference < _Ty2 > :: type _Rtype;
 typedef typename add_rvalue_reference < _Ty2 > :: type _RRtype;

 static _Rtype _Val ( pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }

 static _Ctype _Val ( const pair < _Ty1, _Ty2 > & _Pr )
  {
  return ( _Pr . second );
  }

 static _RRtype _Val ( pair < _Ty1, _Ty2 > && _Pr )
  {
  return ( :: std :: forward < _Ty2 > ( _Pr . second ) );
  }
 };
#line 402
template< class _Ty1, class 
#line 403
_Ty2> 
#line 404
struct tuple_element< 0, pair< _Ty1, _Ty2> >  { 
#line 406
typedef _Ty1 type; 
#line 407
}; 
#line 409
template< class _Ty1, class 
#line 410
_Ty2> 
#line 411
struct tuple_element< 1, pair< _Ty1, _Ty2> >  { 
#line 413
typedef _Ty2 type; 
#line 414
}; 
#line 416
template < int _Idx,
 class _Ty1,
 class _Ty2 > inline
 typename _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _Rtype
  get ( pair < _Ty1, _Ty2 > & _Pr ) throw ( )
 {
 return ( _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }
#line 425
template < int _Idx,
 class _Ty1,
 class _Ty2 > inline
 typename _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _Ctype
  get ( const pair < _Ty1, _Ty2 > & _Pr ) throw ( )
 {
 return ( _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) );
 }
#line 434
template < int _Idx,
 class _Ty1,
 class _Ty2 > inline
 typename _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _RRtype
  get ( pair < _Ty1, _Ty2 > && _Pr ) throw ( )
 {
 typedef typename _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _RRtype
  _RRtype;
 return ( :: std :: forward < _RRtype > (
  _Pair_data < _Idx, pair < _Ty1, _Ty2 > > :: _Val ( _Pr ) ) );
 }
#line 445
}
#line 447
namespace std { 
#line 448
namespace tr1 { 
#line 449
using std::get;
#line 450
using std::tuple_element;
#line 451
using std::tuple_size;
#line 452
}
#line 453
}
#line 456
#pragma warning(pop)
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
#pragma warning(push,3)
#line 457 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\utility"
#pragma pack ( pop )
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 36 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
struct _Container_proxy; 
#line 37
struct _Container_base12; 
#line 38
struct _Iterator_base12; 
#line 40
struct __declspec(dllimport) _Container_base0 { 
#line 42
void _Orphan_all() 
#line 43
{ 
#line 44
} 
#line 46
void _Swap_all(_Container_base0 &) 
#line 47
{ 
#line 48
} 
#line 49
}; 
#line 51
struct _Iterator_base0 { 
#line 53
void _Adopt(const void *) 
#line 54
{ 
#line 55
} 
#line 57
const _Container_base0 *_Getcont() const 
#line 58
{ 
#line 59
return 0; 
#line 60
} 
#line 61
}; 
#line 64
struct _Container_proxy { 
#line 66
_Container_proxy() : _Mycont((0)), _Myfirstiter((0)) 
#line 68
{ 
#line 69
} 
#line 71
const _Container_base12 *_Mycont; 
#line 72
_Iterator_base12 *_Myfirstiter; 
#line 73
}; 
#line 75
struct __declspec(dllimport) _Container_base12 { 
#line 78
_Container_base12() : _Myproxy((0)) 
#line 80
{ 
#line 81
} 
#line 83
_Container_base12(const _Container_base12 &) : _Myproxy((0)) 
#line 85
{ 
#line 86
} 
#line 88
_Container_base12 &operator=(const _Container_base12 &) 
#line 89
{ 
#line 90
return *this; 
#line 91
} 
#line 93
~_Container_base12() throw() 
#line 94
{ 
#line 95
this->_Orphan_all(); 
#line 96
} 
#line 98
_Iterator_base12 **_Getpfirst() const 
#line 99
{ 
#line 100
return ((_Myproxy) == (0)) ? 0 : (&((_Myproxy)->_Myfirstiter)); 
#line 101
} 
#line 103
inline void _Orphan_all(); 
#line 104
inline void _Swap_all(_Container_base12 &); 
#line 106
_Container_proxy *_Myproxy; 
#line 107
}; 
#line 109
struct _Iterator_base12 { 
#line 112
_Iterator_base12() : _Myproxy((0)), _Mynextiter((0)) 
#line 114
{ 
#line 115
} 
#line 117
_Iterator_base12(const _Iterator_base12 &_Right) : _Myproxy((0)), _Mynextiter((0)) 
#line 119
{ 
#line 120
((*this) = _Right); 
#line 121
} 
#line 123
_Iterator_base12 &operator=(const _Iterator_base12 &_Right) 
#line 124
{ 
#line 125
if ((_Myproxy) == (_Right._Myproxy)) { 
#line 126
; } else { 
#line 127
if ((_Right._Myproxy) != (0)) { 
#line 128
this->_Adopt((_Right._Myproxy)->_Mycont); } else 
#line 130
{ 
#line 135 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
}  }  
#line 136
return *this; 
#line 137
} 
#line 139
~_Iterator_base12() throw() 
#line 140
{ 
#line 145 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
} 
#line 147
void _Adopt(const _Container_base12 *_Parent) 
#line 148
{ 
#line 149
if (_Parent == (0)) 
#line 150
{ 
#line 155 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
} else 
#line 157
{ 
#line 158
_Container_proxy *_Parent_proxy = _Parent->_Myproxy; 
#line 171 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
(_Myproxy) = _Parent_proxy; 
#line 173 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
}  
#line 174
} 
#line 176
void _Clrcont() 
#line 177
{ 
#line 178
(_Myproxy) = (0); 
#line 179
} 
#line 181
const _Container_base12 *_Getcont() const 
#line 182
{ 
#line 183
return ((_Myproxy) == (0)) ? 0 : ((_Myproxy)->_Mycont); 
#line 184
} 
#line 186
_Iterator_base12 **_Getpnext() 
#line 187
{ 
#line 188
return &(_Mynextiter); 
#line 189
} 
#line 191
void _Orphan_me() 
#line 192
{ 
#line 206 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
} 
#line 208
_Container_proxy *_Myproxy; 
#line 209
_Iterator_base12 *_Mynextiter; 
#line 210
}; 
#line 213
inline void _Container_base12::_Orphan_all() 
#line 214
{ 
#line 226 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
} 
#line 228
inline void _Container_base12::_Swap_all(_Container_base12 &_Right) 
#line 229
{ 
#line 234 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
_Container_proxy *_Temp = _Myproxy; 
#line 235
(_Myproxy) = (_Right._Myproxy); 
#line 236
(_Right._Myproxy) = _Temp; 
#line 238
if ((_Myproxy) != (0)) { 
#line 239
((_Myproxy)->_Mycont) = ((_Container_base12 *)this); }  
#line 240
if ((_Right._Myproxy) != (0)) { 
#line 241
((_Right._Myproxy)->_Mycont) = ((_Container_base12 *)(&_Right)); }  
#line 242
} 
#line 245
typedef _Container_base0 _Container_base; 
#line 246
typedef _Iterator_base0 _Iterator_base; 
#line 260 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template< class _Ty> 
#line 261
struct _Get_unchecked_type { 
#line 262
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::_Unchecked_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< _Ty> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 266 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template< class _Ty> 
#line 267
struct _Is_checked_helper { 
#line 268
template< class _Uty> static auto _Fn(int, _Identity< typename _Uty::_Unchecked_type>  * = 0, _Identity< typename _Uty::_Unchecked_type>  * = 0, _Identity< typename _Uty::_Unchecked_type>  * = 0)->true_type; template< class _Uty> static auto _Fn(_Wrap_int)->false_type; typedef decltype((_Fn< _Ty> (0))) type; }; 
#line 271
template < class _Iter > inline
 typename _Is_checked_helper < _Iter > :: type _Is_checked ( _Iter )
 {
 return ( typename _Is_checked_helper < _Iter > :: type ( ) );
 }
#line 278
template < class _Iter > inline
 _Iter _Unchecked ( _Iter _Src )
 {
 return ( _Src );
 }
#line 285
template < class _Iter,
 class _UIter > inline
 _Iter & _Rechecked ( _Iter & _Dest, _UIter _Src )
 {
 _Dest = _Src;
 return ( _Dest );
 }
#line 295
struct input_iterator_tag { 
#line 297
}; 
#line 299
struct _Mutable_iterator_tag { 
#line 301
}; 
#line 303
struct output_iterator_tag : public _Mutable_iterator_tag { 
#line 306
}; 
#line 308
struct forward_iterator_tag : public input_iterator_tag, public _Mutable_iterator_tag { 
#line 311
}; 
#line 313
struct bidirectional_iterator_tag : public forward_iterator_tag { 
#line 316
}; 
#line 318
struct random_access_iterator_tag : public bidirectional_iterator_tag { 
#line 321
}; 
#line 324
struct _Nonscalar_ptr_iterator_tag { 
#line 326
}; 
#line 327
struct _Scalar_ptr_iterator_tag { 
#line 329
}; 
#line 332
template< class _Category, class 
#line 333
_Ty, class 
#line 334
_Diff = ptrdiff_t, class 
#line 335
_Pointer = _Ty *, class 
#line 336
_Reference = _Ty &> 
#line 337
struct iterator { 
#line 339
typedef _Category iterator_category; 
#line 340
typedef _Ty value_type; 
#line 341
typedef _Diff difference_type; 
#line 342
typedef _Diff distance_type; 
#line 343
typedef _Pointer pointer; 
#line 344
typedef _Reference reference; 
#line 345
}; 
#line 347
template< class _Category, class 
#line 348
_Ty, class 
#line 349
_Diff, class 
#line 350
_Pointer, class 
#line 351
_Reference, class 
#line 352
_Base> 
#line 353
struct _Iterator012 : public _Base { 
#line 356
typedef _Category iterator_category; 
#line 357
typedef _Ty value_type; 
#line 358
typedef _Diff difference_type; 
#line 359
typedef _Diff distance_type; 
#line 360
typedef _Pointer pointer; 
#line 361
typedef _Reference reference; 
#line 362
}; 
#line 365
typedef iterator< output_iterator_tag, void, void, void, void>  _Outit; 
#line 368
template< class _Iter> 
#line 369
struct iterator_traits { 
#line 371
typedef typename _Iter::iterator_category iterator_category; 
#line 372
typedef typename _Iter::value_type value_type; 
#line 373
typedef typename _Iter::difference_type difference_type; 
#line 374
typedef difference_type distance_type; 
#line 375
typedef typename _Iter::pointer pointer; 
#line 376
typedef typename _Iter::reference reference; 
#line 377
}; 
#line 379
template< class _Ty> 
#line 380
struct iterator_traits< _Ty *>  { 
#line 382
typedef random_access_iterator_tag iterator_category; 
#line 383
typedef _Ty value_type; 
#line 384
typedef ptrdiff_t difference_type; 
#line 385
typedef ptrdiff_t distance_type; 
#line 386
typedef _Ty *pointer; 
#line 387
typedef _Ty &reference; 
#line 388
}; 
#line 390
template< class _Ty> 
#line 391
struct iterator_traits< const _Ty *>  { 
#line 393
typedef random_access_iterator_tag iterator_category; 
#line 394
typedef _Ty value_type; 
#line 395
typedef ptrdiff_t difference_type; 
#line 396
typedef ptrdiff_t distance_type; 
#line 397
typedef const _Ty *pointer; 
#line 398
typedef const _Ty &reference; 
#line 399
}; 
#line 402
template < class _Iter > inline
 typename iterator_traits < _Iter > :: iterator_category
  _Iter_cat ( const _Iter & )
 {
 typename iterator_traits < _Iter > :: iterator_category _Cat;
 return ( _Cat );
 }
#line 411
template < class _Iter1,
 class _Iter2 > inline
 _Nonscalar_ptr_iterator_tag _Ptr_cat ( _Iter1 &, _Iter2 & )
 {
 _Nonscalar_ptr_iterator_tag _Cat;
 return ( _Cat );
 }
#line 419
template< class _Elem1, class 
#line 420
_Elem2> 
#line 421
struct _Ptr_cat_helper { 
#line 423
typedef _Nonscalar_ptr_iterator_tag type; 
#line 424
}; 
#line 426
template< class _Elem> 
#line 427
struct _Ptr_cat_helper< _Elem, _Elem>  { 
#line 431
typedef typename _If< is_scalar< _Elem> ::value, _Scalar_ptr_iterator_tag, _Nonscalar_ptr_iterator_tag> ::type type; 
#line 432
}; 
#line 434
template< class _Anything> 
#line 435
struct _Ptr_cat_helper< _Anything *, const _Anything *>  { 
#line 437
typedef _Scalar_ptr_iterator_tag type; 
#line 438
}; 
#line 440
template < class _Elem1,
 class _Elem2 > inline
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: type
  _Ptr_cat ( _Elem1 *, _Elem2 * )
 {
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: type _Cat;
 return ( _Cat );
 }
#line 449
template < class _Elem1,
 class _Elem2 > inline
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: type
  _Ptr_cat ( const _Elem1 *, _Elem2 * )
 {
 typename _Ptr_cat_helper < _Elem1, _Elem2 > :: type _Cat;
 return ( _Cat );
 }
#line 643 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _Iter > inline
 typename iterator_traits < _Iter > :: value_type * _Val_type ( _Iter )
 {
 return ( 0 );
 }
#line 650
template < class _InIt,
 class _Diff > inline
 void _Advance ( _InIt & _Where, _Diff _Off, input_iterator_tag )
 {





 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 663 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _FwdIt,
 class _Diff > inline
 void _Advance ( _FwdIt & _Where, _Diff _Off, forward_iterator_tag )
 {





 for (; 0 < _Off; -- _Off )
  ++ _Where;
 }
#line 676 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _BidIt,
 class _Diff > inline
 void _Advance ( _BidIt & _Where, _Diff _Off, bidirectional_iterator_tag )
 {
 for (; 0 < _Off; -- _Off )
  ++ _Where;
 for (; _Off < 0; ++ _Off )
  -- _Where;
 }
#line 686
template < class _RanIt,
 class _Diff > inline
 void _Advance ( _RanIt & _Where, _Diff _Off, random_access_iterator_tag )
 {
 _Where += _Off;
 }
#line 693
template < class _InIt,
 class _Diff > inline
 void advance ( _InIt & _Where, _Diff _Off )
 {
 _Advance ( _Where, _Off, _Iter_cat ( _Where ) );
 }
#line 702
template < class _Iter > inline
 typename iterator_traits < _Iter > :: difference_type
  * _Dist_type ( _Iter )
 {
 return ( 0 );
 }
#line 710
template < class _InIt,
 class _Diff > inline
  void _Distance2 ( _InIt _First, _InIt _Last, _Diff & _Off,
   input_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }
#line 719
template < class _FwdIt,
 class _Diff > inline
  void _Distance2 ( _FwdIt _First, _FwdIt _Last, _Diff & _Off,
   forward_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }
#line 728
template < class _BidIt,
 class _Diff > inline
  void _Distance2 ( _BidIt _First, _BidIt _Last, _Diff & _Off,
   bidirectional_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  ++ _Off;
 }
#line 737
template < class _RanIt,
 class _Diff > inline
  void _Distance2 ( _RanIt _First, _RanIt _Last, _Diff & _Off,
   random_access_iterator_tag )
 {








 _Off += _Last - _First;
 }
#line 753 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt > inline
 typename iterator_traits < _InIt > :: difference_type
  distance ( _InIt _First, _InIt _Last )
 {
 typename iterator_traits < _InIt > :: difference_type _Off = 0;
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 return ( _Off );
 }
#line 762
template < class _InIt,
 class _Diff > inline
  void _Distance ( _InIt _First, _InIt _Last, _Diff & _Off )
 {
 _Distance2 ( _First, _Last, _Off, _Iter_cat ( _First ) );
 }
#line 770
template < class _FwdIt > inline
 _FwdIt next ( _FwdIt _First,
  typename iterator_traits < _FwdIt > :: difference_type _Off = 1 )
 {
 static_assert ( ( is_base_of < forward_iterator_tag,
  typename iterator_traits < _FwdIt > :: iterator_category > :: value ),
  "next requires forward iterator" );

 :: std :: advance ( _First, _Off );
 return ( _First );
 }
#line 783
template < class _BidIt > inline
 _BidIt prev ( _BidIt _First,
  typename iterator_traits < _BidIt > :: difference_type _Off = 1 )
 {
 static_assert ( ( is_base_of < bidirectional_iterator_tag,
  typename iterator_traits < _BidIt > :: iterator_category > :: value ),
  "prev requires bidirectional iterator" );

 :: std :: advance ( _First, - _Off );
 return ( _First );
 }
#line 797
template < class _Ty >
 struct pointer_traits;
#line 800
template < class _RanIt,
 class _Base >
 class _Revranit
  : public _Base
 {
public :
 typedef _Revranit < _RanIt, _Base > _Myt;
 typedef typename _Base :: difference_type difference_type;
 typedef typename _Base :: pointer pointer;
 typedef typename _Base :: reference reference;
 typedef _RanIt iterator_type;

 _Revranit ( )
  {
  }

 explicit _Revranit ( _RanIt _Right )
  : current ( _Right )
  {
  }

 template < class _RanIt2,
  class _Base2 >
  _Revranit ( const _Revranit < _RanIt2, _Base2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  _RanIt _Tmp = current;
  return ( * -- _Tmp );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myt & operator ++ ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 template < class _RanIt2,
  class _Base2 >
  bool _Equal ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 template < class _RanIt2,
  class _Base2 >
  bool _Less ( const _Revranit < _RanIt2, _Base2 > & _Right ) const
  {
  return ( _Right . base ( ) < current );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( _Right . base ( ) - current );
  }

protected :
 _RanIt current;
 };
#line 923
template < class _RanIt,
 class _Base,
 class _Diff > inline
 _Revranit < _RanIt, _Base >
  operator + ( _Diff _Off,
  const _Revranit < _RanIt, _Base > & _Right )
 {
 return ( _Right + _Off );
 }
#line 933
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 >
 auto inline operator - (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
   -> decltype ( _Right . base ( ) - _Left . base ( ) )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }
#line 945
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator == (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 956
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator != (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 967
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator < (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 978
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator > (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 989
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator <= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1000
template < class _RanIt1,
 class _Base1,
 class _RanIt2,
 class _Base2 > inline
 bool operator >= (
  const _Revranit < _RanIt1, _Base1 > & _Left,
  const _Revranit < _RanIt2, _Base2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1012
template < class _RanIt >
 class reverse_iterator
  : public _Revranit < _RanIt, iterator <
   typename iterator_traits < _RanIt > :: iterator_category,
   typename iterator_traits < _RanIt > :: value_type,
   typename iterator_traits < _RanIt > :: difference_type,
   typename iterator_traits < _RanIt > :: pointer,
   typename iterator_traits < _RanIt > :: reference > >
 {
 typedef reverse_iterator < _RanIt > _Myt;
 typedef _Revranit < _RanIt, iterator <
  typename iterator_traits < _RanIt > :: iterator_category,
  typename iterator_traits < _RanIt > :: value_type,
  typename iterator_traits < _RanIt > :: difference_type,
  typename iterator_traits < _RanIt > :: pointer,
  typename iterator_traits < _RanIt > :: reference > > _Mybase;

public :
 typedef typename iterator_traits < _RanIt > :: difference_type difference_type;
 typedef typename iterator_traits < _RanIt > :: pointer pointer;
 typedef typename iterator_traits < _RanIt > :: reference reference;
 typedef _RanIt iterator_type;

 reverse_iterator ( )
  {
  }

 explicit reverse_iterator ( _RanIt _Right )
  : _Mybase ( _Right )
  {
  }

 template < class _Other >
  reverse_iterator ( const reverse_iterator < _Other > & _Right )
  : _Mybase ( _Right . base ( ) )
  {
  }

 reverse_iterator ( _Mybase _Right )
  : _Mybase ( _Right )
  {
  }

 template < class _Other >
  _Myt & operator = ( const reverse_iterator < _Other > & _Right )
  {
  this -> current = _Right . base ( );
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  ++ * ( ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- * ( ( _Mybase * ) this );
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  * ( ( _Mybase * ) this ) -= _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }
 };
#line 1113
template< class _RanIt> 
#line 1114
struct _Is_checked_helper< reverse_iterator< _RanIt> >  : public _Is_checked_helper< _RanIt>  { 
#line 1117
}; 
#line 1120
template < class _RanIt,
 class _Diff > inline
 reverse_iterator < _RanIt > operator + ( _Diff _Off,
  const reverse_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 1128
template < class _RanIt1,
 class _RanIt2 >
 auto inline operator - ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
   -> decltype ( _Right . base ( ) - _Left . base ( ) )
 {
 return ( _Right . base ( ) - _Left . base ( ) );
 }
#line 1137
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 1145
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1153
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 1161
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 1169
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 1177
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= ( const reverse_iterator < _RanIt1 > & _Left,
  const reverse_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 1187
template < class _Container >
 auto inline begin ( _Container & _Cont ) -> decltype ( _Cont . begin ( ) )
 {
 return ( _Cont . begin ( ) );
 }
#line 1193
template < class _Container >
 auto inline begin ( const _Container & _Cont ) -> decltype ( _Cont . begin ( ) )
 {
 return ( _Cont . begin ( ) );
 }
#line 1199
template < class _Container >
 auto inline end ( _Container & _Cont ) -> decltype ( _Cont . end ( ) )
 {
 return ( _Cont . end ( ) );
 }
#line 1205
template < class _Container >
 auto inline end ( const _Container & _Cont ) -> decltype ( _Cont . end ( ) )
 {
 return ( _Cont . end ( ) );
 }
#line 1211
template < class _Ty,
 size_t _Size > inline
 _Ty * begin ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( _Array );
 }
#line 1218
template < class _Ty,
 size_t _Size > inline
 _Ty * end ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( _Array + _Size );
 }
#line 1226
template < class _Container >
 auto inline cbegin ( const _Container & _Cont ) -> decltype ( :: std :: begin ( _Cont ) )
 {
 return ( :: std :: begin ( _Cont ) );
 }
#line 1232
template < class _Container >
 auto inline cend ( const _Container & _Cont ) -> decltype ( :: std :: end ( _Cont ) )
 {
 return ( :: std :: end ( _Cont ) );
 }
#line 1239
template < class _Container >
 auto inline rbegin ( _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) )
 {
 return ( _Cont . rbegin ( ) );
 }
#line 1245
template < class _Container >
 auto inline rbegin ( const _Container & _Cont ) -> decltype ( _Cont . rbegin ( ) )
 {
 return ( _Cont . rbegin ( ) );
 }
#line 1251
template < class _Container >
 auto inline rend ( _Container & _Cont ) -> decltype ( _Cont . rend ( ) )
 {
 return ( _Cont . rend ( ) );
 }
#line 1257
template < class _Container >
 auto inline rend ( const _Container & _Cont ) -> decltype ( _Cont . rend ( ) )
 {
 return ( _Cont . rend ( ) );
 }
#line 1263
template < class _Ty,
 size_t _Size > inline
 reverse_iterator < _Ty * > rbegin ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( reverse_iterator < _Ty * > ( _Array + _Size ) );
 }
#line 1270
template < class _Ty,
 size_t _Size > inline
 reverse_iterator < _Ty * > rend ( _Ty ( & _Array ) [ _Size ] )
 {
 return ( reverse_iterator < _Ty * > ( _Array ) );
 }
#line 1277
template < class _Elem > inline
 reverse_iterator < const _Elem * > rbegin ( initializer_list < _Elem > _Ilist )
 {
 return ( reverse_iterator < const _Elem * > ( _Ilist . end ( ) ) );
 }
#line 1283
template < class _Elem > inline
 reverse_iterator < const _Elem * > rend ( initializer_list < _Elem > _Ilist )
 {
 return ( reverse_iterator < const _Elem * > ( _Ilist . begin ( ) ) );
 }
#line 1290
template < class _Container >
 auto inline crbegin ( const _Container & _Cont ) -> decltype ( :: std :: rbegin ( _Cont ) )
 {
 return ( :: std :: rbegin ( _Cont ) );
 }
#line 1296
template < class _Container >
 auto inline crend ( const _Container & _Cont ) -> decltype ( :: std :: rend ( _Cont ) )
 {
 return ( :: std :: rend ( _Cont ) );
 }
#line 1304
template < class _Ty,
 size_t _Size >
 class _Array_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   _Ty,
   ptrdiff_t,
   const _Ty *,
   const _Ty &,
   _Iterator_base >
 {
public :
 typedef _Array_const_iterator < _Ty, _Size > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef const _Ty * pointer;
 typedef const _Ty & reference;
 enum { _EEN_SIZE = _Size };
 enum { _EEN_IDL =
  0 };


 _Array_const_iterator ( )
  {
  _Ptr = 0;
  }

 explicit _Array_const_iterator ( pointer _Parg, size_t _Off = 0 )
  {
  _Ptr = _Parg + _Off;
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Ptr );
  }

 reference operator * ( ) const
  {
  return ( * _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  return ( _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  return ( _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  return ( _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

 pointer _Ptr;











































































































































































































 };
#line 1656 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _Ty,
 size_t _Size > inline
 typename _Array_const_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_const_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 1664
template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > &
  _Rechecked ( _Array_const_iterator < _Ty, _Size > & _Iter,
   typename _Array_const_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 1674
template < class _Ty,
 size_t _Size > inline
 _Array_const_iterator < _Ty, _Size > operator + (
  typename _Array_const_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_const_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 1684
template < class _Ty,
 size_t _Size >
 class _Array_iterator
  : public _Array_const_iterator < _Ty, _Size >
 {
public :
 typedef _Array_iterator < _Ty, _Size > _Myiter;
 typedef _Array_const_iterator < _Ty, _Size > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef _Ty value_type;
 typedef size_t size_type;
 typedef ptrdiff_t difference_type;
 typedef _Ty * pointer;
 typedef _Ty & reference;

 _Array_iterator ( )
  {
  }

 explicit _Array_iterator ( pointer _Parg, size_t _Off = 0 )
  : _Mybase ( _Parg, _Off )
  {
  }
 enum { _EEN_SIZE = _Size };
 enum { _EEN_IDL =
  0 };

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  ( ( _Mybase * ) this ) -> _Rechecked ( _Right );
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( ( pointer ) ( ( _Mybase * ) this ) -> _Unchecked ( ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( * ( _Mybase * ) this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 1795
template < class _Ty,
 size_t _Size > inline
 typename _Array_iterator < _Ty, _Size > :: _Unchecked_type
  _Unchecked ( _Array_iterator < _Ty, _Size > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 1803
template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > &
  _Rechecked ( _Array_iterator < _Ty, _Size > & _Iter,
   typename _Array_iterator < _Ty, _Size >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 1813
template < class _Ty,
 size_t _Size > inline
 _Array_iterator < _Ty, _Size > operator + (
  typename _Array_iterator < _Ty, _Size > :: difference_type _Off,
  _Array_iterator < _Ty, _Size > _Next )
 {
 return ( _Next += _Off );
 }
#line 1823
template < class _RanIt >
 class move_iterator
 {
public :
 typedef move_iterator < _RanIt > _Myt;
 typedef typename iterator_traits < _RanIt > :: iterator_category
  iterator_category;
 typedef typename iterator_traits < _RanIt > :: value_type
  value_type;
 typedef typename iterator_traits < _RanIt > :: difference_type
  difference_type;
 typedef _RanIt pointer;
 typedef value_type && reference;
 typedef _RanIt iterator_type;

 move_iterator ( )
  {
  }

 explicit move_iterator ( iterator_type _Right )
  : current ( _Right )
  {
  }

 template < class _RanIt2 >
  move_iterator ( const move_iterator < _RanIt2 > & _Right )
  : current ( _Right . base ( ) )
  {
  }

 template < class _RanIt2 >
  _Myt & operator = ( const move_iterator < _RanIt2 > & _Right )
  {
  current = _Right . base ( );
  return ( * this );
  }

 _RanIt base ( ) const
  {
  return ( current );
  }

 reference operator * ( ) const
  {
  return ( :: std :: move ( * current ) );
  }

 pointer operator -> ( ) const
  {
  return ( current );
  }

 _Myt & operator ++ ( )
  {
  ++ current;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ current;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- current;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- current;
  return ( _Tmp );
  }

 template < class _RanIt2 >
  bool _Equal ( const move_iterator < _RanIt2 > & _Right ) const
  {
  return ( current == _Right . base ( ) );
  }



 _Myt & operator += ( difference_type _Off )
  {
  current += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  return ( _Myt ( current + _Off ) );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  current -= _Off;
  return ( * this );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  return ( _Myt ( current - _Off ) );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( :: std :: move ( current [ _Off ] ) );
  }

 template < class _RanIt2 >
  bool _Less ( const move_iterator < _RanIt2 > & _Right ) const
  {
  return ( current < _Right . base ( ) );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( current - _Right . base ( ) );
  }

protected :
 iterator_type current;
 };
#line 1951
template< class _RanIt> 
#line 1952
struct _Is_checked_helper< move_iterator< _RanIt> >  : public _Is_checked_helper< _RanIt>  { 
#line 1955
}; 
#line 1958
template < class _RanIt,
 class _Diff > inline
 move_iterator < _RanIt >
  operator + ( _Diff _Off,
  const move_iterator < _RanIt > & _Right )
 {
 return ( _Right + _Off );
 }
#line 1967
template < class _RanIt1,
 class _RanIt2 >
 auto inline operator - (
  move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
   -> decltype ( _Left . base ( ) - _Right . base ( ) )
 {
 return ( _Left . base ( ) - _Right . base ( ) );
 }
#line 1977
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator == (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 1986
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator != (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 1995
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator < (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Left . _Less ( _Right ) );
 }
#line 2004
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator > (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2013
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator <= (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2022
template < class _RanIt1,
 class _RanIt2 > inline
 bool operator >= (
  const move_iterator < _RanIt1 > & _Left,
  const move_iterator < _RanIt2 > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2032
template < class _RanIt > inline
 move_iterator < _RanIt > make_move_iterator ( _RanIt _Iter )
 {
 return ( move_iterator < _RanIt > ( _Iter ) );
 }
#line 2039
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }
#line 2049
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 2060
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_impl ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Copy_impl ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2070
template < class _InIt,
 class _OutIt > inline
 _OutIt copy ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Copy_impl ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2151 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, input_iterator_tag )
 {
 * _Dest = * _First;
 while ( 0 < -- _Count )
  * ++ _Dest = * ++ _First;
 return ( ++ _Dest );
 }
#line 2163
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, forward_iterator_tag )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest, ++ _First )
  * _Dest = * _First;
 return ( _Dest );
 }
#line 2174
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest, _Iter_cat ( _First ) ) );
 }
#line 2183
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 2194
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt _Copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 return ( _Copy_n ( _First, _Count,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2205
template < class _InIt,
 class _Diff,
 class _OutIt > inline
 _OutIt copy_n ( _InIt _First, _Diff _Count,
  _OutIt _Dest )
 {
 if ( _Count <= 0 )
  return ( _Dest );
 else
  return ( _Rechecked ( _Dest,
   _Copy_n ( _Unchecked ( _First ), _Count,
    _Unchecked ( _Dest ) ) ) );
 }
#line 2340 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = * -- _Last;
 return ( _Dest );
 }
#line 2350
template < class _InIt,
 class _OutIt > inline
 _OutIt _Copy_backward ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest - _Count, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest - _Count );
 }
#line 2361
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Copy_backward ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2371
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 copy_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Copy_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2414 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _Dest, ++ _First )
  * _Dest = :: std :: move ( * _First );
 return ( _Dest );
 }
#line 2424
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest + _Count );
 }
#line 2435
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move ( _InIt _First, _InIt _Last,
  _OutIt _Dest )
 {
 return ( _Move ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2445
template< class _InIt, class 
#line 2446
_OutIt> inline _OutIt 
#line 2447
move(_InIt _First, _InIt _Last, _OutIt 
#line 2448
_Dest) 
#line 2449
{ 
#line 2450
return _Rechecked(_Dest, _Move(_Unchecked(_First), _Unchecked(_Last), _Unchecked(_Dest))); 
#line 2453
} 
#line 2521 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest, _Nonscalar_ptr_iterator_tag )
 {
 while ( _First != _Last )
  * -- _Dest = :: std :: move ( * -- _Last );
 return ( _Dest );
 }
#line 2531
template < class _InIt,
 class _OutIt > inline
 _OutIt _Move_backward ( _InIt _First, _InIt _Last,
  _OutIt _Dest, _Scalar_ptr_iterator_tag )
 {
 ptrdiff_t _Count = _Last - _First;
 :: memmove ( & * _Dest - _Count, & * _First,
  _Count * sizeof ( * _First ) );
 return ( _Dest - _Count );
 }
#line 2542
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 _Move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Move_backward ( _First, _Last,
  _Dest, _Ptr_cat ( _First, _Dest ) ) );
 }
#line 2552
template < class _BidIt1,
 class _BidIt2 > inline
 _BidIt2 move_backward ( _BidIt1 _First, _BidIt1 _Last,
  _BidIt2 _Dest )
 {
 return ( _Rechecked ( _Dest,
  _Move_backward ( _Unchecked ( _First ), _Unchecked ( _Last ),
   _Unchecked ( _Dest ) ) ) );
 }
#line 2595 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _FwdIt,
 class _Ty > inline
 void _Fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 for (; _First != _Last; ++ _First )
  * _First = _Val;
 }
#line 2603
inline void _Fill(char *_First, char *_Last, char _Val) 
#line 2604
{ 
#line 2605
::memset(_First, _Val, _Last - _First); 
#line 2606
} 
#line 2608
inline void _Fill(signed char *_First, signed char *_Last, signed char _Val) 
#line 2609
{ 
#line 2610
::memset(_First, _Val, _Last - _First); 
#line 2611
} 
#line 2613
inline void _Fill(unsigned char *_First, unsigned char *_Last, unsigned char _Val) 
#line 2614
{ 
#line 2615
::memset(_First, _Val, _Last - _First); 
#line 2616
} 
#line 2618
template < class _FwdIt,
 class _Ty > inline
 void fill ( _FwdIt _First, _FwdIt _Last, const _Ty & _Val )
 {
 ;
 _Fill ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val );
 }
#line 2627
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt _Fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 for (; 0 < _Count; -- _Count, ++ _Dest )
  * _Dest = _Val;
 return ( _Dest );
 }
#line 2637
inline char *_Fill_n(char *_Dest, size_t _Count, char _Val) 
#line 2638
{ 
#line 2639
::memset(_Dest, _Val, _Count); 
#line 2640
return _Dest + _Count; 
#line 2641
} 
#line 2643
inline signed char *_Fill_n(signed char *_Dest, size_t _Count, signed char 
#line 2644
_Val) 
#line 2645
{ 
#line 2646
::memset(_Dest, _Val, _Count); 
#line 2647
return _Dest + _Count; 
#line 2648
} 
#line 2650
inline unsigned char *_Fill_n(unsigned char *_Dest, size_t _Count, unsigned char 
#line 2651
_Val) 
#line 2652
{ 
#line 2653
::memset(_Dest, _Val, _Count); 
#line 2654
return _Dest + _Count; 
#line 2655
} 
#line 2658
template < class _OutIt,
 class _Diff,
 class _Ty > inline
 _OutIt fill_n ( _OutIt _Dest, _Diff _Count, const _Ty & _Val )
 {
 return ( _Rechecked ( _Dest, _Fill_n ( _Unchecked ( _Dest ), _Count, _Val ) ) );
 }
#line 2732 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool _Equal ( _InIt1 _First1, _InIt1 _Last1, _InIt2 _First2 )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! ( * _First1 == * _First2 ) )
   return ( false );
 return ( true );
 }
#line 2742
inline bool _Equal(const char *_First1, const char *_Last1, const char *
#line 2743
_First2) 
#line 2744
{ 
#line 2745
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
#line 2746
} 
#line 2748
inline bool _Equal(const signed char *_First1, const signed char *_Last1, const signed char *
#line 2749
_First2) 
#line 2750
{ 
#line 2751
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
#line 2752
} 
#line 2754
inline bool _Equal(const unsigned char *_First1, const unsigned char *_Last1, const unsigned char *
#line 2755
_First2) 
#line 2756
{ 
#line 2757
return ::memcmp(_First1, _First2, _Last1 - _First1) == 0; 
#line 2758
} 
#line 2761
template < class _InIt1,
 class _InIt2 > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2 )
 {
 return ( _Equal ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ) ) );
 }
#line 2815 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   return ( false );
 return ( true );
 }
#line 2828
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool equal ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _Pr _Pred )
 {
 return ( _Equal ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Pred ) );
 }
#line 2887 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( ( ( * _First1 ) < ( * _First2 ) ) )
   return ( true );
  else if ( * _First2 < * _First1 )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }
#line 2900
inline bool _Lexicographical_compare(const unsigned char *
#line 2901
_First1, const unsigned char *_Last1, const unsigned char *
#line 2902
_First2, const unsigned char *_Last2) 
#line 2903
{ 
#line 2904
ptrdiff_t _Num1 = _Last1 - _First1; 
#line 2905
ptrdiff_t _Num2 = _Last2 - _First2; 
#line 2906
int _Ans = ::memcmp(_First1, _First2, (_Num1 < _Num2) ? _Num1 : _Num2); 
#line 2907
return (_Ans < 0) || ((_Ans == 0) && (_Num1 < _Num2)); 
#line 2908
} 
#line 2922 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template < class _InIt1,
 class _InIt2 > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2 )
 {
 ;
 ;
 return ( _Lexicographical_compare ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ) ) );
 }
#line 2934
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool _Lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( _Pred ( * _First1, * _First2 ) )
   return ( true );
  else if ( _Pred ( * _First2, * _First1 ) )
   return ( false );
 return ( _First1 == _Last1 && _First2 != _Last2 );
 }
#line 2948
template < class _InIt1,
 class _InIt2,
 class _Pr > inline
 bool lexicographical_compare ( _InIt1 _First1, _InIt1 _Last1,
  _InIt2 _First2, _InIt2 _Last2, _Pr _Pred )
 {
 ;
 ;
 ;
 return ( _Lexicographical_compare ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Unchecked ( _Last2 ), _Pred ) );
 }
#line 2962
template < class _Ty,
 class _Ignored > inline
 bool _Within_limits ( const _Ty & _Val, true_type, true_type, _Ignored )
 {
 return ( ( - 128 ) <= _Val && _Val <= 127 );
 }
#line 2969
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, false_type, true_type )
 {
 return ( _Val <= 127 || static_cast < _Ty > ( ( - 128 ) ) <= _Val );
 }
#line 2975
template < class _Ty > inline
 bool _Within_limits ( const _Ty & _Val, true_type, false_type, false_type )
 {
 return ( _Val <= 127 );
 }
#line 2981
template < class _Ty,
 class _Ignored > inline
 bool _Within_limits ( const _Ty & _Val, false_type, true_type, _Ignored )
 {
 return ( 0 <= _Val && _Val <= 255 );
 }
#line 2988
template < class _Ty,
 class _Ignored > inline
 bool _Within_limits ( const _Ty & _Val, false_type, false_type, _Ignored )
 {
 return ( _Val <= 255 );
 }
#line 2995
template < class _InIt,
 class _Ty > inline
 bool _Within_limits ( _InIt, const _Ty & _Val )
 {
 typedef typename remove_pointer < _InIt > :: type _Elem;
 return ( _Within_limits ( _Val, is_signed < _Elem > ( ), is_signed < _Ty > ( ),
  integral_constant < bool, - 1 == static_cast < _Ty > ( - 1 ) > ( ) ) );
 }
#line 3004
template < class _InIt > inline
 bool _Within_limits ( _InIt, const bool & )
 {
 return ( true );
 }
#line 3010
template < class _InIt,
 class _Ty > inline
 _InIt _Find ( _InIt _First, _InIt _Last, const _Ty & _Val, true_type )
 {
 if ( ! _Within_limits ( _First, _Val ) )
  return ( _Last );
 _First = static_cast < _InIt > ( :: memchr (
  _First, static_cast < unsigned char > ( _Val ), _Last - _First ) );
 return ( _First ? _First : _Last );
 }
#line 3021
template < class _InIt,
 class _Ty > inline
 _InIt _Find ( _InIt _First, _InIt _Last, const _Ty & _Val, false_type )
 {
 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   break;
 return ( _First );
 }
#line 3031
template < class _InIt,
 class _Ty > inline
 _InIt _Find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {

 typedef integral_constant < bool,
  ( is_same < _InIt, char * > :: value
  || is_same < _InIt, signed char * > :: value
  || is_same < _InIt, unsigned char * > :: value
  || is_same < _InIt, const char * > :: value
  || is_same < _InIt, const signed char * > :: value
  || is_same < _InIt, const unsigned char * > :: value )
  && is_integral < _Ty > :: value
 > _Memchr_opt;
 return ( _Find ( _First, _Last, _Val, _Memchr_opt ( ) ) );
 }
#line 3048
template < class _InIt,
 class _Ty > inline
 _InIt find ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 ;
 return ( _Rechecked ( _First,
  _Find ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) ) );
 }
#line 3058
template < class _InIt,
 class _Ty,
 class _Pr > inline
 _InIt _Find_pr ( _InIt _First, _InIt _Last, const _Ty & _Val, _Pr _Pred )
 {
 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First, _Val ) )
   break;
 return ( _First );
 }
#line 3070
template < class _InIt,
 class _Ty > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count_np ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 typename iterator_traits < _InIt > :: difference_type _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( * _First == _Val )
   ++ _Count;
 return ( _Count );
 }
#line 3083
template < class _InIt,
 class _Ty > inline
 typename iterator_traits < _InIt > :: difference_type
  count ( _InIt _First, _InIt _Last, const _Ty & _Val )
 {
 ;
 return ( _Count_np ( _Unchecked ( _First ), _Unchecked ( _Last ), _Val ) );
 }
#line 3093
template < class _InIt,
 class _Ty,
 class _Pr > inline
 typename iterator_traits < _InIt > :: difference_type
  _Count_pr ( _InIt _First, _InIt _Last, const _Ty & _Val, _Pr _Pred )
 {
 typename iterator_traits < _InIt > :: difference_type _Count = 0;

 for (; _First != _Last; ++ _First )
  if ( _Pred ( * _First, _Val ) )
   ++ _Count;
 return ( _Count );
 }
#line 3108
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool _Is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred )
 {
 for (; _First1 != _Last1; ++ _First1, ++ _First2 )
  if ( ! _Pred ( * _First1, * _First2 ) )
   break;
 if ( _First1 != _Last1 )
  {
  _FwdIt2 _Last2 = _First2;
  advance ( _Last2, distance ( _First1, _Last1 ) );
  for ( _FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++ _Next1 )
   if ( _Next1 == _Find_pr ( _First1, _Next1, * _Next1, _Pred ) )
    {
    typename iterator_traits < _FwdIt2 > :: difference_type _Count =
     _Count_pr ( _First2, _Last2, * _Next1, _Pred );
    if ( _Count == 0
     || _Count != _Count_pr ( _Next1, _Last1, * _Next1, _Pred ) )
     return ( false );
    }
  }
 return ( true );
 }
#line 3134
template < class _FwdIt1,
 class _FwdIt2,
 class _Pr > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2, _Pr _Pred )
 {
 ;
 ;
 return _Is_permutation ( _Unchecked ( _First1 ), _Unchecked ( _Last1 ),
  _Unchecked ( _First2 ), _Pred );
 }
#line 3147
template < class _FwdIt1,
 class _FwdIt2 > inline
 bool is_permutation ( _FwdIt1 _First1, _FwdIt1 _Last1,
  _FwdIt2 _First2 )
 {
 return ( :: std :: is_permutation ( _First1, _Last1,
  _First2, equal_to < > ( ) ) );
 }
#line 3157
template < class _BidIt > inline
 void _Reverse ( _BidIt _First, _BidIt _Last, bidirectional_iterator_tag )
 {
 for (; _First != _Last && _First != -- _Last; ++ _First )
  :: std :: iter_swap ( _First, _Last );
 }
#line 3164
template < class _BidIt > inline
 void reverse ( _BidIt _First, _BidIt _Last )
 {
 ;
 _Reverse ( _Unchecked ( _First ), _Unchecked ( _Last ), _Iter_cat ( _First ) );
 }
#line 3172
template < class _FwdIt > inline
 void _Rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last,
  forward_iterator_tag )
 {
 for ( _FwdIt _Next = _Mid;; )
  {
  :: std :: iter_swap ( _First, _Next );
  if ( ++ _First == _Mid )
   if ( ++ _Next == _Last )
    break;
   else
    _Mid = _Next;
  else if ( ++ _Next == _Last )
   _Next = _Mid;
  }
 }
#line 3189
template < class _BidIt > inline
 void _Rotate ( _BidIt _First, _BidIt _Mid, _BidIt _Last,
  bidirectional_iterator_tag )
 {
 :: std :: reverse ( _First, _Mid );
 :: std :: reverse ( _Mid, _Last );
 :: std :: reverse ( _First, _Last );
 }
#line 3198
template < class _RanIt,
 class _Diff,
 class _Ty > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last, _Diff *, _Ty * )
 {
 _Diff _Shift = _Mid - _First;
 _Diff _Count = _Last - _First;

 for ( _Diff _Factor = _Shift; _Factor != 0; )
  {
  _Diff _Tmp = _Count % _Factor;
  _Count = _Factor;
  _Factor = _Tmp;
  }

 if ( _Count < _Last - _First )
  for (; 0 < _Count; -- _Count )
   {
   _RanIt _Hole = _First + _Count;
   _RanIt _Next = _Hole;
   _RanIt _Next1 = _Next + _Shift == _Last ? _First : _Next + _Shift;
   for (;; )
    {
    iter_swap ( _Next, _Next1 );
    _Next = _Next1;
    _Next1 = _Shift < _Last - _Next1 ? _Next1 + _Shift
     : _First + ( _Shift - ( _Last - _Next1 ) );
    if ( _Next1 == _Hole )
     break;
    }
   }
 }
#line 3231
template < class _RanIt > inline
 void _Rotate ( _RanIt _First, _RanIt _Mid, _RanIt _Last,
  random_access_iterator_tag )
 {
 _Rotate ( _First, _Mid, _Last, _Dist_type ( _First ), _Val_type ( _First ) );
 }
#line 3238
template < class _FwdIt > inline
 _FwdIt rotate ( _FwdIt _First, _FwdIt _Mid, _FwdIt _Last )
 {
 ;
 ;
 if ( _First != _Mid && _Mid != _Last )
  _Rotate ( _Unchecked ( _First ), _Unchecked ( _Mid ), _Unchecked ( _Last ),
   _Iter_cat ( _First ) );
 :: std :: advance ( _First, :: std :: distance ( _Mid, _Last ) );
 return ( _First );
 }
#line 3251
template < class _Diff, class _Urng >
 class _Rng_from_urng
 {
public :
 typedef typename make_unsigned < _Diff > :: type _Ty0;
 typedef typename _Urng :: result_type _Ty1;

 typedef typename _If < sizeof ( _Ty1 ) < sizeof ( _Ty0 ),
  _Ty0, _Ty1 > :: type _Udiff;


 explicit _Rng_from_urng ( _Urng & _Func )
  : _Ref ( _Func ), _Bits ( 8 * sizeof ( _Udiff ) ), _Bmask ( _Udiff ( - 1 ) )
  {
  for (; ( _Urng :: max ) ( ) - ( _Urng :: min ) ( ) < _Bmask; _Bmask >>= 1 )
   -- _Bits;
  }

 _Diff operator ( ) ( _Diff _Index )
  {
  for (;; )
   {
   _Udiff _Ret = 0;
   _Udiff _Mask = 0;

   while ( _Mask < _Udiff ( _Index - 1 ) )
    {
    _Ret <<= _Bits - 1;
    _Ret <<= 1;
    _Ret |= _Get_bits ( );
    _Mask <<= _Bits - 1;
    _Mask <<= 1;
    _Mask |= _Bmask;
    }


   if ( _Ret / _Index < _Mask / _Index
    || _Mask % _Index == _Udiff ( _Index - 1 ) )
    return ( _Ret % _Index );
   }
  }

 _Udiff _Get_all_bits ( )
  {
  _Udiff _Ret = 0;

  for ( size_t _Num = 0; _Num < 8 * sizeof ( _Udiff );
   _Num += _Bits )
   {
   _Ret <<= _Bits - 1;
   _Ret <<= 1;
   _Ret |= _Get_bits ( );
   }

  return ( _Ret );
  }

private :
 _Udiff _Get_bits ( )
  {
  for (;; )
   {
   _Udiff _Val = _Ref ( ) - ( _Urng :: min ) ( );

   if ( _Val <= _Bmask )
    return ( _Val );
   }
  }

 _Urng & _Ref;
 size_t _Bits;
 _Udiff _Bmask;

public :
 _Rng_from_urng ( const _Rng_from_urng & ) = delete;
 _Rng_from_urng & operator = ( const _Rng_from_urng & ) = delete;
 };
#line 3330
template < class _Elem >
 class __declspec ( dllimport ) _Yarn
 {
public :
 typedef _Yarn < _Elem > _Myt;

  _Yarn ( )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  }

  _Yarn ( const _Myt & _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

  _Yarn ( const _Elem * _Right )
  : _Myptr ( 0 ), _Nul ( 0 )
  {
  * this = _Right;
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  return ( * this = _Right . _Myptr );
  }

 _Myt & operator = ( const _Elem * _Right )
  {
  if ( _Myptr != _Right )
   {
   _Tidy ( );

   if ( _Right != 0 )
    {
    const _Elem * _Ptr = _Right;
    while ( * _Ptr != ( _Elem ) 0 )
     ++ _Ptr;
    size_t _Count = ( ( const char * ) ++ _Ptr - ( const char * ) _Right );






    _Myptr = ( _Elem * ) :: malloc ( _Count );


    if ( _Myptr != 0 )
     :: memcpy ( _Myptr, _Right, _Count );
    }
   }
  return ( * this );
  }

  ~ _Yarn ( ) throw ( )
  {
  _Tidy ( );
  }

 bool empty ( ) const
  {
  return ( _Myptr == 0 );
  }

 const _Elem * c_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

 bool _Empty ( ) const
  {
  return ( _Myptr == 0 );
  }

 const _Elem * _C_str ( ) const
  {
  return ( _Myptr != 0 ? _Myptr : & _Nul );
  }

private :
 void _Tidy ( )
  {
  if ( _Myptr != 0 )





   :: free ( _Myptr );


  _Myptr = 0;
  }

 _Elem * _Myptr;
 _Elem _Nul;
 };
#line 3431 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
template< class _Ty, class 
#line 3432
_Alloc> 
#line 3433
struct _Has_allocator_type { 
#line 3435
template< class _Uty> static auto _Fn(int)->is_convertible< _Alloc, typename _Uty::allocator_type> ; 
#line 3439
template< class _Uty> static auto _Fn(_Wrap_int)->false_type; 
#line 3443
typedef decltype((_Fn< _Ty> (0))) type; 
#line 3444
}; 
#line 3447
struct allocator_arg_t { 
#line 3449
}; 
#line 3451
const allocator_arg_t allocator_arg = allocator_arg_t(); 
#line 3453
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xbad_alloc(); 
#line 3454
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xinvalid_argument(const char *); 
#line 3455
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xlength_error(const char *); 
#line 3456
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xout_of_range(const char *); 
#line 3457
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xoverflow_error(const char *); 
#line 3458
__declspec(dllimport) __declspec(noreturn) void __cdecl _Xruntime_error(const char *); 
#line 3459
}
#line 3461
namespace std { 
#line 3463
template< class _Ty, class 
#line 3464
_Alloc> 
#line 3465
struct uses_allocator : public _Has_allocator_type< _Ty, _Alloc> ::type { 
#line 3468
}; 
#line 3469
}
#line 3471
#pragma warning(pop)
#line 12 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
#pragma warning(push,3)
#line 16
#pragma warning(disable: 4100)
#line 3472 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xutility"
#pragma pack ( pop )
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 20
template < class _Ty > inline
 _Ty * _Allocate ( size_t _Count, _Ty * )
 {
 void * _Ptr = 0;

 if ( _Count == 0 )
  ;
 else if ( ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) < _Count )
  || ( _Ptr = :: operator new ( _Count * sizeof ( _Ty ) ) ) == 0 )
  _Xbad_alloc ( );

 return ( ( _Ty * ) _Ptr );
 }
#line 35
template < class _Ty1,
 class _Ty2 > inline
 void _Construct ( _Ty1 * _Ptr, _Ty2 && _Val )
 {
 void * _Vptr = _Ptr;
 :: new ( _Vptr ) _Ty1 ( :: std :: forward < _Ty2 > ( _Val ) );
 }
#line 43
template < class _Ty1 > inline
 void _Construct ( _Ty1 * _Ptr )
 {
 void * _Vptr = _Ptr;

 :: new ( _Vptr ) _Ty1 ( );
 }
#line 52
template < class _Ty > inline
 void _Destroy ( _Ty * _Ptr )
 {
 _Ptr -> ~ _Ty ( );
 }
#line 59
template<> inline void _Destroy(char *) 
#line 60
{ 
#line 61
} 
#line 64
template<> inline void _Destroy(__wchar_t *) 
#line 65
{ 
#line 66
} 
#line 70
template<> inline void _Destroy(unsigned short *) 
#line 71
{ 
#line 72
} 
#line 76 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Nonscalar_ptr_iterator_tag )
 {
 for (; _First != _Last; ++ _First )
  _Al . destroy ( _First );
 }
#line 85
template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al,
  _Scalar_ptr_iterator_tag )
 {
 }
#line 92
template < class _Alloc > inline
 void _Destroy_range ( typename _Alloc :: pointer _First,
  typename _Alloc :: pointer _Last, _Alloc & _Al )
 {
 _Destroy_range ( _First, _Last, _Al, _Ptr_cat ( _First, _Last ) );
 }
#line 100
template< class _Alty> 
#line 101
struct _Is_simple_alloc : public _Cat_base< ((((is_same< typename _Alty::size_type, unsigned __w64> ::value && is_same< typename _Alty::difference_type, int __w64> ::value) && is_same< typename _Alty::pointer, typename _Alty::value_type *> ::value) && is_same< typename _Alty::const_pointer, const typename _Alty::value_type *> ::value) && is_same< typename _Alty::reference, typename _Alty::value_type &> ::value) && is_same< typename _Alty::const_reference, const typename _Alty::value_type &> ::value>  { 
#line 113
}; 
#line 116
template< class _Value_type> 
#line 117
struct _Simple_types { 
#line 119
typedef _Value_type value_type; 
#line 120
typedef size_t size_type; 
#line 121
typedef ptrdiff_t difference_type; 
#line 122
typedef value_type *pointer; 
#line 123
typedef const value_type *const_pointer; 
#line 124
typedef value_type &reference; 
#line 125
typedef const value_type &const_reference; 
#line 126
}; 
#line 129
template< class _Alty, class 
#line 130
_Pointer> 
#line 131
struct _Get_voidptr { 
#line 133
typedef typename _Alty::template rebind< void> ::other _Alvoid; 
#line 134
typedef typename _Alvoid::pointer type; 
#line 135
}; 
#line 137
template< class _Alty, class 
#line 138
_Ty> 
#line 139
struct _Get_voidptr< _Alty, _Ty *>  { 
#line 141
typedef void *type; 
#line 142
}; 
#line 145
template< class _Iter> 
#line 146
struct _Is_iterator : public integral_constant< bool, !is_integral< _Iter> ::value>  { 
#line 149
}; 
#line 152
template< class _Ty> struct _Get_first_parameter; 
#line 155
template< template< class , class ...>  class _Ty, class 
#line 156
_First, class ...
#line 157
_Rest> 
#line 158
struct _Get_first_parameter< _Ty< _First, _Rest...> >  { 
#line 160
typedef _First type; 
#line 161
}; 
#line 164
template< class _Newfirst, class 
#line 165
_Ty> struct _Replace_first_parameter; 
#line 168
template< class _Newfirst, 
#line 169
template< class , class ...>  class _Ty, class 
#line 170
_First, class ...
#line 171
_Rest> 
#line 172
struct _Replace_first_parameter< _Newfirst, _Ty< _First, _Rest...> >  { 
#line 174
typedef _Ty< _Newfirst, _Rest...>  type; 
#line 175
}; 
#line 178
template< class _Ty> 
#line 179
struct _Get_element_type { 
#line 180
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::element_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Get_first_parameter< _Uty> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 184 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 185
struct _Get_ptr_difference_type { 
#line 186
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::difference_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< int __w64> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 190 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty, class 
#line 191
_Other> 
#line 192
struct _Get_rebind_type { 
#line 193
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::template rebind< _Other> ::other> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Replace_first_parameter< _Other, _Uty> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 197 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template < class _Ty >
 struct pointer_traits
 {
 typedef typename _Get_element_type < _Ty > :: type element_type;
 typedef _Ty pointer;
 typedef typename _Get_ptr_difference_type < _Ty > :: type difference_type;

 template < class _Other >
  using rebind = typename _Get_rebind_type < _Ty, _Other > :: type;

 typedef typename _If < is_void < element_type > :: value,
  char &,
  typename add_reference < element_type > :: type > :: type _Reftype;

 static pointer pointer_to ( _Reftype _Val )
  {
  return ( _Ty :: pointer_to ( _Val ) );
  }
 };
#line 218
template < class _Ty >
 struct pointer_traits < _Ty * >
 {
 typedef _Ty element_type;
 typedef _Ty * pointer;
 typedef ptrdiff_t difference_type;

 template < class _Other >
  using rebind = _Other *;

 typedef typename _If < is_void < _Ty > :: value,
  char &,
  typename add_reference < _Ty > :: type > :: type _Reftype;

 static pointer pointer_to ( _Reftype _Val )
  {
  return ( :: std :: addressof ( _Val ) );
  }
 };
#line 239
template< class _Ty> 
#line 240
struct _Get_pointer_type { 
#line 241
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Ty::value_type *> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 245 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 246
struct _Get_const_pointer_type { 
#line 247
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::const_pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< const typename _Ty::value_type> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 252 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 253
struct _Get_void_pointer_type { 
#line 254
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::void_pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< void> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 259 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 260
struct _Get_const_void_pointer_type { 
#line 261
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::const_void_pointer> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename pointer_traits< typename _Get_pointer_type< _Ty> ::type> ::template rebind< const void> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 266 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 267
struct _Get_difference_type { 
#line 268
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::difference_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename _Get_ptr_difference_type< typename _Get_pointer_type< _Ty> ::type> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 273 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 274
struct _Get_size_type { 
#line 275
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::size_type> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< typename make_unsigned< typename _Get_difference_type< _Ty> ::type> ::type> ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 280 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 281
struct _Get_propagate_on_container_copy { 
#line 282
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::propagate_on_container_copy_assignment> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< integral_constant< bool, false> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 286 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 287
struct _Get_propagate_on_container_move { 
#line 288
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::propagate_on_container_move_assignment> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< integral_constant< bool, false> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 292 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
template< class _Ty> 
#line 293
struct _Get_propagate_on_container_swap { 
#line 294
template< class _Uty> static auto _Fn(int)->_Identity< typename _Uty::propagate_on_container_swap> ; template< class _Uty> static auto _Fn(_Wrap_int)->_Identity< integral_constant< bool, false> > ; typedef decltype((_Fn< _Ty> (0))) _Decltype; typedef typename _Decltype::type type; }; 
#line 298 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
struct _Alloc_allocate { 
#line 302
template < class _Alloc,
  class _Size_type,
  class _Const_void_pointer >
  static auto _Fn ( int, _Alloc & _Al,
   _Size_type _Count,
   _Const_void_pointer _Hint )
   -> decltype ( _Al . allocate ( _Count, _Hint ) )
  {
  return ( _Al . allocate ( _Count, _Hint ) );
  }
#line 313
template < class _Alloc,
  class _Size_type,
  class _Const_void_pointer >
  static auto _Fn ( _Wrap_int, _Alloc & _Al,
   _Size_type _Count,
   _Const_void_pointer )
   -> decltype ( _Al . allocate ( _Count ) )
  {
  return ( _Al . allocate ( _Count ) );
  }
#line 323
}; 
#line 326
struct _Alloc_construct { 
#line 330
template < class _Ty,
  class _Objty,
  class ... _Types >
  static auto _Fn ( int, _Ty & _Al, _Objty * _Ptr,
   _Types && ... _Args )
   -> decltype (
    _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... ) )
  {
  _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }
#line 341
template < class _Ty,
  class _Objty,
  class ... _Types >
  static auto _Fn ( _Wrap_int, _Ty &, _Objty * _Ptr,
   _Types && ... _Args )
   -> void
  {
  :: new ( static_cast < void * > ( _Ptr ) )
   _Objty ( :: std :: forward < _Types > ( _Args ) ... );
  }
#line 352
}; 
#line 355
struct _Alloc_destroy { 
#line 357
template < class _Ty,
  class _Objty >
  static auto _Fn ( int, _Ty & _Al, _Objty * _Ptr )
   -> decltype ( _Al . destroy ( _Ptr ) )
  {
  _Al . destroy ( _Ptr );
  }
#line 365
template < class _Ty,
  class _Objty >
  static auto _Fn ( _Wrap_int, _Ty &, _Objty * _Ptr )
   -> void
  {
  _Ptr -> ~ _Objty ( );
  }
#line 372
}; 
#line 375
struct _Alloc_max_size { 
#line 377
template < class _Ty >
  static auto _Fn ( int, const _Ty & _Al )
   -> decltype ( _Al . max_size ( ) )
  {
  return ( _Al . max_size ( ) );
  }
#line 384
template < class _Ty >
  static auto _Fn ( _Wrap_int, const _Ty & )
   -> typename _Get_size_type < _Ty > :: type
  {
  return ( ( numeric_limits < typename _Get_size_type < _Ty > :: type > :: max ) ( ) );
  }
#line 390
}; 
#line 393
struct _Alloc_select { 
#line 397
template < class _Ty >
  static auto _Fn ( int, const _Ty & _Al )
   -> decltype ( ( _Ty ) _Al . select_on_container_copy_construction ( ) )
  {
  return ( _Al . select_on_container_copy_construction ( ) );
  }
#line 404
template < class _Ty >
  static auto _Fn ( _Wrap_int, const _Ty & _Al )
   -> _Ty
  {
  return ( _Al );
  }
#line 410
}; 
#line 413
template < class _Alloc >
 struct allocator_traits
 {
 typedef allocator_traits < _Alloc > other;

 typedef _Alloc allocator_type;
 typedef typename _Alloc :: value_type value_type;

 typedef typename _Get_pointer_type < _Alloc > :: type
  pointer;
 typedef typename _Get_const_pointer_type < _Alloc > :: type
  const_pointer;
 typedef typename _Get_void_pointer_type < _Alloc > :: type
  void_pointer;
 typedef typename _Get_const_void_pointer_type < _Alloc > :: type
  const_void_pointer;

 typedef typename _Get_size_type < _Alloc > :: type size_type;
 typedef typename _Get_difference_type < _Alloc > :: type difference_type;

 typedef typename _Get_propagate_on_container_copy < _Alloc > :: type
  propagate_on_container_copy_assignment;
 typedef typename _Get_propagate_on_container_move < _Alloc > :: type
  propagate_on_container_move_assignment;
 typedef typename _Get_propagate_on_container_swap < _Alloc > :: type
  propagate_on_container_swap;

 template < class _Other >
  using rebind_alloc = typename _Get_rebind_type < _Alloc, _Other > :: type;

 template < class _Other >
  using rebind_traits = allocator_traits < rebind_alloc < _Other > >;

 static pointer allocate ( _Alloc & _Al, size_type _Count )
  {
  return ( _Al . allocate ( _Count ) );
  }

 static pointer allocate ( _Alloc & _Al, size_type _Count,
  const_void_pointer _Hint )
  {
  return ( _Alloc_allocate :: _Fn ( 0, _Al, _Count, _Hint ) );
  }

 static void deallocate ( _Alloc & _Al,
  pointer _Ptr, size_type _Count )
  {
  _Al . deallocate ( _Ptr, _Count );
  }

 template < class _Ty,
  class ... _Types >
  static void construct ( _Alloc & _Al, _Ty * _Ptr,
   _Types && ... _Args )
  {
  _Alloc_construct :: _Fn ( 0, _Al, _Ptr,
   :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Ty >
  static void destroy ( _Alloc & _Al, _Ty * _Ptr )
  {
  _Alloc_destroy :: _Fn ( 0, _Al, _Ptr );
  }

 static size_type max_size ( const _Alloc & _Al )
  {
  return ( _Alloc_max_size :: _Fn ( 0, _Al ) );
  }

 static _Alloc select_on_container_copy_construction (
  const _Alloc & _Al )
  {
  return ( _Alloc_select :: _Fn ( 0, _Al ) );
  }
 };
#line 492
template< class _Ty> 
#line 493
struct _Allocator_base { 
#line 495
typedef _Ty value_type; 
#line 496
}; 
#line 499
template< class _Ty> 
#line 500
struct _Allocator_base< const _Ty>  { 
#line 502
typedef _Ty value_type; 
#line 503
}; 
#line 506
template < class _Ty >
 class allocator
  : public _Allocator_base < _Ty >
 {
public :
 typedef allocator < _Ty > other;

 typedef _Allocator_base < _Ty > _Mybase;
 typedef typename _Mybase :: value_type value_type;

 typedef value_type * pointer;
 typedef const value_type * const_pointer;
 typedef void * void_pointer;
 typedef const void * const_void_pointer;

 typedef value_type & reference;
 typedef const value_type & const_reference;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef false_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;

 allocator < _Ty > select_on_container_copy_construction ( ) const
  {
  return ( * this );
  }

 template < class _Other >
  struct rebind
  {
  typedef allocator < _Other > other;
  };

 pointer address ( reference _Val ) const throw ( )
  {
  return ( :: std :: addressof ( _Val ) );
  }

 const_pointer address ( const_reference _Val ) const throw ( )
  {
  return ( :: std :: addressof ( _Val ) );
  }

 allocator ( ) throw ( )
  {
  }

 allocator ( const allocator < _Ty > & ) throw ( )
  {
  }

 template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }

 template < class _Other >
  allocator < _Ty > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }

 void deallocate ( pointer _Ptr, size_type )
  {
  :: operator delete ( _Ptr );
  }

 pointer allocate ( size_type _Count )
  {
  return ( _Allocate ( _Count, ( pointer ) 0 ) );
  }

 pointer allocate ( size_type _Count, const void * )
  {
  return ( allocate ( _Count ) );
  }

 void construct ( _Ty * _Ptr )
  {
  :: new ( ( void * ) _Ptr ) _Ty ( );
  }

 void construct ( _Ty * _Ptr, const _Ty & _Val )
  {
  :: new ( ( void * ) _Ptr ) _Ty ( _Val );
  }

 template < class _Objty,
  class ... _Types >
  void construct ( _Objty * _Ptr, _Types && ... _Args )
  {
  :: new ( ( void * ) _Ptr ) _Objty ( :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Uty >
  void destroy ( _Uty * _Ptr )
  {
  _Ptr -> ~ _Uty ( );
  }

 size_t max_size ( ) const throw ( )
  {
  return ( ( size_t ) ( - 1 ) / sizeof ( _Ty ) );
  }
 };
#line 618
#pragma pack(8)
template<> 
#line 618
class allocator< void>  { 
#line 621
public: typedef std::allocator< void>  other; 
#line 623
typedef void value_type; 
#line 625
typedef void *pointer; 
#line 626
typedef const void *const_pointer; 
#line 627
typedef void *void_pointer; 
#line 628
typedef const void *const_void_pointer; 
#line 630
template< class _Other> 
#line 631
struct rebind { 
#line 633
typedef std::allocator< _Other>  other; 
#line 634
}; 
#line 636
allocator() throw() 
#line 637
{ 
#line 638
} 
#line 640
allocator(const std::allocator< void>  &) throw() 
#line 641
{ 
#line 642
} 
#line 644
template < class _Other >
  allocator ( const allocator < _Other > & ) throw ( )
  {
  }
#line 649
template < class _Other >
  allocator < void > & operator = ( const allocator < _Other > & )
  {
  return ( * this );
  }
#line 654
}; 
#pragma pack(8)
template < class _Ty,
 class _Other > inline
 bool operator == ( const allocator < _Ty > &,
  const allocator < _Other > & ) throw ( )
 {
 return ( true );
 }
#line 664
template < class _Ty,
 class _Other > inline
 bool operator != ( const allocator < _Ty > & _Left,
  const allocator < _Other > & _Right ) throw ( )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 673
template < class _Ty >
 struct allocator_traits < allocator < _Ty > >
 {
 typedef allocator < _Ty > _Alloc;

 typedef allocator_traits < _Alloc > other;

 typedef _Alloc allocator_type;
 typedef typename _Alloc :: value_type value_type;

 typedef value_type * pointer;
 typedef const value_type * const_pointer;
 typedef void * void_pointer;
 typedef const void * const_void_pointer;

 typedef size_t size_type;
 typedef ptrdiff_t difference_type;

 typedef false_type propagate_on_container_copy_assignment;
 typedef false_type propagate_on_container_move_assignment;
 typedef false_type propagate_on_container_swap;

 template < class _Other >
  using rebind_alloc = allocator < _Other >;

 template < class _Other >
  using rebind_traits = allocator_traits < allocator < _Other > >;

 static pointer allocate ( _Alloc & _Al, size_type _Count )
  {
  return ( _Al . allocate ( _Count ) );
  }

 static pointer allocate ( _Alloc & _Al, size_type _Count,
  const_void_pointer _Hint )
  {
  return ( _Al . allocate ( _Count, _Hint ) );
  }

 static void deallocate ( _Alloc & _Al,
  pointer _Ptr, size_type _Count )
  {
  _Al . deallocate ( _Ptr, _Count );
  }

 template < class _Objty,
  class ... _Types >
  static void construct ( _Alloc & _Al, _Objty * _Ptr,
   _Types && ... _Args )
  {
  _Al . construct ( _Ptr, :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Uty >
  static void destroy ( _Alloc & _Al, _Uty * _Ptr )
  {
  _Al . destroy ( _Ptr );
  }

 static size_type max_size ( const _Alloc & _Al )
  {
  return ( _Al . max_size ( ) );
  }

 static _Alloc select_on_container_copy_construction (
  const _Alloc & _Al )
  {
  return ( _Al . select_on_container_copy_construction ( ) );
  }
 };
#line 746
template < class _Alloc >
 struct _Wrap_alloc
  : public _Alloc
 {
 typedef _Wrap_alloc < _Alloc > other;

 typedef _Alloc _Mybase;
 typedef allocator_traits < _Alloc > _Mytraits;

 typedef typename _Mytraits :: value_type value_type;

 typedef typename _Mytraits :: pointer pointer;
 typedef typename _Mytraits :: const_pointer const_pointer;
 typedef typename _Mytraits :: void_pointer void_pointer;
 typedef typename _Mytraits :: const_void_pointer const_void_pointer;

 typedef typename _If < is_void < value_type > :: value,
  int, value_type > :: type & reference;
 typedef typename _If < is_void < const value_type > :: value,
  const int, const value_type > :: type & const_reference;

 typedef typename _Mytraits :: size_type size_type;
 typedef typename _Mytraits :: difference_type difference_type;

 typedef typename _Mytraits :: propagate_on_container_copy_assignment
  propagate_on_container_copy_assignment;
 typedef typename _Mytraits :: propagate_on_container_move_assignment
  propagate_on_container_move_assignment;
 typedef typename _Mytraits :: propagate_on_container_swap
  propagate_on_container_swap;

 _Wrap_alloc select_on_container_copy_construction ( ) const
  {
  return ( _Mytraits :: select_on_container_copy_construction ( * this ) );
  }

 template < class _Other >
  struct rebind
  {
  typedef typename _Mytraits :: template rebind_alloc < _Other > _Other_alloc;
  typedef _Wrap_alloc < _Other_alloc > other;
  };

 pointer address ( reference _Val ) const
  {
  return ( :: std :: addressof ( _Val ) );
  }

 const_pointer address ( const_reference _Val ) const
  {
  return ( :: std :: addressof ( _Val ) );
  }

 _Wrap_alloc ( ) throw ( )
  : _Mybase ( )
  {
  }

 _Wrap_alloc ( const _Mybase & _Right ) throw ( )
  : _Mybase ( _Right )
  {
  }

 _Wrap_alloc ( const _Wrap_alloc & _Right ) throw ( )
  : _Mybase ( _Right )
  {
  }

 template < class _Other >
  _Wrap_alloc ( const _Other & _Right ) throw ( )
  : _Mybase ( _Right )
  {
  }

 template < class _Other >
  _Wrap_alloc ( _Other & _Right ) throw ( )
  : _Mybase ( _Right )
  {
  }

 _Wrap_alloc & operator = ( const _Mybase & _Right )
  {
  _Mybase :: operator = ( _Right );
  return ( * this );
  }

 _Wrap_alloc & operator = ( const _Wrap_alloc & _Right )
  {
  _Mybase :: operator = ( _Right );
  return ( * this );
  }

 template < class _Other >
  _Wrap_alloc & operator = ( const _Other & _Right )
  {
  _Mybase :: operator = ( _Right );
  return ( * this );
  }

 pointer allocate ( size_type _Count )
  {
  return ( _Mybase :: allocate ( _Count ) );
  }

 pointer allocate ( size_type _Count,
  const_void_pointer _Hint )
  {
  return ( _Mytraits :: allocate ( * this, _Count, _Hint ) );
  }

 void deallocate ( pointer _Ptr, size_type _Count )
  {
  _Mybase :: deallocate ( _Ptr, _Count );
  }

 void construct ( value_type * _Ptr )
  {
  _Mytraits :: construct ( * this, _Ptr );
  }

 template < class _Ty,
  class ... _Types >
  void construct ( _Ty * _Ptr,
   _Types && ... _Args )
  {
  _Mytraits :: construct ( * this, _Ptr,
   :: std :: forward < _Types > ( _Args ) ... );
  }


 template < class _Ty >
  void destroy ( _Ty * _Ptr )
  {
  _Mytraits :: destroy ( * this, _Ptr );
  }

 size_type max_size ( ) const throw ( )
  {
  return ( _Mytraits :: max_size ( * this ) );
  }
 };
#line 888
template < class _Ty,
 class _Other > inline
 bool operator == ( const _Wrap_alloc < _Ty > & _Left,
  const _Wrap_alloc < _Other > & _Right ) throw ( )
 {
 return ( static_cast < _Ty > ( _Left ) == static_cast < _Other > ( _Right ) );
 }
#line 896
template < class _Ty,
 class _Other > inline
 bool operator != ( const _Wrap_alloc < _Ty > & _Left,
  const _Wrap_alloc < _Other > & _Right ) throw ( )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 903
}
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xatomic0.h"
#pragma warning(push,3)
#line 8
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 26 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xatomic0.h"
typedef 
#line 19
enum memory_order { 
#line 20
memory_order_relaxed, 
#line 21
memory_order_consume, 
#line 22
memory_order_acquire, 
#line 23
memory_order_release, 
#line 24
memory_order_acq_rel, 
#line 25
memory_order_seq_cst
#line 26
} memory_order; 
#line 28
typedef _Uint32t _Uint4_t; 
#line 29
typedef _Uint4_t _Atomic_integral_t; 
#line 70 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xatomic0.h"
typedef long _Atomic_flag_t; 
#line 77
inline _Uint4_t _Atomic_load_4(volatile _Uint4_t *, memory_order); 
#line 78
inline int _Atomic_compare_exchange_weak_4(volatile _Uint4_t *, _Uint4_t *, _Uint4_t, memory_order, memory_order); 
#line 80
inline _Uint4_t _Atomic_fetch_add_4(volatile _Uint4_t *, _Uint4_t, memory_order); 
#line 82
inline _Uint4_t _Atomic_fetch_sub_4(volatile _Uint4_t *, _Uint4_t, memory_order); 
#line 85
typedef _Atomic_integral_t _Atomic_counter_t; 
#line 89
inline _Atomic_integral_t _Get_atomic_count(const _Atomic_counter_t &_Counter) 
#line 90
{ 
#line 91
return _Counter; 
#line 92
} 
#line 94
inline void _Init_atomic_counter(_Atomic_counter_t &_Counter, _Atomic_integral_t 
#line 95
_Value) 
#line 96
{ 
#line 97
_Counter = _Value; 
#line 98
} 
#line 100
inline _Atomic_integral_t _Inc_atomic_counter_explicit(_Atomic_counter_t &
#line 101
_Counter, memory_order _Order) 
#line 102
{ 
#line 103
return _Atomic_fetch_add_4(&_Counter, 1, _Order) + (1); 
#line 104
} 
#line 106
inline _Atomic_integral_t _Inc_atomic_counter(_Atomic_counter_t &_Counter) 
#line 107
{ 
#line 108
return _Inc_atomic_counter_explicit(_Counter, memory_order_seq_cst); 
#line 109
} 
#line 111
inline _Atomic_integral_t _Dec_atomic_counter_explicit(_Atomic_counter_t &
#line 112
_Counter, memory_order _Order) 
#line 113
{ 
#line 114
return _Atomic_fetch_sub_4(&_Counter, 1, _Order) - (1); 
#line 115
} 
#line 117
inline _Atomic_integral_t _Dec_atomic_counter(_Atomic_counter_t &_Counter) 
#line 118
{ 
#line 119
return _Dec_atomic_counter_explicit(_Counter, memory_order_seq_cst); 
#line 120
} 
#line 122
inline _Atomic_integral_t _Load_atomic_counter_explicit(_Atomic_counter_t &
#line 123
_Counter, memory_order _Order) 
#line 124
{ 
#line 125
return _Atomic_load_4(&_Counter, _Order); 
#line 126
} 
#line 128
inline _Atomic_integral_t _Load_atomic_counter(_Atomic_counter_t &_Counter) 
#line 129
{ 
#line 130
return _Load_atomic_counter_explicit(_Counter, memory_order_seq_cst); 
#line 131
} 
#line 133
inline _Atomic_integral_t _Compare_increment_atomic_counter_explicit(_Atomic_counter_t &
#line 134
_Counter, _Atomic_integral_t 
#line 135
_Expected, memory_order 
#line 136
_Order) 
#line 137
{ 
#line 138
return _Atomic_compare_exchange_weak_4(&_Counter, &_Expected, _Expected + (1), _Order, _Order); 
#line 141
} 
#line 143
inline _Atomic_integral_t _Compare_increment_atomic_counter(_Atomic_counter_t &
#line 144
_Counter, _Atomic_integral_t _Expected) 
#line 145
{ 
#line 146
return _Compare_increment_atomic_counter_explicit(_Counter, _Expected, memory_order_seq_cst); 
#line 148
} 
#line 185 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xatomic0.h"
extern "C" { __declspec(dllimport) void __cdecl _Lock_shared_ptr_spin_lock(); } 
#line 186
extern "C" { __declspec(dllimport) void __cdecl _Unlock_shared_ptr_spin_lock(); } 
#line 188
}
#line 190
#pragma warning(pop)
#pragma pack ( pop )
#line 37 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\setjmp.h"
#pragma pack ( push, 8 )
#line 75 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\setjmp.h"
extern "C" { typedef 
#line 63
struct __JUMP_BUFFER { 
#line 64
unsigned long Ebp; 
#line 65
unsigned long Ebx; 
#line 66
unsigned long Edi; 
#line 67
unsigned long Esi; 
#line 68
unsigned long Esp; 
#line 69
unsigned long Eip; 
#line 70
unsigned long Registration; 
#line 71
unsigned long TryLevel; 
#line 72
unsigned long Cookie; 
#line 73
unsigned long UnwindFunc; 
#line 74
unsigned long UnwindData[6]; 
#line 75
} _JUMP_BUFFER; }
#line 167 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\setjmp.h"
extern "C" { typedef int jmp_buf[16]; }
#line 175 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\setjmp.h"
extern "C" { int __cdecl _setjmp(jmp_buf _Buf); } 
#line 182 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\setjmp.h"
#pragma warning(push)
#pragma warning(disable:4987)
#line 186
extern "C" { __declspec(dllimport) __declspec(noreturn) void __cdecl longjmp(jmp_buf _Buf, int _Value) throw(...); } 
#line 188
#pragma warning(pop)
#line 193 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\setjmp.h"
#pragma pack ( pop )
#line 42 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\mmintrin.h"
extern "C" { typedef 
#line 31
union __declspec(intrin_type) __declspec(align(8)) __m64 { 
#line 33
unsigned __int64 m64_u64; 
#line 34
float m64_f32[2]; 
#line 35
char m64_i8[8]; 
#line 36
short m64_i16[4]; 
#line 37
int m64_i32[2]; 
#line 38
__int64 m64_i64; 
#line 39
unsigned char m64_u8[8]; 
#line 40
unsigned short m64_u16[4]; 
#line 41
unsigned m64_u32[2]; 
#line 42
} __m64; }
#line 45
extern "C" { void _m_empty(); } 
#line 46
extern "C" { __m64 _m_from_int(int _I); } 
#line 47
extern "C" { int _m_to_int(__m64 _M); } 
#line 48
extern "C" { __m64 _m_packsswb(__m64 _MM1, __m64 _MM2); } 
#line 49
extern "C" { __m64 _m_packssdw(__m64 _MM1, __m64 _MM2); } 
#line 50
extern "C" { __m64 _m_packuswb(__m64 _MM1, __m64 _MM2); } 
#line 51
extern "C" { __m64 _m_punpckhbw(__m64 _MM1, __m64 _MM2); } 
#line 52
extern "C" { __m64 _m_punpckhwd(__m64 _MM1, __m64 _MM2); } 
#line 53
extern "C" { __m64 _m_punpckhdq(__m64 _MM1, __m64 _MM2); } 
#line 54
extern "C" { __m64 _m_punpcklbw(__m64 _MM1, __m64 _MM2); } 
#line 55
extern "C" { __m64 _m_punpcklwd(__m64 _MM1, __m64 _MM2); } 
#line 56
extern "C" { __m64 _m_punpckldq(__m64 _MM1, __m64 _MM2); } 
#line 59
extern "C" { __m64 _m_paddb(__m64 _MM1, __m64 _MM2); } 
#line 60
extern "C" { __m64 _m_paddw(__m64 _MM1, __m64 _MM2); } 
#line 61
extern "C" { __m64 _m_paddd(__m64 _MM1, __m64 _MM2); } 
#line 62
extern "C" { __m64 _m_paddsb(__m64 _MM1, __m64 _MM2); } 
#line 63
extern "C" { __m64 _m_paddsw(__m64 _MM1, __m64 _MM2); } 
#line 64
extern "C" { __m64 _m_paddusb(__m64 _MM1, __m64 _MM2); } 
#line 65
extern "C" { __m64 _m_paddusw(__m64 _MM1, __m64 _MM2); } 
#line 66
extern "C" { __m64 _m_psubb(__m64 _MM1, __m64 _MM2); } 
#line 67
extern "C" { __m64 _m_psubw(__m64 _MM1, __m64 _MM2); } 
#line 68
extern "C" { __m64 _m_psubd(__m64 _MM1, __m64 _MM2); } 
#line 69
extern "C" { __m64 _m_psubsb(__m64 _MM1, __m64 _MM2); } 
#line 70
extern "C" { __m64 _m_psubsw(__m64 _MM1, __m64 _MM2); } 
#line 71
extern "C" { __m64 _m_psubusb(__m64 _MM1, __m64 _MM2); } 
#line 72
extern "C" { __m64 _m_psubusw(__m64 _MM1, __m64 _MM2); } 
#line 73
extern "C" { __m64 _m_pmaddwd(__m64 _MM1, __m64 _MM2); } 
#line 74
extern "C" { __m64 _m_pmulhw(__m64 _MM1, __m64 _MM2); } 
#line 75
extern "C" { __m64 _m_pmullw(__m64 _MM1, __m64 _MM2); } 
#line 78
extern "C" { __m64 _m_psllw(__m64 _M, __m64 _Count); } 
#line 79
extern "C" { __m64 _m_psllwi(__m64 _M, int _Count); } 
#line 80
extern "C" { __m64 _m_pslld(__m64 _M, __m64 _Count); } 
#line 81
extern "C" { __m64 _m_pslldi(__m64 _M, int _Count); } 
#line 82
extern "C" { __m64 _m_psllq(__m64 _M, __m64 _Count); } 
#line 83
extern "C" { __m64 _m_psllqi(__m64 _M, int _Count); } 
#line 84
extern "C" { __m64 _m_psraw(__m64 _M, __m64 _Count); } 
#line 85
extern "C" { __m64 _m_psrawi(__m64 _M, int _Count); } 
#line 86
extern "C" { __m64 _m_psrad(__m64 _M, __m64 _Count); } 
#line 87
extern "C" { __m64 _m_psradi(__m64 _M, int _Count); } 
#line 88
extern "C" { __m64 _m_psrlw(__m64 _M, __m64 _Count); } 
#line 89
extern "C" { __m64 _m_psrlwi(__m64 _M, int _Count); } 
#line 90
extern "C" { __m64 _m_psrld(__m64 _M, __m64 _Count); } 
#line 91
extern "C" { __m64 _m_psrldi(__m64 _M, int _Count); } 
#line 92
extern "C" { __m64 _m_psrlq(__m64 _M, __m64 _Count); } 
#line 93
extern "C" { __m64 _m_psrlqi(__m64 _M, int _Count); } 
#line 96
extern "C" { __m64 _m_pand(__m64 _MM1, __m64 _MM2); } 
#line 97
extern "C" { __m64 _m_pandn(__m64 _MM1, __m64 _MM2); } 
#line 98
extern "C" { __m64 _m_por(__m64 _MM1, __m64 _MM2); } 
#line 99
extern "C" { __m64 _m_pxor(__m64 _MM1, __m64 _MM2); } 
#line 102
extern "C" { __m64 _m_pcmpeqb(__m64 _MM1, __m64 _MM2); } 
#line 103
extern "C" { __m64 _m_pcmpeqw(__m64 _MM1, __m64 _MM2); } 
#line 104
extern "C" { __m64 _m_pcmpeqd(__m64 _MM1, __m64 _MM2); } 
#line 105
extern "C" { __m64 _m_pcmpgtb(__m64 _MM1, __m64 _MM2); } 
#line 106
extern "C" { __m64 _m_pcmpgtw(__m64 _MM1, __m64 _MM2); } 
#line 107
extern "C" { __m64 _m_pcmpgtd(__m64 _MM1, __m64 _MM2); } 
#line 110
extern "C" { __m64 _mm_setzero_si64(); } 
#line 111
extern "C" { __m64 _mm_set_pi32(int _I1, int _I0); } 
#line 112
extern "C" { __m64 _mm_set_pi16(short _S3, short _S2, short _S1, short _S0); } 
#line 113
extern "C" { __m64 _mm_set_pi8(char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); } 
#line 115
extern "C" { __m64 _mm_set1_pi32(int _I); } 
#line 116
extern "C" { __m64 _mm_set1_pi16(short _S); } 
#line 117
extern "C" { __m64 _mm_set1_pi8(char _B); } 
#line 118
extern "C" { __m64 _mm_setr_pi32(int _I1, int _I0); } 
#line 119
extern "C" { __m64 _mm_setr_pi16(short _S3, short _S2, short _S1, short _S0); } 
#line 120
extern "C" { __m64 _mm_setr_pi8(char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); } 
#line 70 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmmintrin.h"
typedef 
#line 60
union __declspec(intrin_type) __declspec(align(16)) __m128 { 
#line 61
float m128_f32[4]; 
#line 62
unsigned __int64 m128_u64[2]; 
#line 63
char m128_i8[16]; 
#line 64
short m128_i16[8]; 
#line 65
int m128_i32[4]; 
#line 66
__int64 m128_i64[2]; 
#line 67
unsigned char m128_u8[16]; 
#line 68
unsigned short m128_u16[8]; 
#line 69
unsigned m128_u32[4]; 
#line 70
} __m128; 
#line 186 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmmintrin.h"
extern "C" { extern __m128 _mm_add_ss(__m128 _A, __m128 _B); } 
#line 187
extern "C" { extern __m128 _mm_add_ps(__m128 _A, __m128 _B); } 
#line 188
extern "C" { extern __m128 _mm_sub_ss(__m128 _A, __m128 _B); } 
#line 189
extern "C" { extern __m128 _mm_sub_ps(__m128 _A, __m128 _B); } 
#line 190
extern "C" { extern __m128 _mm_mul_ss(__m128 _A, __m128 _B); } 
#line 191
extern "C" { extern __m128 _mm_mul_ps(__m128 _A, __m128 _B); } 
#line 192
extern "C" { extern __m128 _mm_div_ss(__m128 _A, __m128 _B); } 
#line 193
extern "C" { extern __m128 _mm_div_ps(__m128 _A, __m128 _B); } 
#line 194
extern "C" { extern __m128 _mm_sqrt_ss(__m128 _A); } 
#line 195
extern "C" { extern __m128 _mm_sqrt_ps(__m128 _A); } 
#line 196
extern "C" { extern __m128 _mm_rcp_ss(__m128 _A); } 
#line 197
extern "C" { extern __m128 _mm_rcp_ps(__m128 _A); } 
#line 198
extern "C" { extern __m128 _mm_rsqrt_ss(__m128 _A); } 
#line 199
extern "C" { extern __m128 _mm_rsqrt_ps(__m128 _A); } 
#line 200
extern "C" { extern __m128 _mm_min_ss(__m128 _A, __m128 _B); } 
#line 201
extern "C" { extern __m128 _mm_min_ps(__m128 _A, __m128 _B); } 
#line 202
extern "C" { extern __m128 _mm_max_ss(__m128 _A, __m128 _B); } 
#line 203
extern "C" { extern __m128 _mm_max_ps(__m128 _A, __m128 _B); } 
#line 209
extern "C" { extern __m128 _mm_and_ps(__m128 _A, __m128 _B); } 
#line 210
extern "C" { extern __m128 _mm_andnot_ps(__m128 _A, __m128 _B); } 
#line 211
extern "C" { extern __m128 _mm_or_ps(__m128 _A, __m128 _B); } 
#line 212
extern "C" { extern __m128 _mm_xor_ps(__m128 _A, __m128 _B); } 
#line 218
extern "C" { extern __m128 _mm_cmpeq_ss(__m128 _A, __m128 _B); } 
#line 219
extern "C" { extern __m128 _mm_cmpeq_ps(__m128 _A, __m128 _B); } 
#line 220
extern "C" { extern __m128 _mm_cmplt_ss(__m128 _A, __m128 _B); } 
#line 221
extern "C" { extern __m128 _mm_cmplt_ps(__m128 _A, __m128 _B); } 
#line 222
extern "C" { extern __m128 _mm_cmple_ss(__m128 _A, __m128 _B); } 
#line 223
extern "C" { extern __m128 _mm_cmple_ps(__m128 _A, __m128 _B); } 
#line 224
extern "C" { extern __m128 _mm_cmpgt_ss(__m128 _A, __m128 _B); } 
#line 225
extern "C" { extern __m128 _mm_cmpgt_ps(__m128 _A, __m128 _B); } 
#line 226
extern "C" { extern __m128 _mm_cmpge_ss(__m128 _A, __m128 _B); } 
#line 227
extern "C" { extern __m128 _mm_cmpge_ps(__m128 _A, __m128 _B); } 
#line 228
extern "C" { extern __m128 _mm_cmpneq_ss(__m128 _A, __m128 _B); } 
#line 229
extern "C" { extern __m128 _mm_cmpneq_ps(__m128 _A, __m128 _B); } 
#line 230
extern "C" { extern __m128 _mm_cmpnlt_ss(__m128 _A, __m128 _B); } 
#line 231
extern "C" { extern __m128 _mm_cmpnlt_ps(__m128 _A, __m128 _B); } 
#line 232
extern "C" { extern __m128 _mm_cmpnle_ss(__m128 _A, __m128 _B); } 
#line 233
extern "C" { extern __m128 _mm_cmpnle_ps(__m128 _A, __m128 _B); } 
#line 234
extern "C" { extern __m128 _mm_cmpngt_ss(__m128 _A, __m128 _B); } 
#line 235
extern "C" { extern __m128 _mm_cmpngt_ps(__m128 _A, __m128 _B); } 
#line 236
extern "C" { extern __m128 _mm_cmpnge_ss(__m128 _A, __m128 _B); } 
#line 237
extern "C" { extern __m128 _mm_cmpnge_ps(__m128 _A, __m128 _B); } 
#line 238
extern "C" { extern __m128 _mm_cmpord_ss(__m128 _A, __m128 _B); } 
#line 239
extern "C" { extern __m128 _mm_cmpord_ps(__m128 _A, __m128 _B); } 
#line 240
extern "C" { extern __m128 _mm_cmpunord_ss(__m128 _A, __m128 _B); } 
#line 241
extern "C" { extern __m128 _mm_cmpunord_ps(__m128 _A, __m128 _B); } 
#line 242
extern "C" { extern int _mm_comieq_ss(__m128 _A, __m128 _B); } 
#line 243
extern "C" { extern int _mm_comilt_ss(__m128 _A, __m128 _B); } 
#line 244
extern "C" { extern int _mm_comile_ss(__m128 _A, __m128 _B); } 
#line 245
extern "C" { extern int _mm_comigt_ss(__m128 _A, __m128 _B); } 
#line 246
extern "C" { extern int _mm_comige_ss(__m128 _A, __m128 _B); } 
#line 247
extern "C" { extern int _mm_comineq_ss(__m128 _A, __m128 _B); } 
#line 248
extern "C" { extern int _mm_ucomieq_ss(__m128 _A, __m128 _B); } 
#line 249
extern "C" { extern int _mm_ucomilt_ss(__m128 _A, __m128 _B); } 
#line 250
extern "C" { extern int _mm_ucomile_ss(__m128 _A, __m128 _B); } 
#line 251
extern "C" { extern int _mm_ucomigt_ss(__m128 _A, __m128 _B); } 
#line 252
extern "C" { extern int _mm_ucomige_ss(__m128 _A, __m128 _B); } 
#line 253
extern "C" { extern int _mm_ucomineq_ss(__m128 _A, __m128 _B); } 
#line 259
extern "C" { extern int _mm_cvt_ss2si(__m128 _A); } 
#line 260
extern "C" { extern __m64 _mm_cvt_ps2pi(__m128 _A); } 
#line 261
extern "C" { extern int _mm_cvtt_ss2si(__m128 _A); } 
#line 262
extern "C" { extern __m64 _mm_cvtt_ps2pi(__m128 _A); } 
#line 263
extern "C" { extern __m128 _mm_cvt_si2ss(__m128, int); } 
#line 264
extern "C" { extern __m128 _mm_cvt_pi2ps(__m128, __m64); } 
#line 265
extern "C" { extern float _mm_cvtss_f32(__m128 _A); } 
#line 280 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmmintrin.h"
extern "C" { extern __m128 _mm_shuffle_ps(__m128 _A, __m128 _B, unsigned _Imm8); } 
#line 281
extern "C" { extern __m128 _mm_unpackhi_ps(__m128 _A, __m128 _B); } 
#line 282
extern "C" { extern __m128 _mm_unpacklo_ps(__m128 _A, __m128 _B); } 
#line 283
extern "C" { extern __m128 _mm_loadh_pi(__m128, const __m64 *); } 
#line 284
extern "C" { extern __m128 _mm_movehl_ps(__m128, __m128); } 
#line 285
extern "C" { extern __m128 _mm_movelh_ps(__m128, __m128); } 
#line 286
extern "C" { extern void _mm_storeh_pi(__m64 *, __m128); } 
#line 287
extern "C" { extern __m128 _mm_loadl_pi(__m128, const __m64 *); } 
#line 288
extern "C" { extern void _mm_storel_pi(__m64 *, __m128); } 
#line 289
extern "C" { extern int _mm_movemask_ps(__m128 _A); } 
#line 295
extern "C" { extern int _m_pextrw(__m64, int); } 
#line 296
extern "C" { extern __m64 _m_pinsrw(__m64, int, int); } 
#line 297
extern "C" { extern __m64 _m_pmaxsw(__m64, __m64); } 
#line 298
extern "C" { extern __m64 _m_pmaxub(__m64, __m64); } 
#line 299
extern "C" { extern __m64 _m_pminsw(__m64, __m64); } 
#line 300
extern "C" { extern __m64 _m_pminub(__m64, __m64); } 
#line 301
extern "C" { extern int _m_pmovmskb(__m64); } 
#line 302
extern "C" { extern __m64 _m_pmulhuw(__m64, __m64); } 
#line 303
extern "C" { extern __m64 _m_pshufw(__m64, int); } 
#line 304
extern "C" { extern void _m_maskmovq(__m64, __m64, char *); } 
#line 305
extern "C" { extern __m64 _m_pavgb(__m64, __m64); } 
#line 306
extern "C" { extern __m64 _m_pavgw(__m64, __m64); } 
#line 307
extern "C" { extern __m64 _m_psadbw(__m64, __m64); } 
#line 313
extern "C" { extern __m128 _mm_set_ss(float _A); } 
#line 314
extern "C" { extern __m128 _mm_set_ps1(float _A); } 
#line 315
extern "C" { extern __m128 _mm_set_ps(float _A, float _B, float _C, float _D); } 
#line 316
extern "C" { extern __m128 _mm_setr_ps(float _A, float _B, float _C, float _D); } 
#line 317
extern "C" { extern __m128 _mm_setzero_ps(); } 
#line 318
extern "C" { extern __m128 _mm_load_ss(const float * _A); } 
#line 319
extern "C" { extern __m128 _mm_load_ps1(const float * _A); } 
#line 320
extern "C" { extern __m128 _mm_load_ps(const float * _A); } 
#line 321
extern "C" { extern __m128 _mm_loadr_ps(const float * _A); } 
#line 322
extern "C" { extern __m128 _mm_loadu_ps(const float * _A); } 
#line 323
extern "C" { extern void _mm_store_ss(float * _V, __m128 _A); } 
#line 324
extern "C" { extern void _mm_store_ps1(float * _V, __m128 _A); } 
#line 325
extern "C" { extern void _mm_store_ps(float * _V, __m128 _A); } 
#line 326
extern "C" { extern void _mm_storer_ps(float * _V, __m128 _A); } 
#line 327
extern "C" { extern void _mm_storeu_ps(float * _V, __m128 _A); } 
#line 328
extern "C" { extern void _mm_prefetch(const char * _A, int _Sel); } 
#line 329
extern "C" { extern void _mm_stream_pi(__m64 *, __m64); } 
#line 330
extern "C" { extern void _mm_stream_ps(float *, __m128); } 
#line 331
extern "C" { extern __m128 _mm_move_ss(__m128 _A, __m128 _B); } 
#line 333
extern "C" { extern void _mm_sfence(); } 
#line 334
extern "C" { extern unsigned _mm_getcsr(); } 
#line 335
extern "C" { extern void _mm_setcsr(unsigned); } 
#line 378
extern "C" { __inline __m128 _mm_cvtpi16_ps(__m64 a) 
#line 379
{ 
#line 380
__m128 tmp; 
#line 381
__m64 ext_val = _m_pcmpgtw(_mm_setzero_si64(), a); 
#line 383
tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val)); 
#line 384
return _mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp), _m_punpcklwd(a, ext_val)); 
#line 386
} } 
#line 397
extern "C" { __inline __m128 _mm_cvtpu16_ps(__m64 a) 
#line 398
{ 
#line 399
__m128 tmp; 
#line 400
__m64 ext_val = _mm_setzero_si64(); 
#line 402
tmp = _mm_cvt_pi2ps(_mm_setzero_ps(), _m_punpckhwd(a, ext_val)); 
#line 403
return _mm_cvt_pi2ps(_mm_movelh_ps(tmp, tmp), _m_punpcklwd(a, ext_val)); 
#line 405
} } 
#line 416
extern "C" { __inline __m64 _mm_cvtps_pi16(__m128 a) 
#line 417
{ 
#line 418
return _m_packssdw(_mm_cvt_ps2pi(a), _mm_cvt_ps2pi(_mm_movehl_ps(a, a))); 
#line 420
} } 
#line 431
extern "C" { __inline __m128 _mm_cvtpi8_ps(__m64 a) 
#line 432
{ 
#line 433
__m64 ext_val = _m_pcmpgtb(_mm_setzero_si64(), a); 
#line 435
return _mm_cvtpi16_ps(_m_punpcklbw(a, ext_val)); 
#line 436
} } 
#line 448
extern "C" { __inline __m128 _mm_cvtpu8_ps(__m64 a) 
#line 449
{ 
#line 450
return _mm_cvtpu16_ps(_m_punpcklbw(a, _mm_setzero_si64())); 
#line 451
} } 
#line 462
extern "C" { __inline __m64 _mm_cvtps_pi8(__m128 a) 
#line 463
{ 
#line 464
return _m_packsswb(_mm_cvtps_pi16(a), _mm_setzero_si64()); 
#line 465
} } 
#line 477
extern "C" { __inline __m128 _mm_cvtpi32x2_ps(__m64 a, __m64 b) 
#line 478
{ 
#line 479
return _mm_movelh_ps(_mm_cvt_pi2ps(_mm_setzero_ps(), a), _mm_cvt_pi2ps(_mm_setzero_ps(), b)); 
#line 481
} } 
#line 44 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\emmintrin.h"
typedef 
#line 35
union __declspec(intrin_type) __declspec(align(16)) __m128i { 
#line 36
char m128i_i8[16]; 
#line 37
short m128i_i16[8]; 
#line 38
int m128i_i32[4]; 
#line 39
__int64 m128i_i64[2]; 
#line 40
unsigned char m128i_u8[16]; 
#line 41
unsigned short m128i_u16[8]; 
#line 42
unsigned m128i_u32[4]; 
#line 43
unsigned __int64 m128i_u64[2]; 
#line 44
} __m128i; 
#line 48
typedef 
#line 46
struct __declspec(intrin_type) __declspec(align(16)) __m128d { 
#line 47
double m128d_f64[2]; 
#line 48
} __m128d; 
#line 68 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\emmintrin.h"
extern "C" { extern __m128d _mm_add_sd(__m128d _A, __m128d _B); } 
#line 69
extern "C" { extern __m128d _mm_add_pd(__m128d _A, __m128d _B); } 
#line 70
extern "C" { extern __m128d _mm_sub_sd(__m128d _A, __m128d _B); } 
#line 71
extern "C" { extern __m128d _mm_sub_pd(__m128d _A, __m128d _B); } 
#line 72
extern "C" { extern __m128d _mm_mul_sd(__m128d _A, __m128d _B); } 
#line 73
extern "C" { extern __m128d _mm_mul_pd(__m128d _A, __m128d _B); } 
#line 74
extern "C" { extern __m128d _mm_sqrt_sd(__m128d _A, __m128d _B); } 
#line 75
extern "C" { extern __m128d _mm_sqrt_pd(__m128d _A); } 
#line 76
extern "C" { extern __m128d _mm_div_sd(__m128d _A, __m128d _B); } 
#line 77
extern "C" { extern __m128d _mm_div_pd(__m128d _A, __m128d _B); } 
#line 78
extern "C" { extern __m128d _mm_min_sd(__m128d _A, __m128d _B); } 
#line 79
extern "C" { extern __m128d _mm_min_pd(__m128d _A, __m128d _B); } 
#line 80
extern "C" { extern __m128d _mm_max_sd(__m128d _A, __m128d _B); } 
#line 81
extern "C" { extern __m128d _mm_max_pd(__m128d _A, __m128d _B); } 
#line 87
extern "C" { extern __m128d _mm_and_pd(__m128d _A, __m128d _B); } 
#line 88
extern "C" { extern __m128d _mm_andnot_pd(__m128d _A, __m128d _B); } 
#line 89
extern "C" { extern __m128d _mm_or_pd(__m128d _A, __m128d _B); } 
#line 90
extern "C" { extern __m128d _mm_xor_pd(__m128d _A, __m128d _B); } 
#line 96
extern "C" { extern __m128d _mm_cmpeq_sd(__m128d _A, __m128d _B); } 
#line 97
extern "C" { extern __m128d _mm_cmpeq_pd(__m128d _A, __m128d _B); } 
#line 98
extern "C" { extern __m128d _mm_cmplt_sd(__m128d _A, __m128d _B); } 
#line 99
extern "C" { extern __m128d _mm_cmplt_pd(__m128d _A, __m128d _B); } 
#line 100
extern "C" { extern __m128d _mm_cmple_sd(__m128d _A, __m128d _B); } 
#line 101
extern "C" { extern __m128d _mm_cmple_pd(__m128d _A, __m128d _B); } 
#line 102
extern "C" { extern __m128d _mm_cmpgt_sd(__m128d _A, __m128d _B); } 
#line 103
extern "C" { extern __m128d _mm_cmpgt_pd(__m128d _A, __m128d _B); } 
#line 104
extern "C" { extern __m128d _mm_cmpge_sd(__m128d _A, __m128d _B); } 
#line 105
extern "C" { extern __m128d _mm_cmpge_pd(__m128d _A, __m128d _B); } 
#line 106
extern "C" { extern __m128d _mm_cmpneq_sd(__m128d _A, __m128d _B); } 
#line 107
extern "C" { extern __m128d _mm_cmpneq_pd(__m128d _A, __m128d _B); } 
#line 108
extern "C" { extern __m128d _mm_cmpnlt_sd(__m128d _A, __m128d _B); } 
#line 109
extern "C" { extern __m128d _mm_cmpnlt_pd(__m128d _A, __m128d _B); } 
#line 110
extern "C" { extern __m128d _mm_cmpnle_sd(__m128d _A, __m128d _B); } 
#line 111
extern "C" { extern __m128d _mm_cmpnle_pd(__m128d _A, __m128d _B); } 
#line 112
extern "C" { extern __m128d _mm_cmpngt_sd(__m128d _A, __m128d _B); } 
#line 113
extern "C" { extern __m128d _mm_cmpngt_pd(__m128d _A, __m128d _B); } 
#line 114
extern "C" { extern __m128d _mm_cmpnge_sd(__m128d _A, __m128d _B); } 
#line 115
extern "C" { extern __m128d _mm_cmpnge_pd(__m128d _A, __m128d _B); } 
#line 116
extern "C" { extern __m128d _mm_cmpord_pd(__m128d _A, __m128d _B); } 
#line 117
extern "C" { extern __m128d _mm_cmpord_sd(__m128d _A, __m128d _B); } 
#line 118
extern "C" { extern __m128d _mm_cmpunord_pd(__m128d _A, __m128d _B); } 
#line 119
extern "C" { extern __m128d _mm_cmpunord_sd(__m128d _A, __m128d _B); } 
#line 120
extern "C" { extern int _mm_comieq_sd(__m128d _A, __m128d _B); } 
#line 121
extern "C" { extern int _mm_comilt_sd(__m128d _A, __m128d _B); } 
#line 122
extern "C" { extern int _mm_comile_sd(__m128d _A, __m128d _B); } 
#line 123
extern "C" { extern int _mm_comigt_sd(__m128d _A, __m128d _B); } 
#line 124
extern "C" { extern int _mm_comige_sd(__m128d _A, __m128d _B); } 
#line 125
extern "C" { extern int _mm_comineq_sd(__m128d _A, __m128d _B); } 
#line 126
extern "C" { extern int _mm_ucomieq_sd(__m128d _A, __m128d _B); } 
#line 127
extern "C" { extern int _mm_ucomilt_sd(__m128d _A, __m128d _B); } 
#line 128
extern "C" { extern int _mm_ucomile_sd(__m128d _A, __m128d _B); } 
#line 129
extern "C" { extern int _mm_ucomigt_sd(__m128d _A, __m128d _B); } 
#line 130
extern "C" { extern int _mm_ucomige_sd(__m128d _A, __m128d _B); } 
#line 131
extern "C" { extern int _mm_ucomineq_sd(__m128d _A, __m128d _B); } 
#line 137
extern "C" { extern __m128d _mm_cvtepi32_pd(__m128i _A); } 
#line 138
extern "C" { extern __m128i _mm_cvtpd_epi32(__m128d _A); } 
#line 139
extern "C" { extern __m128i _mm_cvttpd_epi32(__m128d _A); } 
#line 140
extern "C" { extern __m128 _mm_cvtepi32_ps(__m128i _A); } 
#line 141
extern "C" { extern __m128i _mm_cvtps_epi32(__m128 _A); } 
#line 142
extern "C" { extern __m128i _mm_cvttps_epi32(__m128 _A); } 
#line 143
extern "C" { extern __m128 _mm_cvtpd_ps(__m128d _A); } 
#line 144
extern "C" { extern __m128d _mm_cvtps_pd(__m128 _A); } 
#line 145
extern "C" { extern __m128 _mm_cvtsd_ss(__m128 _A, __m128d _B); } 
#line 146
extern "C" { extern __m128d _mm_cvtss_sd(__m128d _A, __m128 _B); } 
#line 148
extern "C" { extern int _mm_cvtsd_si32(__m128d _A); } 
#line 149
extern "C" { extern int _mm_cvttsd_si32(__m128d _A); } 
#line 150
extern "C" { extern __m128d _mm_cvtsi32_sd(__m128d _A, int _B); } 
#line 152
extern "C" { extern __m64 _mm_cvtpd_pi32(__m128d _A); } 
#line 153
extern "C" { extern __m64 _mm_cvttpd_pi32(__m128d _A); } 
#line 154
extern "C" { extern __m128d _mm_cvtpi32_pd(__m64 _A); } 
#line 160
extern "C" { extern __m128d _mm_unpackhi_pd(__m128d _A, __m128d _B); } 
#line 161
extern "C" { extern __m128d _mm_unpacklo_pd(__m128d _A, __m128d _B); } 
#line 162
extern "C" { extern int _mm_movemask_pd(__m128d _A); } 
#line 163
extern "C" { extern __m128d _mm_shuffle_pd(__m128d _A, __m128d _B, int _I); } 
#line 169
extern "C" { extern __m128d _mm_load_pd(const double * _Dp); } 
#line 170
extern "C" { extern __m128d _mm_load1_pd(const double * _Dp); } 
#line 171
extern "C" { extern __m128d _mm_loadr_pd(const double * _Dp); } 
#line 172
extern "C" { extern __m128d _mm_loadu_pd(const double * _Dp); } 
#line 173
extern "C" { extern __m128d _mm_load_sd(const double * _Dp); } 
#line 174
extern "C" { extern __m128d _mm_loadh_pd(__m128d _A, const double * _Dp); } 
#line 175
extern "C" { extern __m128d _mm_loadl_pd(__m128d _A, const double * _Dp); } 
#line 181
extern "C" { extern __m128d _mm_set_sd(double _W); } 
#line 182
extern "C" { extern __m128d _mm_set1_pd(double _A); } 
#line 183
extern "C" { extern __m128d _mm_set_pd(double _Z, double _Y); } 
#line 184
extern "C" { extern __m128d _mm_setr_pd(double _Y, double _Z); } 
#line 185
extern "C" { extern __m128d _mm_setzero_pd(); } 
#line 186
extern "C" { extern __m128d _mm_move_sd(__m128d _A, __m128d _B); } 
#line 192
extern "C" { extern void _mm_store_sd(double * _Dp, __m128d _A); } 
#line 193
extern "C" { extern void _mm_store1_pd(double * _Dp, __m128d _A); } 
#line 194
extern "C" { extern void _mm_store_pd(double * _Dp, __m128d _A); } 
#line 195
extern "C" { extern void _mm_storeu_pd(double * _Dp, __m128d _A); } 
#line 196
extern "C" { extern void _mm_storer_pd(double * _Dp, __m128d _A); } 
#line 197
extern "C" { extern void _mm_storeh_pd(double * _Dp, __m128d _A); } 
#line 198
extern "C" { extern void _mm_storel_pd(double * _Dp, __m128d _A); } 
#line 204
extern "C" { extern __m128i _mm_add_epi8(__m128i _A, __m128i _B); } 
#line 205
extern "C" { extern __m128i _mm_add_epi16(__m128i _A, __m128i _B); } 
#line 206
extern "C" { extern __m128i _mm_add_epi32(__m128i _A, __m128i _B); } 
#line 207
extern "C" { extern __m64 _mm_add_si64(__m64 _A, __m64 _B); } 
#line 208
extern "C" { extern __m128i _mm_add_epi64(__m128i _A, __m128i _B); } 
#line 209
extern "C" { extern __m128i _mm_adds_epi8(__m128i _A, __m128i _B); } 
#line 210
extern "C" { extern __m128i _mm_adds_epi16(__m128i _A, __m128i _B); } 
#line 211
extern "C" { extern __m128i _mm_adds_epu8(__m128i _A, __m128i _B); } 
#line 212
extern "C" { extern __m128i _mm_adds_epu16(__m128i _A, __m128i _B); } 
#line 213
extern "C" { extern __m128i _mm_avg_epu8(__m128i _A, __m128i _B); } 
#line 214
extern "C" { extern __m128i _mm_avg_epu16(__m128i _A, __m128i _B); } 
#line 215
extern "C" { extern __m128i _mm_madd_epi16(__m128i _A, __m128i _B); } 
#line 216
extern "C" { extern __m128i _mm_max_epi16(__m128i _A, __m128i _B); } 
#line 217
extern "C" { extern __m128i _mm_max_epu8(__m128i _A, __m128i _B); } 
#line 218
extern "C" { extern __m128i _mm_min_epi16(__m128i _A, __m128i _B); } 
#line 219
extern "C" { extern __m128i _mm_min_epu8(__m128i _A, __m128i _B); } 
#line 220
extern "C" { extern __m128i _mm_mulhi_epi16(__m128i _A, __m128i _B); } 
#line 221
extern "C" { extern __m128i _mm_mulhi_epu16(__m128i _A, __m128i _B); } 
#line 222
extern "C" { extern __m128i _mm_mullo_epi16(__m128i _A, __m128i _B); } 
#line 223
extern "C" { extern __m64 _mm_mul_su32(__m64 _A, __m64 _B); } 
#line 224
extern "C" { extern __m128i _mm_mul_epu32(__m128i _A, __m128i _B); } 
#line 225
extern "C" { extern __m128i _mm_sad_epu8(__m128i _A, __m128i _B); } 
#line 226
extern "C" { extern __m128i _mm_sub_epi8(__m128i _A, __m128i _B); } 
#line 227
extern "C" { extern __m128i _mm_sub_epi16(__m128i _A, __m128i _B); } 
#line 228
extern "C" { extern __m128i _mm_sub_epi32(__m128i _A, __m128i _B); } 
#line 229
extern "C" { extern __m64 _mm_sub_si64(__m64 _A, __m64 _B); } 
#line 230
extern "C" { extern __m128i _mm_sub_epi64(__m128i _A, __m128i _B); } 
#line 231
extern "C" { extern __m128i _mm_subs_epi8(__m128i _A, __m128i _B); } 
#line 232
extern "C" { extern __m128i _mm_subs_epi16(__m128i _A, __m128i _B); } 
#line 233
extern "C" { extern __m128i _mm_subs_epu8(__m128i _A, __m128i _B); } 
#line 234
extern "C" { extern __m128i _mm_subs_epu16(__m128i _A, __m128i _B); } 
#line 240
extern "C" { extern __m128i _mm_and_si128(__m128i _A, __m128i _B); } 
#line 241
extern "C" { extern __m128i _mm_andnot_si128(__m128i _A, __m128i _B); } 
#line 242
extern "C" { extern __m128i _mm_or_si128(__m128i _A, __m128i _B); } 
#line 243
extern "C" { extern __m128i _mm_xor_si128(__m128i _A, __m128i _B); } 
#line 249
extern "C" { extern __m128i _mm_slli_si128(__m128i _A, int _Imm); } 
#line 250
extern "C" { extern __m128i _mm_slli_epi16(__m128i _A, int _Count); } 
#line 251
extern "C" { extern __m128i _mm_sll_epi16(__m128i _A, __m128i _Count); } 
#line 252
extern "C" { extern __m128i _mm_slli_epi32(__m128i _A, int _Count); } 
#line 253
extern "C" { extern __m128i _mm_sll_epi32(__m128i _A, __m128i _Count); } 
#line 254
extern "C" { extern __m128i _mm_slli_epi64(__m128i _A, int _Count); } 
#line 255
extern "C" { extern __m128i _mm_sll_epi64(__m128i _A, __m128i _Count); } 
#line 256
extern "C" { extern __m128i _mm_srai_epi16(__m128i _A, int _Count); } 
#line 257
extern "C" { extern __m128i _mm_sra_epi16(__m128i _A, __m128i _Count); } 
#line 258
extern "C" { extern __m128i _mm_srai_epi32(__m128i _A, int _Count); } 
#line 259
extern "C" { extern __m128i _mm_sra_epi32(__m128i _A, __m128i _Count); } 
#line 260
extern "C" { extern __m128i _mm_srli_si128(__m128i _A, int _Imm); } 
#line 261
extern "C" { extern __m128i _mm_srli_epi16(__m128i _A, int _Count); } 
#line 262
extern "C" { extern __m128i _mm_srl_epi16(__m128i _A, __m128i _Count); } 
#line 263
extern "C" { extern __m128i _mm_srli_epi32(__m128i _A, int _Count); } 
#line 264
extern "C" { extern __m128i _mm_srl_epi32(__m128i _A, __m128i _Count); } 
#line 265
extern "C" { extern __m128i _mm_srli_epi64(__m128i _A, int _Count); } 
#line 266
extern "C" { extern __m128i _mm_srl_epi64(__m128i _A, __m128i _Count); } 
#line 272
extern "C" { extern __m128i _mm_cmpeq_epi8(__m128i _A, __m128i _B); } 
#line 273
extern "C" { extern __m128i _mm_cmpeq_epi16(__m128i _A, __m128i _B); } 
#line 274
extern "C" { extern __m128i _mm_cmpeq_epi32(__m128i _A, __m128i _B); } 
#line 275
extern "C" { extern __m128i _mm_cmpgt_epi8(__m128i _A, __m128i _B); } 
#line 276
extern "C" { extern __m128i _mm_cmpgt_epi16(__m128i _A, __m128i _B); } 
#line 277
extern "C" { extern __m128i _mm_cmpgt_epi32(__m128i _A, __m128i _B); } 
#line 278
extern "C" { extern __m128i _mm_cmplt_epi8(__m128i _A, __m128i _B); } 
#line 279
extern "C" { extern __m128i _mm_cmplt_epi16(__m128i _A, __m128i _B); } 
#line 280
extern "C" { extern __m128i _mm_cmplt_epi32(__m128i _A, __m128i _B); } 
#line 286
extern "C" { extern __m128i _mm_cvtsi32_si128(int _A); } 
#line 287
extern "C" { extern int _mm_cvtsi128_si32(__m128i _A); } 
#line 293
extern "C" { extern __m128i _mm_packs_epi16(__m128i _A, __m128i _B); } 
#line 294
extern "C" { extern __m128i _mm_packs_epi32(__m128i _A, __m128i _B); } 
#line 295
extern "C" { extern __m128i _mm_packus_epi16(__m128i _A, __m128i _B); } 
#line 296
extern "C" { extern int _mm_extract_epi16(__m128i _A, int _Imm); } 
#line 297
extern "C" { extern __m128i _mm_insert_epi16(__m128i _A, int _B, int _Imm); } 
#line 298
extern "C" { extern int _mm_movemask_epi8(__m128i _A); } 
#line 299
extern "C" { extern __m128i _mm_shuffle_epi32(__m128i _A, int _Imm); } 
#line 300
extern "C" { extern __m128i _mm_shufflehi_epi16(__m128i _A, int _Imm); } 
#line 301
extern "C" { extern __m128i _mm_shufflelo_epi16(__m128i _A, int _Imm); } 
#line 302
extern "C" { extern __m128i _mm_unpackhi_epi8(__m128i _A, __m128i _B); } 
#line 303
extern "C" { extern __m128i _mm_unpackhi_epi16(__m128i _A, __m128i _B); } 
#line 304
extern "C" { extern __m128i _mm_unpackhi_epi32(__m128i _A, __m128i _B); } 
#line 305
extern "C" { extern __m128i _mm_unpackhi_epi64(__m128i _A, __m128i _B); } 
#line 306
extern "C" { extern __m128i _mm_unpacklo_epi8(__m128i _A, __m128i _B); } 
#line 307
extern "C" { extern __m128i _mm_unpacklo_epi16(__m128i _A, __m128i _B); } 
#line 308
extern "C" { extern __m128i _mm_unpacklo_epi32(__m128i _A, __m128i _B); } 
#line 309
extern "C" { extern __m128i _mm_unpacklo_epi64(__m128i _A, __m128i _B); } 
#line 315
extern "C" { extern __m128i _mm_load_si128(const __m128i * _P); } 
#line 316
extern "C" { extern __m128i _mm_loadu_si128(const __m128i * _P); } 
#line 317
extern "C" { extern __m128i _mm_loadl_epi64(const __m128i * _P); } 
#line 323
extern "C" { extern __m128i _mm_set_epi64(__m64 _Q1, __m64 _Q0); } 
#line 324
extern "C" { extern __m128i _mm_set_epi32(int _I3, int _I2, int _I1, int _I0); } 
#line 325
extern "C" { extern __m128i _mm_set_epi16(short _W7, short _W6, short _W5, short _W4, short _W3, short _W2, short _W1, short _W0); } 
#line 327
extern "C" { extern __m128i _mm_set_epi8(char _B15, char _B14, char _B13, char _B12, char _B11, char _B10, char _B9, char _B8, char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); } 
#line 331
extern "C" { extern __m128i _mm_set1_epi64(__m64 _Q); } 
#line 332
extern "C" { extern __m128i _mm_set1_epi32(int _I); } 
#line 333
extern "C" { extern __m128i _mm_set1_epi16(short _W); } 
#line 334
extern "C" { extern __m128i _mm_set1_epi8(char _B); } 
#line 335
extern "C" { extern __m128i _mm_setl_epi64(__m128i _Q); } 
#line 336
extern "C" { extern __m128i _mm_setr_epi64(__m64 _Q0, __m64 _Q1); } 
#line 337
extern "C" { extern __m128i _mm_setr_epi32(int _I0, int _I1, int _I2, int _I3); } 
#line 338
extern "C" { extern __m128i _mm_setr_epi16(short _W0, short _W1, short _W2, short _W3, short _W4, short _W5, short _W6, short _W7); } 
#line 340
extern "C" { extern __m128i _mm_setr_epi8(char _B15, char _B14, char _B13, char _B12, char _B11, char _B10, char _B9, char _B8, char _B7, char _B6, char _B5, char _B4, char _B3, char _B2, char _B1, char _B0); } 
#line 344
extern "C" { extern __m128i _mm_setzero_si128(); } 
#line 350
extern "C" { extern void _mm_store_si128(__m128i * _P, __m128i _B); } 
#line 351
extern "C" { extern void _mm_storeu_si128(__m128i * _P, __m128i _B); } 
#line 352
extern "C" { extern void _mm_storel_epi64(__m128i * _P, __m128i _Q); } 
#line 353
extern "C" { extern void _mm_maskmoveu_si128(__m128i _D, __m128i _N, char * _P); } 
#line 359
extern "C" { extern __m128i _mm_move_epi64(__m128i _Q); } 
#line 360
extern "C" { extern __m128i _mm_movpi64_epi64(__m64 _Q); } 
#line 361
extern "C" { extern __m64 _mm_movepi64_pi64(__m128i _Q); } 
#line 367
extern "C" { extern void _mm_stream_pd(double * _Dp, __m128d _A); } 
#line 368
extern "C" { extern void _mm_stream_si128(__m128i * _P, __m128i _A); } 
#line 369
extern "C" { extern void _mm_clflush(const void * _P); } 
#line 370
extern "C" { extern void _mm_lfence(); } 
#line 371
extern "C" { extern void _mm_mfence(); } 
#line 372
extern "C" { extern void _mm_stream_si32(int * _P, int _I); } 
#line 373
extern "C" { extern void _mm_pause(); } 
#line 379
extern "C" { extern double _mm_cvtsd_f64(__m128d _A); } 
#line 387
extern "C" { extern __m128 _mm_castpd_ps(__m128d); } 
#line 388
extern "C" { extern __m128i _mm_castpd_si128(__m128d); } 
#line 389
extern "C" { extern __m128d _mm_castps_pd(__m128); } 
#line 390
extern "C" { extern __m128i _mm_castps_si128(__m128); } 
#line 391
extern "C" { extern __m128 _mm_castsi128_ps(__m128i); } 
#line 392
extern "C" { extern __m128d _mm_castsi128_pd(__m128i); } 
#line 63 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\pmmintrin.h"
extern "C" { extern __m128 _mm_addsub_ps(__m128 a, __m128 b); } 
#line 64
extern "C" { extern __m128 _mm_hadd_ps(__m128 a, __m128 b); } 
#line 65
extern "C" { extern __m128 _mm_hsub_ps(__m128 a, __m128 b); } 
#line 66
extern "C" { extern __m128 _mm_movehdup_ps(__m128 a); } 
#line 67
extern "C" { extern __m128 _mm_moveldup_ps(__m128 a); } 
#line 73
extern "C" { extern __m128d _mm_addsub_pd(__m128d a, __m128d b); } 
#line 74
extern "C" { extern __m128d _mm_hadd_pd(__m128d a, __m128d b); } 
#line 75
extern "C" { extern __m128d _mm_hsub_pd(__m128d a, __m128d b); } 
#line 76
extern "C" { extern __m128d _mm_loaddup_pd(const double * dp); } 
#line 77
extern "C" { extern __m128d _mm_movedup_pd(__m128d a); } 
#line 82
extern "C" { extern __m128i _mm_lddqu_si128(const __m128i * p); } 
#line 90
extern "C" { extern void _mm_monitor(const void * p, unsigned extensions, unsigned hints); } 
#line 95
extern "C" { extern void _mm_mwait(unsigned extensions, unsigned hints); } 
#line 36 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\tmmintrin.h"
extern "C" { extern __m128i _mm_hadd_epi16(__m128i a, __m128i b); } 
#line 37
extern "C" { extern __m128i _mm_hadd_epi32(__m128i a, __m128i b); } 
#line 38
extern "C" { extern __m128i _mm_hadds_epi16(__m128i a, __m128i b); } 
#line 40
extern "C" { extern __m64 _mm_hadd_pi16(__m64 a, __m64 b); } 
#line 41
extern "C" { extern __m64 _mm_hadd_pi32(__m64 a, __m64 b); } 
#line 42
extern "C" { extern __m64 _mm_hadds_pi16(__m64 a, __m64 b); } 
#line 47
extern "C" { extern __m128i _mm_hsub_epi16(__m128i a, __m128i b); } 
#line 48
extern "C" { extern __m128i _mm_hsub_epi32(__m128i a, __m128i b); } 
#line 49
extern "C" { extern __m128i _mm_hsubs_epi16(__m128i a, __m128i b); } 
#line 51
extern "C" { extern __m64 _mm_hsub_pi16(__m64 a, __m64 b); } 
#line 52
extern "C" { extern __m64 _mm_hsub_pi32(__m64 a, __m64 b); } 
#line 53
extern "C" { extern __m64 _mm_hsubs_pi16(__m64 a, __m64 b); } 
#line 58
extern "C" { extern __m128i _mm_maddubs_epi16(__m128i a, __m128i b); } 
#line 60
extern "C" { extern __m64 _mm_maddubs_pi16(__m64 a, __m64 b); } 
#line 65
extern "C" { extern __m128i _mm_mulhrs_epi16(__m128i a, __m128i b); } 
#line 67
extern "C" { extern __m64 _mm_mulhrs_pi16(__m64 a, __m64 b); } 
#line 72
extern "C" { extern __m128i _mm_shuffle_epi8(__m128i a, __m128i b); } 
#line 74
extern "C" { extern __m64 _mm_shuffle_pi8(__m64 a, __m64 b); } 
#line 79
extern "C" { extern __m128i _mm_sign_epi8(__m128i a, __m128i b); } 
#line 80
extern "C" { extern __m128i _mm_sign_epi16(__m128i a, __m128i b); } 
#line 81
extern "C" { extern __m128i _mm_sign_epi32(__m128i a, __m128i b); } 
#line 83
extern "C" { extern __m64 _mm_sign_pi8(__m64 a, __m64 b); } 
#line 84
extern "C" { extern __m64 _mm_sign_pi16(__m64 a, __m64 b); } 
#line 85
extern "C" { extern __m64 _mm_sign_pi32(__m64 a, __m64 b); } 
#line 90
extern "C" { extern __m128i _mm_alignr_epi8(__m128i a, __m128i b, int n); } 
#line 92
extern "C" { extern __m64 _mm_alignr_pi8(__m64 a, __m64 b, int n); } 
#line 97
extern "C" { extern __m128i _mm_abs_epi8(__m128i a); } 
#line 98
extern "C" { extern __m128i _mm_abs_epi16(__m128i a); } 
#line 99
extern "C" { extern __m128i _mm_abs_epi32(__m128i a); } 
#line 101
extern "C" { extern __m64 _mm_abs_pi8(__m64 a); } 
#line 102
extern "C" { extern __m64 _mm_abs_pi16(__m64 a); } 
#line 103
extern "C" { extern __m64 _mm_abs_pi32(__m64 a); } 
#line 84 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\smmintrin.h"
extern "C" { extern __m128i _mm_blend_epi16(__m128i v1, __m128i v2, const int mask); } 
#line 86
extern "C" { extern __m128i _mm_blendv_epi8(__m128i v1, __m128i v2, __m128i mask); } 
#line 91
extern "C" { extern __m128 _mm_blend_ps(__m128 v1, __m128 v2, const int mask); } 
#line 92
extern "C" { extern __m128 _mm_blendv_ps(__m128 v1, __m128 v2, __m128 v3); } 
#line 97
extern "C" { extern __m128d _mm_blend_pd(__m128d v1, __m128d v2, const int mask); } 
#line 98
extern "C" { extern __m128d _mm_blendv_pd(__m128d v1, __m128d v2, __m128d v3); } 
#line 103
extern "C" { extern __m128 _mm_dp_ps(__m128 val1, __m128 val2, const int mask); } 
#line 104
extern "C" { extern __m128d _mm_dp_pd(__m128d val1, __m128d val2, const int mask); } 
#line 109
extern "C" { extern __m128i _mm_cmpeq_epi64(__m128i val1, __m128i val2); } 
#line 113
extern "C" { extern __m128i _mm_min_epi8(__m128i val1, __m128i val2); } 
#line 114
extern "C" { extern __m128i _mm_max_epi8(__m128i val1, __m128i val2); } 
#line 116
extern "C" { extern __m128i _mm_min_epu16(__m128i val1, __m128i val2); } 
#line 117
extern "C" { extern __m128i _mm_max_epu16(__m128i val1, __m128i val2); } 
#line 119
extern "C" { extern __m128i _mm_min_epi32(__m128i val1, __m128i val2); } 
#line 120
extern "C" { extern __m128i _mm_max_epi32(__m128i val1, __m128i val2); } 
#line 121
extern "C" { extern __m128i _mm_min_epu32(__m128i val1, __m128i val2); } 
#line 122
extern "C" { extern __m128i _mm_max_epu32(__m128i val1, __m128i val2); } 
#line 127
extern "C" { extern __m128i _mm_mullo_epi32(__m128i a, __m128i b); } 
#line 132
extern "C" { extern __m128i _mm_mul_epi32(__m128i a, __m128i b); } 
#line 137
extern "C" { extern int _mm_testz_si128(__m128i mask, __m128i val); } 
#line 142
extern "C" { extern int _mm_testc_si128(__m128i mask, __m128i val); } 
#line 148
extern "C" { extern int _mm_testnzc_si128(__m128i mask, __m128i s2); } 
#line 156
extern "C" { extern __m128 _mm_insert_ps(__m128 dst, __m128 src, const int ndx); } 
#line 166
extern "C" { extern int _mm_extract_ps(__m128 src, const int ndx); } 
#line 184
extern "C" { extern __m128i _mm_insert_epi8(__m128i dst, int s, const int ndx); } 
#line 185
extern "C" { extern __m128i _mm_insert_epi32(__m128i dst, int s, const int ndx); } 
#line 193 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\smmintrin.h"
extern "C" { extern int _mm_extract_epi8(__m128i src, const int ndx); } 
#line 194
extern "C" { extern int _mm_extract_epi32(__m128i src, const int ndx); } 
#line 203 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\smmintrin.h"
extern "C" { extern __m128i _mm_minpos_epu16(__m128i shortValues); } 
#line 207
extern "C" { extern __m128d _mm_round_pd(__m128d val, int iRoundMode); } 
#line 208
extern "C" { extern __m128d _mm_round_sd(__m128d dst, __m128d val, int iRoundMode); } 
#line 212
extern "C" { extern __m128 _mm_round_ps(__m128 val, int iRoundMode); } 
#line 213
extern "C" { extern __m128 _mm_round_ss(__m128 dst, __m128 val, int iRoundMode); } 
#line 217
extern "C" { extern __m128i _mm_cvtepi8_epi32(__m128i byteValues); } 
#line 218
extern "C" { extern __m128i _mm_cvtepi16_epi32(__m128i shortValues); } 
#line 219
extern "C" { extern __m128i _mm_cvtepi8_epi64(__m128i byteValues); } 
#line 220
extern "C" { extern __m128i _mm_cvtepi32_epi64(__m128i intValues); } 
#line 221
extern "C" { extern __m128i _mm_cvtepi16_epi64(__m128i shortValues); } 
#line 222
extern "C" { extern __m128i _mm_cvtepi8_epi16(__m128i byteValues); } 
#line 226
extern "C" { extern __m128i _mm_cvtepu8_epi32(__m128i byteValues); } 
#line 227
extern "C" { extern __m128i _mm_cvtepu16_epi32(__m128i shortValues); } 
#line 228
extern "C" { extern __m128i _mm_cvtepu8_epi64(__m128i shortValues); } 
#line 229
extern "C" { extern __m128i _mm_cvtepu32_epi64(__m128i intValues); } 
#line 230
extern "C" { extern __m128i _mm_cvtepu16_epi64(__m128i shortValues); } 
#line 231
extern "C" { extern __m128i _mm_cvtepu8_epi16(__m128i byteValues); } 
#line 237
extern "C" { extern __m128i _mm_packus_epi32(__m128i val1, __m128i val2); } 
#line 243
extern "C" { extern __m128i _mm_mpsadbw_epu8(__m128i s1, __m128i s2, const int msk); } 
#line 249
extern "C" { extern __m128i _mm_stream_load_si128(__m128i * v1); } 
#line 78 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\nmmintrin.h"
extern "C" { extern __m128i _mm_cmpistrm(__m128i a, __m128i b, const int mode); } 
#line 79
extern "C" { extern int _mm_cmpistri(__m128i a, __m128i b, const int mode); } 
#line 81
extern "C" { extern __m128i _mm_cmpestrm(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 82
extern "C" { extern int _mm_cmpestri(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 88
extern "C" { extern int _mm_cmpistrz(__m128i a, __m128i b, const int mode); } 
#line 89
extern "C" { extern int _mm_cmpistrc(__m128i a, __m128i b, const int mode); } 
#line 90
extern "C" { extern int _mm_cmpistrs(__m128i a, __m128i b, const int mode); } 
#line 91
extern "C" { extern int _mm_cmpistro(__m128i a, __m128i b, const int mode); } 
#line 92
extern "C" { extern int _mm_cmpistra(__m128i a, __m128i b, const int mode); } 
#line 94
extern "C" { extern int _mm_cmpestrz(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 95
extern "C" { extern int _mm_cmpestrc(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 96
extern "C" { extern int _mm_cmpestrs(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 97
extern "C" { extern int _mm_cmpestro(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 98
extern "C" { extern int _mm_cmpestra(__m128i a, int la, __m128i b, int lb, const int mode); } 
#line 105
extern "C" { extern __m128i _mm_cmpgt_epi64(__m128i val1, __m128i val2); } 
#line 111
extern "C" { extern int _mm_popcnt_u32(unsigned v); } 
#line 121 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\nmmintrin.h"
extern "C" { extern unsigned _mm_crc32_u8(unsigned crc, unsigned char v); } 
#line 122
extern "C" { extern unsigned _mm_crc32_u16(unsigned crc, unsigned short v); } 
#line 123
extern "C" { extern unsigned _mm_crc32_u32(unsigned crc, unsigned v); } 
#line 37 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\wmmintrin.h"
extern "C" { extern __m128i _mm_aesdec_si128(__m128i v, __m128i rkey); } 
#line 43
extern "C" { extern __m128i _mm_aesdeclast_si128(__m128i v, __m128i rkey); } 
#line 49
extern "C" { extern __m128i _mm_aesenc_si128(__m128i v, __m128i rkey); } 
#line 55
extern "C" { extern __m128i _mm_aesenclast_si128(__m128i v, __m128i rkey); } 
#line 61
extern "C" { extern __m128i _mm_aesimc_si128(__m128i v); } 
#line 68
extern "C" { extern __m128i _mm_aeskeygenassist_si128(__m128i ckey, const int rcon); } 
#line 76
extern "C" { extern __m128i _mm_clmulepi64_si128(__m128i v1, __m128i v2, const int imm8); } 
#line 34 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { typedef 
#line 32
union __declspec(intrin_type) __declspec(align(32)) __m256 { 
#line 33
float m256_f32[8]; 
#line 34
} __m256; }
#line 38
extern "C" { typedef 
#line 36
struct __declspec(intrin_type) __declspec(align(32)) __m256d { 
#line 37
double m256d_f64[4]; 
#line 38
} __m256d; }
#line 49
extern "C" { typedef 
#line 40
union __declspec(intrin_type) __declspec(align(32)) __m256i { 
#line 41
char m256i_i8[32]; 
#line 42
short m256i_i16[16]; 
#line 43
int m256i_i32[8]; 
#line 44
__int64 m256i_i64[4]; 
#line 45
unsigned char m256i_u8[32]; 
#line 46
unsigned short m256i_u16[16]; 
#line 47
unsigned m256i_u32[8]; 
#line 48
unsigned __int64 m256i_u64[4]; 
#line 49
} __m256i; }
#line 101
extern "C" { extern __m256d __cdecl _mm256_add_pd(__m256d, __m256d); } 
#line 111
extern "C" { extern __m256 __cdecl _mm256_add_ps(__m256, __m256); } 
#line 124
extern "C" { extern __m256d __cdecl _mm256_addsub_pd(__m256d, __m256d); } 
#line 137
extern "C" { extern __m256 __cdecl _mm256_addsub_ps(__m256, __m256); } 
#line 146
extern "C" { extern __m256d __cdecl _mm256_and_pd(__m256d, __m256d); } 
#line 155
extern "C" { extern __m256 __cdecl _mm256_and_ps(__m256, __m256); } 
#line 164
extern "C" { extern __m256d __cdecl _mm256_andnot_pd(__m256d, __m256d); } 
#line 173
extern "C" { extern __m256 __cdecl _mm256_andnot_ps(__m256, __m256); } 
#line 187
extern "C" { extern __m256d __cdecl _mm256_blend_pd(__m256d, __m256d, const int); } 
#line 201
extern "C" { extern __m256 __cdecl _mm256_blend_ps(__m256, __m256, const int); } 
#line 211
extern "C" { extern __m256d __cdecl _mm256_blendv_pd(__m256d, __m256d, __m256d); } 
#line 221
extern "C" { extern __m256 __cdecl _mm256_blendv_ps(__m256, __m256, __m256); } 
#line 230
extern "C" { extern __m256d __cdecl _mm256_div_pd(__m256d, __m256d); } 
#line 239
extern "C" { extern __m256 __cdecl _mm256_div_ps(__m256, __m256); } 
#line 254
extern "C" { extern __m256 __cdecl _mm256_dp_ps(__m256, __m256, const int); } 
#line 263
extern "C" { extern __m256d __cdecl _mm256_hadd_pd(__m256d, __m256d); } 
#line 272
extern "C" { extern __m256 __cdecl _mm256_hadd_ps(__m256, __m256); } 
#line 281
extern "C" { extern __m256d __cdecl _mm256_hsub_pd(__m256d, __m256d); } 
#line 290
extern "C" { extern __m256 __cdecl _mm256_hsub_ps(__m256, __m256); } 
#line 299
extern "C" { extern __m256d __cdecl _mm256_max_pd(__m256d, __m256d); } 
#line 308
extern "C" { extern __m256 __cdecl _mm256_max_ps(__m256, __m256); } 
#line 317
extern "C" { extern __m256d __cdecl _mm256_min_pd(__m256d, __m256d); } 
#line 326
extern "C" { extern __m256 __cdecl _mm256_min_ps(__m256, __m256); } 
#line 336
extern "C" { extern __m256d __cdecl _mm256_mul_pd(__m256d, __m256d); } 
#line 346
extern "C" { extern __m256 __cdecl _mm256_mul_ps(__m256, __m256); } 
#line 355
extern "C" { extern __m256d __cdecl _mm256_or_pd(__m256d, __m256d); } 
#line 364
extern "C" { extern __m256 __cdecl _mm256_or_ps(__m256, __m256); } 
#line 376
extern "C" { extern __m256d __cdecl _mm256_shuffle_pd(__m256d, __m256d, const int); } 
#line 389
extern "C" { extern __m256 __cdecl _mm256_shuffle_ps(__m256, __m256, const int); } 
#line 398
extern "C" { extern __m256d __cdecl _mm256_sub_pd(__m256d, __m256d); } 
#line 408
extern "C" { extern __m256 __cdecl _mm256_sub_ps(__m256, __m256); } 
#line 417
extern "C" { extern __m256d __cdecl _mm256_xor_pd(__m256d, __m256d); } 
#line 426
extern "C" { extern __m256 __cdecl _mm256_xor_ps(__m256, __m256); } 
#line 442
extern "C" { extern __m128d __cdecl _mm_cmp_pd(__m128d, __m128d, const int); } 
#line 443
extern "C" { extern __m256d __cdecl _mm256_cmp_pd(__m256d, __m256d, const int); } 
#line 459
extern "C" { extern __m128 __cdecl _mm_cmp_ps(__m128, __m128, const int); } 
#line 460
extern "C" { extern __m256 __cdecl _mm256_cmp_ps(__m256, __m256, const int); } 
#line 473
extern "C" { extern __m128d __cdecl _mm_cmp_sd(__m128d, __m128d, const int); } 
#line 486
extern "C" { extern __m128 __cdecl _mm_cmp_ss(__m128, __m128, const int); } 
#line 495
extern "C" { extern __m256d __cdecl _mm256_cvtepi32_pd(__m128i); } 
#line 504
extern "C" { extern __m256 __cdecl _mm256_cvtepi32_ps(__m256i); } 
#line 514
extern "C" { extern __m128 __cdecl _mm256_cvtpd_ps(__m256d); } 
#line 523
extern "C" { extern __m256i __cdecl _mm256_cvtps_epi32(__m256); } 
#line 533
extern "C" { extern __m256d __cdecl _mm256_cvtps_pd(__m128); } 
#line 546
extern "C" { extern __m128i __cdecl _mm256_cvttpd_epi32(__m256d); } 
#line 555
extern "C" { extern __m128i __cdecl _mm256_cvtpd_epi32(__m256d); } 
#line 568
extern "C" { extern __m256i __cdecl _mm256_cvttps_epi32(__m256); } 
#line 576
extern "C" { extern __m128 __cdecl _mm256_extractf128_ps(__m256, const int); } 
#line 577
extern "C" { extern __m128d __cdecl _mm256_extractf128_pd(__m256d, const int); } 
#line 578
extern "C" { extern __m128i __cdecl _mm256_extractf128_si256(__m256i, const int); } 
#line 585
extern "C" { extern void __cdecl _mm256_zeroall(); } 
#line 593
extern "C" { extern void __cdecl _mm256_zeroupper(); } 
#line 603
extern "C" { extern __m256 __cdecl _mm256_permutevar_ps(__m256, __m256i); } 
#line 604
extern "C" { extern __m128 __cdecl _mm_permutevar_ps(__m128, __m128i); } 
#line 614
extern "C" { extern __m256 __cdecl _mm256_permute_ps(__m256, int); } 
#line 615
extern "C" { extern __m128 __cdecl _mm_permute_ps(__m128, int); } 
#line 625
extern "C" { extern __m256d __cdecl _mm256_permutevar_pd(__m256d, __m256i); } 
#line 626
extern "C" { extern __m128d __cdecl _mm_permutevar_pd(__m128d, __m128i); } 
#line 636
extern "C" { extern __m256d __cdecl _mm256_permute_pd(__m256d, int); } 
#line 637
extern "C" { extern __m128d __cdecl _mm_permute_pd(__m128d, int); } 
#line 646
extern "C" { extern __m256 __cdecl _mm256_permute2f128_ps(__m256, __m256, int); } 
#line 647
extern "C" { extern __m256d __cdecl _mm256_permute2f128_pd(__m256d, __m256d, int); } 
#line 648
extern "C" { extern __m256i __cdecl _mm256_permute2f128_si256(__m256i, __m256i, int); } 
#line 657
extern "C" { extern __m256 __cdecl _mm256_broadcast_ss(const float *); } 
#line 658
extern "C" { extern __m128 __cdecl _mm_broadcast_ss(const float *); } 
#line 666
extern "C" { extern __m256d __cdecl _mm256_broadcast_sd(const double *); } 
#line 674
extern "C" { extern __m256 __cdecl _mm256_broadcast_ps(const __m128 *); } 
#line 675
extern "C" { extern __m256d __cdecl _mm256_broadcast_pd(const __m128d *); } 
#line 685
extern "C" { extern __m256 __cdecl _mm256_insertf128_ps(__m256, __m128, int); } 
#line 686
extern "C" { extern __m256d __cdecl _mm256_insertf128_pd(__m256d, __m128d, int); } 
#line 687
extern "C" { extern __m256i __cdecl _mm256_insertf128_si256(__m256i, __m128i, int); } 
#line 696
extern "C" { extern __m256d __cdecl _mm256_load_pd(const double *); } 
#line 697
extern "C" { extern void __cdecl _mm256_store_pd(double *, __m256d); } 
#line 706
extern "C" { extern __m256 __cdecl _mm256_load_ps(const float *); } 
#line 707
extern "C" { extern void __cdecl _mm256_store_ps(float *, __m256); } 
#line 716
extern "C" { extern __m256d __cdecl _mm256_loadu_pd(const double *); } 
#line 717
extern "C" { extern void __cdecl _mm256_storeu_pd(double *, __m256d); } 
#line 726
extern "C" { extern __m256 __cdecl _mm256_loadu_ps(const float *); } 
#line 727
extern "C" { extern void __cdecl _mm256_storeu_ps(float *, __m256); } 
#line 736
extern "C" { extern __m256i __cdecl _mm256_load_si256(const __m256i *); } 
#line 737
extern "C" { extern void __cdecl _mm256_store_si256(__m256i *, __m256i); } 
#line 746
extern "C" { extern __m256i __cdecl _mm256_loadu_si256(const __m256i *); } 
#line 747
extern "C" { extern void __cdecl _mm256_storeu_si256(__m256i *, __m256i); } 
#line 819
extern "C" { extern __m256d __cdecl _mm256_maskload_pd(const double *, __m256i); } 
#line 820
extern "C" { extern void __cdecl _mm256_maskstore_pd(double *, __m256i, __m256d); } 
#line 821
extern "C" { extern __m128d __cdecl _mm_maskload_pd(const double *, __m128i); } 
#line 822
extern "C" { extern void __cdecl _mm_maskstore_pd(double *, __m128i, __m128d); } 
#line 842
extern "C" { extern __m256 __cdecl _mm256_maskload_ps(const float *, __m256i); } 
#line 843
extern "C" { extern void __cdecl _mm256_maskstore_ps(float *, __m256i, __m256); } 
#line 844
extern "C" { extern __m128 __cdecl _mm_maskload_ps(const float *, __m128i); } 
#line 845
extern "C" { extern void __cdecl _mm_maskstore_ps(float *, __m128i, __m128); } 
#line 853
extern "C" { extern __m256 __cdecl _mm256_movehdup_ps(__m256); } 
#line 861
extern "C" { extern __m256 __cdecl _mm256_moveldup_ps(__m256); } 
#line 869
extern "C" { extern __m256d __cdecl _mm256_movedup_pd(__m256d); } 
#line 879
extern "C" { extern __m256i __cdecl _mm256_lddqu_si256(const __m256i *); } 
#line 887
extern "C" { extern void __cdecl _mm256_stream_si256(__m256i *, __m256i); } 
#line 896
extern "C" { extern void __cdecl _mm256_stream_pd(double *, __m256d); } 
#line 905
extern "C" { extern void __cdecl _mm256_stream_ps(float *, __m256); } 
#line 915
extern "C" { extern __m256 __cdecl _mm256_rcp_ps(__m256); } 
#line 926
extern "C" { extern __m256 __cdecl _mm256_rsqrt_ps(__m256); } 
#line 935
extern "C" { extern __m256d __cdecl _mm256_sqrt_pd(__m256d); } 
#line 944
extern "C" { extern __m256 __cdecl _mm256_sqrt_ps(__m256); } 
#line 957
extern "C" { extern __m256d __cdecl _mm256_round_pd(__m256d, int); } 
#line 972
extern "C" { extern __m256 __cdecl _mm256_round_ps(__m256, int); } 
#line 982
extern "C" { extern __m256d __cdecl _mm256_unpackhi_pd(__m256d, __m256d); } 
#line 990
extern "C" { extern __m256 __cdecl _mm256_unpackhi_ps(__m256, __m256); } 
#line 998
extern "C" { extern __m256d __cdecl _mm256_unpacklo_pd(__m256d, __m256d); } 
#line 1006
extern "C" { extern __m256 __cdecl _mm256_unpacklo_ps(__m256, __m256); } 
#line 1016
extern "C" { extern int __cdecl _mm256_testz_si256(__m256i, __m256i); } 
#line 1020
extern "C" { extern int __cdecl _mm256_testc_si256(__m256i, __m256i); } 
#line 1024
extern "C" { extern int __cdecl _mm256_testnzc_si256(__m256i, __m256i); } 
#line 1039
extern "C" { extern int __cdecl _mm256_testz_pd(__m256d, __m256d); } 
#line 1040
extern "C" { extern int __cdecl _mm256_testc_pd(__m256d, __m256d); } 
#line 1041
extern "C" { extern int __cdecl _mm256_testnzc_pd(__m256d, __m256d); } 
#line 1042
extern "C" { extern int __cdecl _mm_testz_pd(__m128d, __m128d); } 
#line 1043
extern "C" { extern int __cdecl _mm_testc_pd(__m128d, __m128d); } 
#line 1044
extern "C" { extern int __cdecl _mm_testnzc_pd(__m128d, __m128d); } 
#line 1057
extern "C" { extern int __cdecl _mm256_testz_ps(__m256, __m256); } 
#line 1058
extern "C" { extern int __cdecl _mm256_testc_ps(__m256, __m256); } 
#line 1059
extern "C" { extern int __cdecl _mm256_testnzc_ps(__m256, __m256); } 
#line 1060
extern "C" { extern int __cdecl _mm_testz_ps(__m128, __m128); } 
#line 1061
extern "C" { extern int __cdecl _mm_testc_ps(__m128, __m128); } 
#line 1062
extern "C" { extern int __cdecl _mm_testnzc_ps(__m128, __m128); } 
#line 1071
extern "C" { extern int __cdecl _mm256_movemask_pd(__m256d); } 
#line 1080
extern "C" { extern int __cdecl _mm256_movemask_ps(__m256); } 
#line 1085
extern "C" { extern __m256d __cdecl _mm256_setzero_pd(); } 
#line 1086
extern "C" { extern __m256 __cdecl _mm256_setzero_ps(); } 
#line 1087
extern "C" { extern __m256i __cdecl _mm256_setzero_si256(); } 
#line 1092
extern "C" { extern __m256d __cdecl _mm256_set_pd(double, double, double, double); } 
#line 1093
extern "C" { extern __m256 __cdecl _mm256_set_ps(float, float, float, float, float, float, float, float); } 
#line 1095
extern "C" { extern __m256i __cdecl _mm256_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 1103
extern "C" { extern __m256i __cdecl _mm256_set_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); } 
#line 1107
extern "C" { extern __m256i __cdecl _mm256_set_epi32(int, int, int, int, int, int, int, int); } 
#line 1109
extern "C" { extern __m256i __cdecl _mm256_set_epi64x(__int64, __int64, __int64, __int64); } 
#line 1121
extern "C" { extern __m256d __cdecl _mm256_setr_pd(double, double, double, double); } 
#line 1122
extern "C" { extern __m256 __cdecl _mm256_setr_ps(float, float, float, float, float, float, float, float); } 
#line 1124
extern "C" { extern __m256i __cdecl _mm256_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 1132
extern "C" { extern __m256i __cdecl _mm256_setr_epi16(short, short, short, short, short, short, short, short, short, short, short, short, short, short, short, short); } 
#line 1136
extern "C" { extern __m256i __cdecl _mm256_setr_epi32(int, int, int, int, int, int, int, int); } 
#line 1138
extern "C" { extern __m256i __cdecl _mm256_setr_epi64x(__int64, __int64, __int64, __int64); } 
#line 1147
extern "C" { extern __m256d __cdecl _mm256_set1_pd(double); } 
#line 1148
extern "C" { extern __m256 __cdecl _mm256_set1_ps(float); } 
#line 1149
extern "C" { extern __m256i __cdecl _mm256_set1_epi8(char); } 
#line 1150
extern "C" { extern __m256i __cdecl _mm256_set1_epi16(short); } 
#line 1151
extern "C" { extern __m256i __cdecl _mm256_set1_epi32(int); } 
#line 1152
extern "C" { extern __m256i __cdecl _mm256_set1_epi64x(__int64); } 
#line 1160
extern "C" { extern __m256 __cdecl _mm256_castpd_ps(__m256d); } 
#line 1161
extern "C" { extern __m256d __cdecl _mm256_castps_pd(__m256); } 
#line 1162
extern "C" { extern __m256i __cdecl _mm256_castps_si256(__m256); } 
#line 1163
extern "C" { extern __m256i __cdecl _mm256_castpd_si256(__m256d); } 
#line 1164
extern "C" { extern __m256 __cdecl _mm256_castsi256_ps(__m256i); } 
#line 1165
extern "C" { extern __m256d __cdecl _mm256_castsi256_pd(__m256i); } 
#line 1166
extern "C" { extern __m128 __cdecl _mm256_castps256_ps128(__m256); } 
#line 1167
extern "C" { extern __m128d __cdecl _mm256_castpd256_pd128(__m256d); } 
#line 1168
extern "C" { extern __m128i __cdecl _mm256_castsi256_si128(__m256i); } 
#line 1169
extern "C" { extern __m256 __cdecl _mm256_castps128_ps256(__m128); } 
#line 1170
extern "C" { extern __m256d __cdecl _mm256_castpd128_pd256(__m128d); } 
#line 1171
extern "C" { extern __m256i __cdecl _mm256_castsi128_si256(__m128i); } 
#line 1178
extern "C" { extern __m128 __cdecl _mm_cvtph_ps(__m128i); } 
#line 1179
extern "C" { extern __m256 __cdecl _mm256_cvtph_ps(__m128i); } 
#line 1180
extern "C" { extern __m128i __cdecl _mm_cvtps_ph(__m128 m1, const int imm); } 
#line 1181
extern "C" { extern __m128i __cdecl _mm256_cvtps_ph(__m256, int); } 
#line 1202
extern "C" { extern unsigned __int64 __cdecl _xgetbv(unsigned); } 
#line 1205
extern "C" { extern void __cdecl _xsetbv(unsigned, unsigned __int64); } 
#line 1212
extern "C" { extern void __cdecl _xsave(void *, unsigned __int64); } 
#line 1222 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern void __cdecl _xsaveopt(void *, unsigned __int64); } 
#line 1232 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern void __cdecl _xrstor(const void *, unsigned __int64); } 
#line 1241 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern void __cdecl _fxsave(void *); } 
#line 1250 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern void __cdecl _fxrstor(const void *); } 
#line 1261 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern int __cdecl _rdrand16_step(unsigned short *); } 
#line 1262
extern "C" { extern int __cdecl _rdrand32_step(unsigned *); } 
#line 1288 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern __m128 __cdecl _mm_fmadd_ps(__m128, __m128, __m128); } 
#line 1289
extern "C" { extern __m128d __cdecl _mm_fmadd_pd(__m128d, __m128d, __m128d); } 
#line 1290
extern "C" { extern __m128 __cdecl _mm_fmadd_ss(__m128, __m128, __m128); } 
#line 1291
extern "C" { extern __m128d __cdecl _mm_fmadd_sd(__m128d, __m128d, __m128d); } 
#line 1292
extern "C" { extern __m128 __cdecl _mm_fmsub_ps(__m128, __m128, __m128); } 
#line 1293
extern "C" { extern __m128d __cdecl _mm_fmsub_pd(__m128d, __m128d, __m128d); } 
#line 1294
extern "C" { extern __m128 __cdecl _mm_fmsub_ss(__m128, __m128, __m128); } 
#line 1295
extern "C" { extern __m128d __cdecl _mm_fmsub_sd(__m128d, __m128d, __m128d); } 
#line 1296
extern "C" { extern __m128 __cdecl _mm_fnmadd_ps(__m128, __m128, __m128); } 
#line 1297
extern "C" { extern __m128d __cdecl _mm_fnmadd_pd(__m128d, __m128d, __m128d); } 
#line 1298
extern "C" { extern __m128 __cdecl _mm_fnmadd_ss(__m128, __m128, __m128); } 
#line 1299
extern "C" { extern __m128d __cdecl _mm_fnmadd_sd(__m128d, __m128d, __m128d); } 
#line 1300
extern "C" { extern __m128 __cdecl _mm_fnmsub_ps(__m128, __m128, __m128); } 
#line 1301
extern "C" { extern __m128d __cdecl _mm_fnmsub_pd(__m128d, __m128d, __m128d); } 
#line 1302
extern "C" { extern __m128 __cdecl _mm_fnmsub_ss(__m128, __m128, __m128); } 
#line 1303
extern "C" { extern __m128d __cdecl _mm_fnmsub_sd(__m128d, __m128d, __m128d); } 
#line 1305
extern "C" { extern __m256 __cdecl _mm256_fmadd_ps(__m256, __m256, __m256); } 
#line 1306
extern "C" { extern __m256d __cdecl _mm256_fmadd_pd(__m256d, __m256d, __m256d); } 
#line 1307
extern "C" { extern __m256 __cdecl _mm256_fmsub_ps(__m256, __m256, __m256); } 
#line 1308
extern "C" { extern __m256d __cdecl _mm256_fmsub_pd(__m256d, __m256d, __m256d); } 
#line 1309
extern "C" { extern __m256 __cdecl _mm256_fnmadd_ps(__m256, __m256, __m256); } 
#line 1310
extern "C" { extern __m256d __cdecl _mm256_fnmadd_pd(__m256d, __m256d, __m256d); } 
#line 1311
extern "C" { extern __m256 __cdecl _mm256_fnmsub_ps(__m256, __m256, __m256); } 
#line 1312
extern "C" { extern __m256d __cdecl _mm256_fnmsub_pd(__m256d, __m256d, __m256d); } 
#line 1318
extern "C" { extern __m128 __cdecl _mm_fmaddsub_ps(__m128, __m128, __m128); } 
#line 1319
extern "C" { extern __m128d __cdecl _mm_fmaddsub_pd(__m128d, __m128d, __m128d); } 
#line 1320
extern "C" { extern __m128 __cdecl _mm_fmsubadd_ps(__m128, __m128, __m128); } 
#line 1321
extern "C" { extern __m128d __cdecl _mm_fmsubadd_pd(__m128d, __m128d, __m128d); } 
#line 1323
extern "C" { extern __m256 __cdecl _mm256_fmaddsub_ps(__m256, __m256, __m256); } 
#line 1324
extern "C" { extern __m256d __cdecl _mm256_fmaddsub_pd(__m256d, __m256d, __m256d); } 
#line 1325
extern "C" { extern __m256 __cdecl _mm256_fmsubadd_ps(__m256, __m256, __m256); } 
#line 1326
extern "C" { extern __m256d __cdecl _mm256_fmsubadd_pd(__m256d, __m256d, __m256d); } 
#line 1332
extern "C" { extern __m256i __cdecl _mm256_cmpeq_epi8(__m256i, __m256i); } 
#line 1333
extern "C" { extern __m256i __cdecl _mm256_cmpeq_epi16(__m256i, __m256i); } 
#line 1334
extern "C" { extern __m256i __cdecl _mm256_cmpeq_epi32(__m256i, __m256i); } 
#line 1335
extern "C" { extern __m256i __cdecl _mm256_cmpeq_epi64(__m256i, __m256i); } 
#line 1337
extern "C" { extern __m256i __cdecl _mm256_cmpgt_epi8(__m256i, __m256i); } 
#line 1338
extern "C" { extern __m256i __cdecl _mm256_cmpgt_epi16(__m256i, __m256i); } 
#line 1339
extern "C" { extern __m256i __cdecl _mm256_cmpgt_epi32(__m256i, __m256i); } 
#line 1340
extern "C" { extern __m256i __cdecl _mm256_cmpgt_epi64(__m256i, __m256i); } 
#line 1346
extern "C" { extern __m256i __cdecl _mm256_max_epi8(__m256i, __m256i); } 
#line 1347
extern "C" { extern __m256i __cdecl _mm256_max_epi16(__m256i, __m256i); } 
#line 1348
extern "C" { extern __m256i __cdecl _mm256_max_epi32(__m256i, __m256i); } 
#line 1349
extern "C" { extern __m256i __cdecl _mm256_max_epu8(__m256i, __m256i); } 
#line 1350
extern "C" { extern __m256i __cdecl _mm256_max_epu16(__m256i, __m256i); } 
#line 1351
extern "C" { extern __m256i __cdecl _mm256_max_epu32(__m256i, __m256i); } 
#line 1353
extern "C" { extern __m256i __cdecl _mm256_min_epi8(__m256i, __m256i); } 
#line 1354
extern "C" { extern __m256i __cdecl _mm256_min_epi16(__m256i, __m256i); } 
#line 1355
extern "C" { extern __m256i __cdecl _mm256_min_epi32(__m256i, __m256i); } 
#line 1356
extern "C" { extern __m256i __cdecl _mm256_min_epu8(__m256i, __m256i); } 
#line 1357
extern "C" { extern __m256i __cdecl _mm256_min_epu16(__m256i, __m256i); } 
#line 1358
extern "C" { extern __m256i __cdecl _mm256_min_epu32(__m256i, __m256i); } 
#line 1364
extern "C" { extern __m256i __cdecl _mm256_and_si256(__m256i, __m256i); } 
#line 1365
extern "C" { extern __m256i __cdecl _mm256_andnot_si256(__m256i, __m256i); } 
#line 1366
extern "C" { extern __m256i __cdecl _mm256_or_si256(__m256i, __m256i); } 
#line 1367
extern "C" { extern __m256i __cdecl _mm256_xor_si256(__m256i, __m256i); } 
#line 1373
extern "C" { extern __m256i __cdecl _mm256_abs_epi8(__m256i); } 
#line 1374
extern "C" { extern __m256i __cdecl _mm256_abs_epi16(__m256i); } 
#line 1375
extern "C" { extern __m256i __cdecl _mm256_abs_epi32(__m256i); } 
#line 1377
extern "C" { extern __m256i __cdecl _mm256_add_epi8(__m256i, __m256i); } 
#line 1378
extern "C" { extern __m256i __cdecl _mm256_add_epi16(__m256i, __m256i); } 
#line 1379
extern "C" { extern __m256i __cdecl _mm256_add_epi32(__m256i, __m256i); } 
#line 1380
extern "C" { extern __m256i __cdecl _mm256_add_epi64(__m256i, __m256i); } 
#line 1382
extern "C" { extern __m256i __cdecl _mm256_adds_epi8(__m256i, __m256i); } 
#line 1383
extern "C" { extern __m256i __cdecl _mm256_adds_epi16(__m256i, __m256i); } 
#line 1384
extern "C" { extern __m256i __cdecl _mm256_adds_epu8(__m256i, __m256i); } 
#line 1385
extern "C" { extern __m256i __cdecl _mm256_adds_epu16(__m256i, __m256i); } 
#line 1387
extern "C" { extern __m256i __cdecl _mm256_sub_epi8(__m256i, __m256i); } 
#line 1388
extern "C" { extern __m256i __cdecl _mm256_sub_epi16(__m256i, __m256i); } 
#line 1389
extern "C" { extern __m256i __cdecl _mm256_sub_epi32(__m256i, __m256i); } 
#line 1390
extern "C" { extern __m256i __cdecl _mm256_sub_epi64(__m256i, __m256i); } 
#line 1392
extern "C" { extern __m256i __cdecl _mm256_subs_epi8(__m256i, __m256i); } 
#line 1393
extern "C" { extern __m256i __cdecl _mm256_subs_epi16(__m256i, __m256i); } 
#line 1394
extern "C" { extern __m256i __cdecl _mm256_subs_epu8(__m256i, __m256i); } 
#line 1395
extern "C" { extern __m256i __cdecl _mm256_subs_epu16(__m256i, __m256i); } 
#line 1397
extern "C" { extern __m256i __cdecl _mm256_avg_epu8(__m256i, __m256i); } 
#line 1398
extern "C" { extern __m256i __cdecl _mm256_avg_epu16(__m256i, __m256i); } 
#line 1400
extern "C" { extern __m256i __cdecl _mm256_hadd_epi16(__m256i, __m256i); } 
#line 1401
extern "C" { extern __m256i __cdecl _mm256_hadd_epi32(__m256i, __m256i); } 
#line 1402
extern "C" { extern __m256i __cdecl _mm256_hadds_epi16(__m256i, __m256i); } 
#line 1404
extern "C" { extern __m256i __cdecl _mm256_hsub_epi16(__m256i, __m256i); } 
#line 1405
extern "C" { extern __m256i __cdecl _mm256_hsub_epi32(__m256i, __m256i); } 
#line 1406
extern "C" { extern __m256i __cdecl _mm256_hsubs_epi16(__m256i, __m256i); } 
#line 1408
extern "C" { extern __m256i __cdecl _mm256_madd_epi16(__m256i, __m256i); } 
#line 1409
extern "C" { extern __m256i __cdecl _mm256_maddubs_epi16(__m256i, __m256i); } 
#line 1411
extern "C" { extern __m256i __cdecl _mm256_mulhi_epi16(__m256i, __m256i); } 
#line 1412
extern "C" { extern __m256i __cdecl _mm256_mulhi_epu16(__m256i, __m256i); } 
#line 1414
extern "C" { extern __m256i __cdecl _mm256_mullo_epi16(__m256i, __m256i); } 
#line 1415
extern "C" { extern __m256i __cdecl _mm256_mullo_epi32(__m256i, __m256i); } 
#line 1417
extern "C" { extern __m256i __cdecl _mm256_mul_epu32(__m256i, __m256i); } 
#line 1418
extern "C" { extern __m256i __cdecl _mm256_mul_epi32(__m256i, __m256i); } 
#line 1420
extern "C" { extern __m256i __cdecl _mm256_sign_epi8(__m256i, __m256i); } 
#line 1421
extern "C" { extern __m256i __cdecl _mm256_sign_epi16(__m256i, __m256i); } 
#line 1422
extern "C" { extern __m256i __cdecl _mm256_sign_epi32(__m256i, __m256i); } 
#line 1424
extern "C" { extern __m256i __cdecl _mm256_mulhrs_epi16(__m256i, __m256i); } 
#line 1426
extern "C" { extern __m256i __cdecl _mm256_sad_epu8(__m256i, __m256i); } 
#line 1427
extern "C" { extern __m256i __cdecl _mm256_mpsadbw_epu8(__m256i, __m256i, const int); } 
#line 1433
extern "C" { extern __m256i __cdecl _mm256_slli_si256(__m256i, const int); } 
#line 1434
extern "C" { extern __m256i __cdecl _mm256_srli_si256(__m256i, const int); } 
#line 1436
extern "C" { extern __m256i __cdecl _mm256_sll_epi16(__m256i, __m128i); } 
#line 1437
extern "C" { extern __m256i __cdecl _mm256_sll_epi32(__m256i, __m128i); } 
#line 1438
extern "C" { extern __m256i __cdecl _mm256_sll_epi64(__m256i, __m128i); } 
#line 1440
extern "C" { extern __m256i __cdecl _mm256_slli_epi16(__m256i, int); } 
#line 1441
extern "C" { extern __m256i __cdecl _mm256_slli_epi32(__m256i, int); } 
#line 1442
extern "C" { extern __m256i __cdecl _mm256_slli_epi64(__m256i, int); } 
#line 1444
extern "C" { extern __m256i __cdecl _mm256_sllv_epi32(__m256i, __m256i); } 
#line 1445
extern "C" { extern __m256i __cdecl _mm256_sllv_epi64(__m256i, __m256i); } 
#line 1447
extern "C" { extern __m128i __cdecl _mm_sllv_epi32(__m128i, __m128i); } 
#line 1448
extern "C" { extern __m128i __cdecl _mm_sllv_epi64(__m128i, __m128i); } 
#line 1450
extern "C" { extern __m256i __cdecl _mm256_sra_epi16(__m256i, __m128i); } 
#line 1451
extern "C" { extern __m256i __cdecl _mm256_sra_epi32(__m256i, __m128i); } 
#line 1453
extern "C" { extern __m256i __cdecl _mm256_srai_epi16(__m256i, int); } 
#line 1454
extern "C" { extern __m256i __cdecl _mm256_srai_epi32(__m256i, int); } 
#line 1456
extern "C" { extern __m256i __cdecl _mm256_srav_epi32(__m256i, __m256i); } 
#line 1458
extern "C" { extern __m128i __cdecl _mm_srav_epi32(__m128i, __m128i); } 
#line 1460
extern "C" { extern __m256i __cdecl _mm256_srl_epi16(__m256i, __m128i); } 
#line 1461
extern "C" { extern __m256i __cdecl _mm256_srl_epi32(__m256i, __m128i); } 
#line 1462
extern "C" { extern __m256i __cdecl _mm256_srl_epi64(__m256i, __m128i); } 
#line 1464
extern "C" { extern __m256i __cdecl _mm256_srli_epi16(__m256i, int); } 
#line 1465
extern "C" { extern __m256i __cdecl _mm256_srli_epi32(__m256i, int); } 
#line 1466
extern "C" { extern __m256i __cdecl _mm256_srli_epi64(__m256i, int); } 
#line 1468
extern "C" { extern __m256i __cdecl _mm256_srlv_epi32(__m256i, __m256i); } 
#line 1469
extern "C" { extern __m256i __cdecl _mm256_srlv_epi64(__m256i, __m256i); } 
#line 1471
extern "C" { extern __m128i __cdecl _mm_srlv_epi32(__m128i, __m128i); } 
#line 1472
extern "C" { extern __m128i __cdecl _mm_srlv_epi64(__m128i, __m128i); } 
#line 1478
extern "C" { extern __m128i __cdecl _mm_blend_epi32(__m128i, __m128i, const int); } 
#line 1480
extern "C" { extern __m256i __cdecl _mm256_blend_epi32(__m256i, __m256i, const int); } 
#line 1482
extern "C" { extern __m256i __cdecl _mm256_alignr_epi8(__m256i, __m256i, const int); } 
#line 1484
extern "C" { extern __m256i __cdecl _mm256_blendv_epi8(__m256i, __m256i, __m256i); } 
#line 1485
extern "C" { extern __m256i __cdecl _mm256_blend_epi16(__m256i, __m256i, const int); } 
#line 1487
extern "C" { extern __m256i __cdecl _mm256_packs_epi16(__m256i, __m256i); } 
#line 1488
extern "C" { extern __m256i __cdecl _mm256_packs_epi32(__m256i, __m256i); } 
#line 1489
extern "C" { extern __m256i __cdecl _mm256_packus_epi16(__m256i, __m256i); } 
#line 1490
extern "C" { extern __m256i __cdecl _mm256_packus_epi32(__m256i, __m256i); } 
#line 1492
extern "C" { extern __m256i __cdecl _mm256_unpackhi_epi8(__m256i, __m256i); } 
#line 1493
extern "C" { extern __m256i __cdecl _mm256_unpackhi_epi16(__m256i, __m256i); } 
#line 1494
extern "C" { extern __m256i __cdecl _mm256_unpackhi_epi32(__m256i, __m256i); } 
#line 1495
extern "C" { extern __m256i __cdecl _mm256_unpackhi_epi64(__m256i, __m256i); } 
#line 1497
extern "C" { extern __m256i __cdecl _mm256_unpacklo_epi8(__m256i, __m256i); } 
#line 1498
extern "C" { extern __m256i __cdecl _mm256_unpacklo_epi16(__m256i, __m256i); } 
#line 1499
extern "C" { extern __m256i __cdecl _mm256_unpacklo_epi32(__m256i, __m256i); } 
#line 1500
extern "C" { extern __m256i __cdecl _mm256_unpacklo_epi64(__m256i, __m256i); } 
#line 1502
extern "C" { extern __m256i __cdecl _mm256_shuffle_epi8(__m256i, __m256i); } 
#line 1503
extern "C" { extern __m256i __cdecl _mm256_shuffle_epi32(__m256i, const int); } 
#line 1505
extern "C" { extern __m256i __cdecl _mm256_shufflehi_epi16(__m256i, const int); } 
#line 1506
extern "C" { extern __m256i __cdecl _mm256_shufflelo_epi16(__m256i, const int); } 
#line 1508
extern "C" { extern __m128i __cdecl _mm256_extracti128_si256(__m256i, const int); } 
#line 1509
extern "C" { extern __m256i __cdecl _mm256_inserti128_si256(__m256i, __m128i, const int); } 
#line 1515
extern "C" { extern __m128 __cdecl _mm_broadcastss_ps(__m128); } 
#line 1516
extern "C" { extern __m128d __cdecl _mm_broadcastsd_pd(__m128d); } 
#line 1518
extern "C" { extern __m128i __cdecl _mm_broadcastb_epi8(__m128i); } 
#line 1519
extern "C" { extern __m128i __cdecl _mm_broadcastw_epi16(__m128i); } 
#line 1520
extern "C" { extern __m128i __cdecl _mm_broadcastd_epi32(__m128i); } 
#line 1521
extern "C" { extern __m128i __cdecl _mm_broadcastq_epi64(__m128i); } 
#line 1523
extern "C" { extern __m256 __cdecl _mm256_broadcastss_ps(__m128); } 
#line 1524
extern "C" { extern __m256d __cdecl _mm256_broadcastsd_pd(__m128d); } 
#line 1526
extern "C" { extern __m256i __cdecl _mm256_broadcastb_epi8(__m128i); } 
#line 1527
extern "C" { extern __m256i __cdecl _mm256_broadcastw_epi16(__m128i); } 
#line 1528
extern "C" { extern __m256i __cdecl _mm256_broadcastd_epi32(__m128i); } 
#line 1529
extern "C" { extern __m256i __cdecl _mm256_broadcastq_epi64(__m128i); } 
#line 1531
extern "C" { extern __m256i __cdecl _mm256_broadcastsi128_si256(__m128i); } 
#line 1538
extern "C" { extern __m256i __cdecl _mm256_cvtepi8_epi16(__m128i); } 
#line 1539
extern "C" { extern __m256i __cdecl _mm256_cvtepi8_epi32(__m128i); } 
#line 1540
extern "C" { extern __m256i __cdecl _mm256_cvtepi8_epi64(__m128i); } 
#line 1541
extern "C" { extern __m256i __cdecl _mm256_cvtepi16_epi32(__m128i); } 
#line 1542
extern "C" { extern __m256i __cdecl _mm256_cvtepi16_epi64(__m128i); } 
#line 1543
extern "C" { extern __m256i __cdecl _mm256_cvtepi32_epi64(__m128i); } 
#line 1545
extern "C" { extern __m256i __cdecl _mm256_cvtepu8_epi16(__m128i); } 
#line 1546
extern "C" { extern __m256i __cdecl _mm256_cvtepu8_epi32(__m128i); } 
#line 1547
extern "C" { extern __m256i __cdecl _mm256_cvtepu8_epi64(__m128i); } 
#line 1548
extern "C" { extern __m256i __cdecl _mm256_cvtepu16_epi32(__m128i); } 
#line 1549
extern "C" { extern __m256i __cdecl _mm256_cvtepu16_epi64(__m128i); } 
#line 1550
extern "C" { extern __m256i __cdecl _mm256_cvtepu32_epi64(__m128i); } 
#line 1557
extern "C" { extern int __cdecl _mm256_movemask_epi8(__m256i); } 
#line 1563
extern "C" { extern __m128i __cdecl _mm_maskload_epi32(const int *, __m128i); } 
#line 1565
extern "C" { extern __m128i __cdecl _mm_maskload_epi64(const __int64 *, __m128i); } 
#line 1568
extern "C" { extern void __cdecl _mm_maskstore_epi32(int *, __m128i, __m128i); } 
#line 1571
extern "C" { extern void __cdecl _mm_maskstore_epi64(__int64 *, __m128i, __m128i); } 
#line 1575
extern "C" { extern __m256i __cdecl _mm256_maskload_epi32(const int *, __m256i); } 
#line 1577
extern "C" { extern __m256i __cdecl _mm256_maskload_epi64(const __int64 *, __m256i); } 
#line 1580
extern "C" { extern void __cdecl _mm256_maskstore_epi32(int *, __m256i, __m256i); } 
#line 1583
extern "C" { extern void __cdecl _mm256_maskstore_epi64(__int64 *, __m256i, __m256i); } 
#line 1591
extern "C" { extern __m256i __cdecl _mm256_permutevar8x32_epi32(__m256i, __m256i); } 
#line 1592
extern "C" { extern __m256 __cdecl _mm256_permutevar8x32_ps(__m256, __m256i); } 
#line 1594
extern "C" { extern __m256i __cdecl _mm256_permute4x64_epi64(__m256i, const int); } 
#line 1595
extern "C" { extern __m256d __cdecl _mm256_permute4x64_pd(__m256d, const int); } 
#line 1597
extern "C" { extern __m256i __cdecl _mm256_permute2x128_si256(__m256i, __m256i, const int); } 
#line 1603
extern "C" { extern __m256i __cdecl _mm256_stream_load_si256(const __m256i *); } 
#line 1610
extern "C" { extern __m256d __cdecl _mm256_mask_i32gather_pd(__m256d, const double *, __m128i, __m256d, const int); } 
#line 1615
extern "C" { extern __m256 __cdecl _mm256_mask_i32gather_ps(__m256, const float *, __m256i, __m256, const int); } 
#line 1620
extern "C" { extern __m256d __cdecl _mm256_mask_i64gather_pd(__m256d, const double *, __m256i, __m256d, const int); } 
#line 1625
extern "C" { extern __m128 __cdecl _mm256_mask_i64gather_ps(__m128, const float *, __m256i, __m128, const int); } 
#line 1631
extern "C" { extern __m128d __cdecl _mm_mask_i32gather_pd(__m128d, const double *, __m128i, __m128d, const int); } 
#line 1636
extern "C" { extern __m128 __cdecl _mm_mask_i32gather_ps(__m128, const float *, __m128i, __m128, const int); } 
#line 1641
extern "C" { extern __m128d __cdecl _mm_mask_i64gather_pd(__m128d, const double *, __m128i, __m128d, const int); } 
#line 1646
extern "C" { extern __m128 __cdecl _mm_mask_i64gather_ps(__m128, const float *, __m128i, __m128, const int); } 
#line 1653
extern "C" { extern __m256i __cdecl _mm256_mask_i32gather_epi32(__m256i, const int *, __m256i, __m256i, const int); } 
#line 1658
extern "C" { extern __m256i __cdecl _mm256_mask_i32gather_epi64(__m256i, const __int64 *, __m128i, __m256i, const int); } 
#line 1663
extern "C" { extern __m128i __cdecl _mm256_mask_i64gather_epi32(__m128i, const int *, __m256i, __m128i, const int); } 
#line 1668
extern "C" { extern __m256i __cdecl _mm256_mask_i64gather_epi64(__m256i, const __int64 *, __m256i, __m256i, const int); } 
#line 1674
extern "C" { extern __m128i __cdecl _mm_mask_i32gather_epi32(__m128i, const int *, __m128i, __m128i, const int); } 
#line 1679
extern "C" { extern __m128i __cdecl _mm_mask_i32gather_epi64(__m128i, const __int64 *, __m128i, __m128i, const int); } 
#line 1684
extern "C" { extern __m128i __cdecl _mm_mask_i64gather_epi32(__m128i, const int *, __m128i, __m128i, const int); } 
#line 1689
extern "C" { extern __m128i __cdecl _mm_mask_i64gather_epi64(__m128i, const __int64 *, __m128i, __m128i, const int); } 
#line 1699
extern "C" { extern __m256d __cdecl _mm256_i32gather_pd(const double *, __m128i, const int); } 
#line 1702
extern "C" { extern __m256 __cdecl _mm256_i32gather_ps(const float *, __m256i, const int); } 
#line 1705
extern "C" { extern __m256d __cdecl _mm256_i64gather_pd(const double *, __m256i, const int); } 
#line 1708
extern "C" { extern __m128 __cdecl _mm256_i64gather_ps(const float *, __m256i, const int); } 
#line 1712
extern "C" { extern __m128d __cdecl _mm_i32gather_pd(const double *, __m128i, const int); } 
#line 1715
extern "C" { extern __m128 __cdecl _mm_i32gather_ps(const float *, __m128i, const int); } 
#line 1718
extern "C" { extern __m128d __cdecl _mm_i64gather_pd(const double *, __m128i, const int); } 
#line 1721
extern "C" { extern __m128 __cdecl _mm_i64gather_ps(const float *, __m128i, const int); } 
#line 1725
extern "C" { extern __m256i __cdecl _mm256_i32gather_epi32(const int *, __m256i, const int); } 
#line 1728
extern "C" { extern __m256i __cdecl _mm256_i32gather_epi64(const __int64 *, __m128i, const int); } 
#line 1731
extern "C" { extern __m128i __cdecl _mm256_i64gather_epi32(const int *, __m256i, const int); } 
#line 1734
extern "C" { extern __m256i __cdecl _mm256_i64gather_epi64(const __int64 *, __m256i, const int); } 
#line 1738
extern "C" { extern __m128i __cdecl _mm_i32gather_epi32(const int *, __m128i, const int); } 
#line 1741
extern "C" { extern __m128i __cdecl _mm_i32gather_epi64(const __int64 *, __m128i, const int); } 
#line 1744
extern "C" { extern __m128i __cdecl _mm_i64gather_epi32(const int *, __m128i, const int); } 
#line 1747
extern "C" { extern __m128i __cdecl _mm_i64gather_epi64(const __int64 *, __m128i, const int); } 
#line 1755
extern "C" { extern unsigned _bextr_u32(unsigned, unsigned, unsigned); } 
#line 1758
extern "C" { extern unsigned _blsi_u32(unsigned); } 
#line 1759
extern "C" { extern unsigned _blsmsk_u32(unsigned); } 
#line 1760
extern "C" { extern unsigned _blsr_u32(unsigned); } 
#line 1761
extern "C" { extern unsigned _bzhi_u32(unsigned, unsigned); } 
#line 1763
extern "C" { extern unsigned _mulx_u32(unsigned, unsigned, unsigned *); } 
#line 1766
extern "C" { extern unsigned _pdep_u32(unsigned, unsigned); } 
#line 1768
extern "C" { extern unsigned _pext_u32(unsigned, unsigned); } 
#line 1770
extern "C" { extern unsigned _rorx_u32(unsigned, const unsigned); } 
#line 1772
extern "C" { extern int _sarx_i32(int, unsigned); } 
#line 1774
extern "C" { extern unsigned _shlx_u32(unsigned, unsigned); } 
#line 1776
extern "C" { extern unsigned _shrx_u32(unsigned, unsigned); } 
#line 1812 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern unsigned _lzcnt_u32(unsigned); } 
#line 1824 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern unsigned _tzcnt_u32(unsigned); } 
#line 1834 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern void __cdecl _invpcid(unsigned, void *); } 
#line 1837
extern "C" { extern void _Store_HLERelease(volatile long *, long); } 
#line 1838
extern "C" { extern void _StorePointer_HLERelease(void *volatile *, void *); } 
#line 1840
extern "C" { extern long _InterlockedExchange_HLEAcquire(volatile long *, long); } 
#line 1841
extern "C" { extern long _InterlockedExchange_HLERelease(volatile long *, long); } 
#line 1842
extern "C" { extern void *_InterlockedExchangePointer_HLEAcquire(void *volatile *, void *); } 
#line 1843
extern "C" { extern void *_InterlockedExchangePointer_HLERelease(void *volatile *, void *); } 
#line 1845
extern "C" { extern long _InterlockedCompareExchange_HLEAcquire(volatile long *, long, long); } 
#line 1846
extern "C" { extern long _InterlockedCompareExchange_HLERelease(volatile long *, long, long); } 
#line 1847
extern "C" { extern __int64 _InterlockedCompareExchange64_HLEAcquire(volatile __int64 *, __int64, __int64); } 
#line 1848
extern "C" { extern __int64 _InterlockedCompareExchange64_HLERelease(volatile __int64 *, __int64, __int64); } 
#line 1849
extern "C" { extern void *_InterlockedCompareExchangePointer_HLEAcquire(void *volatile *, void *, void *); } 
#line 1850
extern "C" { extern void *_InterlockedCompareExchangePointer_HLERelease(void *volatile *, void *, void *); } 
#line 1852
extern "C" { extern long _InterlockedExchangeAdd_HLEAcquire(volatile long *, long); } 
#line 1853
extern "C" { extern long _InterlockedExchangeAdd_HLERelease(volatile long *, long); } 
#line 1855
extern "C" { extern long _InterlockedAnd_HLEAcquire(volatile long *, long); } 
#line 1856
extern "C" { extern long _InterlockedAnd_HLERelease(volatile long *, long); } 
#line 1857
extern "C" { extern long _InterlockedOr_HLEAcquire(volatile long *, long); } 
#line 1858
extern "C" { extern long _InterlockedOr_HLERelease(volatile long *, long); } 
#line 1859
extern "C" { extern long _InterlockedXor_HLEAcquire(volatile long *, long); } 
#line 1860
extern "C" { extern long _InterlockedXor_HLERelease(volatile long *, long); } 
#line 1862
extern "C" { extern unsigned char _interlockedbittestandset_HLEAcquire(long * a, long b); } 
#line 1863
extern "C" { extern unsigned char _interlockedbittestandset_HLERelease(long * a, long b); } 
#line 1864
extern "C" { extern unsigned char _interlockedbittestandreset_HLEAcquire(long * a, long b); } 
#line 1865
extern "C" { extern unsigned char _interlockedbittestandreset_HLERelease(long * a, long b); } 
#line 1898 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\immintrin.h"
extern "C" { extern unsigned __cdecl _xbegin(); } 
#line 1899
extern "C" { extern void __cdecl _xend(); } 
#line 1900
extern "C" { extern void __cdecl _xabort(const unsigned); } 
#line 1901
extern "C" { extern unsigned char __cdecl _xtest(); } 
#line 1910
extern "C" { extern int __cdecl _rdseed16_step(unsigned short *); } 
#line 1911
extern "C" { extern int __cdecl _rdseed32_step(unsigned *); } 
#line 1912
extern "C" { extern int __cdecl _rdseed64_step(unsigned __int64 *); } 
#line 1923
extern "C" { extern unsigned char __cdecl _addcarryx_u32(unsigned char, unsigned, unsigned, unsigned *); } 
#line 118 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ammintrin.h"
extern "C" { __m128 _mm_macc_ps(__m128, __m128, __m128); } 
#line 119
extern "C" { __m128d _mm_macc_pd(__m128d, __m128d, __m128d); } 
#line 120
extern "C" { __m128 _mm_macc_ss(__m128, __m128, __m128); } 
#line 121
extern "C" { __m128d _mm_macc_sd(__m128d, __m128d, __m128d); } 
#line 122
extern "C" { __m128 _mm_maddsub_ps(__m128, __m128, __m128); } 
#line 123
extern "C" { __m128d _mm_maddsub_pd(__m128d, __m128d, __m128d); } 
#line 124
extern "C" { __m128 _mm_msubadd_ps(__m128, __m128, __m128); } 
#line 125
extern "C" { __m128d _mm_msubadd_pd(__m128d, __m128d, __m128d); } 
#line 126
extern "C" { __m128 _mm_msub_ps(__m128, __m128, __m128); } 
#line 127
extern "C" { __m128d _mm_msub_pd(__m128d, __m128d, __m128d); } 
#line 128
extern "C" { __m128 _mm_msub_ss(__m128, __m128, __m128); } 
#line 129
extern "C" { __m128d _mm_msub_sd(__m128d, __m128d, __m128d); } 
#line 130
extern "C" { __m128 _mm_nmacc_ps(__m128, __m128, __m128); } 
#line 131
extern "C" { __m128d _mm_nmacc_pd(__m128d, __m128d, __m128d); } 
#line 132
extern "C" { __m128 _mm_nmacc_ss(__m128, __m128, __m128); } 
#line 133
extern "C" { __m128d _mm_nmacc_sd(__m128d, __m128d, __m128d); } 
#line 134
extern "C" { __m128 _mm_nmsub_ps(__m128, __m128, __m128); } 
#line 135
extern "C" { __m128d _mm_nmsub_pd(__m128d, __m128d, __m128d); } 
#line 136
extern "C" { __m128 _mm_nmsub_ss(__m128, __m128, __m128); } 
#line 137
extern "C" { __m128d _mm_nmsub_sd(__m128d, __m128d, __m128d); } 
#line 140
extern "C" { __m128i _mm_maccs_epi16(__m128i, __m128i, __m128i); } 
#line 141
extern "C" { __m128i _mm_macc_epi16(__m128i, __m128i, __m128i); } 
#line 142
extern "C" { __m128i _mm_maccsd_epi16(__m128i, __m128i, __m128i); } 
#line 143
extern "C" { __m128i _mm_maccd_epi16(__m128i, __m128i, __m128i); } 
#line 144
extern "C" { __m128i _mm_maccs_epi32(__m128i, __m128i, __m128i); } 
#line 145
extern "C" { __m128i _mm_macc_epi32(__m128i, __m128i, __m128i); } 
#line 146
extern "C" { __m128i _mm_maccslo_epi32(__m128i, __m128i, __m128i); } 
#line 147
extern "C" { __m128i _mm_macclo_epi32(__m128i, __m128i, __m128i); } 
#line 148
extern "C" { __m128i _mm_maccshi_epi32(__m128i, __m128i, __m128i); } 
#line 149
extern "C" { __m128i _mm_macchi_epi32(__m128i, __m128i, __m128i); } 
#line 150
extern "C" { __m128i _mm_maddsd_epi16(__m128i, __m128i, __m128i); } 
#line 151
extern "C" { __m128i _mm_maddd_epi16(__m128i, __m128i, __m128i); } 
#line 154
extern "C" { __m128i _mm_haddw_epi8(__m128i); } 
#line 155
extern "C" { __m128i _mm_haddd_epi8(__m128i); } 
#line 156
extern "C" { __m128i _mm_haddq_epi8(__m128i); } 
#line 157
extern "C" { __m128i _mm_haddd_epi16(__m128i); } 
#line 158
extern "C" { __m128i _mm_haddq_epi16(__m128i); } 
#line 159
extern "C" { __m128i _mm_haddq_epi32(__m128i); } 
#line 160
extern "C" { __m128i _mm_haddw_epu8(__m128i); } 
#line 161
extern "C" { __m128i _mm_haddd_epu8(__m128i); } 
#line 162
extern "C" { __m128i _mm_haddq_epu8(__m128i); } 
#line 163
extern "C" { __m128i _mm_haddd_epu16(__m128i); } 
#line 164
extern "C" { __m128i _mm_haddq_epu16(__m128i); } 
#line 165
extern "C" { __m128i _mm_haddq_epu32(__m128i); } 
#line 166
extern "C" { __m128i _mm_hsubw_epi8(__m128i); } 
#line 167
extern "C" { __m128i _mm_hsubd_epi16(__m128i); } 
#line 168
extern "C" { __m128i _mm_hsubq_epi32(__m128i); } 
#line 171
extern "C" { __m128i _mm_cmov_si128(__m128i, __m128i, __m128i); } 
#line 172
extern "C" { __m128i _mm_perm_epi8(__m128i, __m128i, __m128i); } 
#line 175
extern "C" { __m128i _mm_rot_epi8(__m128i, __m128i); } 
#line 176
extern "C" { __m128i _mm_rot_epi16(__m128i, __m128i); } 
#line 177
extern "C" { __m128i _mm_rot_epi32(__m128i, __m128i); } 
#line 178
extern "C" { __m128i _mm_rot_epi64(__m128i, __m128i); } 
#line 179
extern "C" { __m128i _mm_roti_epi8(__m128i, int); } 
#line 180
extern "C" { __m128i _mm_roti_epi16(__m128i, int); } 
#line 181
extern "C" { __m128i _mm_roti_epi32(__m128i, int); } 
#line 182
extern "C" { __m128i _mm_roti_epi64(__m128i, int); } 
#line 183
extern "C" { __m128i _mm_shl_epi8(__m128i, __m128i); } 
#line 184
extern "C" { __m128i _mm_shl_epi16(__m128i, __m128i); } 
#line 185
extern "C" { __m128i _mm_shl_epi32(__m128i, __m128i); } 
#line 186
extern "C" { __m128i _mm_shl_epi64(__m128i, __m128i); } 
#line 187
extern "C" { __m128i _mm_sha_epi8(__m128i, __m128i); } 
#line 188
extern "C" { __m128i _mm_sha_epi16(__m128i, __m128i); } 
#line 189
extern "C" { __m128i _mm_sha_epi32(__m128i, __m128i); } 
#line 190
extern "C" { __m128i _mm_sha_epi64(__m128i, __m128i); } 
#line 194
extern "C" { __m128i _mm_com_epu8(__m128i, __m128i, int); } 
#line 195
extern "C" { __m128i _mm_com_epu16(__m128i, __m128i, int); } 
#line 196
extern "C" { __m128i _mm_com_epu32(__m128i, __m128i, int); } 
#line 197
extern "C" { __m128i _mm_com_epu64(__m128i, __m128i, int); } 
#line 198
extern "C" { __m128i _mm_com_epi8(__m128i, __m128i, int); } 
#line 199
extern "C" { __m128i _mm_com_epi16(__m128i, __m128i, int); } 
#line 200
extern "C" { __m128i _mm_com_epi32(__m128i, __m128i, int); } 
#line 201
extern "C" { __m128i _mm_com_epi64(__m128i, __m128i, int); } 
#line 205
extern "C" { __m128 _mm_frcz_ps(__m128); } 
#line 206
extern "C" { __m128d _mm_frcz_pd(__m128d); } 
#line 207
extern "C" { __m128 _mm_frcz_ss(__m128, __m128); } 
#line 208
extern "C" { __m128d _mm_frcz_sd(__m128d, __m128d); } 
#line 217
extern "C" { __m128 _mm_permute2_ps(__m128, __m128, __m128i, int); } 
#line 218
extern "C" { __m128d _mm_permute2_pd(__m128d, __m128d, __m128i, int); } 
#line 222
extern "C" { __m256 _mm256_macc_ps(__m256, __m256, __m256); } 
#line 223
extern "C" { __m256d _mm256_macc_pd(__m256d, __m256d, __m256d); } 
#line 224
extern "C" { __m256 _mm256_maddsub_ps(__m256, __m256, __m256); } 
#line 225
extern "C" { __m256d _mm256_maddsub_pd(__m256d, __m256d, __m256d); } 
#line 226
extern "C" { __m256 _mm256_msubadd_ps(__m256, __m256, __m256); } 
#line 227
extern "C" { __m256d _mm256_msubadd_pd(__m256d, __m256d, __m256d); } 
#line 228
extern "C" { __m256 _mm256_msub_ps(__m256, __m256, __m256); } 
#line 229
extern "C" { __m256d _mm256_msub_pd(__m256d, __m256d, __m256d); } 
#line 230
extern "C" { __m256 _mm256_nmacc_ps(__m256, __m256, __m256); } 
#line 231
extern "C" { __m256d _mm256_nmacc_pd(__m256d, __m256d, __m256d); } 
#line 232
extern "C" { __m256 _mm256_nmsub_ps(__m256, __m256, __m256); } 
#line 233
extern "C" { __m256d _mm256_nmsub_pd(__m256d, __m256d, __m256d); } 
#line 234
extern "C" { __m256i _mm256_cmov_si256(__m256i, __m256i, __m256i); } 
#line 235
extern "C" { __m256 _mm256_frcz_ps(__m256); } 
#line 236
extern "C" { __m256d _mm256_frcz_pd(__m256d); } 
#line 237
extern "C" { __m256 _mm256_permute2_ps(__m256, __m256, __m256i, int); } 
#line 238
extern "C" { __m256d _mm256_permute2_pd(__m256d, __m256d, __m256i, int); } 
#line 241
extern "C" { void __llwpcb(void *); } 
#line 242
extern "C" { void *__slwpcb(); } 
#line 243
extern "C" { void __lwpval32(unsigned, unsigned, unsigned); } 
#line 244
extern "C" { unsigned char __lwpins32(unsigned, unsigned, unsigned); } 
#line 251 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ammintrin.h"
extern "C" { unsigned _bextr_u32(unsigned, unsigned, unsigned); } 
#line 252
extern "C" { unsigned _andn_u32(unsigned, unsigned); } 
#line 253
extern "C" { unsigned _tzcnt_u32(unsigned); } 
#line 254
extern "C" { unsigned _lzcnt_u32(unsigned); } 
#line 255
extern "C" { unsigned _blsr_u32(unsigned); } 
#line 256
extern "C" { unsigned _blsmsk_u32(unsigned); } 
#line 257
extern "C" { unsigned _blsi_u32(unsigned); } 
#line 269 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ammintrin.h"
extern "C" { unsigned _bextri_u32(unsigned, unsigned); } 
#line 270
extern "C" { unsigned _blcfill_u32(unsigned); } 
#line 271
extern "C" { unsigned _blsfill_u32(unsigned); } 
#line 272
extern "C" { unsigned _blcs_u32(unsigned); } 
#line 273
extern "C" { unsigned _tzmsk_u32(unsigned); } 
#line 274
extern "C" { unsigned _blcic_u32(unsigned); } 
#line 275
extern "C" { unsigned _blsic_u32(unsigned); } 
#line 276
extern "C" { unsigned _t1mskc_u32(unsigned); } 
#line 277
extern "C" { unsigned _blcmsk_u32(unsigned); } 
#line 278
extern "C" { unsigned _blci_u32(unsigned); } 
#line 31 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\mm3dnow.h"
extern "C" { void _m_femms(); } 
#line 32
extern "C" { __m64 _m_pavgusb(__m64, __m64); } 
#line 33
extern "C" { __m64 _m_pf2id(__m64); } 
#line 34
extern "C" { __m64 _m_pfacc(__m64, __m64); } 
#line 35
extern "C" { __m64 _m_pfadd(__m64, __m64); } 
#line 36
extern "C" { __m64 _m_pfcmpeq(__m64, __m64); } 
#line 37
extern "C" { __m64 _m_pfcmpge(__m64, __m64); } 
#line 38
extern "C" { __m64 _m_pfcmpgt(__m64, __m64); } 
#line 39
extern "C" { __m64 _m_pfmax(__m64, __m64); } 
#line 40
extern "C" { __m64 _m_pfmin(__m64, __m64); } 
#line 41
extern "C" { __m64 _m_pfmul(__m64, __m64); } 
#line 42
extern "C" { __m64 _m_pfrcp(__m64); } 
#line 43
extern "C" { __m64 _m_pfrcpit1(__m64, __m64); } 
#line 44
extern "C" { __m64 _m_pfrcpit2(__m64, __m64); } 
#line 45
extern "C" { __m64 _m_pfrsqrt(__m64); } 
#line 46
extern "C" { __m64 _m_pfrsqit1(__m64, __m64); } 
#line 47
extern "C" { __m64 _m_pfsub(__m64, __m64); } 
#line 48
extern "C" { __m64 _m_pfsubr(__m64, __m64); } 
#line 49
extern "C" { __m64 _m_pi2fd(__m64); } 
#line 50
extern "C" { __m64 _m_pmulhrw(__m64, __m64); } 
#line 51
extern "C" { void _m_prefetch(void *); } 
#line 52
extern "C" { void _m_prefetchw(const volatile void * _Source); } 
#line 54
extern "C" { __m64 _m_from_float(float); } 
#line 55
extern "C" { float _m_to_float(__m64); } 
#line 59
extern "C" { __m64 _m_pf2iw(__m64); } 
#line 60
extern "C" { __m64 _m_pfnacc(__m64, __m64); } 
#line 61
extern "C" { __m64 _m_pfpnacc(__m64, __m64); } 
#line 62
extern "C" { __m64 _m_pi2fw(__m64); } 
#line 63
extern "C" { __m64 _m_pswapd(__m64); } 
#line 107 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\intrin.h"
extern "C" { void *_AddressOfReturnAddress(); } 
#line 108
extern "C" { unsigned char _BitScanForward(unsigned long * _Index, unsigned long _Mask); } 
#line 110
extern "C" { unsigned char _BitScanReverse(unsigned long * _Index, unsigned long _Mask); } 
#line 131
extern "C" { long _InterlockedAddLargeStatistic(volatile __int64 * _Addend, long _Value); } 
#line 135
extern "C" { long _InterlockedAnd(volatile long * _Value, long _Mask); } 
#line 136
extern "C" { short _InterlockedAnd16(volatile short * _Value, short _Mask); } 
#line 146
extern "C" { char _InterlockedAnd8(volatile char * _Value, char _Mask); } 
#line 155
extern "C" { long __cdecl _InterlockedCompareExchange(volatile long * _Destination, long _Exchange, long _Comparand); } 
#line 159
extern "C" { short _InterlockedCompareExchange16(volatile short * _Destination, short _Exchange, short _Comparand); } 
#line 164
extern "C" { __int64 _InterlockedCompareExchange64(volatile __int64 * _Destination, __int64 _Exchange, __int64 _Comparand); } 
#line 169
extern "C" { char _InterlockedCompareExchange8(volatile char * _Destination, char _Exchange, char _Comparand); } 
#line 173
extern "C" { void *_InterlockedCompareExchangePointer(void *volatile * _Destination, void * _Exchange, void * _Comparand); } 
#line 182
extern "C" { long __cdecl _InterlockedDecrement(volatile long * _Addend); } 
#line 184
extern "C" { short _InterlockedDecrement16(volatile short * _Addend); } 
#line 195
extern "C" { long __cdecl _InterlockedExchange(volatile long * _Target, long _Value); } 
#line 197
extern "C" { short _InterlockedExchange16(volatile short * _Target, short _Value); } 
#line 205
extern "C" { char _InterlockedExchange8(volatile char * _Target, char _Value); } 
#line 209
extern "C" { long __cdecl _InterlockedExchangeAdd(volatile long * _Addend, long _Value); } 
#line 210
extern "C" { short _InterlockedExchangeAdd16(volatile short * _Addend, short _Value); } 
#line 218
extern "C" { char _InterlockedExchangeAdd8(volatile char * _Addend, char _Value); } 
#line 228
extern "C" { static __forceinline void *_Intrin_h_InterlockedExchangePointer(void *volatile *_Target, void *_Value) 
#line 229
{ 
#line 230
return (void *)_InterlockedExchange((volatile long *)_Target, (long)_Value); 
#line 231
} } 
#line 242 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\intrin.h"
extern "C" { long __cdecl _InterlockedIncrement(volatile long * _Addend); } 
#line 244
extern "C" { short _InterlockedIncrement16(volatile short * _Addend); } 
#line 255
extern "C" { long _InterlockedOr(volatile long * _Value, long _Mask); } 
#line 256
extern "C" { short _InterlockedOr16(volatile short * _Value, short _Mask); } 
#line 266
extern "C" { char _InterlockedOr8(volatile char * _Value, char _Mask); } 
#line 275
extern "C" { long _InterlockedXor(volatile long * _Value, long _Mask); } 
#line 276
extern "C" { short _InterlockedXor16(volatile short * _Value, short _Mask); } 
#line 286
extern "C" { char _InterlockedXor8(volatile char * _Value, char _Mask); } 
#line 303
extern "C" { void _ReadBarrier(); } 
#line 305
extern "C" { void _ReadWriteBarrier(); } 
#line 306
extern "C" { void *_ReturnAddress(); } 
#line 308
extern "C" { void _WriteBarrier(); } 
#line 310
extern "C" { void __addfsbyte(unsigned long, unsigned char); } 
#line 311
extern "C" { void __addfsdword(unsigned long, unsigned long); } 
#line 312
extern "C" { void __addfsword(unsigned long, unsigned short); } 
#line 317
extern "C" { void __code_seg(const char *); } 
#line 318
extern "C" { void __cpuid(int [4], int); } 
#line 319
extern "C" { void __cpuidex(int [4], int, int); } 
#line 320
extern "C" { void __cdecl __debugbreak(); } 
#line 322
extern "C" { __int64 __emul(int, int); } 
#line 323
extern "C" { unsigned __int64 __emulu(unsigned, unsigned); } 
#line 324
extern "C" { __declspec(noreturn) void __fastfail(unsigned); } 
#line 326
extern "C" { unsigned __getcallerseflags(); } 
#line 327
extern "C" { void __halt(); } 
#line 329
extern "C" { unsigned char __inbyte(unsigned short); } 
#line 330
extern "C" { void __inbytestring(unsigned short, unsigned char *, unsigned long); } 
#line 331
extern "C" { void __incfsbyte(unsigned long); } 
#line 332
extern "C" { void __incfsdword(unsigned long); } 
#line 333
extern "C" { void __incfsword(unsigned long); } 
#line 338
extern "C" { unsigned long __indword(unsigned short); } 
#line 339
extern "C" { void __indwordstring(unsigned short, unsigned long *, unsigned long); } 
#line 340
extern "C" { void __int2c(); } 
#line 341
extern "C" { void __invlpg(void *); } 
#line 342
extern "C" { unsigned short __inword(unsigned short); } 
#line 343
extern "C" { void __inwordstring(unsigned short, unsigned short *, unsigned long); } 
#line 353
extern "C" { void __lidt(void *); } 
#line 354
extern "C" { unsigned __int64 __ll_lshift(unsigned __int64, int); } 
#line 355
extern "C" { __int64 __ll_rshift(__int64, int); } 
#line 356
extern "C" { unsigned __lzcnt(unsigned); } 
#line 357
extern "C" { unsigned short __lzcnt16(unsigned short); } 
#line 359
extern "C" { void __movsb(unsigned char *, const unsigned char *, size_t); } 
#line 360
extern "C" { void __movsd(unsigned long *, const unsigned long *, size_t); } 
#line 362
extern "C" { void __movsw(unsigned short *, const unsigned short *, size_t); } 
#line 364
extern "C" { void __nop(); } 
#line 365
extern "C" { void __nvreg_restore_fence(); } 
#line 366
extern "C" { void __nvreg_save_fence(); } 
#line 367
extern "C" { void __outbyte(unsigned short, unsigned char); } 
#line 368
extern "C" { void __outbytestring(unsigned short, unsigned char *, unsigned long); } 
#line 369
extern "C" { void __outdword(unsigned short, unsigned long); } 
#line 370
extern "C" { void __outdwordstring(unsigned short, unsigned long *, unsigned long); } 
#line 371
extern "C" { void __outword(unsigned short, unsigned short); } 
#line 372
extern "C" { void __outwordstring(unsigned short, unsigned short *, unsigned long); } 
#line 373
extern "C" { unsigned __popcnt(unsigned); } 
#line 374
extern "C" { unsigned short __popcnt16(unsigned short); } 
#line 379
extern "C" { unsigned __int64 __rdtsc(); } 
#line 380
extern "C" { unsigned __int64 __rdtscp(unsigned *); } 
#line 382
extern "C" { unsigned long __readcr0(); } 
#line 384
extern "C" { unsigned long __readcr2(); } 
#line 386
extern "C" { unsigned long __readcr3(); } 
#line 388
extern "C" { unsigned long __readcr4(); } 
#line 390
extern "C" { unsigned long __readcr8(); } 
#line 392
extern "C" { unsigned __readdr(unsigned); } 
#line 394
extern "C" { unsigned __readeflags(); } 
#line 395
extern "C" { unsigned char __readfsbyte(unsigned long); } 
#line 396
extern "C" { unsigned long __readfsdword(unsigned long); } 
#line 397
extern "C" { unsigned __int64 __readfsqword(unsigned long); } 
#line 398
extern "C" { unsigned short __readfsword(unsigned long); } 
#line 403
extern "C" { unsigned __int64 __readmsr(unsigned long); } 
#line 404
extern "C" { unsigned __int64 __readpmc(unsigned long); } 
#line 405
extern "C" { unsigned long __segmentlimit(unsigned long); } 
#line 409
extern "C" { void __sidt(void *); } 
#line 411
extern "C" { void __stosb(unsigned char *, unsigned char, size_t); } 
#line 412
extern "C" { void __stosd(unsigned long *, unsigned long, size_t); } 
#line 414
extern "C" { void __stosw(unsigned short *, unsigned short, size_t); } 
#line 415
extern "C" { void __svm_clgi(); } 
#line 416
extern "C" { void __svm_invlpga(void *, int); } 
#line 417
extern "C" { void __svm_skinit(int); } 
#line 418
extern "C" { void __svm_stgi(); } 
#line 419
extern "C" { void __svm_vmload(size_t); } 
#line 420
extern "C" { void __svm_vmrun(size_t); } 
#line 421
extern "C" { void __svm_vmsave(size_t); } 
#line 425
extern "C" { void __ud2(); } 
#line 426
extern "C" { unsigned __int64 __ull_rshift(unsigned __int64, int); } 
#line 428
extern "C" { void __vmx_off(); } 
#line 433
extern "C" { void __vmx_vmptrst(unsigned __int64 *); } 
#line 437
extern "C" { void __wbinvd(); } 
#line 441
extern "C" { void __writecr0(unsigned); } 
#line 443
extern "C" { void __writecr3(unsigned); } 
#line 445
extern "C" { void __writecr4(unsigned); } 
#line 447
extern "C" { void __writecr8(unsigned); } 
#line 449
extern "C" { void __writedr(unsigned, unsigned); } 
#line 451
extern "C" { void __writeeflags(unsigned); } 
#line 452
extern "C" { void __writefsbyte(unsigned long, unsigned char); } 
#line 453
extern "C" { void __writefsdword(unsigned long, unsigned long); } 
#line 454
extern "C" { void __writefsqword(unsigned long, unsigned __int64); } 
#line 455
extern "C" { void __writefsword(unsigned long, unsigned short); } 
#line 460
extern "C" { void __writemsr(unsigned long, unsigned __int64); } 
#line 462
extern "C" { unsigned char _bittest(const long *, long); } 
#line 464
extern "C" { unsigned char _bittestandcomplement(long *, long); } 
#line 466
extern "C" { unsigned char _bittestandreset(long *, long); } 
#line 468
extern "C" { unsigned char _bittestandset(long *, long); } 
#line 470
extern "C" { unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64); } 
#line 471
extern "C" { unsigned long __cdecl _byteswap_ulong(unsigned long); } 
#line 472
extern "C" { unsigned short __cdecl _byteswap_ushort(unsigned short); } 
#line 473
extern "C" { void __cdecl _disable(); } 
#line 474
extern "C" { void __cdecl _enable(); } 
#line 475
extern "C" { unsigned char _interlockedbittestandreset(volatile long *, long); } 
#line 480
extern "C" { unsigned char _interlockedbittestandset(volatile long *, long); } 
#line 487
extern "C" { unsigned long __cdecl _lrotl(unsigned long, int); } 
#line 488
extern "C" { unsigned long __cdecl _lrotr(unsigned long, int); } 
#line 489
extern "C" { void _m_empty(); } 
#line 490
extern "C" { void _m_femms(); } 
#line 491
extern "C" { __m64 _m_from_float(float); } 
#line 492
extern "C" { __m64 _m_from_int(int); } 
#line 493
extern "C" { void _m_maskmovq(__m64, __m64, char *); } 
#line 494
extern "C" { __m64 _m_packssdw(__m64, __m64); } 
#line 495
extern "C" { __m64 _m_packsswb(__m64, __m64); } 
#line 496
extern "C" { __m64 _m_packuswb(__m64, __m64); } 
#line 497
extern "C" { __m64 _m_paddb(__m64, __m64); } 
#line 498
extern "C" { __m64 _m_paddd(__m64, __m64); } 
#line 499
extern "C" { __m64 _m_paddsb(__m64, __m64); } 
#line 500
extern "C" { __m64 _m_paddsw(__m64, __m64); } 
#line 501
extern "C" { __m64 _m_paddusb(__m64, __m64); } 
#line 502
extern "C" { __m64 _m_paddusw(__m64, __m64); } 
#line 503
extern "C" { __m64 _m_paddw(__m64, __m64); } 
#line 504
extern "C" { __m64 _m_pand(__m64, __m64); } 
#line 505
extern "C" { __m64 _m_pandn(__m64, __m64); } 
#line 506
extern "C" { __m64 _m_pavgb(__m64, __m64); } 
#line 507
extern "C" { __m64 _m_pavgusb(__m64, __m64); } 
#line 508
extern "C" { __m64 _m_pavgw(__m64, __m64); } 
#line 509
extern "C" { __m64 _m_pcmpeqb(__m64, __m64); } 
#line 510
extern "C" { __m64 _m_pcmpeqd(__m64, __m64); } 
#line 511
extern "C" { __m64 _m_pcmpeqw(__m64, __m64); } 
#line 512
extern "C" { __m64 _m_pcmpgtb(__m64, __m64); } 
#line 513
extern "C" { __m64 _m_pcmpgtd(__m64, __m64); } 
#line 514
extern "C" { __m64 _m_pcmpgtw(__m64, __m64); } 
#line 515
extern "C" { int _m_pextrw(__m64, int); } 
#line 516
extern "C" { __m64 _m_pf2id(__m64); } 
#line 517
extern "C" { __m64 _m_pf2iw(__m64); } 
#line 518
extern "C" { __m64 _m_pfacc(__m64, __m64); } 
#line 519
extern "C" { __m64 _m_pfadd(__m64, __m64); } 
#line 520
extern "C" { __m64 _m_pfcmpeq(__m64, __m64); } 
#line 521
extern "C" { __m64 _m_pfcmpge(__m64, __m64); } 
#line 522
extern "C" { __m64 _m_pfcmpgt(__m64, __m64); } 
#line 523
extern "C" { __m64 _m_pfmax(__m64, __m64); } 
#line 524
extern "C" { __m64 _m_pfmin(__m64, __m64); } 
#line 525
extern "C" { __m64 _m_pfmul(__m64, __m64); } 
#line 526
extern "C" { __m64 _m_pfnacc(__m64, __m64); } 
#line 527
extern "C" { __m64 _m_pfpnacc(__m64, __m64); } 
#line 528
extern "C" { __m64 _m_pfrcp(__m64); } 
#line 529
extern "C" { __m64 _m_pfrcpit1(__m64, __m64); } 
#line 530
extern "C" { __m64 _m_pfrcpit2(__m64, __m64); } 
#line 531
extern "C" { __m64 _m_pfrsqit1(__m64, __m64); } 
#line 532
extern "C" { __m64 _m_pfrsqrt(__m64); } 
#line 533
extern "C" { __m64 _m_pfsub(__m64, __m64); } 
#line 534
extern "C" { __m64 _m_pfsubr(__m64, __m64); } 
#line 535
extern "C" { __m64 _m_pi2fd(__m64); } 
#line 536
extern "C" { __m64 _m_pi2fw(__m64); } 
#line 537
extern "C" { __m64 _m_pinsrw(__m64, int, int); } 
#line 538
extern "C" { __m64 _m_pmaddwd(__m64, __m64); } 
#line 539
extern "C" { __m64 _m_pmaxsw(__m64, __m64); } 
#line 540
extern "C" { __m64 _m_pmaxub(__m64, __m64); } 
#line 541
extern "C" { __m64 _m_pminsw(__m64, __m64); } 
#line 542
extern "C" { __m64 _m_pminub(__m64, __m64); } 
#line 543
extern "C" { int _m_pmovmskb(__m64); } 
#line 544
extern "C" { __m64 _m_pmulhrw(__m64, __m64); } 
#line 545
extern "C" { __m64 _m_pmulhuw(__m64, __m64); } 
#line 546
extern "C" { __m64 _m_pmulhw(__m64, __m64); } 
#line 547
extern "C" { __m64 _m_pmullw(__m64, __m64); } 
#line 548
extern "C" { __m64 _m_por(__m64, __m64); } 
#line 549
extern "C" { void _m_prefetch(void *); } 
#line 550
extern "C" { void _m_prefetchw(const volatile void *); } 
#line 551
extern "C" { __m64 _m_psadbw(__m64, __m64); } 
#line 552
extern "C" { __m64 _m_pshufw(__m64, int); } 
#line 553
extern "C" { __m64 _m_pslld(__m64, __m64); } 
#line 554
extern "C" { __m64 _m_pslldi(__m64, int); } 
#line 555
extern "C" { __m64 _m_psllq(__m64, __m64); } 
#line 556
extern "C" { __m64 _m_psllqi(__m64, int); } 
#line 557
extern "C" { __m64 _m_psllw(__m64, __m64); } 
#line 558
extern "C" { __m64 _m_psllwi(__m64, int); } 
#line 559
extern "C" { __m64 _m_psrad(__m64, __m64); } 
#line 560
extern "C" { __m64 _m_psradi(__m64, int); } 
#line 561
extern "C" { __m64 _m_psraw(__m64, __m64); } 
#line 562
extern "C" { __m64 _m_psrawi(__m64, int); } 
#line 563
extern "C" { __m64 _m_psrld(__m64, __m64); } 
#line 564
extern "C" { __m64 _m_psrldi(__m64, int); } 
#line 565
extern "C" { __m64 _m_psrlq(__m64, __m64); } 
#line 566
extern "C" { __m64 _m_psrlqi(__m64, int); } 
#line 567
extern "C" { __m64 _m_psrlw(__m64, __m64); } 
#line 568
extern "C" { __m64 _m_psrlwi(__m64, int); } 
#line 569
extern "C" { __m64 _m_psubb(__m64, __m64); } 
#line 570
extern "C" { __m64 _m_psubd(__m64, __m64); } 
#line 571
extern "C" { __m64 _m_psubsb(__m64, __m64); } 
#line 572
extern "C" { __m64 _m_psubsw(__m64, __m64); } 
#line 573
extern "C" { __m64 _m_psubusb(__m64, __m64); } 
#line 574
extern "C" { __m64 _m_psubusw(__m64, __m64); } 
#line 575
extern "C" { __m64 _m_psubw(__m64, __m64); } 
#line 576
extern "C" { __m64 _m_pswapd(__m64); } 
#line 577
extern "C" { __m64 _m_punpckhbw(__m64, __m64); } 
#line 578
extern "C" { __m64 _m_punpckhdq(__m64, __m64); } 
#line 579
extern "C" { __m64 _m_punpckhwd(__m64, __m64); } 
#line 580
extern "C" { __m64 _m_punpcklbw(__m64, __m64); } 
#line 581
extern "C" { __m64 _m_punpckldq(__m64, __m64); } 
#line 582
extern "C" { __m64 _m_punpcklwd(__m64, __m64); } 
#line 583
extern "C" { __m64 _m_pxor(__m64, __m64); } 
#line 584
extern "C" { float _m_to_float(__m64); } 
#line 585
extern "C" { int _m_to_int(__m64); } 
#line 586
extern "C" { __m128i _mm_abs_epi16(__m128i); } 
#line 587
extern "C" { __m128i _mm_abs_epi32(__m128i); } 
#line 588
extern "C" { __m128i _mm_abs_epi8(__m128i); } 
#line 589
extern "C" { __m64 _mm_abs_pi16(__m64); } 
#line 590
extern "C" { __m64 _mm_abs_pi32(__m64); } 
#line 591
extern "C" { __m64 _mm_abs_pi8(__m64); } 
#line 592
extern "C" { __m128i _mm_add_epi16(__m128i, __m128i); } 
#line 593
extern "C" { __m128i _mm_add_epi32(__m128i, __m128i); } 
#line 594
extern "C" { __m128i _mm_add_epi64(__m128i, __m128i); } 
#line 595
extern "C" { __m128i _mm_add_epi8(__m128i, __m128i); } 
#line 596
extern "C" { __m128d _mm_add_pd(__m128d, __m128d); } 
#line 597
extern "C" { __m128 _mm_add_ps(__m128, __m128); } 
#line 598
extern "C" { __m128d _mm_add_sd(__m128d, __m128d); } 
#line 599
extern "C" { __m64 _mm_add_si64(__m64, __m64); } 
#line 600
extern "C" { __m128 _mm_add_ss(__m128, __m128); } 
#line 601
extern "C" { __m128i _mm_adds_epi16(__m128i, __m128i); } 
#line 602
extern "C" { __m128i _mm_adds_epi8(__m128i, __m128i); } 
#line 603
extern "C" { __m128i _mm_adds_epu16(__m128i, __m128i); } 
#line 604
extern "C" { __m128i _mm_adds_epu8(__m128i, __m128i); } 
#line 605
extern "C" { __m128d _mm_addsub_pd(__m128d, __m128d); } 
#line 606
extern "C" { __m128 _mm_addsub_ps(__m128, __m128); } 
#line 607
extern "C" { __m128i _mm_alignr_epi8(__m128i, __m128i, int); } 
#line 608
extern "C" { __m64 _mm_alignr_pi8(__m64, __m64, int); } 
#line 609
extern "C" { __m128d _mm_and_pd(__m128d, __m128d); } 
#line 610
extern "C" { __m128 _mm_and_ps(__m128, __m128); } 
#line 611
extern "C" { __m128i _mm_and_si128(__m128i, __m128i); } 
#line 612
extern "C" { __m128d _mm_andnot_pd(__m128d, __m128d); } 
#line 613
extern "C" { __m128 _mm_andnot_ps(__m128, __m128); } 
#line 614
extern "C" { __m128i _mm_andnot_si128(__m128i, __m128i); } 
#line 615
extern "C" { __m128i _mm_avg_epu16(__m128i, __m128i); } 
#line 616
extern "C" { __m128i _mm_avg_epu8(__m128i, __m128i); } 
#line 617
extern "C" { __m128i _mm_blend_epi16(__m128i, __m128i, int); } 
#line 618
extern "C" { __m128d _mm_blend_pd(__m128d, __m128d, int); } 
#line 619
extern "C" { __m128 _mm_blend_ps(__m128, __m128, int); } 
#line 620
extern "C" { __m128i _mm_blendv_epi8(__m128i, __m128i, __m128i); } 
#line 621
extern "C" { __m128d _mm_blendv_pd(__m128d, __m128d, __m128d); } 
#line 622
extern "C" { __m128 _mm_blendv_ps(__m128, __m128, __m128); } 
#line 623
extern "C" { void _mm_clflush(const void *); } 
#line 624
extern "C" { __m128i _mm_cmpeq_epi16(__m128i, __m128i); } 
#line 625
extern "C" { __m128i _mm_cmpeq_epi32(__m128i, __m128i); } 
#line 626
extern "C" { __m128i _mm_cmpeq_epi64(__m128i, __m128i); } 
#line 627
extern "C" { __m128i _mm_cmpeq_epi8(__m128i, __m128i); } 
#line 628
extern "C" { __m128d _mm_cmpeq_pd(__m128d, __m128d); } 
#line 629
extern "C" { __m128 _mm_cmpeq_ps(__m128, __m128); } 
#line 630
extern "C" { __m128d _mm_cmpeq_sd(__m128d, __m128d); } 
#line 631
extern "C" { __m128 _mm_cmpeq_ss(__m128, __m128); } 
#line 632
extern "C" { int _mm_cmpestra(__m128i, int, __m128i, int, int); } 
#line 633
extern "C" { int _mm_cmpestrc(__m128i, int, __m128i, int, int); } 
#line 634
extern "C" { int _mm_cmpestri(__m128i, int, __m128i, int, int); } 
#line 635
extern "C" { __m128i _mm_cmpestrm(__m128i, int, __m128i, int, int); } 
#line 636
extern "C" { int _mm_cmpestro(__m128i, int, __m128i, int, int); } 
#line 637
extern "C" { int _mm_cmpestrs(__m128i, int, __m128i, int, int); } 
#line 638
extern "C" { int _mm_cmpestrz(__m128i, int, __m128i, int, int); } 
#line 639
extern "C" { __m128d _mm_cmpge_pd(__m128d, __m128d); } 
#line 640
extern "C" { __m128 _mm_cmpge_ps(__m128, __m128); } 
#line 641
extern "C" { __m128d _mm_cmpge_sd(__m128d, __m128d); } 
#line 642
extern "C" { __m128 _mm_cmpge_ss(__m128, __m128); } 
#line 643
extern "C" { __m128i _mm_cmpgt_epi16(__m128i, __m128i); } 
#line 644
extern "C" { __m128i _mm_cmpgt_epi32(__m128i, __m128i); } 
#line 645
extern "C" { __m128i _mm_cmpgt_epi64(__m128i, __m128i); } 
#line 646
extern "C" { __m128i _mm_cmpgt_epi8(__m128i, __m128i); } 
#line 647
extern "C" { __m128d _mm_cmpgt_pd(__m128d, __m128d); } 
#line 648
extern "C" { __m128 _mm_cmpgt_ps(__m128, __m128); } 
#line 649
extern "C" { __m128d _mm_cmpgt_sd(__m128d, __m128d); } 
#line 650
extern "C" { __m128 _mm_cmpgt_ss(__m128, __m128); } 
#line 651
extern "C" { int _mm_cmpistra(__m128i, __m128i, int); } 
#line 652
extern "C" { int _mm_cmpistrc(__m128i, __m128i, int); } 
#line 653
extern "C" { int _mm_cmpistri(__m128i, __m128i, int); } 
#line 654
extern "C" { __m128i _mm_cmpistrm(__m128i, __m128i, int); } 
#line 655
extern "C" { int _mm_cmpistro(__m128i, __m128i, int); } 
#line 656
extern "C" { int _mm_cmpistrs(__m128i, __m128i, int); } 
#line 657
extern "C" { int _mm_cmpistrz(__m128i, __m128i, int); } 
#line 658
extern "C" { __m128d _mm_cmple_pd(__m128d, __m128d); } 
#line 659
extern "C" { __m128 _mm_cmple_ps(__m128, __m128); } 
#line 660
extern "C" { __m128d _mm_cmple_sd(__m128d, __m128d); } 
#line 661
extern "C" { __m128 _mm_cmple_ss(__m128, __m128); } 
#line 662
extern "C" { __m128i _mm_cmplt_epi16(__m128i, __m128i); } 
#line 663
extern "C" { __m128i _mm_cmplt_epi32(__m128i, __m128i); } 
#line 664
extern "C" { __m128i _mm_cmplt_epi8(__m128i, __m128i); } 
#line 665
extern "C" { __m128d _mm_cmplt_pd(__m128d, __m128d); } 
#line 666
extern "C" { __m128 _mm_cmplt_ps(__m128, __m128); } 
#line 667
extern "C" { __m128d _mm_cmplt_sd(__m128d, __m128d); } 
#line 668
extern "C" { __m128 _mm_cmplt_ss(__m128, __m128); } 
#line 669
extern "C" { __m128d _mm_cmpneq_pd(__m128d, __m128d); } 
#line 670
extern "C" { __m128 _mm_cmpneq_ps(__m128, __m128); } 
#line 671
extern "C" { __m128d _mm_cmpneq_sd(__m128d, __m128d); } 
#line 672
extern "C" { __m128 _mm_cmpneq_ss(__m128, __m128); } 
#line 673
extern "C" { __m128d _mm_cmpnge_pd(__m128d, __m128d); } 
#line 674
extern "C" { __m128 _mm_cmpnge_ps(__m128, __m128); } 
#line 675
extern "C" { __m128d _mm_cmpnge_sd(__m128d, __m128d); } 
#line 676
extern "C" { __m128 _mm_cmpnge_ss(__m128, __m128); } 
#line 677
extern "C" { __m128d _mm_cmpngt_pd(__m128d, __m128d); } 
#line 678
extern "C" { __m128 _mm_cmpngt_ps(__m128, __m128); } 
#line 679
extern "C" { __m128d _mm_cmpngt_sd(__m128d, __m128d); } 
#line 680
extern "C" { __m128 _mm_cmpngt_ss(__m128, __m128); } 
#line 681
extern "C" { __m128d _mm_cmpnle_pd(__m128d, __m128d); } 
#line 682
extern "C" { __m128 _mm_cmpnle_ps(__m128, __m128); } 
#line 683
extern "C" { __m128d _mm_cmpnle_sd(__m128d, __m128d); } 
#line 684
extern "C" { __m128 _mm_cmpnle_ss(__m128, __m128); } 
#line 685
extern "C" { __m128d _mm_cmpnlt_pd(__m128d, __m128d); } 
#line 686
extern "C" { __m128 _mm_cmpnlt_ps(__m128, __m128); } 
#line 687
extern "C" { __m128d _mm_cmpnlt_sd(__m128d, __m128d); } 
#line 688
extern "C" { __m128 _mm_cmpnlt_ss(__m128, __m128); } 
#line 689
extern "C" { __m128d _mm_cmpord_pd(__m128d, __m128d); } 
#line 690
extern "C" { __m128 _mm_cmpord_ps(__m128, __m128); } 
#line 691
extern "C" { __m128d _mm_cmpord_sd(__m128d, __m128d); } 
#line 692
extern "C" { __m128 _mm_cmpord_ss(__m128, __m128); } 
#line 693
extern "C" { __m128d _mm_cmpunord_pd(__m128d, __m128d); } 
#line 694
extern "C" { __m128 _mm_cmpunord_ps(__m128, __m128); } 
#line 695
extern "C" { __m128d _mm_cmpunord_sd(__m128d, __m128d); } 
#line 696
extern "C" { __m128 _mm_cmpunord_ss(__m128, __m128); } 
#line 697
extern "C" { int _mm_comieq_sd(__m128d, __m128d); } 
#line 698
extern "C" { int _mm_comieq_ss(__m128, __m128); } 
#line 699
extern "C" { int _mm_comige_sd(__m128d, __m128d); } 
#line 700
extern "C" { int _mm_comige_ss(__m128, __m128); } 
#line 701
extern "C" { int _mm_comigt_sd(__m128d, __m128d); } 
#line 702
extern "C" { int _mm_comigt_ss(__m128, __m128); } 
#line 703
extern "C" { int _mm_comile_sd(__m128d, __m128d); } 
#line 704
extern "C" { int _mm_comile_ss(__m128, __m128); } 
#line 705
extern "C" { int _mm_comilt_sd(__m128d, __m128d); } 
#line 706
extern "C" { int _mm_comilt_ss(__m128, __m128); } 
#line 707
extern "C" { int _mm_comineq_sd(__m128d, __m128d); } 
#line 708
extern "C" { int _mm_comineq_ss(__m128, __m128); } 
#line 709
extern "C" { unsigned _mm_crc32_u16(unsigned, unsigned short); } 
#line 710
extern "C" { unsigned _mm_crc32_u32(unsigned, unsigned); } 
#line 712
extern "C" { unsigned _mm_crc32_u8(unsigned, unsigned char); } 
#line 713
extern "C" { __m128 _mm_cvt_pi2ps(__m128, __m64); } 
#line 714
extern "C" { __m64 _mm_cvt_ps2pi(__m128); } 
#line 715
extern "C" { __m128 _mm_cvt_si2ss(__m128, int); } 
#line 716
extern "C" { int _mm_cvt_ss2si(__m128); } 
#line 717
extern "C" { __m128i _mm_cvtepi16_epi32(__m128i); } 
#line 718
extern "C" { __m128i _mm_cvtepi16_epi64(__m128i); } 
#line 719
extern "C" { __m128i _mm_cvtepi32_epi64(__m128i); } 
#line 720
extern "C" { __m128d _mm_cvtepi32_pd(__m128i); } 
#line 721
extern "C" { __m128 _mm_cvtepi32_ps(__m128i); } 
#line 722
extern "C" { __m128i _mm_cvtepi8_epi16(__m128i); } 
#line 723
extern "C" { __m128i _mm_cvtepi8_epi32(__m128i); } 
#line 724
extern "C" { __m128i _mm_cvtepi8_epi64(__m128i); } 
#line 725
extern "C" { __m128i _mm_cvtepu16_epi32(__m128i); } 
#line 726
extern "C" { __m128i _mm_cvtepu16_epi64(__m128i); } 
#line 727
extern "C" { __m128i _mm_cvtepu32_epi64(__m128i); } 
#line 728
extern "C" { __m128i _mm_cvtepu8_epi16(__m128i); } 
#line 729
extern "C" { __m128i _mm_cvtepu8_epi32(__m128i); } 
#line 730
extern "C" { __m128i _mm_cvtepu8_epi64(__m128i); } 
#line 731
extern "C" { __m128i _mm_cvtpd_epi32(__m128d); } 
#line 732
extern "C" { __m64 _mm_cvtpd_pi32(__m128d); } 
#line 733
extern "C" { __m128 _mm_cvtpd_ps(__m128d); } 
#line 734
extern "C" { __m128d _mm_cvtpi32_pd(__m64); } 
#line 735
extern "C" { __m128i _mm_cvtps_epi32(__m128); } 
#line 736
extern "C" { __m128d _mm_cvtps_pd(__m128); } 
#line 737
extern "C" { int _mm_cvtsd_si32(__m128d); } 
#line 740
extern "C" { __m128 _mm_cvtsd_ss(__m128, __m128d); } 
#line 741
extern "C" { int _mm_cvtsi128_si32(__m128i); } 
#line 744
extern "C" { __m128d _mm_cvtsi32_sd(__m128d, int); } 
#line 745
extern "C" { __m128i _mm_cvtsi32_si128(int); } 
#line 752
extern "C" { __m128d _mm_cvtss_sd(__m128d, __m128); } 
#line 755
extern "C" { __m64 _mm_cvtt_ps2pi(__m128); } 
#line 756
extern "C" { int _mm_cvtt_ss2si(__m128); } 
#line 757
extern "C" { __m128i _mm_cvttpd_epi32(__m128d); } 
#line 758
extern "C" { __m64 _mm_cvttpd_pi32(__m128d); } 
#line 759
extern "C" { __m128i _mm_cvttps_epi32(__m128); } 
#line 760
extern "C" { int _mm_cvttsd_si32(__m128d); } 
#line 765
extern "C" { __m128d _mm_div_pd(__m128d, __m128d); } 
#line 766
extern "C" { __m128 _mm_div_ps(__m128, __m128); } 
#line 767
extern "C" { __m128d _mm_div_sd(__m128d, __m128d); } 
#line 768
extern "C" { __m128 _mm_div_ss(__m128, __m128); } 
#line 769
extern "C" { __m128d _mm_dp_pd(__m128d, __m128d, int); } 
#line 770
extern "C" { __m128 _mm_dp_ps(__m128, __m128, int); } 
#line 771
extern "C" { int _mm_extract_epi16(__m128i, int); } 
#line 772
extern "C" { int _mm_extract_epi32(__m128i, int); } 
#line 774
extern "C" { int _mm_extract_epi8(__m128i, int); } 
#line 775
extern "C" { int _mm_extract_ps(__m128, int); } 
#line 776
extern "C" { __m128i _mm_extract_si64(__m128i, __m128i); } 
#line 777
extern "C" { __m128i _mm_extracti_si64(__m128i, int, int); } 
#line 778
extern "C" { unsigned _mm_getcsr(); } 
#line 779
extern "C" { __m128i _mm_hadd_epi16(__m128i, __m128i); } 
#line 780
extern "C" { __m128i _mm_hadd_epi32(__m128i, __m128i); } 
#line 781
extern "C" { __m128d _mm_hadd_pd(__m128d, __m128d); } 
#line 782
extern "C" { __m64 _mm_hadd_pi16(__m64, __m64); } 
#line 783
extern "C" { __m64 _mm_hadd_pi32(__m64, __m64); } 
#line 784
extern "C" { __m128 _mm_hadd_ps(__m128, __m128); } 
#line 785
extern "C" { __m128i _mm_hadds_epi16(__m128i, __m128i); } 
#line 786
extern "C" { __m64 _mm_hadds_pi16(__m64, __m64); } 
#line 787
extern "C" { __m128i _mm_hsub_epi16(__m128i, __m128i); } 
#line 788
extern "C" { __m128i _mm_hsub_epi32(__m128i, __m128i); } 
#line 789
extern "C" { __m128d _mm_hsub_pd(__m128d, __m128d); } 
#line 790
extern "C" { __m64 _mm_hsub_pi16(__m64, __m64); } 
#line 791
extern "C" { __m64 _mm_hsub_pi32(__m64, __m64); } 
#line 792
extern "C" { __m128 _mm_hsub_ps(__m128, __m128); } 
#line 793
extern "C" { __m128i _mm_hsubs_epi16(__m128i, __m128i); } 
#line 794
extern "C" { __m64 _mm_hsubs_pi16(__m64, __m64); } 
#line 795
extern "C" { __m128i _mm_insert_epi16(__m128i, int, int); } 
#line 796
extern "C" { __m128i _mm_insert_epi32(__m128i, int, int); } 
#line 798
extern "C" { __m128i _mm_insert_epi8(__m128i, int, int); } 
#line 799
extern "C" { __m128 _mm_insert_ps(__m128, __m128, int); } 
#line 800
extern "C" { __m128i _mm_insert_si64(__m128i, __m128i); } 
#line 801
extern "C" { __m128i _mm_inserti_si64(__m128i, __m128i, int, int); } 
#line 802
extern "C" { __m128i _mm_lddqu_si128(const __m128i *); } 
#line 803
extern "C" { void _mm_lfence(); } 
#line 804
extern "C" { __m128d _mm_load1_pd(const double *); } 
#line 805
extern "C" { __m128d _mm_load_pd(const double *); } 
#line 806
extern "C" { __m128 _mm_load_ps(const float *); } 
#line 807
extern "C" { __m128 _mm_load_ps1(const float *); } 
#line 808
extern "C" { __m128d _mm_load_sd(const double *); } 
#line 809
extern "C" { __m128i _mm_load_si128(const __m128i *); } 
#line 810
extern "C" { __m128 _mm_load_ss(const float *); } 
#line 811
extern "C" { __m128d _mm_loaddup_pd(const double *); } 
#line 812
extern "C" { __m128d _mm_loadh_pd(__m128d, const double *); } 
#line 813
extern "C" { __m128 _mm_loadh_pi(__m128, const __m64 *); } 
#line 814
extern "C" { __m128i _mm_loadl_epi64(const __m128i *); } 
#line 815
extern "C" { __m128d _mm_loadl_pd(__m128d, const double *); } 
#line 816
extern "C" { __m128 _mm_loadl_pi(__m128, const __m64 *); } 
#line 817
extern "C" { __m128d _mm_loadr_pd(const double *); } 
#line 818
extern "C" { __m128 _mm_loadr_ps(const float *); } 
#line 819
extern "C" { __m128d _mm_loadu_pd(const double *); } 
#line 820
extern "C" { __m128 _mm_loadu_ps(const float *); } 
#line 821
extern "C" { __m128i _mm_loadu_si128(const __m128i *); } 
#line 822
extern "C" { __m128i _mm_madd_epi16(__m128i, __m128i); } 
#line 823
extern "C" { __m128i _mm_maddubs_epi16(__m128i, __m128i); } 
#line 824
extern "C" { __m64 _mm_maddubs_pi16(__m64, __m64); } 
#line 825
extern "C" { void _mm_maskmoveu_si128(__m128i, __m128i, char *); } 
#line 826
extern "C" { __m128i _mm_max_epi16(__m128i, __m128i); } 
#line 827
extern "C" { __m128i _mm_max_epi32(__m128i, __m128i); } 
#line 828
extern "C" { __m128i _mm_max_epi8(__m128i, __m128i); } 
#line 829
extern "C" { __m128i _mm_max_epu16(__m128i, __m128i); } 
#line 830
extern "C" { __m128i _mm_max_epu32(__m128i, __m128i); } 
#line 831
extern "C" { __m128i _mm_max_epu8(__m128i, __m128i); } 
#line 832
extern "C" { __m128d _mm_max_pd(__m128d, __m128d); } 
#line 833
extern "C" { __m128 _mm_max_ps(__m128, __m128); } 
#line 834
extern "C" { __m128d _mm_max_sd(__m128d, __m128d); } 
#line 835
extern "C" { __m128 _mm_max_ss(__m128, __m128); } 
#line 836
extern "C" { void _mm_mfence(); } 
#line 837
extern "C" { __m128i _mm_min_epi16(__m128i, __m128i); } 
#line 838
extern "C" { __m128i _mm_min_epi32(__m128i, __m128i); } 
#line 839
extern "C" { __m128i _mm_min_epi8(__m128i, __m128i); } 
#line 840
extern "C" { __m128i _mm_min_epu16(__m128i, __m128i); } 
#line 841
extern "C" { __m128i _mm_min_epu32(__m128i, __m128i); } 
#line 842
extern "C" { __m128i _mm_min_epu8(__m128i, __m128i); } 
#line 843
extern "C" { __m128d _mm_min_pd(__m128d, __m128d); } 
#line 844
extern "C" { __m128 _mm_min_ps(__m128, __m128); } 
#line 845
extern "C" { __m128d _mm_min_sd(__m128d, __m128d); } 
#line 846
extern "C" { __m128 _mm_min_ss(__m128, __m128); } 
#line 847
extern "C" { __m128i _mm_minpos_epu16(__m128i); } 
#line 848
extern "C" { void _mm_monitor(const void *, unsigned, unsigned); } 
#line 849
extern "C" { __m128i _mm_move_epi64(__m128i); } 
#line 850
extern "C" { __m128d _mm_move_sd(__m128d, __m128d); } 
#line 851
extern "C" { __m128 _mm_move_ss(__m128, __m128); } 
#line 852
extern "C" { __m128d _mm_movedup_pd(__m128d); } 
#line 853
extern "C" { __m128 _mm_movehdup_ps(__m128); } 
#line 854
extern "C" { __m128 _mm_movehl_ps(__m128, __m128); } 
#line 855
extern "C" { __m128 _mm_moveldup_ps(__m128); } 
#line 856
extern "C" { __m128 _mm_movelh_ps(__m128, __m128); } 
#line 857
extern "C" { int _mm_movemask_epi8(__m128i); } 
#line 858
extern "C" { int _mm_movemask_pd(__m128d); } 
#line 859
extern "C" { int _mm_movemask_ps(__m128); } 
#line 860
extern "C" { __m64 _mm_movepi64_pi64(__m128i); } 
#line 861
extern "C" { __m128i _mm_movpi64_epi64(__m64); } 
#line 862
extern "C" { __m128i _mm_mpsadbw_epu8(__m128i, __m128i, int); } 
#line 863
extern "C" { __m128i _mm_mul_epi32(__m128i, __m128i); } 
#line 864
extern "C" { __m128i _mm_mul_epu32(__m128i, __m128i); } 
#line 865
extern "C" { __m128d _mm_mul_pd(__m128d, __m128d); } 
#line 866
extern "C" { __m128 _mm_mul_ps(__m128, __m128); } 
#line 867
extern "C" { __m128d _mm_mul_sd(__m128d, __m128d); } 
#line 868
extern "C" { __m128 _mm_mul_ss(__m128, __m128); } 
#line 869
extern "C" { __m64 _mm_mul_su32(__m64, __m64); } 
#line 870
extern "C" { __m128i _mm_mulhi_epi16(__m128i, __m128i); } 
#line 871
extern "C" { __m128i _mm_mulhi_epu16(__m128i, __m128i); } 
#line 872
extern "C" { __m128i _mm_mulhrs_epi16(__m128i, __m128i); } 
#line 873
extern "C" { __m64 _mm_mulhrs_pi16(__m64, __m64); } 
#line 874
extern "C" { __m128i _mm_mullo_epi16(__m128i, __m128i); } 
#line 875
extern "C" { __m128i _mm_mullo_epi32(__m128i, __m128i); } 
#line 876
extern "C" { void _mm_mwait(unsigned, unsigned); } 
#line 877
extern "C" { __m128d _mm_or_pd(__m128d, __m128d); } 
#line 878
extern "C" { __m128 _mm_or_ps(__m128, __m128); } 
#line 879
extern "C" { __m128i _mm_or_si128(__m128i, __m128i); } 
#line 880
extern "C" { __m128i _mm_packs_epi16(__m128i, __m128i); } 
#line 881
extern "C" { __m128i _mm_packs_epi32(__m128i, __m128i); } 
#line 882
extern "C" { __m128i _mm_packus_epi16(__m128i, __m128i); } 
#line 883
extern "C" { __m128i _mm_packus_epi32(__m128i, __m128i); } 
#line 884
extern "C" { void _mm_pause(); } 
#line 885
extern "C" { int _mm_popcnt_u32(unsigned); } 
#line 887
extern "C" { void _mm_prefetch(const char *, int); } 
#line 888
extern "C" { __m128 _mm_rcp_ps(__m128); } 
#line 889
extern "C" { __m128 _mm_rcp_ss(__m128); } 
#line 890
extern "C" { __m128d _mm_round_pd(__m128d, int); } 
#line 891
extern "C" { __m128 _mm_round_ps(__m128, int); } 
#line 892
extern "C" { __m128d _mm_round_sd(__m128d, __m128d, int); } 
#line 893
extern "C" { __m128 _mm_round_ss(__m128, __m128, int); } 
#line 894
extern "C" { __m128 _mm_rsqrt_ps(__m128); } 
#line 895
extern "C" { __m128 _mm_rsqrt_ss(__m128); } 
#line 896
extern "C" { __m128i _mm_sad_epu8(__m128i, __m128i); } 
#line 897
extern "C" { __m128i _mm_set1_epi16(short); } 
#line 898
extern "C" { __m128i _mm_set1_epi32(int); } 
#line 899
extern "C" { __m128i _mm_set1_epi64(__m64); } 
#line 901
extern "C" { __m128i _mm_set1_epi8(char); } 
#line 902
extern "C" { __m128d _mm_set1_pd(double); } 
#line 903
extern "C" { __m64 _mm_set1_pi16(short); } 
#line 904
extern "C" { __m64 _mm_set1_pi32(int); } 
#line 905
extern "C" { __m64 _mm_set1_pi8(char); } 
#line 906
extern "C" { __m128i _mm_set_epi16(short, short, short, short, short, short, short, short); } 
#line 907
extern "C" { __m128i _mm_set_epi32(int, int, int, int); } 
#line 908
extern "C" { __m128i _mm_set_epi64(__m64, __m64); } 
#line 910
extern "C" { __m128i _mm_set_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 911
extern "C" { __m128d _mm_set_pd(double, double); } 
#line 912
extern "C" { __m64 _mm_set_pi16(short, short, short, short); } 
#line 913
extern "C" { __m64 _mm_set_pi32(int, int); } 
#line 914
extern "C" { __m64 _mm_set_pi8(char, char, char, char, char, char, char, char); } 
#line 915
extern "C" { __m128 _mm_set_ps(float, float, float, float); } 
#line 916
extern "C" { __m128 _mm_set_ps1(float); } 
#line 917
extern "C" { __m128d _mm_set_sd(double); } 
#line 918
extern "C" { __m128 _mm_set_ss(float); } 
#line 919
extern "C" { void _mm_setcsr(unsigned); } 
#line 920
extern "C" { __m128i _mm_setl_epi64(__m128i); } 
#line 921
extern "C" { __m128i _mm_setr_epi16(short, short, short, short, short, short, short, short); } 
#line 922
extern "C" { __m128i _mm_setr_epi32(int, int, int, int); } 
#line 923
extern "C" { __m128i _mm_setr_epi64(__m64, __m64); } 
#line 924
extern "C" { __m128i _mm_setr_epi8(char, char, char, char, char, char, char, char, char, char, char, char, char, char, char, char); } 
#line 925
extern "C" { __m128d _mm_setr_pd(double, double); } 
#line 926
extern "C" { __m64 _mm_setr_pi16(short, short, short, short); } 
#line 927
extern "C" { __m64 _mm_setr_pi32(int, int); } 
#line 928
extern "C" { __m64 _mm_setr_pi8(char, char, char, char, char, char, char, char); } 
#line 929
extern "C" { __m128 _mm_setr_ps(float, float, float, float); } 
#line 930
extern "C" { __m128d _mm_setzero_pd(); } 
#line 931
extern "C" { __m128 _mm_setzero_ps(); } 
#line 932
extern "C" { __m128i _mm_setzero_si128(); } 
#line 933
extern "C" { __m64 _mm_setzero_si64(); } 
#line 934
extern "C" { void _mm_sfence(); } 
#line 935
extern "C" { __m128i _mm_shuffle_epi32(__m128i, int); } 
#line 936
extern "C" { __m128i _mm_shuffle_epi8(__m128i, __m128i); } 
#line 937
extern "C" { __m128d _mm_shuffle_pd(__m128d, __m128d, int); } 
#line 938
extern "C" { __m64 _mm_shuffle_pi8(__m64, __m64); } 
#line 939
extern "C" { __m128 _mm_shuffle_ps(__m128, __m128, unsigned); } 
#line 940
extern "C" { __m128i _mm_shufflehi_epi16(__m128i, int); } 
#line 941
extern "C" { __m128i _mm_shufflelo_epi16(__m128i, int); } 
#line 942
extern "C" { __m128i _mm_sign_epi16(__m128i, __m128i); } 
#line 943
extern "C" { __m128i _mm_sign_epi32(__m128i, __m128i); } 
#line 944
extern "C" { __m128i _mm_sign_epi8(__m128i, __m128i); } 
#line 945
extern "C" { __m64 _mm_sign_pi16(__m64, __m64); } 
#line 946
extern "C" { __m64 _mm_sign_pi32(__m64, __m64); } 
#line 947
extern "C" { __m64 _mm_sign_pi8(__m64, __m64); } 
#line 948
extern "C" { __m128i _mm_sll_epi16(__m128i, __m128i); } 
#line 949
extern "C" { __m128i _mm_sll_epi32(__m128i, __m128i); } 
#line 950
extern "C" { __m128i _mm_sll_epi64(__m128i, __m128i); } 
#line 951
extern "C" { __m128i _mm_slli_epi16(__m128i, int); } 
#line 952
extern "C" { __m128i _mm_slli_epi32(__m128i, int); } 
#line 953
extern "C" { __m128i _mm_slli_epi64(__m128i, int); } 
#line 954
extern "C" { __m128i _mm_slli_si128(__m128i, int); } 
#line 955
extern "C" { __m128d _mm_sqrt_pd(__m128d); } 
#line 956
extern "C" { __m128 _mm_sqrt_ps(__m128); } 
#line 957
extern "C" { __m128d _mm_sqrt_sd(__m128d, __m128d); } 
#line 958
extern "C" { __m128 _mm_sqrt_ss(__m128); } 
#line 959
extern "C" { __m128i _mm_sra_epi16(__m128i, __m128i); } 
#line 960
extern "C" { __m128i _mm_sra_epi32(__m128i, __m128i); } 
#line 961
extern "C" { __m128i _mm_srai_epi16(__m128i, int); } 
#line 962
extern "C" { __m128i _mm_srai_epi32(__m128i, int); } 
#line 963
extern "C" { __m128i _mm_srl_epi16(__m128i, __m128i); } 
#line 964
extern "C" { __m128i _mm_srl_epi32(__m128i, __m128i); } 
#line 965
extern "C" { __m128i _mm_srl_epi64(__m128i, __m128i); } 
#line 966
extern "C" { __m128i _mm_srli_epi16(__m128i, int); } 
#line 967
extern "C" { __m128i _mm_srli_epi32(__m128i, int); } 
#line 968
extern "C" { __m128i _mm_srli_epi64(__m128i, int); } 
#line 969
extern "C" { __m128i _mm_srli_si128(__m128i, int); } 
#line 970
extern "C" { void _mm_store1_pd(double *, __m128d); } 
#line 971
extern "C" { void _mm_store_pd(double *, __m128d); } 
#line 972
extern "C" { void _mm_store_ps(float *, __m128); } 
#line 973
extern "C" { void _mm_store_ps1(float *, __m128); } 
#line 974
extern "C" { void _mm_store_sd(double *, __m128d); } 
#line 975
extern "C" { void _mm_store_si128(__m128i *, __m128i); } 
#line 976
extern "C" { void _mm_store_ss(float *, __m128); } 
#line 977
extern "C" { void _mm_storeh_pd(double *, __m128d); } 
#line 978
extern "C" { void _mm_storeh_pi(__m64 *, __m128); } 
#line 979
extern "C" { void _mm_storel_epi64(__m128i *, __m128i); } 
#line 980
extern "C" { void _mm_storel_pd(double *, __m128d); } 
#line 981
extern "C" { void _mm_storel_pi(__m64 *, __m128); } 
#line 982
extern "C" { void _mm_storer_pd(double *, __m128d); } 
#line 983
extern "C" { void _mm_storer_ps(float *, __m128); } 
#line 984
extern "C" { void _mm_storeu_pd(double *, __m128d); } 
#line 985
extern "C" { void _mm_storeu_ps(float *, __m128); } 
#line 986
extern "C" { void _mm_storeu_si128(__m128i *, __m128i); } 
#line 987
extern "C" { __m128i _mm_stream_load_si128(__m128i *); } 
#line 988
extern "C" { void _mm_stream_pd(double *, __m128d); } 
#line 989
extern "C" { void _mm_stream_pi(__m64 *, __m64); } 
#line 990
extern "C" { void _mm_stream_ps(float *, __m128); } 
#line 991
extern "C" { void _mm_stream_sd(double *, __m128d); } 
#line 992
extern "C" { void _mm_stream_si128(__m128i *, __m128i); } 
#line 993
extern "C" { void _mm_stream_si32(int *, int); } 
#line 995
extern "C" { void _mm_stream_ss(float *, __m128); } 
#line 996
extern "C" { __m128i _mm_sub_epi16(__m128i, __m128i); } 
#line 997
extern "C" { __m128i _mm_sub_epi32(__m128i, __m128i); } 
#line 998
extern "C" { __m128i _mm_sub_epi64(__m128i, __m128i); } 
#line 999
extern "C" { __m128i _mm_sub_epi8(__m128i, __m128i); } 
#line 1000
extern "C" { __m128d _mm_sub_pd(__m128d, __m128d); } 
#line 1001
extern "C" { __m128 _mm_sub_ps(__m128, __m128); } 
#line 1002
extern "C" { __m128d _mm_sub_sd(__m128d, __m128d); } 
#line 1003
extern "C" { __m64 _mm_sub_si64(__m64, __m64); } 
#line 1004
extern "C" { __m128 _mm_sub_ss(__m128, __m128); } 
#line 1005
extern "C" { __m128i _mm_subs_epi16(__m128i, __m128i); } 
#line 1006
extern "C" { __m128i _mm_subs_epi8(__m128i, __m128i); } 
#line 1007
extern "C" { __m128i _mm_subs_epu16(__m128i, __m128i); } 
#line 1008
extern "C" { __m128i _mm_subs_epu8(__m128i, __m128i); } 
#line 1009
extern "C" { int _mm_testc_si128(__m128i, __m128i); } 
#line 1010
extern "C" { int _mm_testnzc_si128(__m128i, __m128i); } 
#line 1011
extern "C" { int _mm_testz_si128(__m128i, __m128i); } 
#line 1012
extern "C" { int _mm_ucomieq_sd(__m128d, __m128d); } 
#line 1013
extern "C" { int _mm_ucomieq_ss(__m128, __m128); } 
#line 1014
extern "C" { int _mm_ucomige_sd(__m128d, __m128d); } 
#line 1015
extern "C" { int _mm_ucomige_ss(__m128, __m128); } 
#line 1016
extern "C" { int _mm_ucomigt_sd(__m128d, __m128d); } 
#line 1017
extern "C" { int _mm_ucomigt_ss(__m128, __m128); } 
#line 1018
extern "C" { int _mm_ucomile_sd(__m128d, __m128d); } 
#line 1019
extern "C" { int _mm_ucomile_ss(__m128, __m128); } 
#line 1020
extern "C" { int _mm_ucomilt_sd(__m128d, __m128d); } 
#line 1021
extern "C" { int _mm_ucomilt_ss(__m128, __m128); } 
#line 1022
extern "C" { int _mm_ucomineq_sd(__m128d, __m128d); } 
#line 1023
extern "C" { int _mm_ucomineq_ss(__m128, __m128); } 
#line 1024
extern "C" { __m128i _mm_unpackhi_epi16(__m128i, __m128i); } 
#line 1025
extern "C" { __m128i _mm_unpackhi_epi32(__m128i, __m128i); } 
#line 1026
extern "C" { __m128i _mm_unpackhi_epi64(__m128i, __m128i); } 
#line 1027
extern "C" { __m128i _mm_unpackhi_epi8(__m128i, __m128i); } 
#line 1028
extern "C" { __m128d _mm_unpackhi_pd(__m128d, __m128d); } 
#line 1029
extern "C" { __m128 _mm_unpackhi_ps(__m128, __m128); } 
#line 1030
extern "C" { __m128i _mm_unpacklo_epi16(__m128i, __m128i); } 
#line 1031
extern "C" { __m128i _mm_unpacklo_epi32(__m128i, __m128i); } 
#line 1032
extern "C" { __m128i _mm_unpacklo_epi64(__m128i, __m128i); } 
#line 1033
extern "C" { __m128i _mm_unpacklo_epi8(__m128i, __m128i); } 
#line 1034
extern "C" { __m128d _mm_unpacklo_pd(__m128d, __m128d); } 
#line 1035
extern "C" { __m128 _mm_unpacklo_ps(__m128, __m128); } 
#line 1036
extern "C" { __m128d _mm_xor_pd(__m128d, __m128d); } 
#line 1037
extern "C" { __m128 _mm_xor_ps(__m128, __m128); } 
#line 1038
extern "C" { __m128i _mm_xor_si128(__m128i, __m128i); } 
#line 1040
extern "C" { unsigned __cdecl _rotl(unsigned _Value, int _Shift); } 
#line 1041
extern "C" { unsigned short __cdecl _rotl16(unsigned short _Value, unsigned char _Shift); } 
#line 1042
extern "C" { unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift); } 
#line 1043
extern "C" { unsigned char __cdecl _rotl8(unsigned char _Value, unsigned char _Shift); } 
#line 1044
extern "C" { unsigned __cdecl _rotr(unsigned _Value, int _Shift); } 
#line 1045
extern "C" { unsigned short __cdecl _rotr16(unsigned short _Value, unsigned char _Shift); } 
#line 1046
extern "C" { unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift); } 
#line 1047
extern "C" { unsigned char __cdecl _rotr8(unsigned char _Value, unsigned char _Shift); } 
#line 1048
extern "C" { int __cdecl _setjmp(jmp_buf); } 
#line 1051
extern "C" { void _rsm(); } 
#line 1052
extern "C" { void _lgdt(void *); } 
#line 1053
extern "C" { void _sgdt(void *); } 
#line 1054
extern "C" { void _clac(); } 
#line 1055
extern "C" { void _stac(); } 
#line 1056
extern "C" { unsigned char __cdecl _addcarry_u8(unsigned char, unsigned char, unsigned char, unsigned char *); } 
#line 1057
extern "C" { unsigned char __cdecl _subborrow_u8(unsigned char, unsigned char, unsigned char, unsigned char *); } 
#line 1058
extern "C" { unsigned char __cdecl _addcarry_u16(unsigned char, unsigned short, unsigned short, unsigned short *); } 
#line 1059
extern "C" { unsigned char __cdecl _subborrow_u16(unsigned char, unsigned short, unsigned short, unsigned short *); } 
#line 1060
extern "C" { unsigned char __cdecl _addcarry_u32(unsigned char, unsigned, unsigned, unsigned *); } 
#line 1061
extern "C" { unsigned char __cdecl _subborrow_u32(unsigned char, unsigned, unsigned, unsigned *); } 
#line 926 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
#pragma warning(push,3)
#line 927 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xmemory0"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#pragma warning(disable: 4127)
#line 16
#pragma warning(disable: 4251)
#line 18
template < class _Elem,
 class _Traits = char_traits < _Elem >,
 class _Ax = allocator < _Elem > >
 class basic_string;
#line 28
template < class _Mystr >
 class _String_const_iterator
  : public _Iterator012 < random_access_iterator_tag,
   typename _Mystr :: value_type,
   typename _Mystr :: difference_type,
   typename _Mystr :: const_pointer,
   typename _Mystr :: const_reference,
   _Iterator_base >
 {
public :
 typedef _String_const_iterator < _Mystr > _Myiter;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr :: value_type value_type;
 typedef typename _Mystr :: difference_type difference_type;
 typedef typename _Mystr :: const_pointer pointer;
 typedef typename _Mystr :: const_reference reference;

 _String_const_iterator ( )
  {
  this -> _Ptr = 0;
  }

 _String_const_iterator ( pointer _Parg, const _Container_base * _Pstring )
  {
  this -> _Adopt ( _Pstring );
  this -> _Ptr = _Parg;
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {



















  ;

  return ( * this -> _Ptr );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {

















  ++ this -> _Ptr;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {















  -- this -> _Ptr;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {



















  _Ptr += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr - _Right . _Ptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr == _Right . _Ptr );
  }

 bool operator != ( const _Myiter & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myiter & _Right ) const
  {
  _Compat ( _Right );
  return ( this -> _Ptr < _Right . _Ptr );
  }

 bool operator > ( const _Myiter & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myiter & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myiter & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }




















 void _Compat ( const _Myiter & ) const
  {
  }


 pointer _Ptr;
 };
#line 271 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
template < class _Mystr > inline
 typename _String_const_iterator < _Mystr > :: _Unchecked_type
  _Unchecked ( _String_const_iterator < _Mystr > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 278
template < class _Mystr > inline
 _String_const_iterator < _Mystr >
  _Rechecked ( _String_const_iterator < _Mystr > & _Iter,
   typename _String_const_iterator < _Mystr >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 287
template < class _Mystr > inline
 _String_const_iterator < _Mystr > operator + (
  typename _String_const_iterator < _Mystr >
   :: difference_type _Off,
  _String_const_iterator < _Mystr > _Next )
 {
 return ( _Next += _Off );
 }
#line 297
template < class _Mystr >
 class _String_iterator
  : public _String_const_iterator < _Mystr >
 {
public :
 typedef _String_iterator < _Mystr > _Myiter;
 typedef _String_const_iterator < _Mystr > _Mybase;
 typedef random_access_iterator_tag iterator_category;

 typedef typename _Mystr :: value_type value_type;
 typedef typename _Mystr :: difference_type difference_type;
 typedef typename _Mystr :: pointer pointer;
 typedef typename _Mystr :: reference reference;

 _String_iterator ( )
  {
  }

 _String_iterator ( pointer _Parg, const _Container_base * _Pstring )
  : _Mybase ( _Parg, _Pstring )
  {
  }

 typedef pointer _Unchecked_type;

 _Myiter & _Rechecked ( _Unchecked_type _Right )
  {
  this -> _Ptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( _Unchecked_type ( this -> _Ptr ) );
  }

 reference operator * ( ) const
  {
  return ( ( reference ) * * ( _Mybase * ) this );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myiter & operator ++ ( )
  {
  ++ * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator ++ ( int )
  {
  _Myiter _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myiter & operator -- ( )
  {
  -- * ( _Mybase * ) this;
  return ( * this );
  }

 _Myiter operator -- ( int )
  {
  _Myiter _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myiter & operator += ( difference_type _Off )
  {
  * ( _Mybase * ) this += _Off;
  return ( * this );
  }

 _Myiter operator + ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myiter & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myiter operator - ( difference_type _Off ) const
  {
  _Myiter _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Mybase & _Right ) const
  {
  return ( ( _Mybase ) * this - _Right );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }
 };
#line 403
template < class _Mystr > inline
 typename _String_iterator < _Mystr > :: _Unchecked_type
  _Unchecked ( _String_iterator < _Mystr > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 410
template < class _Mystr > inline
 _String_iterator < _Mystr >
  _Rechecked ( _String_iterator < _Mystr > & _Iter,
   typename _String_iterator < _Mystr >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 419
template < class _Mystr > inline
 _String_iterator < _Mystr > operator + (
  typename _String_iterator < _Mystr >
   :: difference_type _Off,
  _String_iterator < _Mystr > _Next )
 {
 return ( _Next += _Off );
 }
#line 429
template< class _Value_type, class 
#line 430
_Size_type, class 
#line 431
_Difference_type, class 
#line 432
_Pointer, class 
#line 433
_Const_pointer, class 
#line 434
_Reference, class 
#line 435
_Const_reference> 
#line 436
struct _String_iter_types { 
#line 438
typedef _Value_type value_type; 
#line 439
typedef _Size_type size_type; 
#line 440
typedef _Difference_type difference_type; 
#line 441
typedef _Pointer pointer; 
#line 442
typedef _Const_pointer const_pointer; 
#line 443
typedef _Reference reference; 
#line 444
typedef _Const_reference const_reference; 
#line 445
}; 
#line 447
template< class _Ty, class 
#line 448
_Alloc0> 
#line 449
struct _String_base_types { 
#line 451
typedef _Alloc0 _Alloc; 
#line 452
typedef _String_base_types _Myt; 
#line 454
typedef _Wrap_alloc< _Alloc0>  _Alty0; 
#line 455
typedef typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other _Alty; 
#line 458
typedef typename _Alty::pointer _Tptr; 
#line 459
typedef typename _Alty::template rebind< typename _Alty::pointer> ::other _Alpty; 
#line 470
typedef typename _If< _Is_simple_alloc< typename _Wrap_alloc< _Alloc0> ::template rebind< _Ty> ::other> ::value, _Simple_types< typename _Alty::value_type> , _String_iter_types< typename _Alty::value_type, typename _Alty::size_type, typename _Alty::difference_type, typename _Alty::pointer, typename _Alty::const_pointer, typename _Alty::reference, typename _Alty::const_reference> > ::type _Val_types; 
#line 471
}; 
#line 474
template < class _Val_types >
 class _String_val
  : public _Container_base
 {
public :
 typedef _String_val < _Val_types > _Myt;

 typedef typename _Val_types :: value_type value_type;
 typedef typename _Val_types :: size_type size_type;
 typedef typename _Val_types :: difference_type difference_type;
 typedef typename _Val_types :: pointer pointer;
 typedef typename _Val_types :: const_pointer const_pointer;
 typedef typename _Val_types :: reference reference;
 typedef typename _Val_types :: const_reference const_reference;

 typedef _String_iterator < _Myt > iterator;
 typedef _String_const_iterator < _Myt > const_iterator;

 _String_val ( )
  {
  _Mysize = 0;
  _Myres = 0;
  }

 enum
  {
  _BUF_SIZE = 16 / sizeof ( value_type ) < 1 ? 1
   : 16 / sizeof ( value_type ) };
 enum
  {
  _ALLOC_MASK = sizeof ( value_type ) <= 1 ? 15
   : sizeof ( value_type ) <= 2 ? 7
   : sizeof ( value_type ) <= 4 ? 3
   : sizeof ( value_type ) <= 8 ? 1 : 0 };

 value_type * _Myptr ( )
  {
  return ( this -> _BUF_SIZE <= this -> _Myres
   ? :: std :: addressof ( * this -> _Bx . _Ptr )
   : this -> _Bx . _Buf );
  }

 const value_type * _Myptr ( ) const
  {
  return ( this -> _BUF_SIZE <= this -> _Myres
   ? :: std :: addressof ( * this -> _Bx . _Ptr )
   : this -> _Bx . _Buf );
  }

 union _Bxty
  {
  value_type _Buf [ _BUF_SIZE ];
  pointer _Ptr;
  char _Alias [ _BUF_SIZE ];
  } _Bx;

 size_type _Mysize;
 size_type _Myres;
 };
#line 535
template < bool _Al_has_storage,
 class _Alloc_types >
 class _String_alloc
  : public _String_val < typename _Alloc_types :: _Val_types >
 {
public :
 typename _Alloc_types :: _Alty _Alval;

 typedef _String_alloc < _Al_has_storage, _Alloc_types > _Myt;
 typedef typename _Alloc_types :: _Alloc _Alloc;
 typedef typename _Alloc_types :: _Alty _Alty;


 _String_alloc ( const _Alloc & _Al = _Alloc ( ) )
  : _Alval ( _Al )
  {
  }

 void _Change_alloc ( const _Alty & _Al )
  {
  this -> _Alval = _Al;
  }

 void _Swap_alloc ( _Myt & _Right )
  {
  _Swap_adl ( this -> _Alval, _Right . _Alval );
  }














































 _Alty & _Getal ( )
  {
  return ( this -> _Alval );
  }

 const _Alty & _Getal ( ) const
  {
  return ( this -> _Alval );
  }
 };
#line 619 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
template < class _Alloc_types >
 class _String_alloc < false, _Alloc_types >
  : public _String_val < typename _Alloc_types :: _Val_types >
 {
public :
 typedef _String_alloc < false, _Alloc_types > _Myt;
 typedef typename _Alloc_types :: _Alloc _Alloc;

 typedef typename _Alloc_types :: _Alty _Alty;


 _String_alloc ( const _Alloc & = _Alloc ( ) )
  {
  }

 void _Change_alloc ( const _Alty & )
  {
  }

 void _Swap_alloc ( _Myt & )
  {
  }









































 _Alty _Getal ( ) const
  {
  return ( _Alty ( ) );
  }
 };
#line 689 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
template < class _Elem,
 class _Traits,
 class _Alloc >
 class basic_string
  : public _String_alloc < ! is_empty < _Alloc > :: value,
   _String_base_types < _Elem, _Alloc > >
 {
public :
 typedef basic_string < _Elem, _Traits, _Alloc > _Myt;
 typedef _String_alloc < ! is_empty < _Alloc > :: value,
  _String_base_types < _Elem, _Alloc > > _Mybase;
 typedef _Traits traits_type;
 typedef _Alloc allocator_type;

 typedef typename _Mybase :: _Alty _Alty;

 typedef typename _Mybase :: value_type value_type;
 typedef typename _Mybase :: size_type size_type;
 typedef typename _Mybase :: difference_type difference_type;
 typedef typename _Mybase :: pointer pointer;
 typedef typename _Mybase :: const_pointer const_pointer;
 typedef typename _Mybase :: reference reference;
 typedef typename _Mybase :: const_reference const_reference;

 typedef typename _Mybase :: iterator iterator;
 typedef typename _Mybase :: const_iterator const_iterator;

 typedef :: std :: reverse_iterator < iterator > reverse_iterator;
 typedef :: std :: reverse_iterator < const_iterator > const_reverse_iterator;

 basic_string ( const _Myt & _Right )

  : _Mybase ( _Right . _Getal ( ) . select_on_container_copy_construction ( ) )


  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }

 basic_string ( const _Myt & _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Right, 0, npos );
  }

 basic_string ( )
  : _Mybase ( )
  {
  _Tidy ( );
  }

 explicit basic_string ( const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  }

 basic_string ( const _Myt & _Right, size_type _Roff,
  size_type _Count = npos )
  : _Mybase ( _Right . _Getal ( ) )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Myt & _Right, size_type _Roff, size_type _Count,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Right, _Roff, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr, size_type _Count, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr, _Count );
  }

 basic_string ( const _Elem * _Ptr )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( const _Elem * _Ptr, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ptr );
  }

 basic_string ( size_type _Count, _Elem _Ch )
  : _Mybase ( )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 basic_string ( size_type _Count, _Elem _Ch, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Count, _Ch );
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  basic_string ( _Iter _First, _Iter _Last )
  : _Mybase ( )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter,
  class = typename enable_if < _Is_iterator < _Iter > :: value,
   void > :: type >
  basic_string ( _Iter _First, _Iter _Last, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  _Construct ( _First, _Last, _Iter_cat ( _First ) );
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, input_iterator_tag )
  {
  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 template < class _Iter >
  void _Construct ( _Iter _First,
   _Iter _Last, forward_iterator_tag )
  {
  ;
  size_type _Count = 0;
  _Distance ( _First, _Last, _Count );
  reserve ( _Count );

  try {
  for (; _First != _Last; ++ _First )
   append ( ( size_type ) 1, ( _Elem ) * _First );
  } catch ( ... ) {
  _Tidy ( true );
  throw;
  }
  }

 basic_string ( const_pointer _First, const_pointer _Last )
  : _Mybase ( )
  {
  ;
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( const_pointer _First, const_pointer _Last,
  const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  ;
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( const_iterator _First, const_iterator _Last )
  : _Mybase ( )
  {
  ;
  _Tidy ( );
  if ( _First != _Last )
   assign ( & * _First, _Last - _First );
  }

 basic_string ( _Myt && _Right ) throw ( )
  : _Mybase ( _Right . _Getal ( ) )
  {
  _Tidy ( );
  _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 basic_string ( _Myt && _Right, const _Alloc & _Al )
  : _Mybase ( _Al )
  {
  if ( this -> _Getal ( ) != _Right . _Getal ( ) )
   assign ( _Right . begin ( ), _Right . end ( ) );
  else
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right ) throw ( )
  {
  if ( this != & _Right )
   {
   _Tidy ( true );

   if ( _Alty :: propagate_on_container_move_assignment :: value
    && this -> _Getal ( ) != _Right . _Getal ( ) )
    this -> _Change_alloc ( _Right . _Getal ( ) );

   if ( this -> _Getal ( ) != _Right . _Getal ( ) )
    assign ( _Right . begin ( ), _Right . end ( ) );
   else
    _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  return ( * this );
  }

 _Myt & assign ( _Myt && _Right ) throw ( )
  {
  if ( this == & _Right )
   ;
  else if ( get_allocator ( ) != _Right . get_allocator ( )
   && this -> _BUF_SIZE <= _Right . _Myres )
   * this = _Right;
  else
   {
   _Tidy ( true );
   _Assign_rv ( :: std :: forward < _Myt > ( _Right ) );
   }
  return ( * this );
  }

 void _Assign_rv ( _Myt && _Right )
  {
  if ( _Right . _Myres < this -> _BUF_SIZE )
   _Traits :: move ( this -> _Bx . _Buf, _Right . _Bx . _Buf,
    _Right . _Mysize + 1 );
  else
   {
   this -> _Getal ( ) . construct ( & this -> _Bx . _Ptr, _Right . _Bx . _Ptr );
   _Right . _Bx . _Ptr = pointer ( );
   }
  this -> _Mysize = _Right . _Mysize;
  this -> _Myres = _Right . _Myres;
  _Right . _Tidy ( );
  }

 basic_string ( :: std :: initializer_list < _Elem > _Ilist,
  const _Alloc & _Al = allocator_type ( ) )
  : _Mybase ( _Al )
  {
  _Tidy ( );
  assign ( _Ilist . begin ( ), _Ilist . end ( ) );
  }

 _Myt & operator = ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( assign ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & operator += ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( append ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & assign ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( assign ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & append ( :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( append ( _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 iterator insert ( const_iterator _Where,
  :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( insert ( _Where, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  :: std :: initializer_list < _Elem > _Ilist )
  {
  return ( replace ( _First, _Last, _Ilist . begin ( ), _Ilist . end ( ) ) );
  }

 ~ basic_string ( ) throw ( )
  {
  _Tidy ( true );
  }

  static const size_type npos;

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   if ( this -> _Getal ( ) != _Right . _Getal ( )
    && _Alty :: propagate_on_container_copy_assignment :: value )
    {
    _Tidy ( true );
    this -> _Change_alloc ( _Right . _Getal ( ) );
    }

   assign ( _Right );
   }
  return ( * this );
  }

 _Myt & operator = ( const _Elem * _Ptr )
  {
  return ( assign ( _Ptr ) );
  }

 _Myt & operator = ( _Elem _Ch )
  {
  return ( assign ( 1, _Ch ) );
  }

 _Myt & operator += ( const _Myt & _Right )
  {
  return ( append ( _Right ) );
  }

 _Myt & operator += ( const _Elem * _Ptr )
  {
  return ( append ( _Ptr ) );
  }

 _Myt & operator += ( _Elem _Ch )
  {
  return ( append ( ( size_type ) 1, _Ch ) );
  }

 _Myt & append ( const _Myt & _Right )
  {
  return ( append ( _Right, 0, npos ) );
  }

 _Myt & append ( const _Myt & _Right,
  size_type _Roff, size_type _Count )
  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: copy ( this -> _Myptr ( ) + this -> _Mysize,
    _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( append ( * this,
    _Ptr - this -> _Myptr ( ), _Count ) );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: copy ( this -> _Myptr ( ) + this -> _Mysize, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & append ( const _Elem * _Ptr )
  {
  ;
  return ( append ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & append ( size_type _Count, _Elem _Ch )
  {
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Chassign ( this -> _Mysize, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   _Myt & > :: type
  append ( _Iter _First, _Iter _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & append ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( end ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const _Myt & _Right )
  {
  return ( assign ( _Right, 0, npos ) );
  }

 _Myt & assign ( const _Myt & _Right,
  size_type _Roff, size_type _Count )
  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Count < _Num )
   _Num = _Count;

  if ( this == & _Right )
   erase ( ( size_type ) ( _Roff + _Num ) ), erase ( 0, _Roff );
  else if ( _Grow ( _Num ) )
   {
   _Traits :: copy ( this -> _Myptr ( ),
    _Right . _Myptr ( ) + _Roff, _Num );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( assign ( * this,
    _Ptr - this -> _Myptr ( ), _Count ) );

  if ( _Grow ( _Count ) )
   {
   _Traits :: copy ( this -> _Myptr ( ), _Ptr, _Count );
   _Eos ( _Count );
   }
  return ( * this );
  }

 _Myt & assign ( const _Elem * _Ptr )
  {
  ;
  return ( assign ( _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & assign ( size_type _Count, _Elem _Ch )
  {
  if ( _Count == npos )
   _Xlen ( );

  if ( _Grow ( _Count ) )
   {
   _Chassign ( 0, _Count, _Ch );
   _Eos ( _Count );
   }
  return ( * this );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   _Myt & > :: type
  assign ( _Iter _First, _Iter _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_pointer _First, const_pointer _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & assign ( const_iterator _First, const_iterator _Last )
  {
  return ( replace ( begin ( ), end ( ), _First, _Last ) );
  }

 _Myt & insert ( size_type _Off, const _Myt & _Right )
  {
  return ( insert ( _Off, _Right, 0, npos ) );
  }

 _Myt & insert ( size_type _Off,
  const _Myt & _Right, size_type _Roff, size_type _Count )
  {
  if ( this -> _Mysize < _Off || _Right . size ( ) < _Roff )
   _Xran ( );
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );

  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off,
    this -> _Mysize - _Off );
   if ( this == & _Right )
    _Traits :: move ( this -> _Myptr ( ) + _Off,
     this -> _Myptr ( ) + ( _Off < _Roff ? _Roff + _Count : _Roff ),
      _Count );
   else
    _Traits :: copy ( this -> _Myptr ( ) + _Off,
     _Right . _Myptr ( ) + _Roff, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off,
  const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( insert ( _Off, * this,
    _Ptr - this -> _Myptr ( ), _Count ) );
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off,
    this -> _Mysize - _Off );
   _Traits :: copy ( this -> _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & insert ( size_type _Off, const _Elem * _Ptr )
  {
  ;
  return ( insert ( _Off, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & insert ( size_type _Off,
  size_type _Count, _Elem _Ch )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( npos - this -> _Mysize <= _Count )
   _Xlen ( );
  size_type _Num;
  if ( 0 < _Count && _Grow ( _Num = this -> _Mysize + _Count ) )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off,
    this -> _Mysize - _Off );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 iterator insert ( const_iterator _Where )
  {
  return ( insert ( _Where, _Elem ( ) ) );
  }

 iterator insert ( const_iterator _Where, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, 1, _Ch );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where, size_type _Count, _Elem _Ch )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  insert ( _Off, _Count, _Ch );
  return ( begin ( ) + _Off );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   iterator > :: type
  insert ( const_iterator _Where, _Iter _First, _Iter _Last )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where,
  const_pointer _First, const_pointer _Last )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 iterator insert ( const_iterator _Where,
  const_iterator _First, const_iterator _Last )
  {
  size_type _Off = _Pdif ( _Where, begin ( ) );
  replace ( _Where, _Where, _First, _Last );
  return ( begin ( ) + _Off );
  }

 _Myt & erase ( size_type _Off = 0 )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  _Eos ( _Off );
  return ( * this );
  }

 _Myt & erase ( size_type _Off, size_type _Count )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off <= _Count )
   _Eos ( _Off );
  else if ( 0 < _Count )
   {
   value_type * _Ptr = this -> _Myptr ( ) + _Off;
   size_type _Newsize = this -> _Mysize - _Count;
   _Traits :: move ( _Ptr, _Ptr + _Count, _Newsize - _Off );
   _Eos ( _Newsize );
   }
  return ( * this );
  }

 iterator erase ( const_iterator _Where )
  {
  size_type _Count = _Pdif ( _Where, begin ( ) );
  erase ( _Count, 1 );
  return ( iterator ( this -> _Myptr ( ) + _Count, this ) );
  }

 iterator erase ( const_iterator _First, const_iterator _Last )
  {
  ;
  size_type _Count = _Pdif ( _First, begin ( ) );
  erase ( _Count, _Pdif ( _Last, _First ) );
  return ( iterator ( this -> _Myptr ( ) + _Count, this ) );
  }

 void clear ( ) throw ( )
  {
  _Eos ( 0 );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Myt & _Right )
  {
  return ( replace ( _Off, _N0, _Right, 0, npos ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Myt & _Right, size_type _Roff, size_type _Count )
  {
  if ( this -> _Mysize < _Off || _Right . size ( ) < _Roff )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  size_type _Num = _Right . size ( ) - _Roff;
  if ( _Num < _Count )
   _Count = _Num;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );

  size_type _Nm = this -> _Mysize - _N0 - _Off;
  size_type _Newsize = this -> _Mysize + _Count - _N0;
  if ( this -> _Mysize < _Newsize )
   _Grow ( _Newsize );

  if ( this != & _Right )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( this -> _Myptr ( ) + _Off,
    _Right . _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Count <= _N0 )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + _Roff, _Count );
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   }
  else if ( _Roff <= _Off )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + _Roff, _Count );
   }
  else if ( _Off + _N0 <= _Roff )
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + ( _Roff + _Count - _N0 ),
    _Count );
   }
  else
   {
   _Traits :: move ( this -> _Myptr ( ) + _Off,
    this -> _Myptr ( ) + _Roff, _N0 );
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: move ( this -> _Myptr ( ) + _Off + _N0,
    this -> _Myptr ( ) + _Roff + _Count,
    _Count - _N0 );
   }

  _Eos ( _Newsize );
  return ( * this );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count )
  {





  if ( _Inside ( _Ptr ) )
   return ( replace ( _Off, _N0, * this,
    _Ptr - this -> _Myptr ( ),
    _Count ) );
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0,
    _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num = this -> _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
     this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Traits :: copy ( this -> _Myptr ( ) + _Off, _Ptr, _Count );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( size_type _Off, size_type _N0, const _Elem * _Ptr )
  {
  ;
  return ( replace ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 _Myt & replace ( size_type _Off,
  size_type _N0, size_type _Count, _Elem _Ch )
  {
  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;
  if ( npos - _Count <= this -> _Mysize - _N0 )
   _Xlen ( );
  size_type _Nm = this -> _Mysize - _N0 - _Off;

  if ( _Count < _N0 )
   _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
    this -> _Myptr ( ) + _Off + _N0,
    _Nm );
  size_type _Num;
  if ( ( 0 < _Count || 0 < _N0 )
   && _Grow ( _Num = this -> _Mysize + _Count - _N0 ) )
   {
   if ( _N0 < _Count )
    _Traits :: move ( this -> _Myptr ( ) + _Off + _Count,
     this -> _Myptr ( ) + _Off + _N0, _Nm );
   _Chassign ( _Off, _Count, _Ch );
   _Eos ( _Num );
   }
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Myt & _Right )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Right ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr, size_type _Count )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr, _Count ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const _Elem * _Ptr )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Ptr ) );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  size_type _Count, _Elem _Ch )
  {
  return ( replace (
   _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ), _Count, _Ch ) );
  }

 template < class _Iter >
  typename enable_if < _Is_iterator < _Iter > :: value,
   _Myt & > :: type
  replace ( const_iterator _First, const_iterator _Last,
   _Iter _First2, _Iter _Last2 )
  {
  _Myt _Right ( _First2, _Last2 );
  replace ( _First, _Last, _Right );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_pointer _First2, const_pointer _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  pointer _First2, pointer _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  const_iterator _First2, const_iterator _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 _Myt & replace ( const_iterator _First, const_iterator _Last,
  iterator _First2, iterator _Last2 )
  {
  if ( _First2 == _Last2 )
   erase ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ) );
  else
   replace ( _Pdif ( _First, begin ( ) ), _Pdif ( _Last, _First ),
    & * _First2, _Last2 - _First2 );
  return ( * this );
  }

 iterator begin ( ) throw ( )
  {
  return ( iterator ( this -> _Myptr ( ), this ) );
  }

 const_iterator begin ( ) const throw ( )
  {
  return ( const_iterator ( this -> _Myptr ( ), this ) );
  }

 iterator end ( ) throw ( )
  {
  return ( iterator ( this -> _Myptr ( ) + this -> _Mysize, this ) );
  }

 const_iterator end ( ) const throw ( )
  {
  return ( const_iterator ( this -> _Myptr ( ) + this -> _Mysize, this ) );
  }

 reverse_iterator rbegin ( ) throw ( )
  {
  return ( reverse_iterator ( end ( ) ) );
  }

 const_reverse_iterator rbegin ( ) const throw ( )
  {
  return ( const_reverse_iterator ( end ( ) ) );
  }

 reverse_iterator rend ( ) throw ( )
  {
  return ( reverse_iterator ( begin ( ) ) );
  }

 const_reverse_iterator rend ( ) const throw ( )
  {
  return ( const_reverse_iterator ( begin ( ) ) );
  }

 const_iterator cbegin ( ) const throw ( )
  {
  return ( ( ( const _Myt * ) this ) -> begin ( ) );
  }

 const_iterator cend ( ) const throw ( )
  {
  return ( ( ( const _Myt * ) this ) -> end ( ) );
  }

 const_reverse_iterator crbegin ( ) const throw ( )
  {
  return ( ( ( const _Myt * ) this ) -> rbegin ( ) );
  }

 const_reverse_iterator crend ( ) const throw ( )
  {
  return ( ( ( const _Myt * ) this ) -> rend ( ) );
  }

 void shrink_to_fit ( )
  {
  if ( ( size ( ) | this -> _ALLOC_MASK ) < capacity ( ) )
   {
   _Myt _Tmp ( * this );
   swap ( _Tmp );
   }
  }

 reference at ( size_type _Off )
  {
  if ( this -> _Mysize <= _Off )
   _Xran ( );
  return ( this -> _Myptr ( ) [ _Off ] );
  }

 const_reference at ( size_type _Off ) const
  {
  if ( this -> _Mysize <= _Off )
   _Xran ( );
  return ( this -> _Myptr ( ) [ _Off ] );
  }

 reference operator [ ] ( size_type _Off )
  {








  return ( this -> _Myptr ( ) [ _Off ] );
  }

 const_reference operator [ ] ( size_type _Off ) const
  {








  return ( this -> _Myptr ( ) [ _Off ] );
  }

 void push_back ( _Elem _Ch )
  {
  insert ( end ( ), _Ch );
  }

 void pop_back ( )
  {
  erase ( this -> _Mysize - 1 );
  }

 reference front ( )
  {
  return ( * begin ( ) );
  }

 const_reference front ( ) const
  {
  return ( * begin ( ) );
  }

 reference back ( )
  {
  return ( * ( end ( ) - 1 ) );
  }

 const_reference back ( ) const
  {
  return ( * ( end ( ) - 1 ) );
  }

 const _Elem * c_str ( ) const throw ( )
  {
  return ( this -> _Myptr ( ) );
  }

 const _Elem * data ( ) const throw ( )
  {
  return ( c_str ( ) );
  }

 size_type length ( ) const throw ( )
  {
  return ( this -> _Mysize );
  }

 size_type size ( ) const throw ( )
  {
  return ( this -> _Mysize );
  }

 size_type max_size ( ) const throw ( )
  {
  size_type _Num = this -> _Getal ( ) . max_size ( );
  return ( _Num <= 1 ? 1 : _Num - 1 );
  }

 void resize ( size_type _Newsize )
  {
  resize ( _Newsize, _Elem ( ) );
  }

 void resize ( size_type _Newsize, _Elem _Ch )
  {
  if ( _Newsize <= this -> _Mysize )
   _Eos ( _Newsize );
  else
   append ( _Newsize - this -> _Mysize, _Ch );
  }

 size_type capacity ( ) const throw ( )
  {
  return ( this -> _Myres );
  }

 void reserve ( size_type _Newcap = 0 )
  {
  if ( this -> _Mysize <= _Newcap && this -> _Myres != _Newcap )
   {
   size_type _Size = this -> _Mysize;
   if ( _Grow ( _Newcap, true ) )
    _Eos ( _Size );
   }
  }

 bool empty ( ) const throw ( )
  {
  return ( this -> _Mysize == 0 );
  }



 size_type copy ( _Elem * _Ptr,
  size_type _Count, size_type _Off = 0 ) const
  {





  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  _Traits :: copy ( _Ptr, this -> _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 size_type _Copy_s ( _Elem * _Dest, size_type _Dest_size,
  size_type _Count, size_type _Off = 0 ) const
  {





  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _Count )
   _Count = this -> _Mysize - _Off;
  _Traits :: _Copy_s ( _Dest, _Dest_size, this -> _Myptr ( ) + _Off, _Count );
  return ( _Count );
  }

 void _Swap_bx ( _Myt & _Right )
  {
  if ( this -> _BUF_SIZE <= this -> _Myres )
   if ( this -> _BUF_SIZE <= _Right . _Myres )
    _Swap_adl ( this -> _Bx . _Ptr, _Right . _Bx . _Ptr );
   else
    {
    pointer _Ptr = this -> _Bx . _Ptr;
    this -> _Getal ( ) . destroy ( & this -> _Bx . _Ptr );
    _Traits :: copy ( this -> _Bx . _Buf,
     _Right . _Bx . _Buf, _Right . _Mysize + 1 );
    this -> _Getal ( ) . construct ( & _Right . _Bx . _Ptr, _Ptr );
    }
  else
   if ( _Right . _Myres < this -> _BUF_SIZE )
    :: std :: swap ( this -> _Bx . _Buf, _Right . _Bx . _Buf );
   else
    {
    pointer _Ptr = _Right . _Bx . _Ptr;
    this -> _Getal ( ) . destroy ( & _Right . _Bx . _Ptr );
    _Traits :: copy ( _Right . _Bx . _Buf,
     this -> _Bx . _Buf, this -> _Mysize + 1 );
    this -> _Getal ( ) . construct ( & this -> _Bx . _Ptr, _Ptr );
    }
  }

 void swap ( _Myt & _Right )
  {
  if ( this == & _Right )
   ;
  else if ( this -> _Getal ( ) == _Right . _Getal ( ) )
   {
   this -> _Swap_all ( _Right );
   _Swap_bx ( _Right );
   :: std :: swap ( this -> _Mysize, _Right . _Mysize );
   :: std :: swap ( this -> _Myres, _Right . _Myres );
   }

  else if ( _Alty :: propagate_on_container_swap :: value )
   {
   this -> _Swap_alloc ( _Right );
   _Swap_bx ( _Right );
   :: std :: swap ( this -> _Bx, _Right . _Bx );
   :: std :: swap ( this -> _Mysize, _Right . _Mysize );
   :: std :: swap ( this -> _Myres, _Right . _Myres );
   }

  else
   {
   _Myt _Tmp = * this;

   * this = _Right;
   _Right = _Tmp;
   }
  }

 size_type find ( const _Myt & _Right, size_type _Off = 0 ) const throw ( )
  {
  return ( find ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( _Count == 0 && _Off <= this -> _Mysize )
   return ( _Off );

  size_type _Nm;
  if ( _Off < this -> _Mysize && _Count <= ( _Nm = this -> _Mysize - _Off ) )
   {
   const _Elem * _Uptr, * _Vptr;
   for ( _Nm -= _Count - 1, _Vptr = this -> _Myptr ( ) + _Off;
    ( _Uptr = _Traits :: find ( _Vptr, _Nm, * _Ptr ) ) != 0;
    _Nm -= _Uptr - _Vptr + 1, _Vptr = _Uptr + 1 )
    if ( _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find ( const _Elem * _Ptr, size_type _Off = 0 ) const
  {
  ;
  return ( find ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find ( _Elem _Ch, size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type rfind ( const _Myt & _Right, size_type _Off = npos ) const throw ( )
  {
  return ( rfind ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type rfind ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( _Count == 0 )
   return ( _Off < this -> _Mysize ? _Off
    : this -> _Mysize );
  if ( _Count <= this -> _Mysize )
   {
   const _Elem * _Uptr = this -> _Myptr ( ) +
    ( _Off < this -> _Mysize - _Count ? _Off
     : this -> _Mysize - _Count );
   for (;; -- _Uptr )
    if ( _Traits :: eq ( * _Uptr, * _Ptr )
     && _Traits :: compare ( _Uptr, _Ptr, _Count ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
    else if ( _Uptr == this -> _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type rfind ( const _Elem * _Ptr, size_type _Off = npos ) const
  {
  ;
  return ( rfind ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type rfind ( _Elem _Ch, size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_of ( const _Myt & _Right,
  size_type _Off = 0 ) const throw ( )
  {
  return ( find_first_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( 0 < _Count && _Off < this -> _Mysize )
   {
   const _Elem * const _Vptr = this -> _Myptr ( ) + this -> _Mysize;
   for ( const _Elem * _Uptr = this -> _Myptr ( ) + _Off;
    _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - this -> _Myptr ( ) );
   }

  return ( npos );
  }

 size_type find_first_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const
  {
  ;
  return ( find_first_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_of ( _Elem _Ch,
  size_type _Off = 0 ) const
  {
  return ( find ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_of ( const _Myt & _Right,
  size_type _Off = npos ) const throw ( )
  {
  return ( find_last_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( 0 < _Count && 0 < this -> _Mysize )
   {
   const _Elem * _Uptr = this -> _Myptr ( )
    + ( _Off < this -> _Mysize ? _Off : this -> _Mysize - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) != 0 )
     return ( _Uptr - this -> _Myptr ( ) );
    else if ( _Uptr == this -> _Myptr ( ) )
     break;
   }

  return ( npos );
  }

 size_type find_last_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  ;
  return ( find_last_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_of ( _Elem _Ch,
  size_type _Off = npos ) const
  {
  return ( rfind ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_first_not_of ( const _Myt & _Right,
  size_type _Off = 0 ) const throw ( )
  {
  return ( find_first_not_of ( _Right . _Myptr ( ), _Off,
   _Right . size ( ) ) );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( _Off < this -> _Mysize )
   {
   const _Elem * const _Vptr = this -> _Myptr ( ) + this -> _Mysize;
   for ( const _Elem * _Uptr = this -> _Myptr ( ) + _Off;
    _Uptr < _Vptr; ++ _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
   }
  return ( npos );
  }

 size_type find_first_not_of ( const _Elem * _Ptr,
  size_type _Off = 0 ) const
  {
  ;
  return ( find_first_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_first_not_of ( _Elem _Ch,
  size_type _Off = 0 ) const
  {
  return ( find_first_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 size_type find_last_not_of ( const _Myt & _Right,
  size_type _Off = npos ) const throw ( )
  {
  return ( find_last_not_of ( _Right . _Myptr ( ), _Off, _Right . size ( ) ) );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off, size_type _Count ) const
  {





  if ( 0 < this -> _Mysize )
   {
   const _Elem * _Uptr = this -> _Myptr ( )
    + ( _Off < this -> _Mysize ? _Off : this -> _Mysize - 1 );
   for (;; -- _Uptr )
    if ( _Traits :: find ( _Ptr, _Count, * _Uptr ) == 0 )
     return ( _Uptr - this -> _Myptr ( ) );
    else if ( _Uptr == this -> _Myptr ( ) )
     break;
   }
  return ( npos );
  }

 size_type find_last_not_of ( const _Elem * _Ptr,
  size_type _Off = npos ) const
  {
  ;
  return ( find_last_not_of ( _Ptr, _Off, _Traits :: length ( _Ptr ) ) );
  }

 size_type find_last_not_of ( _Elem _Ch,
  size_type _Off = npos ) const
  {
  return ( find_last_not_of ( ( const _Elem * ) & _Ch, _Off, 1 ) );
  }

 _Myt substr ( size_type _Off = 0, size_type _Count = npos ) const
  {
  return ( _Myt ( * this, _Off, _Count, get_allocator ( ) ) );
  }

 int compare ( const _Myt & _Right ) const throw ( )
  {
  return ( compare ( 0, this -> _Mysize, _Right . _Myptr ( ), _Right . size ( ) ) );
  }

 int compare ( size_type _Off, size_type _N0,
  const _Myt & _Right ) const
  {
  return ( compare ( _Off, _N0, _Right, 0, npos ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Myt & _Right,
  size_type _Roff, size_type _Count ) const
  {
  if ( _Right . size ( ) < _Roff )
   _Xran ( );
  if ( _Right . _Mysize - _Roff < _Count )
   _Count = _Right . _Mysize - _Roff;
  return ( compare ( _Off, _N0, _Right . _Myptr ( ) + _Roff, _Count ) );
  }

 int compare ( const _Elem * _Ptr ) const
  {
  ;
  return ( compare ( 0, this -> _Mysize, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off, size_type _N0, const _Elem * _Ptr ) const
  {
  ;
  return ( compare ( _Off, _N0, _Ptr, _Traits :: length ( _Ptr ) ) );
  }

 int compare ( size_type _Off,
  size_type _N0, const _Elem * _Ptr, size_type _Count ) const
  {





  if ( this -> _Mysize < _Off )
   _Xran ( );
  if ( this -> _Mysize - _Off < _N0 )
   _N0 = this -> _Mysize - _Off;

  size_type _Ans = _Traits :: compare ( this -> _Myptr ( ) + _Off, _Ptr,
   _N0 < _Count ? _N0 : _Count );
  return ( _Ans != 0 ? ( int ) _Ans : _N0 < _Count ? - 1
   : _N0 == _Count ? 0 : + 1 );
  }

 allocator_type get_allocator ( ) const throw ( )
  {
  return ( this -> _Getal ( ) );
  }

 void _Chassign ( size_type _Off, size_type _Count, _Elem _Ch )
  {
  if ( _Count == 1 )
   _Traits :: assign ( * ( this -> _Myptr ( ) + _Off ), _Ch );
  else
   _Traits :: assign ( this -> _Myptr ( ) + _Off, _Count, _Ch );
  }

 void _Copy ( size_type _Newsize, size_type _Oldlen )
  {
  size_type _Newres = _Newsize | this -> _ALLOC_MASK;
  if ( max_size ( ) < _Newres )
   _Newres = _Newsize;
  else if ( this -> _Myres / 2 <= _Newres / 3 )
   ;
  else if ( this -> _Myres <= max_size ( ) - this -> _Myres / 2 )
   _Newres = this -> _Myres
    + this -> _Myres / 2;
  else
   _Newres = max_size ( );

  _Elem * _Ptr;
  try {
   _Ptr = this -> _Getal ( ) . allocate ( _Newres + 1 );
  } catch ( ... ) {
   _Newres = _Newsize;
   try {
    _Ptr = this -> _Getal ( ) . allocate ( _Newres + 1 );
   } catch ( ... ) {
   _Tidy ( true );
   throw;
   }
  }

  if ( 0 < _Oldlen )
   _Traits :: copy ( _Ptr, this -> _Myptr ( ),
    _Oldlen );
  _Tidy ( true );
  this -> _Getal ( ) . construct ( & this -> _Bx . _Ptr, _Ptr );
  this -> _Myres = _Newres;
  _Eos ( _Oldlen );
  }

 void _Eos ( size_type _Newsize )
  {
  _Traits :: assign ( this -> _Myptr ( ) [ this -> _Mysize = _Newsize ], _Elem ( ) );
  }

 bool _Grow ( size_type _Newsize,
  bool _Trim = false )
  {
  if ( max_size ( ) < _Newsize )
   _Xlen ( );
  if ( this -> _Myres < _Newsize )
   _Copy ( _Newsize, this -> _Mysize );
  else if ( _Trim && _Newsize < this -> _BUF_SIZE )
   _Tidy ( true,
    _Newsize < this -> _Mysize ? _Newsize : this -> _Mysize );
  else if ( _Newsize == 0 )
   _Eos ( 0 );
  return ( 0 < _Newsize );
  }

 bool _Inside ( const _Elem * _Ptr )
  {
  if ( _Ptr == 0 || _Ptr < this -> _Myptr ( )
   || this -> _Myptr ( ) + this -> _Mysize <= _Ptr )
   return ( false );
  else
   return ( true );
  }

 static size_type _Pdif ( const_iterator _P2,
  const_iterator _P1 )
  {
  return ( ( _P2 ) . _Ptr == 0 ? 0 : _P2 - _P1 );
  }

 void _Tidy ( bool _Built = false,
  size_type _Newsize = 0 )
  {
  if ( ! _Built )
   ;
  else if ( this -> _BUF_SIZE <= this -> _Myres )
   {
   pointer _Ptr = this -> _Bx . _Ptr;
   this -> _Getal ( ) . destroy ( & this -> _Bx . _Ptr );
   if ( 0 < _Newsize )
    _Traits :: copy ( this -> _Bx . _Buf,
     :: std :: addressof ( * _Ptr ), _Newsize );
   this -> _Getal ( ) . deallocate ( _Ptr, this -> _Myres + 1 );
   }
  this -> _Myres = this -> _BUF_SIZE - 1;
  _Eos ( _Newsize );
  }

 __declspec ( noreturn ) void _Xlen ( ) const
  {
  _Xlength_error ( "string too long" );
  }

 __declspec ( noreturn ) void _Xran ( ) const
  {
  _Xout_of_range ( "invalid string position" );
  }
 };
#line 2300 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
template< class _Elem, class 
#line 2301
_Traits, class 
#line 2302
_Alloc> const typename basic_string< _Elem, _Traits, _Alloc> ::size_type 
#line 2304
basic_string< _Elem, _Traits, _Alloc> ::npos = ((size_type)(-1)); 
#line 2309
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 void swap ( basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 _Left . swap ( _Right );
 }
#line 2318
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2332
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Traits :: length ( _Left ) + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2346
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( 1 + _Right . size ( ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2360
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + _Traits :: length ( _Right ) );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2374
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem _Right )
 {
 basic_string < _Elem, _Traits, _Alloc > _Ans;
 _Ans . reserve ( _Left . size ( ) + 1 );
 _Ans += _Left;
 _Ans += _Right;
 return ( _Ans );
 }
#line 2388
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 2398
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 2408
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 if ( _Right . size ( ) <= _Left . capacity ( ) - _Left . size ( )
  || _Right . capacity ( ) - _Right . size ( ) < _Left . size ( ) )
  return ( :: std :: move ( _Left . append ( _Right ) ) );
 else
  return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 2422
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem * _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, _Left ) ) );
 }
#line 2432
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  const _Elem _Left,
  basic_string < _Elem, _Traits, _Alloc > && _Right )
 {
 return ( :: std :: move ( _Right . insert ( 0, 1, _Left ) ) );
 }
#line 2442
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem * _Right )
 {
 return ( :: std :: move ( _Left . append ( _Right ) ) );
 }
#line 2452
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_string < _Elem, _Traits, _Alloc > operator + (
  basic_string < _Elem, _Traits, _Alloc > && _Left,
  const _Elem _Right )
 {
 return ( :: std :: move ( _Left . append ( 1, _Right ) ) );
 }
#line 2462
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Left . compare ( _Right ) == 0 );
 }
#line 2472
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) == 0 );
 }
#line 2482
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator == (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Left . compare ( _Right ) == 0 );
 }
#line 2492
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2502
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2512
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator != (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 2522
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 2532
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right . compare ( _Left ) > 0 );
 }
#line 2542
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator < (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Left . compare ( _Right ) < 0 );
 }
#line 2552
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2562
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( _Right < _Left );
 }
#line 2572
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator > (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( _Right < _Left );
 }
#line 2582
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2592
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2602
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator <= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Right < _Left ) );
 }
#line 2612
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2622
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const _Elem * _Left,
  const basic_string < _Elem, _Traits, _Alloc > & _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2632
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 bool operator >= (
  const basic_string < _Elem, _Traits, _Alloc > & _Left,
  const _Elem * _Right )
 {
 return ( ! ( _Left < _Right ) );
 }
#line 2643
typedef basic_string< char, char_traits< char> , allocator< char> >  string; 
#line 2645
typedef basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> >  wstring; 
#line 2648
template < class _Elem,
 class _Traits,
 class _Alloc >
 struct hash < basic_string < _Elem, _Traits, _Alloc > >
  : public unary_function < basic_string < _Elem, _Traits, _Alloc >, size_t >
 {
 typedef basic_string < _Elem, _Traits, _Alloc > _Kty;

 size_t operator ( ) ( const _Kty & _Keyval ) const
  {
  return ( _Hash_seq ( ( const unsigned char * ) _Keyval . c_str ( ),
   _Keyval . size ( ) * sizeof ( _Elem ) ) );
  }
 };
#line 2664
typedef basic_string< unsigned short, char_traits< unsigned short> , allocator< unsigned short> >  u16string; 
#line 2666
typedef basic_string< unsigned, char_traits< unsigned> , allocator< unsigned> >  u32string; 
#line 2667
}
#line 2670
#pragma warning(pop)
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
#pragma warning(push,3)
#line 2671 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xstring"
#pragma pack ( pop )
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
#pragma pack ( push, 8 )
#line 13
namespace std { 
#line 25
class logic_error : public exception { 
#line 29
public: typedef exception _Mybase; 
#line 31
explicit logic_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 33
{ 
#line 34
} 
#line 36
explicit logic_error(const char *_Message) : _Mybase(_Message) 
#line 38
{ 
#line 39
} 
#line 50 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 53
class domain_error : public logic_error { 
#line 57
public: typedef logic_error _Mybase; 
#line 59
explicit domain_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 61
{ 
#line 62
} 
#line 64
explicit domain_error(const char *_Message) : _Mybase(_Message) 
#line 66
{ 
#line 67
} 
#line 78 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 81
class invalid_argument : public logic_error { 
#line 85
public: typedef logic_error _Mybase; 
#line 87
explicit invalid_argument(const string &_Message) : _Mybase(_Message.c_str()) 
#line 89
{ 
#line 90
} 
#line 92
explicit invalid_argument(const char *_Message) : _Mybase(_Message) 
#line 94
{ 
#line 95
} 
#line 106 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 109
class length_error : public logic_error { 
#line 113
public: typedef logic_error _Mybase; 
#line 115
explicit length_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 117
{ 
#line 118
} 
#line 120
explicit length_error(const char *_Message) : _Mybase(_Message) 
#line 122
{ 
#line 123
} 
#line 134 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 137
class out_of_range : public logic_error { 
#line 141
public: typedef logic_error _Mybase; 
#line 143
explicit out_of_range(const string &_Message) : _Mybase(_Message.c_str()) 
#line 145
{ 
#line 146
} 
#line 148
explicit out_of_range(const char *_Message) : _Mybase(_Message) 
#line 150
{ 
#line 151
} 
#line 162 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 165
class runtime_error : public exception { 
#line 169
public: typedef exception _Mybase; 
#line 171
explicit runtime_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 173
{ 
#line 174
} 
#line 176
explicit runtime_error(const char *_Message) : _Mybase(_Message) 
#line 178
{ 
#line 179
} 
#line 190 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 193
class overflow_error : public runtime_error { 
#line 197
public: typedef runtime_error _Mybase; 
#line 199
explicit overflow_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 201
{ 
#line 202
} 
#line 204
explicit overflow_error(const char *_Message) : _Mybase(_Message) 
#line 206
{ 
#line 207
} 
#line 218 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 221
class underflow_error : public runtime_error { 
#line 225
public: typedef runtime_error _Mybase; 
#line 227
explicit underflow_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 229
{ 
#line 230
} 
#line 232
explicit underflow_error(const char *_Message) : _Mybase(_Message) 
#line 234
{ 
#line 235
} 
#line 246 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 249
class range_error : public runtime_error { 
#line 253
public: typedef runtime_error _Mybase; 
#line 255
explicit range_error(const string &_Message) : _Mybase(_Message.c_str()) 
#line 257
{ 
#line 258
} 
#line 260
explicit range_error(const char *_Message) : _Mybase(_Message) 
#line 262
{ 
#line 263
} 
#line 274 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
}; 
#line 275
}
#line 277
#pragma warning(pop)
#line 24 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
#pragma warning(push,3)
#line 27
#pragma warning(disable: 4275)
#line 278 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\stdexcept"
#pragma pack ( pop )
#line 23 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
#pragma pack ( push, 8 )
#line 37 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
struct __type_info_node { 
#line 38
void *_MemPtr; 
#line 39
__type_info_node *_Next; 
#line 40
}; 
#line 42
extern __type_info_node __type_info_root_node; 
#line 44
class type_info { 
#line 46
public: size_t hash_code() const throw() 
#line 47
{ 
#line 48
return ::std::_Hash_seq((const unsigned char *)this->name(), ::strlen(this->name())); 
#line 50
} 
#line 58 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
virtual ~type_info() throw(); 
#line 63 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
__declspec(dllimport) bool operator==(const type_info & _Rhs) const; 
#line 64
__declspec(dllimport) bool operator!=(const type_info & _Rhs) const; 
#line 66 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
__declspec(dllimport) bool before(const type_info & _Rhs) const; 
#line 67
__declspec(dllimport) const char *name(__type_info_node * __ptype_info_node = &__type_info_root_node) const; 
#line 68
__declspec(dllimport) const char *raw_name() const; 
#line 70
private: void *_M_data; 
#line 71
char _M_d_name[1]; 
#line 77 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
public: type_info(const type_info &) = delete;
#line 78
type_info &operator=(const type_info &) = delete;
#line 81 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
private: __declspec(dllimport) static const char *__cdecl _Name_base(const type_info *, __type_info_node * __ptype_info_node); 
#line 82
__declspec(dllimport) static void __cdecl _Type_info_dtor(type_info *); 
#line 95 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
}; 
#line 99
namespace std { 
#line 101
using ::type_info;
#line 103
}
#line 110
namespace std { 
#line 112
class __declspec(dllimport) bad_cast : public exception { 
#line 132
public: bad_cast(const char * _Message = "bad cast"); 
#line 133
bad_cast(const bad_cast &); 
#line 134
virtual ~bad_cast() throw(); 
#line 142 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
}; 
#line 144
class __declspec(dllimport) bad_typeid : public exception { 
#line 156
public: bad_typeid(const char * _Message = "bad typeid"); 
#line 157
bad_typeid(const bad_typeid &); 
#line 158
virtual ~bad_typeid() throw(); 
#line 161 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
}; 
#line 163
class __declspec(dllimport) __non_rtti_object : public bad_typeid { 
#line 175
public: __non_rtti_object(const char * _Message); 
#line 176
__non_rtti_object(const __non_rtti_object &); 
#line 177
virtual ~__non_rtti_object() throw(); 
#line 179 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
}; 
#line 181
}
#line 246 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\typeinfo"
#pragma warning(pop)
#line 245
#pragma pack ( pop )
#line 119 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ctype.h"
extern "C" { __declspec(dllimport) int __cdecl _isctype(int _C, int _Type); } 
#line 120
extern "C" { __declspec(dllimport) int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale); } 
#line 121
extern "C" { __declspec(dllimport) int __cdecl isalpha(int _C); } 
#line 122
extern "C" { __declspec(dllimport) int __cdecl _isalpha_l(int _C, _locale_t _Locale); } 
#line 123
extern "C" { __declspec(dllimport) int __cdecl isupper(int _C); } 
#line 124
extern "C" { __declspec(dllimport) int __cdecl _isupper_l(int _C, _locale_t _Locale); } 
#line 125
extern "C" { __declspec(dllimport) int __cdecl islower(int _C); } 
#line 126
extern "C" { __declspec(dllimport) int __cdecl _islower_l(int _C, _locale_t _Locale); } 
#line 127
extern "C" { __declspec(dllimport) int __cdecl isdigit(int _C); } 
#line 128
extern "C" { __declspec(dllimport) int __cdecl _isdigit_l(int _C, _locale_t _Locale); } 
#line 129
extern "C" { __declspec(dllimport) int __cdecl isxdigit(int _C); } 
#line 130
extern "C" { __declspec(dllimport) int __cdecl _isxdigit_l(int _C, _locale_t _Locale); } 
#line 131
extern "C" { __declspec(dllimport) int __cdecl isspace(int _C); } 
#line 132
extern "C" { __declspec(dllimport) int __cdecl _isspace_l(int _C, _locale_t _Locale); } 
#line 133
extern "C" { __declspec(dllimport) int __cdecl ispunct(int _C); } 
#line 134
extern "C" { __declspec(dllimport) int __cdecl _ispunct_l(int _C, _locale_t _Locale); } 
#line 135
extern "C" { __declspec(dllimport) int __cdecl isblank(int _C); } 
#line 136
extern "C" { __declspec(dllimport) int __cdecl _isblank_l(int _C, _locale_t _Locale); } 
#line 137
extern "C" { __declspec(dllimport) int __cdecl isalnum(int _C); } 
#line 138
extern "C" { __declspec(dllimport) int __cdecl _isalnum_l(int _C, _locale_t _Locale); } 
#line 139
extern "C" { __declspec(dllimport) int __cdecl isprint(int _C); } 
#line 140
extern "C" { __declspec(dllimport) int __cdecl _isprint_l(int _C, _locale_t _Locale); } 
#line 141
extern "C" { __declspec(dllimport) int __cdecl isgraph(int _C); } 
#line 142
extern "C" { __declspec(dllimport) int __cdecl _isgraph_l(int _C, _locale_t _Locale); } 
#line 143
extern "C" { __declspec(dllimport) int __cdecl iscntrl(int _C); } 
#line 144
extern "C" { __declspec(dllimport) int __cdecl _iscntrl_l(int _C, _locale_t _Locale); } 
#line 145
extern "C" { __declspec(dllimport) int __cdecl toupper(int _C); } 
#line 146
extern "C" { __declspec(dllimport) int __cdecl tolower(int _C); } 
#line 147
extern "C" { __declspec(dllimport) int __cdecl _tolower(int _C); } 
#line 148
extern "C" { __declspec(dllimport) int __cdecl _tolower_l(int _C, _locale_t _Locale); } 
#line 149
extern "C" { __declspec(dllimport) int __cdecl _toupper(int _C); } 
#line 150
extern "C" { __declspec(dllimport) int __cdecl _toupper_l(int _C, _locale_t _Locale); } 
#line 151
extern "C" { __declspec(dllimport) int __cdecl __isascii(int _C); } 
#line 152
extern "C" { __declspec(dllimport) int __cdecl __toascii(int _C); } 
#line 153
extern "C" { __declspec(dllimport) int __cdecl __iscsymf(int _C); } 
#line 154
extern "C" { __declspec(dllimport) int __cdecl __iscsym(int _C); } 
#line 25 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\locale.h"
#pragma pack ( push, 8 )
#line 55 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\locale.h"
extern "C" { struct lconv { 
#line 56
char *decimal_point; 
#line 57
char *thousands_sep; 
#line 58
char *grouping; 
#line 59
char *int_curr_symbol; 
#line 60
char *currency_symbol; 
#line 61
char *mon_decimal_point; 
#line 62
char *mon_thousands_sep; 
#line 63
char *mon_grouping; 
#line 64
char *positive_sign; 
#line 65
char *negative_sign; 
#line 66
char int_frac_digits; 
#line 67
char frac_digits; 
#line 68
char p_cs_precedes; 
#line 69
char p_sep_by_space; 
#line 70
char n_cs_precedes; 
#line 71
char n_sep_by_space; 
#line 72
char p_sign_posn; 
#line 73
char n_sign_posn; 
#line 74
__wchar_t *_W_decimal_point; 
#line 75
__wchar_t *_W_thousands_sep; 
#line 76
__wchar_t *_W_int_curr_symbol; 
#line 77
__wchar_t *_W_currency_symbol; 
#line 78
__wchar_t *_W_mon_decimal_point; 
#line 79
__wchar_t *_W_mon_thousands_sep; 
#line 80
__wchar_t *_W_positive_sign; 
#line 81
__wchar_t *_W_negative_sign; 
#line 82
}; }
#line 107 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\locale.h"
extern "C" { __declspec(dllimport) int __cdecl _configthreadlocale(int _Flag); } 
#line 108
extern "C" { __declspec(dllimport) char *__cdecl setlocale(int _Category, const char * _Locale); } 
#line 109
extern "C" { __declspec(dllimport) lconv *__cdecl localeconv(); } 
#line 110
extern "C" { __declspec(dllimport) _locale_t __cdecl _get_current_locale(); } 
#line 111
extern "C" { __declspec(dllimport) _locale_t __cdecl _create_locale(int _Category, const char * _Locale); } 
#line 112
extern "C" { __declspec(dllimport) void __cdecl _free_locale(_locale_t _Locale); } 
#line 116
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _get_current_lo" "cale instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __get_current_locale(); } 
#line 117
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _create_locale " "instead. See online help for details.")) __declspec(dllimport) _locale_t __cdecl __create_locale(int _Category, const char * _Locale); } 
#line 118
extern "C" { __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using _free_locale in" "stead. See online help for details.")) __declspec(dllimport) void __cdecl __free_locale(_locale_t _Locale); } 
#line 12 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
#pragma warning(push,3)
#line 135 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\locale.h"
#pragma pack ( pop )
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
#pragma pack ( push, 8 )
#line 60 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
extern "C" { typedef 
#line 56
struct _Collvec { 
#line 58
unsigned _Page; 
#line 59
__wchar_t *_LocaleName; 
#line 60
} _Collvec; }
#line 68
extern "C" { typedef 
#line 62
struct _Ctypevec { 
#line 64
unsigned _Page; 
#line 65
const short *_Table; 
#line 66
int _Delfl; 
#line 67
__wchar_t *_LocaleName; 
#line 68
} _Ctypevec; }
#line 76
extern "C" { typedef 
#line 70
struct _Cvtvec { 
#line 72
unsigned _Page; 
#line 73
unsigned _Mbcurmax; 
#line 74
int _Isclocale; 
#line 75
unsigned char _Isleadbyte[32]; 
#line 76
} _Cvtvec; }
#line 79
extern "C" { __declspec(dllimport) _Collvec __cdecl _Getcoll(); } 
#line 80
extern "C" { __declspec(dllimport) _Ctypevec __cdecl _Getctype(); } 
#line 81
extern "C" { __declspec(dllimport) _Cvtvec __cdecl _Getcvt(); } 
#line 82
extern "C" { __declspec(dllimport) int __cdecl _Getdateorder(); } 
#line 93
extern "C" { __declspec(dllimport) int __cdecl _Mbrtowc(__wchar_t *, const char *, size_t, mbstate_t *, const _Cvtvec *); } 
#line 97 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
extern "C" { __declspec(dllimport) float __cdecl _Stof(const char *, char **, long); } 
#line 99
extern "C" { __declspec(dllimport) double __cdecl _Stod(const char *, char **, long); } 
#line 101
extern "C" { __declspec(dllimport) long double __cdecl _Stold(const char *, char **, long); } 
#line 104
extern "C" { __declspec(dllimport) int __cdecl _Strcoll(const char *, const char *, const char *, const char *, const _Collvec *); } 
#line 106
extern "C" { __declspec(dllimport) size_t __cdecl _Strxfrm(char * _String1, char * _End1, const char *, const char *, const _Collvec *); } 
#line 109
extern "C" { __declspec(dllimport) int __cdecl _Tolower(int, const _Ctypevec *); } 
#line 110
extern "C" { __declspec(dllimport) int __cdecl _Toupper(int, const _Ctypevec *); } 
#line 111
extern "C" { __declspec(dllimport) int __cdecl _Wcrtomb(char *, __wchar_t, mbstate_t *, const _Cvtvec *); } 
#line 113
extern "C" { __declspec(dllimport) int __cdecl _Wcscoll(const __wchar_t *, const __wchar_t *, const __wchar_t *, const __wchar_t *, const _Collvec *); } 
#line 115
extern "C" { __declspec(dllimport) size_t __cdecl _Wcsxfrm(__wchar_t * _String1, __wchar_t * _End1, const __wchar_t *, const __wchar_t *, const _Collvec *); } 
#line 119
extern "C" { __declspec(dllimport) short __cdecl _Getwctype(__wchar_t, const _Ctypevec *); } 
#line 120
extern "C" { __declspec(dllimport) const __wchar_t *__cdecl _Getwctypes(const __wchar_t *, const __wchar_t *, short *, const _Ctypevec *); } 
#line 122
extern "C" { __declspec(dllimport) __wchar_t __cdecl _Towlower(__wchar_t, const _Ctypevec *); } 
#line 123
extern "C" { __declspec(dllimport) __wchar_t __cdecl _Towupper(__wchar_t, const _Ctypevec *); } 
#line 133 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
extern "C" { __declspec(dllimport) char *__cdecl _Getdays(); } 
#line 134
extern "C" { __declspec(dllimport) char *__cdecl _Getmonths(); } 
#line 135
extern "C" { __declspec(dllimport) void *__cdecl _Gettnames(); } 
#line 136
extern "C" { __declspec(dllimport) size_t __cdecl _Strftime(char *, size_t _Maxsize, const char *, const tm *, void *); } 
#line 140
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _W_Getdays(); } 
#line 141
extern "C" { __declspec(dllimport) __wchar_t *__cdecl _W_Getmonths(); } 
#line 142
extern "C" { __declspec(dllimport) void *__cdecl _W_Gettnames(); } 
#line 143
extern "C" { __declspec(dllimport) size_t __cdecl _Wcsftime(__wchar_t *, size_t _Maxsize, const __wchar_t *, const tm *, void *); } 
#line 156
__declspec(dllimport) _locale_t __cdecl _GetLocaleForCP(unsigned); 
#line 160 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
#pragma warning(pop)
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
#pragma warning(push,3)
#line 15
#pragma warning(disable: 4412)
#line 161 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo.h"
#pragma pack ( pop )
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
#pragma pack ( push, 8 )
#line 17
namespace std { 
#line 19
class __declspec(dllimport) _Timevec { 
#line 22
public: _Timevec(void *_Ptr = 0) : _Timeptr(_Ptr) 
#line 24
{ 
#line 25
} 
#line 27
_Timevec(const _Timevec &_Right) 
#line 28
{ 
#line 29
((*this) = _Right); 
#line 30
} 
#line 32
~_Timevec() throw() 
#line 33
{ 
#line 34
free(_Timeptr); 
#line 35
} 
#line 37
_Timevec &operator=(const _Timevec &_Right) 
#line 38
{ 
#line 39
(_Timeptr) = (_Right._Timeptr); 
#line 40
(((_Timevec *)(&_Right))->_Timeptr) = (0); 
#line 41
return *this; 
#line 42
} 
#line 44
void *_Getptr() const 
#line 45
{ 
#line 46
return _Timeptr; 
#line 47
} 
#line 50
private: void *_Timeptr; 
#line 51
}; 
#line 54
class __declspec(dllimport) _Locinfo { 
#line 57
public: typedef ::_Collvec _Collvec; 
#line 58
typedef ::_Ctypevec _Ctypevec; 
#line 59
typedef ::_Cvtvec _Cvtvec; 
#line 60
typedef std::_Timevec _Timevec; 
#line 62
static void __cdecl _Locinfo_ctor(_Locinfo *, const char *); 
#line 64
static void __cdecl _Locinfo_ctor(_Locinfo *, int, const char *); 
#line 66
static void __cdecl _Locinfo_dtor(_Locinfo *); 
#line 68
static _Locinfo &__cdecl _Locinfo_Addcats(_Locinfo *, int, const char *); 
#line 71
_Locinfo(const char *_Pch = "C") : _Lock(0) 
#line 76 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
{ 
#line 77
if (_Pch == (0)) { 
#line 78
throw ((runtime_error)("bad locale name")); }  
#line 79
_Locinfo_ctor(this, _Pch); 
#line 80
} 
#line 82
_Locinfo(int _Cat, const char *_Pch) : _Lock(0) 
#line 87 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
{ 
#line 88
if (_Pch == (0)) { 
#line 89
throw ((runtime_error)("bad locale name")); }  
#line 90
_Locinfo_ctor(this, _Cat, _Pch); 
#line 91
} 
#line 93
~_Locinfo() throw() 
#line 94
{ 
#line 95
_Locinfo_dtor(this); 
#line 96
} 
#line 98
_Locinfo &_Addcats(int _Cat, const char *_Pch) 
#line 99
{ 
#line 100
if (_Pch == (0)) { 
#line 101
throw ((runtime_error)("bad locale name")); }  
#line 102
return _Locinfo_Addcats(this, _Cat, _Pch); 
#line 103
} 
#line 105
const char *_Getname() const 
#line 106
{ 
#line 107
return (_Newlocname)._C_str(); 
#line 108
} 
#line 110
_Collvec _Getcoll() const 
#line 111
{ 
#line 112
return ::_Getcoll(); 
#line 113
} 
#line 115
_Ctypevec _Getctype() const 
#line 116
{ 
#line 117
return ::_Getctype(); 
#line 118
} 
#line 120
_Cvtvec _Getcvt() const 
#line 121
{ 
#line 122
return ::_Getcvt(); 
#line 123
} 
#line 125
const lconv *_Getlconv() const 
#line 126
{ 
#line 127
return localeconv(); 
#line 128
} 
#line 130
_Timevec _Gettnames() const 
#line 131
{ 
#line 132
return ((_Timevec)(::_Gettnames())); 
#line 133
} 
#line 135
const char *_Getdays() const 
#line 136
{ 
#line 137
const char *_Ptr = ::_Getdays(); 
#line 139
if (_Ptr != (0)) 
#line 140
{ 
#line 141
((((_Locinfo *)this)->_Days) = _Ptr); 
#line 142
free((void *)_Ptr); 
#line 143
}  
#line 144
return (!(_Days)._Empty()) ? (_Days)._C_str() : (":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday"); 
#line 147
} 
#line 149
const char *_Getmonths() const 
#line 150
{ 
#line 151
const char *_Ptr = ::_Getmonths(); 
#line 153
if (_Ptr != (0)) 
#line 154
{ 
#line 155
((((_Locinfo *)this)->_Months) = _Ptr); 
#line 156
free((void *)_Ptr); 
#line 157
}  
#line 158
return (!(_Months)._Empty()) ? (_Months)._C_str() : (":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June:Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:De" "cember"); 
#line 163
} 
#line 165
const char *_Getfalse() const 
#line 166
{ 
#line 167
return "false"; 
#line 168
} 
#line 170
const char *_Gettrue() const 
#line 171
{ 
#line 172
return "true"; 
#line 173
} 
#line 175
int _Getdateorder() const 
#line 176
{ 
#line 177
return ::_Getdateorder(); 
#line 178
} 
#line 180
_Timevec _W_Gettnames() const 
#line 181
{ 
#line 182
return ((_Timevec)(::_W_Gettnames())); 
#line 183
} 
#line 185
const unsigned short *_W_Getdays() const 
#line 186
{ 
#line 187
const __wchar_t *_Ptr = ::_W_Getdays(); 
#line 189
if (_Ptr != (0)) 
#line 190
{ 
#line 191
((((_Locinfo *)this)->_W_Days) = _Ptr); 
#line 192
free((void *)_Ptr); 
#line 193
}  
#line 194
return (const unsigned short *)((!(_W_Days)._Empty()) ? (_W_Days)._C_str() : (L"\x3a\x53\x75\x6e\x3a\x53\x75\x6e\x64\x61\x79\x3a\x4d\x6f\x6e\x3a\x4d\x6f\x6e\x64\x61\x79\x3a\x54\x75\x65\x3a\x54\x75\x65\x73\x64" L"\x61\x79\x3a\x57\x65\x64\x3a\x57\x65\x64\x6e\x65\x73\x64\x61\x79\x3a\x54\x68\x75\x3a\x54\x68\x75\x72\x73\x64\x61\x79\x3a\x46\x72" L"\x69\x3a\x46\x72\x69\x64\x61\x79\x3a\x53\x61\x74\x3a\x53\x61\x74\x75\x72\x64\x61\x79")); 
#line 198
} 
#line 200
const unsigned short *_W_Getmonths() const 
#line 201
{ 
#line 202
const __wchar_t *_Ptr = ::_W_Getmonths(); 
#line 204
if (_Ptr != (0)) 
#line 205
{ 
#line 206
((((_Locinfo *)this)->_W_Months) = _Ptr); 
#line 207
free((void *)_Ptr); 
#line 208
}  
#line 209
return (const unsigned short *)((!(_W_Months)._Empty()) ? (_W_Months)._C_str() : (L"\x3a\x4a\x61\x6e\x3a\x4a\x61\x6e\x75\x61\x72\x79\x3a\x46\x65\x62\x3a\x46\x65\x62\x72\x75\x61\x72\x79\x3a\x4d\x61\x72\x3a\x4d\x61" L"\x72\x63\x68\x3a\x41\x70\x72\x3a\x41\x70\x72\x69\x6c\x3a\x4d\x61\x79\x3a\x4d\x61\x79\x3a\x4a\x75\x6e\x3a\x4a\x75\x6e\x65\x3a\x4a" L"\x75\x6c\x3a\x4a\x75\x6c\x79\x3a\x41\x75\x67\x3a\x41\x75\x67\x75\x73\x74\x3a\x53\x65\x70\x3a\x53\x65\x70\x74\x65\x6d\x62\x65\x72" L"\x3a\x4f\x63\x74\x3a\x4f\x63\x74\x6f\x62\x65\x72\x3a\x4e\x6f\x76\x3a\x4e\x6f\x76\x65\x6d\x62\x65\x72\x3a\x44\x65\x63\x3a\x44\x65" L"\x63\x65\x6d\x62\x65\x72")); 
#line 215
} 
#line 217
_Locinfo(const _Locinfo &) = delete;
#line 218
_Locinfo &operator=(const _Locinfo &) = delete;
#line 225
private: _Lockit _Lock; 
#line 228 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
_Yarn< char>  _Days; 
#line 229
_Yarn< char>  _Months; 
#line 230
_Yarn< __wchar_t>  _W_Days; 
#line 231
_Yarn< __wchar_t>  _W_Months; 
#line 232
_Yarn< char>  _Oldlocname; 
#line 233
_Yarn< char>  _Newlocname; 
#line 234
}; 
#line 237
template < class _Elem > inline
 int __cdecl _LStrcoll ( const _Elem * _First1, const _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 for (; _First1 != _Last1 && _First2 != _Last2; ++ _First1, ++ _First2 )
  if ( * _First1 < * _First2 )
   return ( - 1 );
  else if ( * _First2 < * _First1 )
   return ( + 1 );
 return ( _First2 != _Last2 ? - 1 : _First1 != _Last1 ? + 1 : 0 );
 }
#line 251
template<> inline int __cdecl _LStrcoll(const char *_First1, const char *_Last1, const char *
#line 252
_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 253
_Vector) 
#line 254
{ 
#line 255
return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 256
} 
#line 259
template<> inline int __cdecl _LStrcoll(const __wchar_t *_First1, const __wchar_t *_Last1, const __wchar_t *
#line 260
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 261
_Vector) 
#line 262
{ 
#line 263
return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector); 
#line 264
} 
#line 267
template < class _Elem > inline
 size_t __cdecl _LStrxfrm ( _Elem * _First1, _Elem * _Last1,
  const _Elem * _First2, const _Elem * _Last2,
   const _Locinfo :: _Collvec * )
 {
 size_t _Count = _Last2 - _First2;
 if ( _Count <= ( size_t ) ( _Last1 - _First1 ) )
  :: memcpy_s ( ( _First1 ), ( ( _Last1 - _First1 ) * sizeof ( _Elem ) ), ( _First2 ), ( _Count * sizeof ( _Elem ) ) );

 return ( _Count );
 }
#line 280 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
template<> inline size_t __cdecl _LStrxfrm(char *
#line 281
_First1, char *_Last1, const char *
#line 282
_First2, const char *_Last2, const _Locinfo::_Collvec *
#line 283
_Vector) 
#line 284
{ 
#line 285
return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 286
} 
#line 289
template<> inline size_t __cdecl _LStrxfrm(__wchar_t *
#line 290
_First1, __wchar_t *_Last1, const __wchar_t *
#line 291
_First2, const __wchar_t *_Last2, const _Locinfo::_Collvec *
#line 292
_Vector) 
#line 293
{ 
#line 294
return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector); 
#line 295
} 
#line 296
}
#line 298
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xdebug"
#pragma warning(push,3)
#line 299 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocinfo"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xdebug"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 17
struct _DebugHeapTag_t { 
#line 19
int _Type; 
#line 20
}; 
#line 21
}
#line 77 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xdebug"
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xfacet"
#pragma warning(push,3)
#line 78 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xdebug"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xfacet"
#pragma pack ( push, 8 )
#line 18
namespace std { 
#line 20
class __declspec(dllimport) _Facet_base { 
#line 23
public: virtual ~_Facet_base() throw() 
#line 24
{ 
#line 25
} 
#line 28
virtual void _Incref() = 0; 
#line 31
virtual _Facet_base *_Decref() = 0; 
#line 32
}; 
#line 38 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xfacet"
void __cdecl _Facet_Register(_Facet_base *); 
#line 40 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xfacet"
}
#line 42
#pragma warning(pop)
#line 16 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
#pragma warning(push,3)
#line 20
#pragma warning(disable: 4412 28197)
#line 43 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xfacet"
#pragma pack ( pop )
#line 15 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
#pragma pack ( push, 8 )
#line 22
namespace std { 
#line 24
template< class _Dummy> 
#line 25
class _Locbase { 
#line 28
public: static const int collate = ((1 << 1) >> 1); 
#line 29
static const int ctype = ((1 << 2) >> 1); 
#line 30
static const int monetary = ((1 << 3) >> 1); 
#line 31
static const int numeric = ((1 << 4) >> 1); 
#line 32
static const int time = ((1 << 5) >> 1); 
#line 33
static const int messages = ((1 << 6) >> 1); 
#line 34
static const int all = (((1 << (6 + 1)) >> 1) - 1); 
#line 35
static const int none = 0; 
#line 36
}; 
#line 38
template< class _Dummy> const int 
#line 39
_Locbase< _Dummy> ::collate; 
#line 40
template< class _Dummy> const int 
#line 41
_Locbase< _Dummy> ::ctype; 
#line 42
template< class _Dummy> const int 
#line 43
_Locbase< _Dummy> ::monetary; 
#line 44
template< class _Dummy> const int 
#line 45
_Locbase< _Dummy> ::numeric; 
#line 46
template< class _Dummy> const int 
#line 47
_Locbase< _Dummy> ::time; 
#line 48
template< class _Dummy> const int 
#line 49
_Locbase< _Dummy> ::messages; 
#line 50
template< class _Dummy> const int 
#line 51
_Locbase< _Dummy> ::all; 
#line 52
template< class _Dummy> const int 
#line 53
_Locbase< _Dummy> ::none; 
#line 56
class locale; 
#line 57
template < class _Facet >
 const _Facet & __cdecl use_facet ( const locale & );
#line 59
template< class _Elem> class collate; 
#line 62
class locale : public _Locbase< int>  { 
#line 66
public: typedef int category; 
#line 69
class __declspec(dllimport) id { 
#line 72
public: id(size_t _Val = 0) : _Id(_Val) 
#line 74
{ 
#line 75
} 
#line 77
operator size_t() 
#line 78
{ 
#line 79
if ((_Id) == (0)) 
#line 80
{ 
#line 81
{ _Lockit _Lock(0); 
#line 82
if ((_Id) == (0)) { 
#line 83
(_Id) = (++_Id_cnt); }  
#line 84
} 
#line 85
}  
#line 86
return _Id; 
#line 87
} 
#line 90
private: size_t _Id; 
#line 92
static int _Id_cnt; 
#line 95
public: id(const id &) = delete;
#line 96
id &operator=(const id &) = delete;
#line 97
}; 
#line 99
class _Locimp; 
#line 102
class __declspec(dllimport) facet : public _Facet_base { 
#line 105
friend class locale; 
#line 106
friend class _Locimp; 
#line 108
template< class _Ty> friend void __cdecl _DebugHeapDelete(_Ty * _Ptr); 
#line 112
public: static size_t __cdecl _Getcat(const facet ** = 0, const locale * = 0) 
#line 114
{ 
#line 115
return (size_t)(-1); 
#line 116
} 
#line 143 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
virtual void _Incref() 
#line 144
{ 
#line 145
_InterlockedIncrement(reinterpret_cast< volatile long *>(&(_Refs))); 
#line 146
} 
#line 148
virtual _Facet_base *_Decref() 
#line 149
{ 
#line 150
if (_InterlockedDecrement(reinterpret_cast< volatile long *>(&(_Refs))) == (0)) { 
#line 151
return this; } else { 
#line 153
return 0; }  
#line 154
} 
#line 157
private: _Atomic_counter_t _Refs; 
#line 160
protected: explicit facet(size_t _Initrefs = 0) 
#line 161
{ 
#line 162
_Init_atomic_counter(_Refs, (_Atomic_integral_t)_Initrefs); 
#line 163
} 
#line 165
virtual ~facet() throw() 
#line 166
{ 
#line 167
} 
#line 170
public: facet(const facet &) = delete;
#line 171
facet &operator=(const facet &) = delete;
#line 172
}; 
#line 175
#pragma warning(push)
#pragma warning(disable: 4275)
#line 178
class __declspec(dllimport) _Locimp : public facet { 
#line 182
protected: virtual ~_Locimp() throw() 
#line 183
{ 
#line 184
_Locimp_dtor(this); 
#line 185
} 
#line 189
private: static _Locimp *__cdecl _New_Locimp(bool _Transparent = false); 
#line 191
static _Locimp *__cdecl _New_Locimp(const _Locimp & _Right); 
#line 194
static void __cdecl _Locimp_dtor(_Locimp *); 
#line 196
static void __cdecl _Locimp_Addfac(_Locimp *, facet *, size_t); 
#line 198
static void __cdecl _Locimp_ctor(_Locimp *, const _Locimp &); 
#line 200
friend class locale; 
#line 202
_Locimp(bool _Transparent) : facet(1), _Facetvec((0)), _Facetcount((0)), _Catmask(none), _Xparent(_Transparent), _Name("*") 
#line 206
{ 
#line 207
} 
#line 209
_Locimp(const _Locimp &_Right) : facet(1), _Facetvec((0)), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask), _Xparent(_Right._Xparent), _Name((_Right._Name).c_str()) 
#line 213
{ 
#line 214
_Locimp_ctor(this, _Right); 
#line 215
} 
#line 217
void _Addfac(facet *_Pfacet, size_t _Id) 
#line 218
{ 
#line 219
_Locimp_Addfac(this, _Pfacet, _Id); 
#line 220
} 
#line 222
static _Locimp *__cdecl _Makeloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 225
static void __cdecl _Makewloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 229
static void __cdecl _Makeushloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 233 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
static void __cdecl _Makexloc(const _Locinfo &, category, _Locimp *, const locale *); 
#line 236
facet **_Facetvec; 
#line 237
size_t _Facetcount; 
#line 238
category _Catmask; 
#line 239
bool _Xparent; 
#line 240
_Yarn< char>  _Name; 
#line 242
static _Locimp *_Clocptr; 
#line 245
public: _Locimp &operator=(const _Locimp &) = delete;
#line 246
}; 
#line 248
#pragma warning(pop)
#line 250
template < class _Elem,
  class _Traits,
  class _Alloc >
  bool operator ( ) ( const basic_string < _Elem, _Traits, _Alloc > & _Left,
   const basic_string < _Elem, _Traits, _Alloc > & _Right ) const
  {
  const :: std :: collate < _Elem > & _Coll_fac =
   use_facet < :: std :: collate < _Elem > > ( * this );

  return ( _Coll_fac . compare ( _Left . c_str ( ), _Left . c_str ( ) + _Left . size ( ),
   _Right . c_str ( ), _Right . c_str ( ) + _Right . size ( ) ) < 0 );
  }
#line 263
template < class _Facet >
  locale combine ( const locale & _Loc ) const
  {
  _Facet * _Facptr;

  try {
   _Facptr = ( _Facet * ) & use_facet < _Facet > ( _Loc );
  } catch ( ... ) {
   _Xruntime_error ( "locale::combine facet missing" );
  }

  _Locimp * _Newimp = _Locimp :: _New_Locimp ( * _Ptr );
  _Newimp -> _Addfac ( _Facptr, _Facet :: id );
  _Newimp -> _Catmask = 0;
  _Newimp -> _Name = "*";
  return ( locale ( _Newimp ) );
  }
#line 281
template < class _Facet >
  locale ( const locale & _Loc, const _Facet * _Facptr )
   : _Ptr ( _Locimp :: _New_Locimp ( * _Loc . _Ptr ) )
  {
  if ( _Facptr != 0 )
   {
   _Ptr -> _Addfac ( ( _Facet * ) _Facptr, _Facet :: id );
   if ( _Facet :: _Getcat ( ) != ( size_t ) ( - 1 ) )
    {
    _Ptr -> _Catmask = 0;
    _Ptr -> _Name = "*";
    }
   }
  }
#line 296
locale(_Uninitialized) 
#line 297
{ 
#line 298
} 
#line 321 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
locale(const locale &_Right) throw() : _Ptr(_Right._Ptr) 
#line 323
{ 
#line 324
(_Ptr)->_Incref(); 
#line 325
} 
#line 327
locale() throw() : _Ptr(_Init(true)) 
#line 329
{ 
#line 330
} 
#line 333
locale(const locale &_Loc, const locale &_Other, category 
#line 334
_Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) 
#line 336
{ 
#line 337
try { 
#line 338
{ _Locinfo _Lobj((_Loc._Ptr)->_Catmask, ((_Loc._Ptr)->_Name).c_str()); 
#line 339
_Locimp::_Makeloc(_Lobj._Addcats(_Cat & ((_Other._Ptr)->_Catmask), ((_Other._Ptr)->_Name).c_str()), _Cat, _Ptr, &_Other); 
#line 341
} 
#line 342
} catch (...) { 
#line 343
delete (_Ptr)->_Decref(); 
#line 344
throw; 
#line 345
}  
#line 346
} 
#line 349
private: void _Construct(const string &_Str, category 
#line 350
_Cat) 
#line 351
{ 
#line 352
bool _Bad = false; 
#line 353
try { 
#line 354
_Init(); 
#line 355
{ _Locinfo _Lobj(_Cat, _Str.c_str()); 
#line 356
if (this->_Badname(_Lobj)) { 
#line 357
_Bad = true; } else { 
#line 359
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); }  
#line 360
} 
#line 361
} catch (...) { 
#line 362
delete (_Ptr)->_Decref(); 
#line 363
throw; 
#line 364
}  
#line 366
if (_Bad) 
#line 367
{ 
#line 368
delete (_Ptr)->_Decref(); 
#line 369
_Xruntime_error("bad locale name"); 
#line 370
}  
#line 371
} 
#line 373
void _Construct(const locale &_Loc, const string &_Str, category 
#line 374
_Cat) 
#line 375
{ 
#line 376
bool _Bad = false; 
#line 377
try { 
#line 378
{ _Locinfo _Lobj((_Loc._Ptr)->_Catmask, ((_Loc._Ptr)->_Name).c_str()); 
#line 379
bool _Hadname = !this->_Badname(_Lobj); 
#line 380
_Lobj._Addcats(_Cat, _Str.c_str()); 
#line 382
if (_Hadname && this->_Badname(_Lobj)) { 
#line 383
_Bad = true; } else { 
#line 385
_Locimp::_Makeloc(_Lobj, _Cat, _Ptr, 0); }  
#line 386
} 
#line 387
} catch (...) { 
#line 388
delete (_Ptr)->_Decref(); 
#line 389
throw; 
#line 390
}  
#line 392
if (_Bad) 
#line 393
{ 
#line 394
delete (_Ptr)->_Decref(); 
#line 395
_Xruntime_error("bad locale name"); 
#line 396
}  
#line 397
} 
#line 400
public: explicit locale(const char *_Locname, category 
#line 401
_Cat = all) : _Ptr(_Locimp::_New_Locimp()) 
#line 403
{ 
#line 406
if (_Locname == (0)) { 
#line 407
_Xruntime_error("bad locale name"); }  
#line 408
this->_Construct(_Locname, _Cat); 
#line 409
} 
#line 411
locale(const locale &_Loc, const char *_Locname, category 
#line 412
_Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) 
#line 414
{ 
#line 417
if (_Locname == (0)) { 
#line 418
_Xruntime_error("bad locale name"); }  
#line 419
this->_Construct(_Loc, _Locname, _Cat); 
#line 420
} 
#line 422
explicit locale(const string &_Str, category 
#line 423
_Cat = all) : _Ptr(_Locimp::_New_Locimp()) 
#line 425
{ 
#line 426
this->_Construct(_Str, _Cat); 
#line 427
} 
#line 429
locale(const locale &_Loc, const string &_Str, category 
#line 430
_Cat) : _Ptr(_Locimp::_New_Locimp(*(_Loc._Ptr))) 
#line 432
{ 
#line 433
this->_Construct(_Loc, _Str, _Cat); 
#line 434
} 
#line 437 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
~locale() throw() 
#line 438
{ 
#line 439
if ((_Ptr) != (0)) { 
#line 440
delete (_Ptr)->_Decref(); }  
#line 441
} 
#line 443
locale &operator=(const locale &_Right) throw() 
#line 444
{ 
#line 445
if ((_Ptr) != (_Right._Ptr)) 
#line 446
{ 
#line 447
delete (_Ptr)->_Decref(); 
#line 448
(_Ptr) = (_Right._Ptr); 
#line 449
(_Ptr)->_Incref(); 
#line 450
}  
#line 451
return *this; 
#line 452
} 
#line 455 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
string name() const 
#line 456
{ 
#line 457
return (((_Ptr) == (0)) ? string() : ((_Ptr)->_Name).c_str()); 
#line 458
} 
#line 460
const char *c_str() const 
#line 461
{ 
#line 462
return ((_Ptr) == (0)) ? "" : ((_Ptr)->_Name).c_str(); 
#line 463
} 
#line 465
const facet *_Getfacet(size_t _Id) const 
#line 466
{ 
#line 467
const facet *_Facptr = (_Id < ((_Ptr)->_Facetcount)) ? ((_Ptr)->_Facetvec)[_Id] : (0); 
#line 469
if ((_Facptr != (0)) || (!((_Ptr)->_Xparent))) { 
#line 470
return _Facptr; } else 
#line 472
{ 
#line 473
_Locimp *_Ptr = _Getgloballocale(); 
#line 474
return (_Id < (_Ptr->_Facetcount)) ? (_Ptr->_Facetvec)[_Id] : (0); 
#line 477
}  
#line 478
} 
#line 480
bool operator==(const locale &_Loc) const 
#line 481
{ 
#line 482
return ((_Ptr) == (_Loc._Ptr)) || (((this->name()).compare("*") != 0) && ((this->name()).compare(_Loc.name()) == 0)); 
#line 485
} 
#line 487
bool operator!=(const locale &_Right) const 
#line 488
{ 
#line 489
return !((*this) == _Right); 
#line 490
} 
#line 492
__declspec(dllimport) static const locale &__cdecl 
#line 493
classic(); 
#line 495
__declspec(dllimport) static locale __cdecl 
#line 496
global(const locale &); 
#line 498
__declspec(dllimport) static locale __cdecl 
#line 499
empty(); 
#line 502
private: locale(_Locimp *_Ptrimp) : _Ptr(_Ptrimp) 
#line 504
{ 
#line 505
} 
#line 507
__declspec(dllimport) static _Locimp *__cdecl 
#line 508
_Init(bool _Do_incref = false); 
#line 509
__declspec(dllimport) static _Locimp *__cdecl 
#line 510
_Getgloballocale(); 
#line 511
__declspec(dllimport) static void __cdecl 
#line 512
_Setgloballocale(void *); 
#line 514
bool _Badname(const _Locinfo &_Lobj) 
#line 515
{ 
#line 516
return ::strcmp(_Lobj._Getname(), "*") == 0; 
#line 517
} 
#line 519
_Locimp *_Ptr; 
#line 520
}; 
#line 543 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template< class _Facet> 
#line 544
struct _Facetptr { 
#line 546
static const locale::facet *_Psave; 
#line 547
}; 
#line 549
template< class _Facet> const locale::facet *
#line 551
_Facetptr< _Facet> ::_Psave = (0); 
#line 558
template < class _Facet > inline
 const _Facet & __cdecl use_facet ( const locale & _Loc )

 {





 { :: std :: _Lockit _Lock ( 0 );
  const locale :: facet * _Psave =
   _Facetptr < _Facet > :: _Psave;

  size_t _Id = _Facet :: id;
  const locale :: facet * _Pf = _Loc . _Getfacet ( _Id );

  if ( _Pf != 0 )
   ;
  else if ( _Psave != 0 )
   _Pf = _Psave;
  else if ( _Facet :: _Getcat ( & _Psave, & _Loc ) == ( size_t ) ( - 1 ) )



   throw :: std :: bad_cast ( );





  else
   {
   _Pf = _Psave;
   _Facetptr < _Facet > :: _Psave = _Psave;

   locale :: facet * _Pfmod = ( _Facet * ) _Psave;
   _Pfmod -> _Incref ( );





   _Facet_Register ( _Pfmod );

   }

  return ( ( const _Facet & ) ( * _Pf ) );
 }

 }
#line 610 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template < class _Elem,
 class _InIt > inline
 int __cdecl _Getloctxt ( _InIt & _First, _InIt & _Last, size_t _Numfields,
  const _Elem * _Ptr )
 {
 for ( size_t _Off = 0; _Ptr [ _Off ] != ( _Elem ) 0; ++ _Off )
  if ( _Ptr [ _Off ] == _Ptr [ 0 ] )
   ++ _Numfields;
 string _Str ( _Numfields, '\000' );

 int _Ans = - 2;
 for ( size_t _Column = 1;; ++ _Column, ++ _First, _Ans = - 1 )
  {
  bool _Prefix = false;
  size_t _Off = 0;
  size_t _Field = 0;

  for (; _Field < _Numfields; ++ _Field )
   {
   for (; _Ptr [ _Off ] != ( _Elem ) 0 && _Ptr [ _Off ] != _Ptr [ 0 ]; ++ _Off )
    ;

   if ( _Str [ _Field ] != '\000' )
    _Off += _Str [ _Field ];
   else if ( _Ptr [ _Off += _Column ] == _Ptr [ 0 ]
    || _Ptr [ _Off ] == ( _Elem ) 0 )
    {
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
    _Ans = ( int ) _Field;
    }
   else if ( _First == _Last || _Ptr [ _Off ] != * _First )
    _Str [ _Field ] = ( char ) ( _Column < 127
     ? _Column : 127 );
   else
    _Prefix = true;
   }

  if ( ! _Prefix || _First == _Last )
   break;
  }
 return ( _Ans );
 }
#line 658
template < class _Elem > inline
 char __cdecl _Maklocbyte ( _Elem _Char,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( char ) ( unsigned char ) _Char );
 }
#line 666
template<> inline char __cdecl _Maklocbyte(__wchar_t _Char, const _Locinfo::_Cvtvec &
#line 667
_Cvt) 
#line 668
{ 
#line 669
char _Byte = '\000'; 
#line 670
mbstate_t _Mbst1 = 0; 
#line 671
_Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt); 
#line 672
return _Byte; 
#line 673
} 
#line 677
template<> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec &
#line 678
_Cvt) 
#line 679
{ 
#line 680
char _Byte = '\000'; 
#line 681
mbstate_t _Mbst1 = 0; 
#line 682
_Wcrtomb(&_Byte, (__wchar_t)_Char, &_Mbst1, &_Cvt); 
#line 683
return _Byte; 
#line 684
} 
#line 691 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template < class _Elem > inline
 _Elem __cdecl _Maklocchr ( char _Byte, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 return ( ( _Elem ) ( unsigned char ) _Byte );
 }
#line 699
template<> inline __wchar_t __cdecl _Maklocchr(char _Byte, __wchar_t *, const _Locinfo::_Cvtvec &
#line 700
_Cvt) 
#line 701
{ 
#line 702
__wchar_t _Wc = L'\x0'; 
#line 703
mbstate_t _Mbst1 = 0; 
#line 704
_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt); 
#line 705
return _Wc; 
#line 706
} 
#line 710
template<> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short *, const _Locinfo::_Cvtvec &
#line 711
_Cvt) 
#line 712
{ 
#line 713
unsigned short _Wc = ((unsigned short)0); 
#line 714
mbstate_t _Mbst1 = 0; 
#line 715
_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt); 
#line 716
return _Wc; 
#line 717
} 
#line 724 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template < class _Elem > inline
 _Elem * __cdecl _Maklocstr ( const char * _Ptr, _Elem *,
  const _Locinfo :: _Cvtvec & )
 {
 size_t _Count = :: strlen ( _Ptr ) + 1;
 _Elem * _Ptrdest = new _Elem [ _Count ];

 #pragma warning(push)
 #pragma warning(disable: 6011)
 for ( _Elem * _Ptrnext = _Ptrdest; 0 < _Count; -- _Count, ++ _Ptrnext, ++ _Ptr )
  * _Ptrnext = ( _Elem ) ( unsigned char ) * _Ptr;
 #pragma warning(pop)

 return ( _Ptrdest );
 }
#line 741
template<> inline __wchar_t *__cdecl _Maklocstr(const char *_Ptr, __wchar_t *, const _Locinfo::_Cvtvec &
#line 742
_Cvt) 
#line 743
{ 
#line 744
size_t _Count, _Count1; 
#line 745
size_t _Wchars; 
#line 746
const char *_Ptr1; 
#line 747
int _Bytes; 
#line 748
__wchar_t _Wc; 
#line 749
mbstate_t _Mbst1 = 0; 
#line 751
_Count1 = (::strlen(_Ptr) + (1)); 
#line 752
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 754
if ((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 755
break; }  }  
#line 756
++_Wchars; 
#line 758
__wchar_t *_Ptrdest = new __wchar_t [_Wchars]; 
#line 759
__wchar_t *_Ptrnext = _Ptrdest; 
#line 760
mbstate_t _Mbst2 = 0; 
#line 762
#pragma warning(push)
#pragma warning(disable: 6011)
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 766
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 767
break; }  }  
#line 768
(*_Ptrnext) = L'\x0'; 
#pragma warning(pop)
#line 771
return _Ptrdest; 
#line 772
} 
#line 776
template<> inline unsigned short *__cdecl _Maklocstr(const char *_Ptr, unsigned short *, const _Locinfo::_Cvtvec &
#line 777
_Cvt) 
#line 778
{ 
#line 779
size_t _Count, _Count1; 
#line 780
size_t _Wchars; 
#line 781
const char *_Ptr1; 
#line 782
int _Bytes; 
#line 783
unsigned short _Wc; 
#line 784
mbstate_t _Mbst1 = 0; 
#line 786
_Count1 = (::strlen(_Ptr) + (1)); 
#line 787
for (((_Count = _Count1), (_Wchars = (0))), (_Ptr1 = _Ptr); (0) < _Count; ((_Count -= _Bytes), (_Ptr1 += _Bytes)), (++_Wchars)) { 
#line 789
if ((_Bytes = _Mbrtowc((__wchar_t *)(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0) { 
#line 791
break; }  }  
#line 792
++_Wchars; 
#line 794
__wchar_t *_Ptrdest = new __wchar_t [_Wchars]; 
#line 795
__wchar_t *_Ptrnext = _Ptrdest; 
#line 796
mbstate_t _Mbst2 = 0; 
#line 797
for (; (0) < _Wchars; (((_Count -= _Bytes), (_Ptr += _Bytes)), (--_Wchars)), (++_Ptrnext)) { 
#line 799
if ((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0) { 
#line 800
break; }  }  
#line 801
(*_Ptrnext) = L'\x0'; 
#line 802
return (unsigned short *)_Ptrdest; 
#line 803
} 
#line 807 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
#pragma warning(push)
#pragma warning(disable: 4275)
#line 810
class __declspec(dllimport) codecvt_base : public locale::facet { 
#line 815
public: enum { 
#line 816
ok, partial, error, noconv}; 
#line 817
typedef int result; 
#line 819
codecvt_base(size_t _Refs = 0) : locale::facet(_Refs) 
#line 821
{ 
#line 822
} 
#line 824
bool always_noconv() const throw() 
#line 825
{ 
#line 826
return this->do_always_noconv(); 
#line 827
} 
#line 829
int max_length() const throw() 
#line 830
{ 
#line 831
return this->do_max_length(); 
#line 832
} 
#line 834
int encoding() const throw() 
#line 835
{ 
#line 836
return this->do_encoding(); 
#line 837
} 
#line 839
virtual ~codecvt_base() throw() 
#line 840
{ 
#line 841
} 
#line 844
protected: virtual bool do_always_noconv() const throw() 
#line 845
{ 
#line 846
return false; 
#line 847
} 
#line 849
virtual int do_max_length() const throw() 
#line 850
{ 
#line 851
return 1; 
#line 852
} 
#line 854
virtual int do_encoding() const throw() 
#line 855
{ 
#line 856
return 1; 
#line 857
} 
#line 858
}; 
#line 860
#pragma warning(pop)
#line 863
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt
  : public codecvt_base
 {
public :
 typedef _Elem intern_type;
 typedef _Byte extern_type;
 typedef _Statype state_type;

 result in ( _Statype & _State,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const
  {
  return ( do_in ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result out ( _Statype & _State,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_out ( _State,
   _First1, _Last1, _Mid1, _First2, _Last2, _Mid2 ) );
  }

 result unshift ( _Statype & _State,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  return ( do_unshift ( _State, _First2, _Last2, _Mid2 ) );
  }

 int length ( _Statype & _State, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( do_length ( _State, _First1, _Last1, _Count ) );
  }

  static locale :: id id;

 explicit codecvt ( size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Locinfo ( ) );
  }

  codecvt ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : codecvt_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new codecvt < _Elem, _Byte, _Statype > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ codecvt ( ) throw ( )
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

 virtual bool do_always_noconv ( ) const throw ( )
  {
  return ( is_same < _Byte, _Elem > :: value );
  }

 virtual result do_in ( _Statype &,
  const _Byte * _First1, const _Byte * _Last1, const _Byte * & _Mid1,
  _Elem * _First2, _Elem * _Last2, _Elem * & _Mid2 ) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if ( is_same < _Byte, _Elem > :: value )
   return ( noconv );
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++ _Mid1, ++ _Mid2 )
    * _Mid2 = ( _Elem ) * _Mid1;
   return ( ok );
   }
  }

 virtual result do_out ( _Statype &,
  const _Elem * _First1, const _Elem * _Last1, const _Elem * & _Mid1,
  _Byte * _First2, _Byte * _Last2, _Byte * & _Mid2 ) const
  {
  _Mid1 = _First1, _Mid2 = _First2;
  if ( is_same < _Byte, _Elem > :: value )
   return ( noconv );
  else
   {
   for (; _Mid1 != _Last1 && _Mid2 != _Last2; ++ _Mid1, ++ _Mid2 )
    * _Mid2 = ( _Byte ) * _Mid1;
   return ( ok );
   }
  }

 virtual result do_unshift ( _Statype &,
  _Byte * _First2, _Byte *, _Byte * & _Mid2 ) const
  {
  _Mid2 = _First2;
  return ( ok );
  }

 virtual int do_length ( _Statype &, const _Byte * _First1,
  const _Byte * _Last1, size_t _Count ) const
  {
  return ( ( int ) ( _Count < ( size_t ) ( _Last1 - _First1 )
   ? _Count : _Last1 - _First1 ) );
  }
 };
#line 985
template< class _Elem, class 
#line 986
_Byte, class 
#line 987
_Statype> locale::id 
#line 988
codecvt< _Elem, _Byte, _Statype> ::id; 
#line 1591 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template<> class __declspec(dllimport) codecvt< __wchar_t, char, int>  : public codecvt_base { 
#line 1595
public: typedef __wchar_t _Elem; 
#line 1596
typedef char _Byte; 
#line 1597
typedef _Mbstatet _Statype; 
#line 1598
typedef _Elem intern_type; 
#line 1599
typedef _Byte extern_type; 
#line 1600
typedef _Statype state_type; 
#line 1602
result in(_Statype &_State, const _Byte *
#line 1603
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1604
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1605
{ 
#line 1606
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1608
} 
#line 1610
result out(_Statype &_State, const _Elem *
#line 1611
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1612
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1613
{ 
#line 1614
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1616
} 
#line 1618
result unshift(_Statype &_State, _Byte *
#line 1619
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1620
{ 
#line 1621
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1623
} 
#line 1625
int length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1626
_Last1, size_t _Count) const 
#line 1627
{ 
#line 1628
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1629
} 
#line 1631
static locale::id id; 
#line 1633
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1635
{ 
#line 1636
{ _Locinfo _Lobj; 
#line 1637
this->_Init(_Lobj); 
#line 1638
} 
#line 1639
} 
#line 1641
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1643
{ 
#line 1644
this->_Init(_Lobj); 
#line 1645
} 
#line 1647
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1648
_Ploc = 0) 
#line 1649
{ 
#line 1650
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 1651
(*_Ppf) = (new std::codecvt< __wchar_t, char, int> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1653
return 2; 
#line 1654
} 
#line 1657
protected: virtual ~codecvt() throw() 
#line 1658
{ 
#line 1659
} 
#line 1661
void _Init(const _Locinfo &_Lobj) 
#line 1662
{ 
#line 1663
(_Cvt) = _Lobj._Getcvt(); 
#line 1664
} 
#line 1666
virtual result do_in(_Statype &_State, const _Byte *
#line 1667
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1668
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1669
{ 
#line 1670
; 
#line 1671
; 
#line 1672
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1673
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1674
int _Bytes; 
#line 1676
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1677
switch (_Bytes = _Mbrtowc(_Mid2, _Mid1, _Last1 - _Mid1, &_State, &(_Cvt))) 
#line 1679
{ 
#line 1680
case -2:  
#line 1681
_Mid1 = _Last1; 
#line 1682
return _Ans; 
#line 1684
case -1:  
#line 1685
return error; 
#line 1687
case 0:  
#line 1688
if ((*_Mid2) == ((_Elem)0)) { 
#line 1689
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1692
default:  
#line 1693
if (_Bytes == (-3)) { 
#line 1694
_Bytes = 0; }  
#line 1695
_Mid1 += _Bytes; 
#line 1696
++_Mid2; 
#line 1697
_Ans = (ok); 
#line 1698
}  }  
#line 1699
return _Ans; 
#line 1700
} 
#line 1702
virtual result do_out(_Statype &_State, const _Elem *
#line 1703
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1704
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1705
{ 
#line 1706
; 
#line 1707
; 
#line 1708
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1709
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1710
int _Bytes; 
#line 1712
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1713
if (((int)___mb_cur_max_func()) <= (_Last2 - _Mid2)) { 
#line 1714
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1716
return error; } else { 
#line 1718
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 
#line 1720
{ 
#line 1721
_Byte _Buf[5]; 
#line 1722
_Statype _Stsave = _State; 
#line 1724
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1726
return error; } else { 
#line 1727
if ((_Last2 - _Mid2) < _Bytes) 
#line 1728
{ 
#line 1729
_State = _Stsave; 
#line 1730
return _Ans; 
#line 1731
} else 
#line 1733
{ 
#line 1734
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1735
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
#line 1736
}  }  
#line 1737
}  }  
#line 1738
return _Ans; 
#line 1739
} 
#line 1741
virtual result do_unshift(_Statype &_State, _Byte *
#line 1742
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1743
{ 
#line 1744
; 
#line 1745
_Mid2 = _First2; 
#line 1746
result _Ans = (ok); 
#line 1747
int _Bytes; 
#line 1748
_Byte _Buf[5]; 
#line 1749
_Statype _Stsave = _State; 
#line 1751
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 1752
_Ans = (error); } else { 
#line 1753
if ((_Last2 - _Mid2) < (--_Bytes)) 
#line 1754
{ 
#line 1755
_State = _Stsave; 
#line 1756
_Ans = (partial); 
#line 1757
} else { 
#line 1758
if (0 < _Bytes) 
#line 1759
{ 
#line 1760
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1761
_Mid2 += _Bytes; 
#line 1762
}  }  }  
#line 1763
return _Ans; 
#line 1764
} 
#line 1766
virtual int do_length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1767
_Last1, size_t _Count) const 
#line 1768
{ 
#line 1769
; 
#line 1770
int _Wchars; 
#line 1771
const _Byte *_Mid1; 
#line 1772
_Statype _Mystate = _State; 
#line 1774
for ((_Wchars = 0), (_Mid1 = _First1); (((size_t)_Wchars) < _Count) && (_Mid1 != _Last1);) 
#line 1776
{ 
#line 1777
int _Bytes; 
#line 1778
_Elem _Ch; 
#line 1780
switch (_Bytes = _Mbrtowc(&_Ch, _Mid1, _Last1 - _Mid1, &_Mystate, &(_Cvt))) 
#line 1782
{ 
#line 1783
case -2:  
#line 1784
return _Wchars; 
#line 1786
case -1:  
#line 1787
return _Wchars; 
#line 1789
case 0:  
#line 1790
if (_Ch == ((_Elem)0)) { 
#line 1791
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1794
default:  
#line 1795
if (_Bytes == (-3)) { 
#line 1796
_Bytes = 0; }  
#line 1797
_Mid1 += _Bytes; 
#line 1798
++_Wchars; 
#line 1799
}  
#line 1800
}  
#line 1801
return _Wchars; 
#line 1802
} 
#line 1804
virtual bool do_always_noconv() const throw() 
#line 1805
{ 
#line 1806
return false; 
#line 1807
} 
#line 1809
virtual int do_max_length() const throw() 
#line 1810
{ 
#line 1811
return 5; 
#line 1812
} 
#line 1814
virtual int do_encoding() const throw() 
#line 1815
{ 
#line 1816
return 0; 
#line 1817
} 
#line 1820
private: _Locinfo::_Cvtvec _Cvt; 
#line 1821
}; 
#line 1826
template<> class __declspec(dllimport) codecvt< unsigned short, char, int>  : public codecvt_base { 
#line 1830
public: typedef unsigned short _Elem; 
#line 1831
typedef char _Byte; 
#line 1832
typedef _Mbstatet _Statype; 
#line 1833
typedef _Elem intern_type; 
#line 1834
typedef _Byte extern_type; 
#line 1835
typedef _Statype state_type; 
#line 1837
result in(_Statype &_State, const _Byte *
#line 1838
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1839
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1840
{ 
#line 1841
return this->do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1843
} 
#line 1845
result out(_Statype &_State, const _Elem *
#line 1846
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1847
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1848
{ 
#line 1849
return this->do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2); 
#line 1851
} 
#line 1853
result unshift(_Statype &_State, _Byte *
#line 1854
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1855
{ 
#line 1856
return this->do_unshift(_State, _First2, _Last2, _Mid2); 
#line 1858
} 
#line 1860
int length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 1861
_Last1, size_t _Count) const 
#line 1862
{ 
#line 1863
return this->do_length(_State, _First1, _Last1, _Count); 
#line 1864
} 
#line 1866
static locale::id id; 
#line 1868
explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1870
{ 
#line 1871
{ _Locinfo _Lobj; 
#line 1872
this->_Init(_Lobj); 
#line 1873
} 
#line 1874
} 
#line 1876
codecvt(const _Locinfo &_Lobj, size_t _Refs = 0) : codecvt_base(_Refs) 
#line 1878
{ 
#line 1879
this->_Init(_Lobj); 
#line 1880
} 
#line 1882
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 1883
_Ploc = 0) 
#line 1884
{ 
#line 1885
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 1886
(*_Ppf) = (new std::codecvt< unsigned short, char, int> (((_Locinfo)(_Ploc->c_str())))); }  
#line 1888
return 2; 
#line 1889
} 
#line 1892
protected: virtual ~codecvt() throw() 
#line 1893
{ 
#line 1894
} 
#line 1896
void _Init(const _Locinfo &_Lobj) 
#line 1897
{ 
#line 1898
(_Cvt) = _Lobj._Getcvt(); 
#line 1899
} 
#line 1901
virtual result do_in(_Statype &_State, const _Byte *
#line 1902
_First1, const _Byte *_Last1, const _Byte *&_Mid1, _Elem *
#line 1903
_First2, _Elem *_Last2, _Elem *&_Mid2) const 
#line 1904
{ 
#line 1905
; 
#line 1906
; 
#line 1907
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1908
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1909
int _Bytes; 
#line 1911
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1912
switch (_Bytes = _Mbrtowc((__wchar_t *)_Mid2, _Mid1, _Last1 - _Mid1, &_State, &(_Cvt))) 
#line 1914
{ 
#line 1915
case -2:  
#line 1916
_Mid1 = _Last1; 
#line 1917
return _Ans; 
#line 1919
case -1:  
#line 1920
return error; 
#line 1922
case 0:  
#line 1923
if ((*_Mid2) == ((_Elem)0)) { 
#line 1924
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 1927
default:  
#line 1928
if (_Bytes == (-3)) { 
#line 1929
_Bytes = 0; }  
#line 1930
_Mid1 += _Bytes; 
#line 1931
++_Mid2; 
#line 1932
_Ans = (ok); 
#line 1933
}  }  
#line 1934
return _Ans; 
#line 1935
} 
#line 1937
virtual result do_out(_Statype &_State, const _Elem *
#line 1938
_First1, const _Elem *_Last1, const _Elem *&_Mid1, _Byte *
#line 1939
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1940
{ 
#line 1941
; 
#line 1942
; 
#line 1943
(_Mid1 = _First1), (_Mid2 = _First2); 
#line 1944
result _Ans = (_Mid1 == _Last1) ? ok : partial; 
#line 1945
int _Bytes; 
#line 1947
while ((_Mid1 != _Last1) && (_Mid2 != _Last2)) { 
#line 1948
if (((int)___mb_cur_max_func()) <= (_Last2 - _Mid2)) { 
#line 1949
if ((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1951
return error; } else { 
#line 1953
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); }  } else 
#line 1955
{ 
#line 1956
_Byte _Buf[5]; 
#line 1957
_Statype _Stsave = _State; 
#line 1959
if ((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &(_Cvt))) < 0) { 
#line 1961
return error; } else { 
#line 1962
if ((_Last2 - _Mid2) < _Bytes) 
#line 1963
{ 
#line 1964
_State = _Stsave; 
#line 1965
return _Ans; 
#line 1966
} else 
#line 1968
{ 
#line 1969
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1970
((++_Mid1), (_Mid2 += _Bytes)), (_Ans = (ok)); 
#line 1971
}  }  
#line 1972
}  }  
#line 1973
return _Ans; 
#line 1974
} 
#line 1976
virtual result do_unshift(_Statype &_State, _Byte *
#line 1977
_First2, _Byte *_Last2, _Byte *&_Mid2) const 
#line 1978
{ 
#line 1979
; 
#line 1980
_Mid2 = _First2; 
#line 1981
result _Ans = (ok); 
#line 1982
int _Bytes; 
#line 1983
_Byte _Buf[5]; 
#line 1984
_Statype _Stsave = _State; 
#line 1986
if ((_Bytes = _Wcrtomb(_Buf, L'\x0', &_State, &(_Cvt))) <= 0) { 
#line 1987
_Ans = (error); } else { 
#line 1988
if ((_Last2 - _Mid2) < (--_Bytes)) 
#line 1989
{ 
#line 1990
_State = _Stsave; 
#line 1991
_Ans = (partial); 
#line 1992
} else { 
#line 1993
if (0 < _Bytes) 
#line 1994
{ 
#line 1995
::memcpy(_Mid2, _Buf, _Bytes); 
#line 1996
_Mid2 += _Bytes; 
#line 1997
}  }  }  
#line 1998
return _Ans; 
#line 1999
} 
#line 2001
virtual int do_length(_Statype &_State, const _Byte *_First1, const _Byte *
#line 2002
_Last1, size_t _Count) const 
#line 2003
{ 
#line 2004
; 
#line 2005
int _Wchars; 
#line 2006
const _Byte *_Mid1; 
#line 2007
_Statype _Mystate = _State; 
#line 2009
for ((_Wchars = 0), (_Mid1 = _First1); (((size_t)_Wchars) < _Count) && (_Mid1 != _Last1);) 
#line 2011
{ 
#line 2012
int _Bytes; 
#line 2013
_Elem _Ch; 
#line 2015
switch (_Bytes = _Mbrtowc((__wchar_t *)(&_Ch), _Mid1, _Last1 - _Mid1, &_Mystate, &(_Cvt))) 
#line 2017
{ 
#line 2018
case -2:  
#line 2019
return _Wchars; 
#line 2021
case -1:  
#line 2022
return _Wchars; 
#line 2024
case 0:  
#line 2025
if (_Ch == ((_Elem)0)) { 
#line 2026
_Bytes = (((int)::strlen(_Mid1)) + 1); }  
#line 2029
default:  
#line 2030
if (_Bytes == (-3)) { 
#line 2031
_Bytes = 0; }  
#line 2032
_Mid1 += _Bytes; 
#line 2033
++_Wchars; 
#line 2034
}  
#line 2035
}  
#line 2036
return _Wchars; 
#line 2037
} 
#line 2039
virtual bool do_always_noconv() const throw() 
#line 2040
{ 
#line 2041
return false; 
#line 2042
} 
#line 2044
virtual int do_max_length() const throw() 
#line 2045
{ 
#line 2046
return 5; 
#line 2047
} 
#line 2049
virtual int do_encoding() const throw() 
#line 2050
{ 
#line 2051
return 0; 
#line 2052
} 
#line 2055
private: _Locinfo::_Cvtvec _Cvt; 
#line 2056
}; 
#line 2060 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template < class _Elem,
 class _Byte,
 class _Statype >
 class codecvt_byname
  : public codecvt < _Elem, _Byte, _Statype >
 {
public :
 explicit codecvt_byname ( const char * _Locname, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Locname ), _Refs )
  {
  }

 explicit codecvt_byname ( const string & _Str, size_t _Refs = 0 )
  : codecvt < _Elem, _Byte, _Statype > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }

protected :
 virtual ~ codecvt_byname ( ) throw ( )
  {
  }
 };
#line 2084
#pragma warning(push)
#pragma warning(disable: 4275)
#line 2087
struct __declspec(dllimport) ctype_base : public locale::facet { 
#line 2091
enum { 
#line 2092
alnum = 263, alpha = 259, 
#line 2093
cntrl = 32, digit = 4, graph = 279, 
#line 2094
lower = 2, print = 471, 
#line 2095
punct = 16, space = 72, upper = 1, 
#line 2096
xdigit = 128, blank = 72}; 
#line 2097
typedef short mask; 
#line 2099
ctype_base(size_t _Refs = 0) : locale::facet(_Refs) 
#line 2101
{ 
#line 2102
} 
#line 2104
virtual ~ctype_base() throw() 
#line 2105
{ 
#line 2106
} 
#line 2107
}; 
#line 2109
#pragma warning(pop)
#line 2112
template < class _Elem >
 class ctype
  : public ctype_base
 {
public :
 typedef _Elem char_type;

 bool is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( do_is ( _Maskval, _Ch ) );
  }

 const _Elem * is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  return ( do_is ( _First, _Last, _Dest ) );
  }

 const _Elem * scan_is ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_is ( _Maskval, _First, _Last ) );
  }

 const _Elem * scan_not ( mask _Maskval, const _Elem * _First,
  const _Elem * _Last ) const
  {
  return ( do_scan_not ( _Maskval, _First, _Last ) );
  }

 _Elem tolower ( _Elem _Ch ) const
  {
  return ( do_tolower ( _Ch ) );
  }

 const _Elem * tolower ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_tolower ( _First, _Last ) );
  }

 _Elem toupper ( _Elem _Ch ) const
  {
  return ( do_toupper ( _Ch ) );
  }

 const _Elem * toupper ( _Elem * _First, const _Elem * _Last ) const
  {
  return ( do_toupper ( _First, _Last ) );
  }

 _Elem widen ( char _Byte ) const
  {
  return ( do_widen ( _Byte ) );
  }

 const char * widen ( const char * _First, const char * _Last,
  _Elem * _Dest ) const
  {
  return ( do_widen ( _First, _Last, _Dest ) );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  return ( do_narrow ( _Ch, _Dflt ) );
  }

 const _Elem * narrow ( const _Elem * _First, const _Elem * _Last,
  char _Dflt, char * _Dest ) const
  {
  return ( do_narrow ( _First, _Last, _Dflt, _Dest ) );
  }

  static locale :: id id;

 explicit ctype ( size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  ctype ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : ctype_base ( _Refs )
  {
  _Init ( _Lobj );
  }

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new ctype < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 2 );
  }

protected :
 virtual ~ ctype ( ) throw ( )
  {
  if ( _Ctype . _Delfl )
   free ( ( void * ) _Ctype . _Table );

  free ( ( void * ) _Ctype . _LocaleName );
  }

 void _Init ( const _Locinfo & _Lobj )
  {
  _Ctype = _Lobj . _Getctype ( );
  _Cvt = _Lobj . _Getcvt ( );
  }

 virtual bool do_is ( mask _Maskval, _Elem _Ch ) const
  {
  return ( ( _Ctype . _Table [ ( unsigned char ) narrow ( _Ch ) ]
   & _Maskval ) != 0 );
  }

 virtual const _Elem * do_is ( const _Elem * _First, const _Elem * _Last,
  mask * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Ctype . _Table [ ( unsigned char ) narrow ( * _First ) ];
  return ( _First );
  }

 virtual const _Elem * do_scan_is ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last && ! is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

 virtual const _Elem * do_scan_not ( mask _Maskval,
  const _Elem * _First, const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last && is ( _Maskval, * _First ); ++ _First )
   ;
  return ( _First );
  }

 virtual _Elem do_tolower ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_tolower ( _Elem * _First,
  const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Tolower ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_toupper ( _Elem _Ch ) const
  {
  unsigned char _Byte = ( unsigned char ) narrow ( _Ch, '\000' );
  if ( _Byte == '\000' )
   return ( _Ch );
  else
   return ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
  }

 virtual const _Elem * do_toupper ( _Elem * _First,
  const _Elem * _Last ) const
  {
  ;
  for (; _First != _Last; ++ _First )
   {
   unsigned char _Byte = ( unsigned char ) narrow ( * _First, '\000' );
   if ( _Byte != '\000' )
    * _First = ( widen ( ( char ) _Toupper ( _Byte, & _Ctype ) ) );
   }
  return ( ( const _Elem * ) _First );
  }

 virtual _Elem do_widen ( char _Byte ) const
  {
  return ( _Maklocchr ( _Byte, ( _Elem * ) 0, _Cvt ) );
  }

 virtual const char * do_widen ( const char * _First,
  const char * _Last, _Elem * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Maklocchr ( * _First, ( _Elem * ) 0, _Cvt );
  return ( _First );
  }

 char _Donarrow ( _Elem _Ch, char _Dflt ) const
  {
  char _Byte;
  if ( _Ch == ( _Elem ) 0 )
   return ( '\000' );
  else if ( ( _Byte = _Maklocbyte ( ( _Elem ) _Ch, _Cvt ) ) == '\000' )
   return ( _Dflt );
  else
   return ( _Byte );
  }

 virtual char do_narrow ( _Elem _Ch, char _Dflt ) const
  {
  return ( _Donarrow ( _Ch, _Dflt ) );
  }

 virtual const _Elem * do_narrow ( const _Elem * _First,
  const _Elem * _Last, char _Dflt, char * _Dest ) const
  {
  ;
  ;
  for (; _First != _Last; ++ _First, ++ _Dest )
   * _Dest = _Donarrow ( * _First, _Dflt );
  return ( _First );
  }

private :
 _Locinfo :: _Ctypevec _Ctype;
 _Locinfo :: _Cvtvec _Cvt;
 };
#line 2349
template< class _Elem> locale::id 
#line 2350
ctype< _Elem> ::id; 
#line 2354
template<> class __declspec(dllimport) ctype< char>  : public ctype_base { 
#line 2357
typedef std::ctype< char>  _Myt; 
#line 2360
public: typedef char _Elem; 
#line 2361
typedef _Elem char_type; 
#line 2363
bool is(mask _Maskval, _Elem _Ch) const 
#line 2364
{ 
#line 2365
return ((((_Ctype)._Table)[(unsigned char)_Ch]) & _Maskval) != 0; 
#line 2366
} 
#line 2368
const _Elem *is(const _Elem *_First, const _Elem *
#line 2369
_Last, mask *_Dest) const 
#line 2370
{ 
#line 2371
; 
#line 2372
; 
#line 2373
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2374
(*_Dest) = (((_Ctype)._Table)[(unsigned char)(*_First)]); }  
#line 2375
return _First; 
#line 2376
} 
#line 2378
const _Elem *scan_is(mask _Maskval, const _Elem *
#line 2379
_First, const _Elem *_Last) const 
#line 2380
{ 
#line 2381
; 
#line 2382
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
#line 2383
; }  
#line 2384
return _First; 
#line 2385
} 
#line 2387
const _Elem *scan_not(mask _Maskval, const _Elem *
#line 2388
_First, const _Elem *_Last) const 
#line 2389
{ 
#line 2390
; 
#line 2391
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
#line 2392
; }  
#line 2393
return _First; 
#line 2394
} 
#line 2396
_Elem tolower(_Elem _Ch) const 
#line 2397
{ 
#line 2398
return this->do_tolower(_Ch); 
#line 2399
} 
#line 2401
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2402
{ 
#line 2403
return this->do_tolower(_First, _Last); 
#line 2404
} 
#line 2406
_Elem toupper(_Elem _Ch) const 
#line 2407
{ 
#line 2408
return this->do_toupper(_Ch); 
#line 2409
} 
#line 2411
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2412
{ 
#line 2413
return this->do_toupper(_First, _Last); 
#line 2414
} 
#line 2416
_Elem widen(char _Byte) const 
#line 2417
{ 
#line 2418
return this->do_widen(_Byte); 
#line 2419
} 
#line 2421
const _Elem *widen(const char *_First, const char *_Last, _Elem *
#line 2422
_Dest) const 
#line 2423
{ 
#line 2424
return this->do_widen(_First, _Last, _Dest); 
#line 2425
} 
#line 2427
_Elem narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2428
{ 
#line 2429
return this->do_narrow(_Ch, _Dflt); 
#line 2430
} 
#line 2432
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2433
_Dflt, char *_Dest) const 
#line 2434
{ 
#line 2435
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2436
} 
#line 2438
static locale::id id; 
#line 2440
explicit ctype(const mask *_Table = 0, bool 
#line 2441
_Deletetable = false, size_t 
#line 2442
_Refs = 0) : ctype_base(_Refs) 
#line 2444
{ 
#line 2445
{ _Locinfo _Lobj; 
#line 2446
this->_Init(_Lobj); 
#line 2447
} 
#line 2449
this->_Tidy(); 
#line 2450
if (_Table != (0)) 
#line 2451
{ 
#line 2452
((_Ctype)._Table) = _Table; 
#line 2453
((_Ctype)._Delfl) = (_Deletetable ? -1 : 0); 
#line 2454
} else 
#line 2456
{ 
#line 2457
((_Ctype)._Table) = classic_table(); 
#line 2458
((_Ctype)._Delfl) = 0; 
#line 2459
}  
#line 2460
} 
#line 2462
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2464
{ 
#line 2465
this->_Init(_Lobj); 
#line 2466
} 
#line 2468
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2469
_Ploc = 0) 
#line 2470
{ 
#line 2471
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 2472
(*_Ppf) = (new std::ctype< char> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2474
return 2; 
#line 2475
} 
#line 2477
const mask *table() const throw() 
#line 2478
{ 
#line 2479
return (_Ctype)._Table; 
#line 2480
} 
#line 2482
static const mask *__cdecl classic_table() throw() 
#line 2483
{ 
#line 2484
const _Myt &_Ctype_fac = use_facet< std::ctype< char> > (locale::classic()); 
#line 2485
return _Ctype_fac.table(); 
#line 2486
} 
#line 2488
static const size_t table_size = (1 << 8); 
#line 2492
protected: virtual ~ctype() throw() 
#line 2493
{ 
#line 2494
this->_Tidy(); 
#line 2495
} 
#line 2497
void _Init(const _Locinfo &_Lobj) 
#line 2498
{ 
#line 2499
(_Ctype) = _Lobj._Getctype(); 
#line 2500
} 
#line 2502
void _Tidy() 
#line 2503
{ 
#line 2504
if (0 < ((_Ctype)._Delfl)) { 
#line 2505
free((void *)((_Ctype)._Table)); } else { 
#line 2506
if (((_Ctype)._Delfl) < 0) { 
#line 2507
delete [] ((void *)((_Ctype)._Table)); }  }  
#line 2509
free((void *)((_Ctype)._LocaleName)); 
#line 2510
} 
#line 2512
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2513
{ 
#line 2514
return (_Elem)_Tolower((unsigned char)_Ch, &(_Ctype)); 
#line 2515
} 
#line 2517
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2518
_Last) const 
#line 2519
{ 
#line 2520
; 
#line 2521
for (; _First != _Last; ++_First) { 
#line 2522
(*_First) = ((_Elem)_Tolower((unsigned char)(*_First), &(_Ctype))); }  
#line 2523
return (const _Elem *)_First; 
#line 2524
} 
#line 2526
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2527
{ 
#line 2528
return (_Elem)_Toupper((unsigned char)_Ch, &(_Ctype)); 
#line 2529
} 
#line 2531
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2532
_Last) const 
#line 2533
{ 
#line 2534
; 
#line 2535
for (; _First != _Last; ++_First) { 
#line 2536
(*_First) = ((_Elem)_Toupper((unsigned char)(*_First), &(_Ctype))); }  
#line 2537
return (const _Elem *)_First; 
#line 2538
} 
#line 2540
virtual _Elem do_widen(char _Byte) const 
#line 2541
{ 
#line 2542
return _Byte; 
#line 2543
} 
#line 2545
virtual const _Elem *do_widen(const char *_First, const char *
#line 2546
_Last, _Elem *_Dest) const 
#line 2547
{ 
#line 2548
; 
#line 2549
; 
#line 2550
::memcpy(_Dest, _First, _Last - _First); 
#line 2551
return _Last; 
#line 2552
} 
#line 2554
virtual _Elem do_narrow(_Elem _Ch, char) const 
#line 2555
{ 
#line 2556
return _Ch; 
#line 2557
} 
#line 2559
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2560
_Last, char, char *_Dest) const 
#line 2561
{ 
#line 2562
; 
#line 2563
; 
#line 2564
::memcpy(_Dest, _First, _Last - _First); 
#line 2565
return _Last; 
#line 2566
} 
#line 2569
private: _Locinfo::_Ctypevec _Ctype; 
#line 2570
}; 
#line 2574
template<> class __declspec(dllimport) ctype< __wchar_t>  : public ctype_base { 
#line 2577
typedef std::ctype< __wchar_t>  _Myt; 
#line 2580
public: typedef __wchar_t _Elem; 
#line 2581
typedef _Elem char_type; 
#line 2583
bool is(mask _Maskval, _Elem _Ch) const 
#line 2584
{ 
#line 2585
return this->do_is(_Maskval, _Ch); 
#line 2586
} 
#line 2588
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2589
_Dest) const 
#line 2590
{ 
#line 2591
return this->do_is(_First, _Last, _Dest); 
#line 2592
} 
#line 2594
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2595
_Last) const 
#line 2596
{ 
#line 2597
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2598
} 
#line 2600
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2601
_Last) const 
#line 2602
{ 
#line 2603
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2604
} 
#line 2606
_Elem tolower(_Elem _Ch) const 
#line 2607
{ 
#line 2608
return this->do_tolower(_Ch); 
#line 2609
} 
#line 2611
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2612
{ 
#line 2613
return this->do_tolower(_First, _Last); 
#line 2614
} 
#line 2616
_Elem toupper(_Elem _Ch) const 
#line 2617
{ 
#line 2618
return this->do_toupper(_Ch); 
#line 2619
} 
#line 2621
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2622
{ 
#line 2623
return this->do_toupper(_First, _Last); 
#line 2624
} 
#line 2626
_Elem widen(char _Byte) const 
#line 2627
{ 
#line 2628
return this->do_widen(_Byte); 
#line 2629
} 
#line 2631
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2632
_Dest) const 
#line 2633
{ 
#line 2634
return this->do_widen(_First, _Last, _Dest); 
#line 2635
} 
#line 2637
char narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2638
{ 
#line 2639
return this->do_narrow(_Ch, _Dflt); 
#line 2640
} 
#line 2642
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2643
_Dflt, char *_Dest) const 
#line 2644
{ 
#line 2645
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2646
} 
#line 2648
static locale::id id; 
#line 2650
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 
#line 2652
{ 
#line 2653
{ _Locinfo _Lobj; 
#line 2654
this->_Init(_Lobj); 
#line 2655
} 
#line 2656
} 
#line 2658
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2660
{ 
#line 2661
this->_Init(_Lobj); 
#line 2662
} 
#line 2664
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2665
_Ploc = 0) 
#line 2666
{ 
#line 2667
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 2668
(*_Ppf) = (new std::ctype< __wchar_t> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2670
return 2; 
#line 2671
} 
#line 2674
protected: virtual ~ctype() throw() 
#line 2675
{ 
#line 2676
if ((_Ctype)._Delfl) { 
#line 2677
free((void *)((_Ctype)._Table)); }  
#line 2679
free((void *)((_Ctype)._LocaleName)); 
#line 2680
} 
#line 2682
void _Init(const _Locinfo &_Lobj) 
#line 2683
{ 
#line 2684
(_Ctype) = _Lobj._Getctype(); 
#line 2685
(_Cvt) = _Lobj._Getcvt(); 
#line 2686
} 
#line 2688
virtual bool do_is(mask _Maskval, _Elem _Ch) const 
#line 2689
{ 
#line 2690
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2691
} 
#line 2693
virtual const _Elem *do_is(const _Elem *_First, const _Elem *
#line 2694
_Last, mask *_Dest) const 
#line 2695
{ 
#line 2696
; 
#line 2697
; 
#line 2698
return ::_Getwctypes(_First, _Last, _Dest, &(_Ctype)); 
#line 2699
} 
#line 2701
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
#line 2702
_First, const _Elem *_Last) const 
#line 2703
{ 
#line 2704
; 
#line 2705
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
#line 2706
; }  
#line 2707
return _First; 
#line 2708
} 
#line 2710
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
#line 2711
_First, const _Elem *_Last) const 
#line 2712
{ 
#line 2713
; 
#line 2714
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
#line 2715
; }  
#line 2716
return _First; 
#line 2717
} 
#line 2719
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2720
{ 
#line 2721
return _Towlower(_Ch, &(_Ctype)); 
#line 2722
} 
#line 2724
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2725
_Last) const 
#line 2726
{ 
#line 2727
; 
#line 2728
for (; _First != _Last; ++_First) { 
#line 2729
(*_First) = _Towlower(*_First, &(_Ctype)); }  
#line 2730
return (const _Elem *)_First; 
#line 2731
} 
#line 2733
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2734
{ 
#line 2735
return _Towupper(_Ch, &(_Ctype)); 
#line 2736
} 
#line 2738
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2739
_Last) const 
#line 2740
{ 
#line 2741
; 
#line 2742
for (; _First != _Last; ++_First) { 
#line 2743
(*_First) = _Towupper(*_First, &(_Ctype)); }  
#line 2744
return (const _Elem *)_First; 
#line 2745
} 
#line 2747
_Elem _Dowiden(char _Byte) const 
#line 2748
{ 
#line 2749
mbstate_t _Mbst = 0; 
#line 2750
__wchar_t _Wc; 
#line 2751
return (_Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? (__wchar_t)((wint_t)65535) : _Wc; 
#line 2753
} 
#line 2755
virtual _Elem do_widen(char _Byte) const 
#line 2756
{ 
#line 2757
return this->_Dowiden(_Byte); 
#line 2758
} 
#line 2760
virtual const char *do_widen(const char *_First, const char *
#line 2761
_Last, _Elem *_Dest) const 
#line 2762
{ 
#line 2763
; 
#line 2764
; 
#line 2765
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2766
(*_Dest) = this->_Dowiden(*_First); }  
#line 2767
return _First; 
#line 2768
} 
#line 2770
char _Donarrow(_Elem _Ch, char _Dflt) const 
#line 2771
{ 
#line 2772
char _Buf[5]; 
#line 2773
mbstate_t _Mbst = 0; 
#line 2774
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 
#line 2776
} 
#line 2778
virtual char do_narrow(_Elem _Ch, char _Dflt) const 
#line 2779
{ 
#line 2780
return this->_Donarrow(_Ch, _Dflt); 
#line 2781
} 
#line 2783
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 2784
_Last, char _Dflt, char *_Dest) const 
#line 2785
{ 
#line 2786
; 
#line 2787
; 
#line 2788
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2789
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
#line 2790
return _First; 
#line 2791
} 
#line 2794
private: _Locinfo::_Ctypevec _Ctype; 
#line 2795
_Locinfo::_Cvtvec _Cvt; 
#line 2796
}; 
#line 2801
template<> class __declspec(dllimport) ctype< unsigned short>  : public ctype_base { 
#line 2804
typedef std::ctype< unsigned short>  _Myt; 
#line 2807
public: typedef unsigned short _Elem; 
#line 2808
typedef _Elem char_type; 
#line 2810
bool is(mask _Maskval, _Elem _Ch) const 
#line 2811
{ 
#line 2812
return this->do_is(_Maskval, _Ch); 
#line 2813
} 
#line 2815
const _Elem *is(const _Elem *_First, const _Elem *_Last, mask *
#line 2816
_Dest) const 
#line 2817
{ 
#line 2818
return this->do_is(_First, _Last, _Dest); 
#line 2819
} 
#line 2821
const _Elem *scan_is(mask _Maskval, const _Elem *_First, const _Elem *
#line 2822
_Last) const 
#line 2823
{ 
#line 2824
return this->do_scan_is(_Maskval, _First, _Last); 
#line 2825
} 
#line 2827
const _Elem *scan_not(mask _Maskval, const _Elem *_First, const _Elem *
#line 2828
_Last) const 
#line 2829
{ 
#line 2830
return this->do_scan_not(_Maskval, _First, _Last); 
#line 2831
} 
#line 2833
_Elem tolower(_Elem _Ch) const 
#line 2834
{ 
#line 2835
return this->do_tolower(_Ch); 
#line 2836
} 
#line 2838
const _Elem *tolower(_Elem *_First, const _Elem *_Last) const 
#line 2839
{ 
#line 2840
return this->do_tolower(_First, _Last); 
#line 2841
} 
#line 2843
_Elem toupper(_Elem _Ch) const 
#line 2844
{ 
#line 2845
return this->do_toupper(_Ch); 
#line 2846
} 
#line 2848
const _Elem *toupper(_Elem *_First, const _Elem *_Last) const 
#line 2849
{ 
#line 2850
return this->do_toupper(_First, _Last); 
#line 2851
} 
#line 2853
_Elem widen(char _Byte) const 
#line 2854
{ 
#line 2855
return this->do_widen(_Byte); 
#line 2856
} 
#line 2858
const char *widen(const char *_First, const char *_Last, _Elem *
#line 2859
_Dest) const 
#line 2860
{ 
#line 2861
return this->do_widen(_First, _Last, _Dest); 
#line 2862
} 
#line 2864
char narrow(_Elem _Ch, char _Dflt = '\000') const 
#line 2865
{ 
#line 2866
return this->do_narrow(_Ch, _Dflt); 
#line 2867
} 
#line 2869
const _Elem *narrow(const _Elem *_First, const _Elem *_Last, char 
#line 2870
_Dflt, char *_Dest) const 
#line 2871
{ 
#line 2872
return this->do_narrow(_First, _Last, _Dflt, _Dest); 
#line 2873
} 
#line 2875
static locale::id id; 
#line 2877
explicit ctype(size_t _Refs = 0) : ctype_base(_Refs) 
#line 2879
{ 
#line 2880
{ _Locinfo _Lobj; 
#line 2881
this->_Init(_Lobj); 
#line 2882
} 
#line 2883
} 
#line 2885
ctype(const _Locinfo &_Lobj, size_t _Refs = 0) : ctype_base(_Refs) 
#line 2887
{ 
#line 2888
this->_Init(_Lobj); 
#line 2889
} 
#line 2891
static size_t __cdecl _Getcat(const locale::facet **_Ppf = 0, const locale *
#line 2892
_Ploc = 0) 
#line 2893
{ 
#line 2894
if ((_Ppf != (0)) && ((*_Ppf) == (0))) { 
#line 2895
(*_Ppf) = (new std::ctype< unsigned short> (((_Locinfo)(_Ploc->c_str())))); }  
#line 2897
return 2; 
#line 2898
} 
#line 2901
protected: virtual ~ctype() throw() 
#line 2902
{ 
#line 2903
if ((_Ctype)._Delfl) { 
#line 2904
free((void *)((_Ctype)._Table)); }  
#line 2906
free((void *)((_Ctype)._LocaleName)); 
#line 2907
} 
#line 2909
void _Init(const _Locinfo &_Lobj) 
#line 2910
{ 
#line 2911
(_Ctype) = _Lobj._Getctype(); 
#line 2912
(_Cvt) = _Lobj._Getcvt(); 
#line 2913
} 
#line 2915
virtual bool do_is(mask _Maskval, _Elem _Ch) const 
#line 2916
{ 
#line 2917
return ((::_Getwctype(_Ch, &(_Ctype))) & _Maskval) != 0; 
#line 2918
} 
#line 2920
virtual const _Elem *do_is(const _Elem *_First, const _Elem *
#line 2921
_Last, mask *_Dest) const 
#line 2922
{ 
#line 2923
; 
#line 2924
; 
#line 2925
return (const _Elem *)::_Getwctypes((const __wchar_t *)_First, (const __wchar_t *)_Last, _Dest, &(_Ctype)); 
#line 2927
} 
#line 2929
virtual const _Elem *do_scan_is(mask _Maskval, const _Elem *
#line 2930
_First, const _Elem *_Last) const 
#line 2931
{ 
#line 2932
; 
#line 2933
for (; (_First != _Last) && (!this->is(_Maskval, *_First)); ++_First) { 
#line 2934
; }  
#line 2935
return _First; 
#line 2936
} 
#line 2938
virtual const _Elem *do_scan_not(mask _Maskval, const _Elem *
#line 2939
_First, const _Elem *_Last) const 
#line 2940
{ 
#line 2941
; 
#line 2942
for (; (_First != _Last) && this->is(_Maskval, *_First); ++_First) { 
#line 2943
; }  
#line 2944
return _First; 
#line 2945
} 
#line 2947
virtual _Elem do_tolower(_Elem _Ch) const 
#line 2948
{ 
#line 2949
return _Towlower(_Ch, &(_Ctype)); 
#line 2950
} 
#line 2952
virtual const _Elem *do_tolower(_Elem *_First, const _Elem *
#line 2953
_Last) const 
#line 2954
{ 
#line 2955
; 
#line 2956
for (; _First != _Last; ++_First) { 
#line 2957
(*_First) = (_Towlower(*_First, &(_Ctype))); }  
#line 2958
return (const _Elem *)_First; 
#line 2959
} 
#line 2961
virtual _Elem do_toupper(_Elem _Ch) const 
#line 2962
{ 
#line 2963
return _Towupper(_Ch, &(_Ctype)); 
#line 2964
} 
#line 2966
virtual const _Elem *do_toupper(_Elem *_First, const _Elem *
#line 2967
_Last) const 
#line 2968
{ 
#line 2969
; 
#line 2970
for (; _First != _Last; ++_First) { 
#line 2971
(*_First) = (_Towupper(*_First, &(_Ctype))); }  
#line 2972
return (const _Elem *)_First; 
#line 2973
} 
#line 2975
_Elem _Dowiden(char _Byte) const 
#line 2976
{ 
#line 2977
mbstate_t _Mbst = 0; 
#line 2978
unsigned short _Wc; 
#line 2979
return (_Mbrtowc((__wchar_t *)(&_Wc), &_Byte, 1, &_Mbst, &(_Cvt)) < 0) ? (unsigned short)((wint_t)65535) : _Wc; 
#line 2981
} 
#line 2983
virtual _Elem do_widen(char _Byte) const 
#line 2984
{ 
#line 2985
return this->_Dowiden(_Byte); 
#line 2986
} 
#line 2988
virtual const char *do_widen(const char *_First, const char *
#line 2989
_Last, _Elem *_Dest) const 
#line 2990
{ 
#line 2991
; 
#line 2992
; 
#line 2993
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 2994
(*_Dest) = this->_Dowiden(*_First); }  
#line 2995
return _First; 
#line 2996
} 
#line 2998
char _Donarrow(_Elem _Ch, char _Dflt) const 
#line 2999
{ 
#line 3000
char _Buf[5]; 
#line 3001
mbstate_t _Mbst = 0; 
#line 3002
return (_Wcrtomb(_Buf, _Ch, &_Mbst, &(_Cvt)) != 1) ? _Dflt : ((_Buf)[0]); 
#line 3004
} 
#line 3006
virtual char do_narrow(_Elem _Ch, char _Dflt) const 
#line 3007
{ 
#line 3008
return this->_Donarrow(_Ch, _Dflt); 
#line 3009
} 
#line 3011
virtual const _Elem *do_narrow(const _Elem *_First, const _Elem *
#line 3012
_Last, char _Dflt, char *_Dest) const 
#line 3013
{ 
#line 3014
; 
#line 3015
; 
#line 3016
for (; _First != _Last; (++_First), (++_Dest)) { 
#line 3017
(*_Dest) = this->_Donarrow(*_First, _Dflt); }  
#line 3018
return _First; 
#line 3019
} 
#line 3022
private: _Locinfo::_Ctypevec _Ctype; 
#line 3023
_Locinfo::_Cvtvec _Cvt; 
#line 3024
}; 
#line 3028 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
template < class _Elem >
 class ctype_byname
 : public ctype < _Elem >
 {
public :
 explicit ctype_byname ( const char * _Locname, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Locname ), _Refs )
  {
  }

 explicit ctype_byname ( const string & _Str, size_t _Refs = 0 )
  : ctype < _Elem > ( _Locinfo ( _Str . c_str ( ) ), _Refs )
  {
  }

protected :
 virtual ~ ctype_byname ( ) throw ( )
  {
  }
 };
#line 3051
template<> class ctype_byname< char>  : public ctype< char>  { 
#line 3055
public: explicit ctype_byname(const char *_Locname, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Locname)), _Refs) 
#line 3057
{ 
#line 3058
} 
#line 3060
explicit ctype_byname(const string &_Str, size_t _Refs = 0) : std::ctype< char> (((_Locinfo)(_Str.c_str())), _Refs) 
#line 3062
{ 
#line 3063
} 
#line 3066
protected: virtual ~ctype_byname() throw() 
#line 3067
{ 
#line 3068
} 
#line 3069
}; 
#line 3074
template class __declspec(dllimport) codecvt< char, char, int> ;
#line 3077 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
}
#line 3079
#pragma warning(pop)
#line 11 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\system_error"
#pragma warning(push,3)
#line 3080 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocale"
#pragma pack ( pop )
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\system_error"
#pragma pack ( push, 8 )
#line 17
namespace std { 
#line 20
enum class errc { 
#line 21
address_family_not_supported = 102, 
#line 22
address_in_use = 100, 
#line 23
address_not_available, 
#line 24
already_connected = 113, 
#line 25
argument_list_too_long = 7, 
#line 26
argument_out_of_domain = 33, 
#line 27
bad_address = 14, 
#line 28
bad_file_descriptor = 9, 
#line 29
bad_message = 104, 
#line 30
broken_pipe = 32, 
#line 31
connection_aborted = 106, 
#line 32
connection_already_in_progress = 103, 
#line 33
connection_refused = 107, 
#line 34
connection_reset, 
#line 35
cross_device_link = 18, 
#line 36
destination_address_required = 109, 
#line 37
device_or_resource_busy = 16, 
#line 38
directory_not_empty = 41, 
#line 39
executable_format_error = 8, 
#line 40
file_exists = 17, 
#line 41
file_too_large = 27, 
#line 42
filename_too_long = 38, 
#line 43
function_not_supported = 40, 
#line 44
host_unreachable = 110, 
#line 45
identifier_removed, 
#line 46
illegal_byte_sequence = 42, 
#line 47
inappropriate_io_control_operation = 25, 
#line 48
interrupted = 4, 
#line 49
invalid_argument = 22, 
#line 50
invalid_seek = 29, 
#line 51
io_error = 5, 
#line 52
is_a_directory = 21, 
#line 53
message_size = 115, 
#line 54
network_down, 
#line 55
network_reset, 
#line 56
network_unreachable, 
#line 57
no_buffer_space, 
#line 58
no_child_process = 10, 
#line 59
no_link = 121, 
#line 60
no_lock_available = 39, 
#line 61
no_message_available = 120, 
#line 62
no_message = 122, 
#line 63
no_protocol_option, 
#line 64
no_space_on_device = 28, 
#line 65
no_stream_resources = 124, 
#line 66
no_such_device_or_address = 6, 
#line 67
no_such_device = 19, 
#line 68
no_such_file_or_directory = 2, 
#line 69
no_such_process, 
#line 70
not_a_directory = 20, 
#line 71
not_a_socket = 128, 
#line 72
not_a_stream = 125, 
#line 73
not_connected, 
#line 74
not_enough_memory = 12, 
#line 75
not_supported = 129, 
#line 76
operation_canceled = 105, 
#line 77
operation_in_progress = 112, 
#line 78
operation_not_permitted = 1, 
#line 79
operation_not_supported = 130, 
#line 80
operation_would_block = 140, 
#line 81
owner_dead = 133, 
#line 82
permission_denied = 13, 
#line 83
protocol_error = 134, 
#line 84
protocol_not_supported, 
#line 85
read_only_file_system = 30, 
#line 86
resource_deadlock_would_occur = 36, 
#line 87
resource_unavailable_try_again = 11, 
#line 88
result_out_of_range = 34, 
#line 89
state_not_recoverable = 127, 
#line 90
stream_timeout = 137, 
#line 91
text_file_busy = 139, 
#line 92
timed_out = 138, 
#line 93
too_many_files_open_in_system = 23, 
#line 94
too_many_files_open, 
#line 95
too_many_links = 31, 
#line 96
too_many_symbolic_link_levels = 114, 
#line 97
value_too_large = 132, 
#line 98
wrong_protocol_type = 136
#line 99
}; 
#line 101
typedef errc generic_errno; 
#line 105
enum class io_errc { 
#line 106
stream = 1
#line 107
}; 
#line 109
typedef io_errc _Io_errc; 
#line 112
template< class _Enum> 
#line 113
struct is_error_code_enum : public false_type { 
#line 116
}; 
#line 119
template<> struct is_error_code_enum< io_errc>  : public true_type { 
#line 122
}; 
#line 125
template< class _Enum> 
#line 126
struct is_error_condition_enum : public false_type { 
#line 129
}; 
#line 132
template<> struct is_error_condition_enum< errc>  : public true_type { 
#line 135
}; 
#line 137
class error_code; 
#line 138
class error_condition; 
#line 139
inline error_code make_error_code(generic_errno) throw(); 
#line 140
inline error_code make_error_code(_Io_errc) throw(); 
#line 141
inline error_condition make_error_condition(generic_errno) throw(); 
#line 142
inline error_condition make_error_condition(_Io_errc) throw(); 
#line 145
class error_category; 
#line 147
inline const error_category &generic_category() throw(); 
#line 148
inline const error_category &iostream_category() throw(); 
#line 149
inline const error_category &system_category() throw(); 
#line 151
class error_category { 
#line 154
public: error_category() 
#line 155
{ 
#line 156
} 
#line 158
virtual ~error_category() throw() 
#line 159
{ 
#line 160
} 
#line 162
virtual const char *name() const throw() = 0; 
#line 164
virtual string message(int _Errval) const = 0; 
#line 167
inline virtual error_condition default_error_condition(int _Errval) const throw(); 
#line 169
inline virtual bool equivalent(int _Errval, const error_condition & _Cond) const throw(); 
#line 172
inline virtual bool equivalent(const error_code & _Code, int _Errval) const throw(); 
#line 175
bool operator==(const error_category &_Right) const throw() 
#line 176
{ 
#line 177
return this == (&_Right); 
#line 178
} 
#line 180
bool operator!=(const error_category &_Right) const throw() 
#line 181
{ 
#line 182
return !((*this) == _Right); 
#line 183
} 
#line 185
bool operator<(const error_category &_Right) const throw() 
#line 186
{ 
#line 187
return this < (&_Right); 
#line 188
} 
#line 190
error_category(const error_category &) = delete;
#line 191
error_category &operator=(const error_category &) = delete;
#line 192
}; 
#line 195
class error_code { 
#line 198
public: typedef error_code _Myt; 
#line 200
error_code() : _Myval(0), _Mycat(&system_category()) 
#line 203
{ 
#line 204
} 
#line 206
error_code(int _Val, const error_category &_Cat) : _Myval(_Val), _Mycat(&_Cat) 
#line 208
{ 
#line 209
} 
#line 211
template < class _Enum,
  class = typename enable_if < is_error_code_enum < _Enum > :: value,
   void > :: type >
  error_code ( _Enum _Errcode )
  : _Myval ( 0 ), _Mycat ( 0 )
  {
  * this = make_error_code ( _Errcode );
  }
#line 220
void assign(int _Val, const error_category &_Cat) 
#line 221
{ 
#line 222
(_Myval) = _Val; 
#line 223
(_Mycat) = (&_Cat); 
#line 224
} 
#line 226
template < class _Enum >
  typename enable_if < is_error_code_enum < _Enum > :: value,
   error_code > :: type & operator = ( _Enum _Errcode )
  {
  * this = make_error_code ( _Errcode );
  return ( * this );
  }
#line 234
void clear() throw() 
#line 235
{ 
#line 236
(_Myval) = 0; 
#line 237
(_Mycat) = (&system_category()); 
#line 238
} 
#line 240
int value() const 
#line 241
{ 
#line 242
return _Myval; 
#line 243
} 
#line 245
const error_category &category() const 
#line 246
{ 
#line 247
return *(_Mycat); 
#line 248
} 
#line 250
inline error_condition default_error_condition() const; 
#line 252
string message() const 
#line 253
{ 
#line 254
return this->category().message(this->value()); 
#line 255
} 
#line 257
explicit operator bool() const throw() 
#line 258
{ 
#line 259
return this->value() != 0; 
#line 260
} 
#line 262
bool operator==(const error_code &_Right) const throw() 
#line 263
{ 
#line 264
return ((this->category()) == (_Right.category())) && (this->value() == _Right.value()); 
#line 266
} 
#line 268
bool operator!=(const error_code &_Right) const throw() 
#line 269
{ 
#line 270
return !((*this) == _Right); 
#line 271
} 
#line 273
bool operator<(const error_code &_Right) const throw() 
#line 274
{ 
#line 275
return ((this->category()) < (_Right.category())) || (((this->category()) == (_Right.category())) && (this->value() < _Right.value())); 
#line 278
} 
#line 281
private: int _Myval; 
#line 282
const error_category *_Mycat; 
#line 283
}; 
#line 286
class error_condition { 
#line 289
public: typedef error_condition _Myt; 
#line 291
error_condition() throw() : _Myval(0), _Mycat(&generic_category()) 
#line 294
{ 
#line 295
} 
#line 297
error_condition(int _Val, const error_category &_Cat) throw() : _Myval(_Val), _Mycat(&_Cat) 
#line 299
{ 
#line 300
} 
#line 302
template < class _Enum,
  class = typename enable_if < is_error_condition_enum < _Enum > :: value,
   void > :: type >
  error_condition ( _Enum _Errcode ) throw ( )
  : _Myval ( 0 ), _Mycat ( 0 )
  {
  * this = make_error_condition ( _Errcode );
  }
#line 311
void assign(int _Val, const error_category &_Cat) throw() 
#line 312
{ 
#line 313
(_Myval) = _Val; 
#line 314
(_Mycat) = (&_Cat); 
#line 315
} 
#line 317
template < class _Enum >
  typename enable_if < is_error_condition_enum < _Enum > :: value,
   error_condition > :: type & operator = ( _Enum _Errcode ) throw ( )
  {
  * this = make_error_condition ( _Errcode );
  return ( * this );
  }
#line 325
void clear() throw() 
#line 326
{ 
#line 327
(_Myval) = 0; 
#line 328
(_Mycat) = (&generic_category()); 
#line 329
} 
#line 331
int value() const throw() 
#line 332
{ 
#line 333
return _Myval; 
#line 334
} 
#line 336
const error_category &category() const throw() 
#line 337
{ 
#line 338
return *(_Mycat); 
#line 339
} 
#line 341
string message() const 
#line 342
{ 
#line 343
return this->category().message(this->value()); 
#line 344
} 
#line 346
explicit operator bool() const throw() 
#line 347
{ 
#line 348
return this->value() != 0; 
#line 349
} 
#line 351
bool operator==(const error_condition &_Right) const throw() 
#line 352
{ 
#line 353
return ((this->category()) == (_Right.category())) && (this->value() == _Right.value()); 
#line 355
} 
#line 357
bool operator!=(const error_condition &_Right) const throw() 
#line 358
{ 
#line 359
return !((*this) == _Right); 
#line 360
} 
#line 362
bool operator<(const error_condition &_Right) const throw() 
#line 363
{ 
#line 364
return ((this->category()) < (_Right.category())) || (((this->category()) == (_Right.category())) && (this->value() < _Right.value())); 
#line 367
} 
#line 370
private: int _Myval; 
#line 371
const error_category *_Mycat; 
#line 372
}; 
#line 376
inline error_condition error_category::default_error_condition(int _Errval) const throw() 
#line 377
{ 
#line 378
return error_condition(_Errval, *this); 
#line 379
} 
#line 382
inline bool error_category::equivalent(int _Errval, const error_condition &
#line 383
_Cond) const throw() 
#line 384
{ 
#line 385
return ((this->default_error_condition(_Errval)) == _Cond); 
#line 386
} 
#line 389
inline bool error_category::equivalent(const error_code &_Code, int 
#line 390
_Errval) const throw() 
#line 391
{ 
#line 392
return ((*this) == (_Code.category())) && (_Code.value() == _Errval); 
#line 393
} 
#line 396
inline error_condition error_code::default_error_condition() const 
#line 397
{ 
#line 398
return this->category().default_error_condition(this->value()); 
#line 399
} 
#line 402
inline bool operator==(const error_code &
#line 403
_Left, const error_condition &
#line 404
_Right) throw() 
#line 405
{ 
#line 406
return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value()); 
#line 408
} 
#line 410
inline bool operator==(const error_condition &
#line 411
_Left, const error_code &
#line 412
_Right) throw() 
#line 413
{ 
#line 414
return _Right.category().equivalent(_Right.value(), _Left) || _Left.category().equivalent(_Right, _Left.value()); 
#line 416
} 
#line 419
inline bool operator!=(const error_code &
#line 420
_Left, const error_condition &
#line 421
_Right) throw() 
#line 422
{ 
#line 423
return !((_Left == _Right)); 
#line 424
} 
#line 426
inline bool operator!=(const error_condition &
#line 427
_Left, const error_code &
#line 428
_Right) throw() 
#line 429
{ 
#line 430
return !((_Left == _Right)); 
#line 431
} 
#line 434
inline error_code make_error_code(generic_errno _Errno) throw() 
#line 435
{ 
#line 436
return error_code((int)_Errno, generic_category()); 
#line 437
} 
#line 439
inline error_code make_error_code(_Io_errc _Errno) throw() 
#line 440
{ 
#line 441
return error_code((int)_Errno, iostream_category()); 
#line 442
} 
#line 445
inline error_condition make_error_condition(generic_errno _Errno) throw() 
#line 446
{ 
#line 447
return error_condition((int)_Errno, generic_category()); 
#line 448
} 
#line 450
inline error_condition make_error_condition(_Io_errc _Errno) throw() 
#line 451
{ 
#line 452
return error_condition((int)_Errno, iostream_category()); 
#line 453
} 
#line 457
template<> struct hash< error_code>  : public unary_function< error_code, unsigned __w64>  { 
#line 460
typedef error_code _Kty; 
#line 462
size_t operator()(const _Kty &_Keyval) const 
#line 463
{ 
#line 464
return std::hash< int> ()(_Keyval.value()); 
#line 465
} 
#line 466
}; 
#line 469
class _System_error : public runtime_error { 
#line 473
static string _Makestr(error_code _Errcode, string _Message) 
#line 474
{ 
#line 475
if (!_Message.empty()) { 
#line 476
_Message.append(": "); }  
#line 477
_Message.append(_Errcode.message()); 
#line 478
return _Message; 
#line 479
} 
#line 482
protected: _System_error(error_code _Errcode, const string &_Message) : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode) 
#line 484
{ 
#line 485
} 
#line 487
error_code _Mycode; 
#line 488
}; 
#line 490
class system_error : public _System_error { 
#line 494
typedef _System_error _Mybase; 
#line 497
public: explicit system_error(error_code _Errcode) : _Mybase(_Errcode, "") 
#line 499
{ 
#line 500
} 
#line 502
system_error(error_code _Errcode, const string &_Message) : _Mybase(_Errcode, _Message) 
#line 504
{ 
#line 505
} 
#line 507
system_error(error_code _Errcode, const char *_Message) : _Mybase(_Errcode, _Message) 
#line 509
{ 
#line 510
} 
#line 512
system_error(int _Errval, const error_category &_Errcat) : _Mybase(error_code(_Errval, _Errcat), "") 
#line 514
{ 
#line 515
} 
#line 517
system_error(int _Errval, const error_category &_Errcat, const string &
#line 518
_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 520
{ 
#line 521
} 
#line 523
system_error(int _Errval, const error_category &_Errcat, const char *
#line 524
_Message) : _Mybase(error_code(_Errval, _Errcat), _Message) 
#line 526
{ 
#line 527
} 
#line 529
const error_code &code() const throw() 
#line 530
{ 
#line 531
return _Mycode; 
#line 532
} 
#line 543 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\system_error"
}; 
#line 545
__declspec(dllimport) const char *__cdecl _Syserror_map(int); 
#line 546
__declspec(dllimport) const char *__cdecl _Winerror_map(int); 
#line 549
class _Generic_error_category : public error_category { 
#line 553
public: _Generic_error_category() 
#line 554
{ 
#line 555
} 
#line 557
virtual const char *name() const throw() 
#line 558
{ 
#line 559
return "generic"; 
#line 560
} 
#line 562
virtual string message(int _Errcode) const 
#line 563
{ 
#line 564
const char *_Name = _Syserror_map(_Errcode); 
#line 565
return ((string)((_Name != (0)) ? _Name : ("unknown error"))); 
#line 566
} 
#line 567
}; 
#line 570
class _Iostream_error_category : public _Generic_error_category { 
#line 574
public: _Iostream_error_category() 
#line 575
{ 
#line 576
} 
#line 578
virtual const char *name() const throw() 
#line 579
{ 
#line 580
return "iostream"; 
#line 581
} 
#line 583
virtual string message(int _Errcode) const 
#line 584
{ 
#line 585
if (_Errcode == ((int)io_errc::stream)) { 
#line 586
return "iostream stream error"; } else { 
#line 588
return this->_Generic_error_category::message(_Errcode); }  
#line 589
} 
#line 590
}; 
#line 593
class _System_error_category : public _Generic_error_category { 
#line 597
public: _System_error_category() 
#line 598
{ 
#line 599
} 
#line 601
virtual const char *name() const throw() 
#line 602
{ 
#line 603
return "system"; 
#line 604
} 
#line 606
virtual string message(int _Errcode) const 
#line 607
{ 
#line 608
const char *_Name = _Winerror_map(_Errcode); 
#line 609
return ((string)((_Name != (0)) ? _Name : ("unknown error"))); 
#line 610
} 
#line 613
virtual error_condition default_error_condition(int _Errval) const throw() 
#line 614
{ 
#line 615
if (_Syserror_map(_Errval)) { 
#line 616
return error_condition(_Errval, generic_category()); } else { 
#line 618
return error_condition(_Errval, system_category()); }  
#line 619
} 
#line 620
}; 
#line 622
template < class _Cat >
 struct _Error_objects
 {
 _Error_objects ( )
  {
  }

 static _Generic_error_category _Generic_object;
 static _Iostream_error_category _Iostream_object;
 static _System_error_category _System_object;
 };
#line 634
template< class _Cat> _Generic_error_category 
#line 635
_Error_objects< _Cat> ::_Generic_object; 
#line 636
template< class _Cat> _Iostream_error_category 
#line 637
_Error_objects< _Cat> ::_Iostream_object; 
#line 638
template< class _Cat> _System_error_category 
#line 639
_Error_objects< _Cat> ::_System_object; 
#line 641
inline const error_category &generic_category() throw() 
#line 642
{ 
#line 643
return _Error_objects< int> ::_Generic_object; 
#line 644
} 
#line 646
inline const error_category &iostream_category() throw() 
#line 647
{ 
#line 648
return _Error_objects< int> ::_Iostream_object; 
#line 649
} 
#line 651
inline const error_category &system_category() throw() 
#line 652
{ 
#line 653
return _Error_objects< int> ::_System_object; 
#line 654
} 
#line 655
}
#line 657
#pragma warning(pop)
#line 13 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xiosbase"
#pragma warning(push,3)
#line 17
#pragma warning(disable: 4412)
#line 658 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\system_error"
#pragma pack ( pop )
#line 12 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xiosbase"
#pragma pack ( push, 8 )
#line 21
namespace std { 
#line 47
template< class _Dummy> 
#line 48
class _Iosb { 
#line 51
public: enum _Dummy_enum { _Dummy_enum_val = 1}; 
#line 52
enum _Fmtflags { 
#line 54
_Fmtmask = 65535, _Fmtzero = 0}; 
#line 56
static const _Fmtflags skipws = ((_Fmtflags)1); 
#line 57
static const _Fmtflags unitbuf = ((_Fmtflags)2); 
#line 58
static const _Fmtflags uppercase = ((_Fmtflags)4); 
#line 59
static const _Fmtflags showbase = ((_Fmtflags)8); 
#line 60
static const _Fmtflags showpoint = ((_Fmtflags)16); 
#line 61
static const _Fmtflags showpos = ((_Fmtflags)32); 
#line 62
static const _Fmtflags left = ((_Fmtflags)64); 
#line 63
static const _Fmtflags right = ((_Fmtflags)128); 
#line 64
static const _Fmtflags internal = ((_Fmtflags)256); 
#line 65
static const _Fmtflags dec = ((_Fmtflags)512); 
#line 66
static const _Fmtflags oct = ((_Fmtflags)1024); 
#line 67
static const _Fmtflags hex = ((_Fmtflags)2048); 
#line 68
static const _Fmtflags scientific = ((_Fmtflags)4096); 
#line 69
static const _Fmtflags fixed = ((_Fmtflags)8192); 
#line 71
static const _Fmtflags hexfloat = ((_Fmtflags)12288); 
#line 74
static const _Fmtflags boolalpha = ((_Fmtflags)16384); 
#line 75
static const _Fmtflags _Stdio = ((_Fmtflags)32768); 
#line 76
static const _Fmtflags adjustfield = ((_Fmtflags)((64 | 128) | 256)); 
#line 78
static const _Fmtflags basefield = ((_Fmtflags)((512 | 1024) | 2048)); 
#line 80
static const _Fmtflags floatfield = ((_Fmtflags)(4096 | 8192)); 
#line 83
enum _Iostate { 
#line 85
_Statmask = 23}; 
#line 87
static const _Iostate goodbit = ((_Iostate)0); 
#line 88
static const _Iostate eofbit = ((_Iostate)1); 
#line 89
static const _Iostate failbit = ((_Iostate)2); 
#line 90
static const _Iostate badbit = ((_Iostate)4); 
#line 91
static const _Iostate _Hardfail = ((_Iostate)16); 
#line 93
enum _Openmode { 
#line 95
_Openmask = 255}; 
#line 97
static const _Openmode in = ((_Openmode)1); 
#line 98
static const _Openmode out = ((_Openmode)2); 
#line 99
static const _Openmode ate = ((_Openmode)4); 
#line 100
static const _Openmode app = ((_Openmode)8); 
#line 101
static const _Openmode trunc = ((_Openmode)16); 
#line 102
static const _Openmode _Nocreate = ((_Openmode)64); 
#line 103
static const _Openmode _Noreplace = ((_Openmode)128); 
#line 104
static const _Openmode binary = ((_Openmode)32); 
#line 106
enum _Seekdir { 
#line 108
_Seekmask = 3}; 
#line 110
static const _Seekdir beg = ((_Seekdir)0); 
#line 111
static const _Seekdir cur = ((_Seekdir)1); 
#line 112
static const _Seekdir end = ((_Seekdir)2); 
#line 115
enum { 
#line 116
_Openprot = 64}; 
#line 117
}; 
#line 119
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 120
_Iosb< _Dummy> ::skipws; 
#line 121
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 122
_Iosb< _Dummy> ::unitbuf; 
#line 123
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 124
_Iosb< _Dummy> ::uppercase; 
#line 125
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 126
_Iosb< _Dummy> ::showbase; 
#line 127
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 128
_Iosb< _Dummy> ::showpoint; 
#line 129
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 130
_Iosb< _Dummy> ::showpos; 
#line 131
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 132
_Iosb< _Dummy> ::left; 
#line 133
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 134
_Iosb< _Dummy> ::right; 
#line 135
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 136
_Iosb< _Dummy> ::internal; 
#line 137
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 138
_Iosb< _Dummy> ::dec; 
#line 139
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 140
_Iosb< _Dummy> ::oct; 
#line 141
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 142
_Iosb< _Dummy> ::hex; 
#line 143
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 144
_Iosb< _Dummy> ::scientific; 
#line 145
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 146
_Iosb< _Dummy> ::fixed; 
#line 148
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 150
_Iosb< _Dummy> ::hexfloat; 
#line 152
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 153
_Iosb< _Dummy> ::boolalpha; 
#line 154
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 155
_Iosb< _Dummy> ::_Stdio; 
#line 156
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 157
_Iosb< _Dummy> ::adjustfield; 
#line 158
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 159
_Iosb< _Dummy> ::basefield; 
#line 160
template< class _Dummy> const typename _Iosb< _Dummy> ::_Fmtflags 
#line 161
_Iosb< _Dummy> ::floatfield; 
#line 163
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 164
_Iosb< _Dummy> ::goodbit; 
#line 165
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 166
_Iosb< _Dummy> ::eofbit; 
#line 167
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 168
_Iosb< _Dummy> ::failbit; 
#line 169
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 170
_Iosb< _Dummy> ::badbit; 
#line 171
template< class _Dummy> const typename _Iosb< _Dummy> ::_Iostate 
#line 172
_Iosb< _Dummy> ::_Hardfail; 
#line 174
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 175
_Iosb< _Dummy> ::in; 
#line 176
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 177
_Iosb< _Dummy> ::out; 
#line 178
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 179
_Iosb< _Dummy> ::ate; 
#line 180
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 181
_Iosb< _Dummy> ::app; 
#line 182
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 183
_Iosb< _Dummy> ::trunc; 
#line 184
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 185
_Iosb< _Dummy> ::_Nocreate; 
#line 186
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 187
_Iosb< _Dummy> ::_Noreplace; 
#line 188
template< class _Dummy> const typename _Iosb< _Dummy> ::_Openmode 
#line 189
_Iosb< _Dummy> ::binary; 
#line 191
template< class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
#line 192
_Iosb< _Dummy> ::beg; 
#line 193
template< class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
#line 194
_Iosb< _Dummy> ::cur; 
#line 195
template< class _Dummy> const typename _Iosb< _Dummy> ::_Seekdir 
#line 196
_Iosb< _Dummy> ::end; 
#line 199
class __declspec(dllimport) ios_base : public _Iosb< int>  { 
#line 203
public: typedef int fmtflags; 
#line 204
typedef int iostate; 
#line 205
typedef int openmode; 
#line 206
typedef int seekdir; 
#line 208
typedef std::streamoff streamoff; 
#line 209
typedef std::streampos streampos; 
#line 211
enum event { 
#line 213
erase_event, imbue_event, copyfmt_event}; 
#line 215
typedef void (__cdecl *event_callback)(event, ios_base &, int); 
#line 216
typedef unsigned io_state, open_mode, seek_dir; 
#line 219
class failure : public system_error { 
#line 224
public: explicit failure(const string &_Message, const error_code &
#line 225
_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 227
{ 
#line 228
} 
#line 230
explicit failure(const char *_Message, const error_code &
#line 231
_Errcode = make_error_code(io_errc::stream)) : system_error(_Errcode, _Message) 
#line 233
{ 
#line 234
} 
#line 246 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xiosbase"
}; 
#line 249
class __declspec(dllimport) Init { 
#line 252
public: Init() 
#line 253
{ 
#line 254
_Init_ctor(this); 
#line 255
} 
#line 257
~Init() throw() 
#line 258
{ 
#line 259
_Init_dtor(this); 
#line 260
} 
#line 263
private: static void __cdecl _Init_ctor(Init *); 
#line 264
static void __cdecl _Init_dtor(Init *); 
#line 266
static int _Init_cnt; 
#line 268
static int &__cdecl _Init_cnt_func(); 
#line 269
}; 
#line 271
explicit operator bool() const 
#line 272
{ 
#line 273
return !this->fail(); 
#line 274
} 
#line 276
bool operator!() const 
#line 277
{ 
#line 278
return this->fail(); 
#line 279
} 
#line 281
void clear(iostate _State, bool _Reraise) 
#line 282
{ 
#line 283
(_Mystate) = ((iostate)(_State & (_Statmask))); 
#line 284
if (((_Mystate) & (_Except)) == 0) { 
#line 285
; } else { 
#line 286
if (_Reraise) { 
#line 287
throw; } else { 
#line 288
if (((_Mystate) & (_Except)) & badbit) { 
#line 289
throw ((failure)("ios_base::badbit set")); } else { 
#line 290
if (((_Mystate) & (_Except)) & failbit) { 
#line 291
throw ((failure)("ios_base::failbit set")); } else { 
#line 293
throw ((failure)("ios_base::eofbit set")); }  }  }  }  
#line 294
} 
#line 296
void clear(iostate _State = goodbit) 
#line 297
{ 
#line 298
this->clear(_State, false); 
#line 299
} 
#line 301
void clear(io_state _State) 
#line 302
{ 
#line 303
this->clear((iostate)_State); 
#line 304
} 
#line 306
iostate rdstate() const 
#line 307
{ 
#line 308
return _Mystate; 
#line 309
} 
#line 311
void setstate(iostate _State, bool _Exreraise) 
#line 312
{ 
#line 313
if (_State != goodbit) { 
#line 314
this->clear((iostate)(((int)this->rdstate()) | _State), _Exreraise); }  
#line 315
} 
#line 317
void setstate(iostate _State) 
#line 318
{ 
#line 319
if (_State != goodbit) { 
#line 320
this->clear((iostate)(((int)this->rdstate()) | _State), false); }  
#line 321
} 
#line 323
void setstate(io_state _State) 
#line 324
{ 
#line 325
this->setstate((iostate)_State); 
#line 326
} 
#line 328
bool good() const 
#line 329
{ 
#line 330
return this->rdstate() == goodbit; 
#line 331
} 
#line 333
bool eof() const 
#line 334
{ 
#line 335
return ((int)this->rdstate()) & ((int)eofbit); 
#line 336
} 
#line 338
bool fail() const 
#line 339
{ 
#line 340
return (((int)this->rdstate()) & (((int)badbit) | ((int)failbit))) != 0; 
#line 342
} 
#line 344
bool bad() const 
#line 345
{ 
#line 346
return (((int)this->rdstate()) & ((int)badbit)) != 0; 
#line 347
} 
#line 349
iostate exceptions() const 
#line 350
{ 
#line 351
return _Except; 
#line 352
} 
#line 354
void exceptions(iostate _Newexcept) 
#line 355
{ 
#line 356
(_Except) = ((iostate)(_Newexcept & ((int)_Statmask))); 
#line 357
this->clear(_Mystate); 
#line 358
} 
#line 360
void exceptions(io_state _State) 
#line 361
{ 
#line 362
this->exceptions((iostate)_State); 
#line 363
} 
#line 365
fmtflags flags() const 
#line 366
{ 
#line 367
return _Fmtfl; 
#line 368
} 
#line 370
fmtflags flags(fmtflags _Newfmtflags) 
#line 371
{ 
#line 372
fmtflags _Oldfmtflags = _Fmtfl; 
#line 373
(_Fmtfl) = ((fmtflags)(_Newfmtflags & ((int)_Fmtmask))); 
#line 374
return _Oldfmtflags; 
#line 375
} 
#line 377
fmtflags setf(fmtflags _Newfmtflags) 
#line 378
{ 
#line 379
fmtflags _Oldfmtflags = _Fmtfl; 
#line 380
(_Fmtfl) = ((fmtflags)((_Fmtfl) | (_Newfmtflags & ((int)_Fmtmask)))); 
#line 382
return _Oldfmtflags; 
#line 383
} 
#line 385
fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask) 
#line 386
{ 
#line 387
fmtflags _Oldfmtflags = _Fmtfl; 
#line 388
(_Fmtfl) = ((fmtflags)(((_Fmtfl) & ((int)(~_Mask))) | ((_Newfmtflags & _Mask) & ((int)_Fmtmask)))); 
#line 390
return _Oldfmtflags; 
#line 391
} 
#line 393
void unsetf(fmtflags _Mask) 
#line 394
{ 
#line 395
(_Fmtfl) = ((fmtflags)((_Fmtfl) & ((int)(~_Mask)))); 
#line 396
} 
#line 398
streamsize precision() const 
#line 399
{ 
#line 400
return _Prec; 
#line 401
} 
#line 403
streamsize precision(streamsize _Newprecision) 
#line 404
{ 
#line 405
streamsize _Oldprecision = _Prec; 
#line 406
(_Prec) = _Newprecision; 
#line 407
return _Oldprecision; 
#line 408
} 
#line 410
streamsize width() const 
#line 411
{ 
#line 412
return _Wide; 
#line 413
} 
#line 415
streamsize width(streamsize _Newwidth) 
#line 416
{ 
#line 417
streamsize _Oldwidth = _Wide; 
#line 418
(_Wide) = _Newwidth; 
#line 419
return _Oldwidth; 
#line 420
} 
#line 422
locale getloc() const 
#line 423
{ 
#line 424
return *(_Ploc); 
#line 425
} 
#line 427
locale imbue(const locale &_Loc) 
#line 428
{ 
#line 429
locale _Oldlocale = *(_Ploc); 
#line 430
((*(_Ploc)) = _Loc); 
#line 431
this->_Callfns(imbue_event); 
#line 432
return _Oldlocale; 
#line 433
} 
#line 435
static int __cdecl xalloc() 
#line 436
{ 
#line 437
{ _Lockit _Lock(2); 
#line 438
return _Index++; 
#line 439
} 
#line 440
} 
#line 442
long &iword(int _Idx) 
#line 443
{ 
#line 444
return this->_Findarr(_Idx)._Lo; 
#line 445
} 
#line 447
void *&pword(int _Idx) 
#line 448
{ 
#line 449
return this->_Findarr(_Idx)._Vp; 
#line 450
} 
#line 452
void register_callback(event_callback _Pfn, int 
#line 453
_Idx) 
#line 454
{ 
#line 455
(_Calls) = (new _Fnarray(_Idx, _Pfn, _Calls)); 
#line 456
} 
#line 458
ios_base &copyfmt(const ios_base &_Other) 
#line 459
{ 
#line 460
if (this != (&_Other)) 
#line 461
{ 
#line 462
this->_Tidy(); 
#line 463
((*(_Ploc)) = (*(_Other._Ploc))); 
#line 464
(_Fmtfl) = (_Other._Fmtfl); 
#line 465
(_Prec) = (_Other._Prec); 
#line 466
(_Wide) = (_Other._Wide); 
#line 467
_Iosarray *_Ptr = _Other._Arr; 
#line 469
for ((_Arr) = (0); _Ptr != (0); _Ptr = (_Ptr->_Next)) { 
#line 470
if (((_Ptr->_Lo) != (0)) || ((_Ptr->_Vp) != (0))) 
#line 471
{ 
#line 472
this->iword(_Ptr->_Index) = (_Ptr->_Lo); 
#line 473
this->pword(_Ptr->_Index) = (_Ptr->_Vp); 
#line 474
}  }  
#line 476
for (_Fnarray *_Pfa = _Other._Calls; _Pfa != (0); _Pfa = (_Pfa->_Next)) { 
#line 478
this->register_callback(_Pfa->_Pfn, _Pfa->_Index); }  
#line 480
this->_Callfns(copyfmt_event); 
#line 481
this->exceptions(_Other._Except); 
#line 482
}  
#line 483
return *this; 
#line 484
} 
#line 486
static bool __cdecl sync_with_stdio(bool _Newsync = true) 
#line 487
{ 
#line 488
{ _Lockit _Lock(2); 
#line 489
const bool _Oldsync = _Sync; 
#line 490
_Sync = _Newsync; 
#line 491
return _Oldsync; 
#line 492
} 
#line 493
} 
#line 495
void swap(ios_base &_Right) 
#line 496
{ 
#line 497
if (this != (&_Right)) 
#line 498
{ 
#line 499
::std::swap(_Mystate, _Right._Mystate); 
#line 500
::std::swap(_Except, _Right._Except); 
#line 501
::std::swap(_Fmtfl, _Right._Fmtfl); 
#line 502
::std::swap(_Prec, _Right._Prec); 
#line 503
::std::swap(_Wide, _Right._Wide); 
#line 505
::std::swap(_Arr, _Right._Arr); 
#line 506
::std::swap(_Calls, _Right._Calls); 
#line 507
::std::swap(_Ploc, _Right._Ploc); 
#line 508
}  
#line 509
} 
#line 511
virtual ~ios_base() throw() 
#line 512
{ 
#line 513
_Ios_base_dtor(this); 
#line 514
} 
#line 517
static void __cdecl _Addstd(ios_base *); 
#line 519
size_t _Stdstr; 
#line 522
protected: ios_base() 
#line 523
{ 
#line 524
} 
#line 526
void _Init() 
#line 527
{ 
#line 528
(_Ploc) = (0); 
#line 529
(_Stdstr) = (0); 
#line 530
(_Except) = goodbit; 
#line 531
(_Fmtfl) = ((fmtflags)(skipws | dec)); 
#line 532
(_Prec) = (6); 
#line 533
(_Wide) = (0); 
#line 534
(_Arr) = (0); 
#line 535
(_Calls) = (0); 
#line 536
this->clear(goodbit); 
#line 537
(_Ploc) = (new locale); 
#line 538
} 
#line 542
private: struct _Iosarray { 
#line 545
_Iosarray(int _Idx, _Iosarray *_Link) : _Next(_Link), _Index(_Idx), _Lo((0)), _Vp((0)) 
#line 547
{ 
#line 548
} 
#line 550
_Iosarray *_Next; 
#line 551
int _Index; 
#line 552
long _Lo; 
#line 553
void *_Vp; 
#line 554
}; 
#line 557
struct _Fnarray { 
#line 559
_Fnarray(int _Idx, event_callback _Pnew, _Fnarray *_Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew) 
#line 561
{ 
#line 562
} 
#line 564
_Fnarray *_Next; 
#line 565
int _Index; 
#line 566
event_callback _Pfn; 
#line 567
}; 
#line 569
void _Callfns(event _Ev) 
#line 570
{ 
#line 571
for (_Fnarray *_Pfa = _Calls; _Pfa != (0); _Pfa = (_Pfa->_Next)) { 
#line 572
(*(_Pfa->_Pfn))(_Ev, *this, _Pfa->_Index); }  
#line 573
} 
#line 575
_Iosarray &_Findarr(int _Idx) 
#line 576
{ 
#line 577
_Iosarray *_Ptr1, *_Ptr2; 
#line 579
for ((_Ptr1 = (_Arr)), (_Ptr2 = (0)); _Ptr1 != (0); _Ptr1 = (_Ptr1->_Next)) { 
#line 580
if ((_Ptr1->_Index) == _Idx) { 
#line 581
return *_Ptr1; } else { 
#line 582
if (((_Ptr2 == (0)) && ((_Ptr1->_Lo) == (0))) && ((_Ptr1->_Vp) == (0))) { 
#line 583
_Ptr2 = _Ptr1; }  }  }  
#line 585
if (_Ptr2 != (0)) 
#line 586
{ 
#line 587
(_Ptr2->_Index) = _Idx; 
#line 588
return *_Ptr2; 
#line 589
}  
#line 591
(_Arr) = (new _Iosarray(_Idx, _Arr)); 
#line 592
return *(_Arr); 
#line 593
} 
#line 595
void _Tidy() 
#line 596
{ 
#line 597
this->_Callfns(erase_event); 
#line 598
_Iosarray *_Ptr1, *_Ptr2; 
#line 600
for (_Ptr1 = (_Arr); _Ptr1 != (0); _Ptr1 = _Ptr2) 
#line 601
{ 
#line 602
_Ptr2 = (_Ptr1->_Next); 
#line 603
delete _Ptr1; 
#line 604
}  
#line 605
(_Arr) = (0); 
#line 607
_Fnarray *_Pfa1, *_Pfa2; 
#line 608
for (_Pfa1 = (_Calls); _Pfa1 != (0); _Pfa1 = _Pfa2) 
#line 609
{ 
#line 610
_Pfa2 = (_Pfa1->_Next); 
#line 611
delete _Pfa1; 
#line 612
}  
#line 613
(_Calls) = (0); 
#line 614
} 
#line 616
iostate _Mystate; 
#line 617
iostate _Except; 
#line 618
fmtflags _Fmtfl; 
#line 619
streamsize _Prec; 
#line 620
streamsize _Wide; 
#line 621
_Iosarray *_Arr; 
#line 622
_Fnarray *_Calls; 
#line 623
locale *_Ploc; 
#line 625
static int _Index; 
#line 626
static bool _Sync; 
#line 629
static void __cdecl _Ios_base_dtor(ios_base *); 
#line 632
public: ios_base(const ios_base &) = delete;
#line 633
ios_base &operator=(const ios_base &) = delete;
#line 634
}; 
#line 640
}
#line 642
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\streambuf"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4251)
#line 643 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xiosbase"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\streambuf"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 17
template < class _Elem,
 class _Traits >
 class basic_streambuf
 {
 typedef basic_streambuf < _Elem, _Traits > _Myt;

protected :
  basic_streambuf ( )
  : _Plocale ( new locale )
  {
  _Init ( );
  }

  basic_streambuf ( _Uninitialized )
  {
  }

  basic_streambuf ( const _Myt & _Right )
  : _Plocale ( new locale ( _Right . getloc ( ) ) )
  {
  _Init ( );
  setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
  setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
  }

 _Myt & operator = ( const _Myt & _Right )
  {
  if ( this != & _Right )
   {
   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   pubimbue ( _Right . getloc ( ) );
   }
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Elem * _Pfirst = pbase ( );
   _Elem * _Pnext = pptr ( );
   _Elem * _Pend = epptr ( );
   _Elem * _Gfirst = eback ( );
   _Elem * _Gnext = gptr ( );
   _Elem * _Gend = egptr ( );

   setp ( _Right . pbase ( ), _Right . pptr ( ), _Right . epptr ( ) );
   _Right . setp ( _Pfirst, _Pnext, _Pend );

   setg ( _Right . eback ( ), _Right . gptr ( ), _Right . egptr ( ) );
   _Right . setg ( _Gfirst, _Gnext, _Gend );

   :: std :: swap ( _Plocale, _Right . _Plocale );
   }
  }

public :
 typedef _Elem char_type;
 typedef _Traits traits_type;

 virtual ~ basic_streambuf ( ) throw ( )
  {
  delete ( _Plocale );
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 pos_type pubseekoff ( off_type _Off,
  ios_base :: seekdir _Way,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekoff ( _Off, _Way, _Mode ) );
  }

 pos_type pubseekoff ( off_type _Off,
  ios_base :: seek_dir _Way,
  ios_base :: open_mode _Mode )
  {
  return ( pubseekoff ( _Off, ( ios_base :: seekdir ) _Way,
   ( ios_base :: openmode ) _Mode ) );
  }

 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: openmode _Mode = ios_base :: in | ios_base :: out )
  {
  return ( seekpos ( _Pos, _Mode ) );
  }

 pos_type pubseekpos ( pos_type _Pos,
  ios_base :: open_mode _Mode )
  {
  return ( seekpos ( _Pos, ( ios_base :: openmode ) _Mode ) );
  }

 _Myt * pubsetbuf ( _Elem * _Buffer,
  streamsize _Count )
  {
  return ( setbuf ( _Buffer, _Count ) );
  }

 locale pubimbue ( const locale & _Newlocale )
  {
  locale _Oldlocale = * _Plocale;
  imbue ( _Newlocale );
  * _Plocale = _Newlocale;
  return ( _Oldlocale );
  }

 locale getloc ( ) const
  {
  return ( * _Plocale );
  }

 streamsize in_avail ( )
  {
  streamsize _Res = _Gnavail ( );
  return ( 0 < _Res ? _Res : showmanyc ( ) );
  }

 int pubsync ( )
  {
  return ( sync ( ) );
  }

 int_type sbumpc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gninc ( ) ) : uflow ( ) );
  }

 int_type sgetc ( )
  {
  return ( 0 < _Gnavail ( )
   ? _Traits :: to_int_type ( * gptr ( ) ) : underflow ( ) );
  }

 streamsize sgetn ( _Elem * _Ptr,
  streamsize _Count )
  {
  return ( xsgetn ( _Ptr, _Count ) );
  }

 int_type snextc ( )
  {
  return ( 1 < _Gnavail ( )
   ? _Traits :: to_int_type ( * _Gnpreinc ( ) )
   : _Traits :: eq_int_type ( _Traits :: eof ( ), sbumpc ( ) )
    ? _Traits :: eof ( ) : sgetc ( ) );
  }

 int_type sputbackc ( _Elem _Ch )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   && _Traits :: eq ( _Ch, gptr ( ) [ - 1 ] )
   ? _Traits :: to_int_type ( * _Gndec ( ) )
   : pbackfail ( _Traits :: to_int_type ( _Ch ) ) );
  }

 void stossc ( )
  {
  if ( 0 < _Gnavail ( ) )
   _Gninc ( );
  else
   uflow ( );
  }

 int_type sungetc ( )
  {
  return ( gptr ( ) != 0 && eback ( ) < gptr ( )
   ? _Traits :: to_int_type ( * _Gndec ( ) ) : pbackfail ( ) );
  }

 int_type sputc ( _Elem _Ch )
  {
  return ( 0 < _Pnavail ( )
   ? _Traits :: to_int_type ( * _Pninc ( ) = _Ch )
   : overflow ( _Traits :: to_int_type ( _Ch ) ) );
  }

 streamsize sputn ( const _Elem * _Ptr,
  streamsize _Count )
  {
  return ( xsputn ( _Ptr, _Count ) );
  }

 virtual void _Lock ( )
  {
  }

 virtual void _Unlock ( )
  {
  }

protected :
 _Elem * eback ( ) const
  {
  return ( * _IGfirst );
  }

 _Elem * gptr ( ) const
  {
  return ( * _IGnext );
  }

 _Elem * pbase ( ) const
  {
  return ( * _IPfirst );
  }

 _Elem * pptr ( ) const
  {
  return ( * _IPnext );
  }

 _Elem * egptr ( ) const
  {
  return ( * _IGnext + * _IGcount );
  }

 void gbump ( int _Off )
  {
  * _IGcount -= _Off;
  * _IGnext += _Off;
  }

 void setg ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IGfirst = _First;
  * _IGnext = _Next;
  * _IGcount = ( int ) ( _Last - _Next );
  }

 _Elem * epptr ( ) const
  {
  return ( * _IPnext + * _IPcount );
  }

 _Elem * _Gndec ( )
  {
  ++ * _IGcount;
  return ( -- * _IGnext );
  }

 _Elem * _Gninc ( )
  {
  -- * _IGcount;
  return ( ( * _IGnext ) ++ );
  }

 _Elem * _Gnpreinc ( )
  {
  -- * _IGcount;
  return ( ++ ( * _IGnext ) );
  }

 streamsize _Gnavail ( ) const
  {
  return ( * _IGnext != 0 ? * _IGcount : 0 );
  }

 void pbump ( int _Off )
  {
  * _IPcount -= _Off;
  * _IPnext += _Off;
  }

 void setp ( _Elem * _First, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _First;
  * _IPcount = ( int ) ( _Last - _First );
  }

 void setp ( _Elem * _First, _Elem * _Next, _Elem * _Last )
  {
  * _IPfirst = _First;
  * _IPnext = _Next;
  * _IPcount = ( int ) ( _Last - _Next );
  }

 _Elem * _Pninc ( )
  {
  -- * _IPcount;
  return ( ( * _IPnext ) ++ );
  }

 streamsize _Pnavail ( ) const
  {
  return ( * _IPnext != 0 ? * _IPcount : 0 );
  }

 void _Init ( )
  {
  _IGfirst = & _Gfirst;
  _IPfirst = & _Pfirst;
  _IGnext = & _Gnext;
  _IPnext = & _Pnext;
  _IGcount = & _Gcount;
  _IPcount = & _Pcount;
  setp ( 0, 0 );
  setg ( 0, 0, 0 );
  }

 void _Init ( _Elem * * _Gf, _Elem * * _Gn, int * _Gc,
  _Elem * * _Pf, _Elem * * _Pn, int * _Pc )
  {
  _IGfirst = _Gf;
  _IPfirst = _Pf;
  _IGnext = _Gn;
  _IPnext = _Pn;
  _IGcount = _Gc;
  _IPcount = _Pc;
  }

 virtual int_type overflow ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type pbackfail ( int_type = _Traits :: eof ( ) )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual streamsize showmanyc ( )
  {
  return ( 0 );
  }

 virtual int_type underflow ( )
  {
  return ( _Traits :: eof ( ) );
  }

 virtual int_type uflow ( )
  {
  return ( _Traits :: eq_int_type ( _Traits :: eof ( ), underflow ( ) )
   ? _Traits :: eof ( ) : _Traits :: to_int_type ( * _Gninc ( ) ) );
  }

 virtual streamsize xsgetn ( _Elem * _Ptr,
  streamsize _Count )
  {
  int_type _Meta;
  streamsize _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Size = _Gnavail ( ) ) )
    {
    if ( _Count < _Size )
     _Size = _Count;
    _Traits :: copy ( _Ptr, gptr ( ), ( size_t ) _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    gbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta = uflow ( ) ) )
    break;
   else
    {
    * _Ptr ++ = _Traits :: to_char_type ( _Meta );
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

 virtual streamsize xsputn ( const _Elem * _Ptr,
  streamsize _Count )
  {
  streamsize _Size, _Copied;

  for ( _Copied = 0; 0 < _Count; )
   if ( 0 < ( _Size = _Pnavail ( ) ) )
    {
    if ( _Count < _Size )
     _Size = _Count;
    _Traits :: copy ( pptr ( ), _Ptr, ( size_t ) _Size );
    _Ptr += _Size;
    _Copied += _Size;
    _Count -= _Size;
    pbump ( ( int ) _Size );
    }
   else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    overflow ( _Traits :: to_int_type ( * _Ptr ) ) ) )
    break;
   else
    {
    ++ _Ptr;
    ++ _Copied;
    -- _Count;
    }

  return ( _Copied );
  }

 virtual pos_type seekoff ( off_type,
  ios_base :: seekdir,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( _BADOFF ) );
  }

 virtual pos_type seekpos ( pos_type,
  ios_base :: openmode = ios_base :: in | ios_base :: out )
  {
  return ( streampos ( _BADOFF ) );
  }

 virtual _Myt * setbuf ( _Elem *, streamsize )
  {
  return ( this );
  }

 virtual int sync ( )
  {
  return ( 0 );
  }

 virtual void imbue ( const locale & )
  {
  }

private :
 _Elem * _Gfirst;
 _Elem * _Pfirst;
 _Elem * * _IGfirst;
 _Elem * * _IPfirst;
 _Elem * _Gnext;
 _Elem * _Pnext;
 _Elem * * _IGnext;
 _Elem * * _IPnext;

 int _Gcount;
 int _Pcount;
 int * _IGcount;
 int * _IPcount;

protected :
 locale * _Plocale;
 };
#line 467
template class __declspec(dllimport) basic_streambuf< char, char_traits< char> > ;
#line 468
template class __declspec(dllimport) basic_streambuf< __wchar_t, char_traits< __wchar_t> > ;
#line 478 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\streambuf"
template < class _Elem,
 class _Traits >
 class istreambuf_iterator
  : public iterator < input_iterator_tag,
   _Elem, typename _Traits :: off_type, const _Elem *, _Elem >
 {
 typedef istreambuf_iterator < _Elem, _Traits > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf < _Elem, _Traits > streambuf_type;
 typedef basic_istream < _Elem, _Traits > istream_type;

 typedef typename traits_type :: int_type int_type;
 typedef const _Elem * pointer;

 istreambuf_iterator ( streambuf_type * _Sb = 0 ) throw ( )
  : _Strbuf ( _Sb ), _Got ( _Sb == 0 )
  {
  }

 istreambuf_iterator ( istream_type & _Istr ) throw ( )
  : _Strbuf ( _Istr . rdbuf ( ) ), _Got ( _Istr . rdbuf ( ) == 0 )
  {
  }

 _Elem operator * ( ) const
  {
  if ( ! _Got )
   _Peek ( );






  return ( _Val );
  }

 const _Elem * operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myt & operator ++ ( )
  {





  _Inc ( );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  if ( ! _Got )
   _Peek ( );
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 bool equal ( const _Myt & _Right ) const
  {
  if ( ! _Got )
   _Peek ( );
  if ( ! _Right . _Got )
   _Right . _Peek ( );
  return ( ( _Strbuf == 0 && _Right . _Strbuf == 0 )
   || ( _Strbuf != 0 && _Right . _Strbuf != 0 ) );
  }

private :
 void _Inc ( )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Strbuf -> sbumpc ( ) ) )
   _Strbuf = 0, _Got = true;
  else
   _Got = false;
  }

 _Elem _Peek ( ) const
  {
  int_type _Meta;
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( traits_type :: eof ( ),
    _Meta = _Strbuf -> sgetc ( ) ) )
   _Strbuf = 0;
  else
   _Val = traits_type :: to_char_type ( _Meta );
  _Got = true;
  return ( _Val );
  }

 mutable streambuf_type * _Strbuf;
 mutable bool _Got;
 mutable _Elem _Val;
 };
#line 581 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\streambuf"
template< class _Elem, class 
#line 582
_Traits> 
#pragma pack(8)
#line 583
struct _Is_checked_helper< istreambuf_iterator< _Elem, _Traits> >  : public true_type { 
#line 586
}; 
#pragma pack()
#line 589
template < class _Elem,
 class _Traits > inline
 bool operator == (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( _Left . equal ( _Right ) );
 }
#line 598
template < class _Elem,
 class _Traits > inline
 bool operator != (
  const istreambuf_iterator < _Elem, _Traits > & _Left,
  const istreambuf_iterator < _Elem, _Traits > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 608
template < class _Elem,
 class _Traits >
 class ostreambuf_iterator
  : public _Outit
 {
 typedef ostreambuf_iterator < _Elem, _Traits > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_streambuf < _Elem, _Traits > streambuf_type;
 typedef basic_ostream < _Elem, _Traits > ostream_type;

 ostreambuf_iterator ( streambuf_type * _Sb ) throw ( )
  : _Failed ( false ), _Strbuf ( _Sb )
  {
  }

 ostreambuf_iterator ( ostream_type & _Ostr ) throw ( )
  : _Failed ( false ), _Strbuf ( _Ostr . rdbuf ( ) )
  {
  }

 _Myt & operator = ( _Elem _Right )
  {
  if ( _Strbuf == 0
   || traits_type :: eq_int_type ( _Traits :: eof ( ),
    _Strbuf -> sputc ( _Right ) ) )
   _Failed = true;
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( int )
  {
  return ( * this );
  }

 bool failed ( ) const throw ( )
  {
  return ( _Failed );
  }

private :
 bool _Failed;
 streambuf_type * _Strbuf;
 };
#line 664
template< class _Elem, class 
#line 665
_Traits> 
#pragma pack(8)
#line 666
struct _Is_checked_helper< ostreambuf_iterator< _Elem, _Traits> >  : public true_type { 
#line 669
}; 
#pragma pack()
#line 670
}
#line 673
#pragma warning(pop)
#line 13 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
#pragma warning(push,3)
#line 17
#pragma warning(disable: 4189 4275)
#line 674 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\streambuf"
#pragma pack ( pop )
#line 12 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
#pragma pack ( push, 8 )
#line 25 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
extern "C" { __declspec(dllimport) extern float __cdecl _Stofx(const char *, char **, long, int *); } 
#line 28
extern "C" { __declspec(dllimport) extern double __cdecl _Stodx(const char *, char **, long, int *); } 
#line 31
extern "C" { __declspec(dllimport) extern long double __cdecl _Stoldx(const char *, char **, long, int *); } 
#line 34
extern "C" { __declspec(dllimport) extern long __cdecl _Stolx(const char *, char **, int, int *); } 
#line 37
extern "C" { __declspec(dllimport) extern unsigned long __cdecl _Stoulx(const char *, char **, int, int *); } 
#line 40
extern "C" { __declspec(dllimport) extern __int64 __cdecl _Stollx(const char *, char **, int, int *); } 
#line 43
extern "C" { __declspec(dllimport) extern unsigned __int64 __cdecl _Stoullx(const char *, char **, int, int *); } 
#line 51 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
namespace std { 
#line 53
template < class _Elem > inline
 size_t _Find_elem ( _Elem * _Base, _Elem _Ch )
 {
 _Elem * _Ptr = _Base;
 for (; * _Ptr != ( _Elem ) 0 && * _Ptr != _Ch; ++ _Ptr )
  ;
 return ( ( size_t ) ( _Ptr - _Base ) );
 }
#line 62
inline __wchar_t *_Maklocwcs(const __wchar_t *_Ptr) 
#line 63
{ 
#line 64
size_t _Count = ::wcslen(_Ptr) + (1); 
#line 65
__wchar_t *_Ptrdest = new __wchar_t [_Count]; 
#line 66
::wmemcpy(_Ptrdest, _Ptr, _Count); 
#line 67
return _Ptrdest; 
#line 68
} 
#line 71
template < class _Elem >
 class numpunct
  : public locale :: facet
 {
public :
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  string_type;
 typedef _Elem char_type;

  __declspec ( dllimport ) static locale :: id id;

 _Elem decimal_point ( ) const
  {
  return ( do_decimal_point ( ) );
  }

 _Elem thousands_sep ( ) const
  {
  return ( do_thousands_sep ( ) );
  }

 string grouping ( ) const
  {
  return ( do_grouping ( ) );
  }

 string_type falsename ( ) const
  {
  return ( do_falsename ( ) );
  }

 string_type truename ( ) const
  {
  return ( do_truename ( ) );
  }

 explicit numpunct ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
   if ( _Kseparator == 0 )
    _Kseparator =
     _Maklocchr ( ',', ( _Elem * ) 0, _Lobj . _Getcvt ( ) );
  }
  }

 numpunct ( const _Locinfo & _Lobj, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj, _Isdef );
  }

 static size_t _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new numpunct < _Elem > (
    _Locinfo ( _Ploc -> c_str ( ) ), 0, true );
  return ( 4 );
  }

protected :
 virtual ~ numpunct ( ) throw ( )
  {
  _Tidy ( );
  }

 numpunct ( const char * _Locname, size_t _Refs = 0, bool _Isdef = false )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj ( _Locname );
   _Init ( _Lobj, _Isdef );
  }
  }

 template < class _Elem2 >
  void _Getvals ( _Elem2, const lconv * _Ptr, _Locinfo :: _Cvtvec _Cvt )
  {
  _Dp = _Maklocchr ( _Ptr -> decimal_point [ 0 ], ( _Elem2 * ) 0, _Cvt );
  _Kseparator = _Maklocchr ( _Ptr -> thousands_sep [ 0 ], ( _Elem2 * ) 0, _Cvt );
  }

 template < >
  void _Getvals ( wchar_t, const lconv * _Ptr, _Locinfo :: _Cvtvec )
  {
  _Dp = ( _Elem ) _Ptr -> _W_decimal_point [ 0 ];
  _Kseparator = ( _Elem ) _Ptr -> _W_thousands_sep [ 0 ];
  }

 void _Init ( const _Locinfo & _Lobj, bool _Isdef = false )
  {
  const lconv * _Ptr = _Lobj . _Getlconv ( );
  _Locinfo :: _Cvtvec _Cvt = _Lobj . _Getcvt ( );

  _Grouping = 0;
  _Falsename = 0;
  _Truename = 0;

  try {
  _Grouping = _Maklocstr ( _Isdef ? "" : _Ptr -> grouping, ( char * ) 0, _Lobj . _Getcvt ( ) );

  _Falsename = _Maklocstr ( _Lobj . _Getfalse ( ), ( _Elem * ) 0, _Cvt );
  _Truename = _Maklocstr ( _Lobj . _Gettrue ( ), ( _Elem * ) 0, _Cvt );
  } catch ( ... ) {
  _Tidy ( );
  throw;
  }

  if ( _Isdef )
   {

   _Dp = _Maklocchr ( '.', ( _Elem * ) 0, _Cvt );
   _Kseparator = _Maklocchr ( ',', ( _Elem * ) 0, _Cvt );
   }
  else
   _Getvals ( ( _Elem ) 0, _Ptr, _Cvt );
  }

 virtual _Elem do_decimal_point ( ) const
  {
  return ( _Dp );
  }

 virtual _Elem do_thousands_sep ( ) const
  {
  return ( _Kseparator );
  }

 virtual string do_grouping ( ) const
  {
  return ( string ( _Grouping ) );
  }

 virtual string_type do_falsename ( ) const
  {
  return ( string_type ( _Falsename ) );
  }

 virtual string_type do_truename ( ) const
  {
  return ( string_type ( _Truename ) );
  }

private :
 void _Tidy ( )
  {
  delete [ ] ( ( void * ) _Grouping );
  delete [ ] ( ( void * ) _Falsename );
  delete [ ] ( ( void * ) _Truename );
  }

 const char * _Grouping;
 _Elem _Dp;
 _Elem _Kseparator;
 const _Elem * _Falsename;
 const _Elem * _Truename;
 };
#line 231 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
template < class _Elem >
 class numpunct_byname
  : public numpunct < _Elem >
 {
public :
 explicit numpunct_byname ( const char * _Locname, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Locname, _Refs )
  {
  }

 explicit numpunct_byname ( const string & _Str, size_t _Refs = 0 )
  : numpunct < _Elem > ( _Str . c_str ( ), _Refs )
  {
  }

protected :
 virtual ~ numpunct_byname ( ) throw ( )
  {
  }
 };
#line 253
template< class _Elem> locale::id 
#line 254
numpunct< _Elem> ::id; 
#line 257
template < class _Elem,
 class _InIt = istreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_get
  : public locale :: facet
 {
public :
 typedef numpunct < _Elem > _Mypunct;
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  _Mystr;

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new num_get < _Elem, _InIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_get ( ) throw ( )
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

public :
 explicit num_get ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_get ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _InIt iter_type;

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }


 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

 _InIt get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  return ( do_get ( _First, _Last, _Iosbase, _State, _Val ) );
  }

protected :
 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   _Bool & _Val ) const
  {
  ;
  int _Ans = - 1;

  if ( _Iosbase . flags ( ) & ios_base :: boolalpha )
   {
   typedef typename _Mystr :: size_type _Mystrsize;
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str ( ( _Mystrsize ) 1, ( char_type ) 0 );
   _Str += _Punct_fac . falsename ( );
   _Str += ( char_type ) 0;
   _Str += _Punct_fac . truename ( );
   _Ans = _Getloctxt ( _First, _Last, ( size_t ) 2, _Str . c_str ( ) );
   }
  else
   {
   char _Ac [ 32 ], * _Ep;
   int _Errno = 0;
   const unsigned long _Ulo = :: _Stoulx ( _Ac, & _Ep,
    _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
     _Iosbase . getloc ( ) ), & _Errno );
   if ( _Ep != _Ac && _Errno == 0 && _Ulo <= 1 )
    _Ans = _Ulo;
   }

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ans < 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans != 0;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned short & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 65535 < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = ( unsigned short ) ( _Ac [ 0 ] == '-'
    ? 0 - _Ans : _Ans );
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned int & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  int _Base = _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
   _Iosbase . getloc ( ) );
  char * _Ptr = _Ac [ 0 ] == '-' ? _Ac + 1 : _Ac;
  const unsigned long _Ans =
   :: _Stoulx ( _Ptr, & _Ep, _Base, & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ptr || _Errno != 0 || 4294967295U < _Ans )
   _State |= ios_base :: failbit;
  else
   _Val = _Ac [ 0 ] == '-' ? 0 - _Ans : _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const long _Ans = :: _Stolx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned long & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned long _Ans = :: _Stoulx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   __int64 & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const __int64 _Ans = :: _Stollx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   unsigned __int64 & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;
  const unsigned __int64 _Ans = :: _Stoullx ( _Ac, & _Ep,
   _Getifld ( _Ac, _First, _Last, _Iosbase . flags ( ),
    _Iosbase . getloc ( ) ), & _Errno );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }


 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   float & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  float _Ans = :: _Stofx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexpf ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   double & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  double _Ans = :: _Stodx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexp ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   long double & _Val ) const
  {
  ;
  char _Ac [ 8 + 36 + 16 ], * _Ep;
  int _Errno = 0;
  int _Hexexp = 0;
  long double _Ans = :: _Stoldx ( _Ac, & _Ep,
   _Getffld ( _Ac, _First, _Last,
    _Iosbase, & _Hexexp ), & _Errno );

  if ( _Hexexp != 0 )
   _Ans = :: ldexpl ( _Ans, 4 * _Hexexp );

  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = _Ans;
  return ( _First );
  }

 virtual _InIt do_get ( _InIt _First, _InIt _Last,
  ios_base & _Iosbase, ios_base :: iostate & _State,
   void * & _Val ) const
  {
  ;
  char _Ac [ 32 ], * _Ep;
  int _Errno = 0;


  int _Base = _Getifld ( _Ac, _First, _Last, ios_base :: hex,
   _Iosbase . getloc ( ) );
  const unsigned __int64 _Ans =
   ( sizeof ( void * ) == sizeof ( unsigned long ) )
    ? ( unsigned __int64 ) :: _Stoulx ( _Ac, & _Ep, _Base, & _Errno )
    : :: _Stoullx ( _Ac, & _Ep, _Base, & _Errno );







  if ( _First == _Last )
   _State |= ios_base :: eofbit;
  if ( _Ep == _Ac || _Errno != 0 )
   _State |= ios_base :: failbit;
  else
   _Val = ( void * ) ( ( char * ) 0 + _Ans );
  return ( _First );
  }

private :
 int __cdecl _Getifld ( char * _Ac,
  _InIt & _First, _InIt & _Last, ios_base :: fmtflags _Basefield,
   const locale & _Loc ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Loc );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Grouping . size ( ) == 0
   ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24 };
  static const char _Src [ ] = { "0123456789ABCDEFabcdef-+Xx" };
  _Elem _Atoms [ sizeof ( _Src ) - 1 ];
  const ctype < _Elem > & _Ctype_fac =
   use_facet < ctype < _Elem > > ( _Loc );
  _Ctype_fac . widen ( & _Src [ 0 ], & _Src [ sizeof ( _Src ) - 1 ], _Atoms );

  char * _Ptr = _Ac;

  if ( _First == _Last )
   ;
  else if ( * _First == _Atoms [ _NUMGET_SIGNOFF + 1 ] )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Atoms [ _NUMGET_SIGNOFF ] )
   * _Ptr ++ = '-', ++ _First;

  _Basefield &= ios_base :: basefield;
  int _Base = _Basefield == ios_base :: oct ? 8
   : _Basefield == ios_base :: hex ? 16
   : _Basefield == ios_base :: _Fmtzero ? 0 : 10;

  bool _Seendigit = false;
  bool _Nonzero = false;

  if ( _First != _Last && * _First == _Atoms [ 0 ] )
   {
   _Seendigit = true, ++ _First;
   if ( _First != _Last && ( * _First == _Atoms [ _NUMGET_XOFF + 1 ]
     || * _First == _Atoms [ _NUMGET_XOFF ] )
    && ( _Base == 0 || _Base == 16 ) )
    _Base = 16, _Seendigit = false, ++ _First;
   else if ( _Base == 0 )
    _Base = 8;
   }

  size_t _Dlen = _Base == 0 || _Base == 10 ? 10
   : _Base == 8 ? 8 : 16 + 6;
  string _Groups ( ( size_t ) 1, ( char ) _Seendigit );
  size_t _Group = 0;

  for ( char * const _Pe = & _Ac [ 32 - 1 ];
   _First != _Last; ++ _First )
   {
   size_t _Idx = _Find_elem ( _Atoms, * _First );
   if ( _Idx < _Dlen )
    {
    * _Ptr = _Src [ _Idx ];
    if ( ( _Nonzero || * _Ptr != '0' ) && _Ptr < _Pe )
     ++ _Ptr, _Nonzero = true;
    _Seendigit = true;
    if ( _Groups [ _Group ] != 127 )
     ++ _Groups [ _Group ];
    }
   else if ( _Groups [ _Group ] == '\000'
    || _Kseparator == ( _Elem ) 0
    || * _First != _Kseparator )
    break;
   else
    {
    _Groups . append ( ( string :: size_type ) 1, '\000' );
    ++ _Group;
    }
   }

  if ( _Group == 0 )
   ;
  else if ( '\000' < _Groups [ _Group ] )
   ++ _Group;
  else
   _Seendigit = false;

  for ( const char * _Pg = & _Grouping [ 0 ]; _Seendigit && 0 < _Group; )
   if ( * _Pg == 127 )
    break;
   else if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] )
    || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) )
    _Seendigit = false;
   else if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;

  if ( _Seendigit && ! _Nonzero )
   * _Ptr ++ = '0';
  else if ( ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Base );
  }

 int __cdecl _Getffld ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: hexfloat )
   return ( _Getffldx ( _Ac, _First, _Last,
    _Iosbase, _Phexexp ) );

  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  char * _Ptr = _Ac;
  bool _Bad = false;

  enum {
   _NUMGET_SIGNOFF = 10,
   _NUMGET_EOFF = 12 };
  static const char _Src [ ] = { "0123456789-+Ee" };
  _Elem _Atoms [ sizeof ( _Src ) - 1 ];
  const ctype < _Elem > & _Ctype_fac =
   use_facet < ctype < _Elem > > ( _Iosbase . getloc ( ) );
  _Ctype_fac . widen ( & _Src [ 0 ], & _Src [ sizeof ( _Src ) - 1 ], _Atoms );

  if ( _First == _Last )
   ;
  else if ( * _First == _Atoms [ _NUMGET_SIGNOFF + 1 ] )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Atoms [ _NUMGET_SIGNOFF ] )
   * _Ptr ++ = '-', ++ _First;

  bool _Seendigit = false;
  int _Significant = 0;
  int _Pten = 0;
  size_t _Idx;

  const char * _Pg = & _Grouping [ 0 ];
  if ( * _Pg == 127 || * _Pg <= '\000' )
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10;
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Pten;
    else if ( _Idx == 0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10 )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Pten;
     else if ( _Idx == 0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = _Src [ _Idx ];
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   while ( ! _Bad && 0 < _Group )
    if ( * _Pg == 127 )
     break;
    else if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] )
     || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _Atoms [ 0 ];
    _Seendigit = true, ++ _First )
    -- _Pten;
   if ( _Pten < 0 )
    * _Ptr ++ = '0', ++ _Pten;
   }

  for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10;
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = _Src [ _Idx ];
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Atoms [ _NUMGET_EOFF + 1 ]
    || * _First == _Atoms [ _NUMGET_EOFF ] ) )
   {
   * _Ptr ++ = 'e', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Atoms [ _NUMGET_SIGNOFF + 1 ] )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Atoms [ _NUMGET_SIGNOFF ] )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _Atoms [ 0 ]; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < 10;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  return ( _Pten );
  }

 int __cdecl _Getffldx ( char * _Ac,
  _InIt & _First, _InIt & _Last,
  ios_base & _Iosbase, int * _Phexexp ) const
  {
  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );

  enum {
   _NUMGET_SIGNOFF = 22,
   _NUMGET_XOFF = 24,
   _NUMGET_POFF = 26 };
  static const char _Src [ ] = { "0123456789ABCDEFabcdef-+XxPp" };
  _Elem _Atoms [ sizeof ( _Src ) - 1 ];
  const ctype < _Elem > & _Ctype_fac =
   use_facet < ctype < _Elem > > ( _Iosbase . getloc ( ) );
  _Ctype_fac . widen ( & _Src [ 0 ], & _Src [ sizeof ( _Src ) - 1 ], _Atoms );

  char * _Ptr = _Ac;
  bool _Bad = false;
  size_t _Idx;

  if ( _First == _Last )
   ;
  else if ( * _First == _Atoms [ _NUMGET_SIGNOFF + 1 ] )
   * _Ptr ++ = '+', ++ _First;
  else if ( * _First == _Atoms [ _NUMGET_SIGNOFF ] )
   * _Ptr ++ = '-', ++ _First;

  * _Ptr ++ = '0';
  * _Ptr ++ = 'x';

  bool _Seendigit = false;
  int _Significant = 0;
  int _Phex = 0;

  if ( _First == _Last || * _First != _Atoms [ 0 ] )
   ;
  else if ( ++ _First != _Last
   && ( * _First == _Atoms [ _NUMGET_XOFF + 1 ]
     || * _First == _Atoms [ _NUMGET_XOFF ] ) )
   ++ _First;
  else
   _Seendigit = true;

  const char * _Pg = & _Grouping [ 0 ];
  if ( * _Pg == 127 || * _Pg <= '\000' )
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _NUMGET_SIGNOFF;
     _Seendigit = true, ++ _First )
    if ( 36 <= _Significant )
     ++ _Phex;
    else if ( _Idx == 0 && _Significant == 0 )
     ;
    else
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
  else
   {
   const _Elem _Kseparator = _Grouping . size ( ) == 0
    ? ( _Elem ) 0 : _Punct_fac . thousands_sep ( );
   string _Groups ( ( size_t ) 1, '\000' );
   size_t _Group = 0;

   for (; _First != _Last; ++ _First )
    if ( ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _NUMGET_SIGNOFF )
     {
     _Seendigit = true;
     if ( 36 <= _Significant )
      ++ _Phex;
     else if ( _Idx == 0 && _Significant == 0 )
      ;
     else
      {
      * _Ptr ++ = _Src [ _Idx ];
      ++ _Significant;
      }
     if ( _Groups [ _Group ] != 127 )
      ++ _Groups [ _Group ];
     }
    else if ( _Groups [ _Group ] == '\000'
     || _Kseparator == ( _Elem ) 0
     || * _First != _Kseparator )
     break;
    else
     {
     _Groups . append ( ( size_t ) 1, '\000' );
     ++ _Group;
     }
   if ( _Group == 0 )
    ;
   else if ( '\000' < _Groups [ _Group ] )
    ++ _Group;
   else
    _Bad = true;

   while ( ! _Bad && 0 < _Group )
    if ( * _Pg == 127 )
     break;
    else if ( ( 0 < -- _Group && * _Pg != _Groups [ _Group ] )
     || ( 0 == _Group && * _Pg < _Groups [ _Group ] ) )
     _Bad = true;
    else if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
   }

  if ( _Seendigit && _Significant == 0 )
   * _Ptr ++ = '0';

  if ( _First != _Last && * _First == _Punct_fac . decimal_point ( ) )
   * _Ptr ++ = localeconv ( ) -> decimal_point [ 0 ], ++ _First;

  if ( _Significant == 0 )
   {
   for (; _First != _Last && * _First == _Atoms [ 0 ];
    _Seendigit = true, ++ _First )
    -- _Phex;
   if ( _Phex < 0 )
    * _Ptr ++ = '0', ++ _Phex;
   }

  for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++ _First )
   if ( _Significant < 36 )
    {
    * _Ptr ++ = _Src [ _Idx ];
    ++ _Significant;
    }

  if ( _Seendigit && _First != _Last
   && ( * _First == _Atoms [ _NUMGET_POFF + 1 ]
    || * _First == _Atoms [ _NUMGET_POFF ] ) )
   {
   * _Ptr ++ = 'p', ++ _First;
   _Seendigit = false, _Significant = 0;

   if ( _First == _Last )
    ;
   else if ( * _First == _Atoms [ _NUMGET_SIGNOFF + 1 ] )
    * _Ptr ++ = '+', ++ _First;
   else if ( * _First == _Atoms [ _NUMGET_SIGNOFF ] )
    * _Ptr ++ = '-', ++ _First;
   for (; _First != _Last && * _First == _Atoms [ 0 ]; )
    _Seendigit = true, ++ _First;
   if ( _Seendigit )
    * _Ptr ++ = '0';
   for (; _First != _Last
    && ( _Idx = _Find_elem ( _Atoms, * _First ) ) < _NUMGET_SIGNOFF;
    _Seendigit = true, ++ _First )
    if ( _Significant < 8 )
     {
     * _Ptr ++ = _Src [ _Idx ];
     ++ _Significant;
     }
   }

  if ( _Bad || ! _Seendigit )
   _Ptr = _Ac;
  * _Ptr = '\000';
  * _Phexexp = _Phex;
  return ( 0 );
  }
 };
#line 1073 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
template< class _Elem, class 
#line 1074
_InIt> locale::id 
#line 1075
num_get< _Elem, _InIt> ::id; 
#line 1078
template < class _Elem,
 class _OutIt = ostreambuf_iterator < _Elem, char_traits < _Elem > > >
 class num_put
  : public locale :: facet
 {
public :
 typedef numpunct < _Elem > _Mypunct;
 typedef basic_string < _Elem, char_traits < _Elem >, allocator < _Elem > >
  _Mystr;

 static size_t __cdecl _Getcat ( const locale :: facet * * _Ppf = 0,
  const locale * _Ploc = 0 )
  {
  if ( _Ppf != 0 && * _Ppf == 0 )
   * _Ppf = new num_put < _Elem, _OutIt > (
    _Locinfo ( _Ploc -> c_str ( ) ) );
  return ( 4 );
  }

  static locale :: id id;

protected :
 virtual ~ num_put ( ) throw ( )
  {
  }

 void _Init ( const _Locinfo & )
  {
  }

public :
 explicit num_put ( size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  { _Locinfo _Lobj;
   _Init ( _Lobj );
  }
  }

  num_put ( const _Locinfo & _Lobj, size_t _Refs = 0 )
  : locale :: facet ( _Refs )
  {
  _Init ( _Lobj );
  }

 typedef _Elem char_type;
 typedef _OutIt iter_type;

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }


 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

 _OutIt put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  return ( do_put ( _Dest, _Iosbase, _Fill, _Val ) );
  }

protected :
 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, _Bool _Val ) const
  {
  ;
  if ( ! ( _Iosbase . flags ( ) & ios_base :: boolalpha ) )
   return ( do_put ( _Dest, _Iosbase, _Fill, ( long ) _Val ) );
  else
   {
   const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
   _Mystr _Str;
   if ( _Val )
    _Str . assign ( _Punct_fac . truename ( ) );
   else
    _Str . assign ( _Punct_fac . falsename ( ) );

   size_t _Fillcount = _Iosbase . width ( ) <= 0
    || ( size_t ) _Iosbase . width ( ) <= _Str . size ( )
     ? 0 : ( size_t ) _Iosbase . width ( ) - _Str . size ( );

   if ( ( _Iosbase . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
    {
    _Dest = _Rep ( _Dest, _Fill, _Fillcount );
    _Fillcount = 0;
    }
   _Dest = _Put ( _Dest, _Str . c_str ( ), _Str . size ( ) );
   _Iosbase . width ( 0 );
   return ( _Rep ( _Dest, _Fill, _Fillcount ) );
   }
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned long _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 6 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, __int64 _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Ld",
    _Iosbase . flags ( ) ), _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, unsigned __int64 _Val ) const
  {
  char _Buf [ 2 * 32 ], _Fmt [ 8 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), _Ifmt ( _Fmt, "Lu",
    _Iosbase . flags ( ) ), _Val ) ) );
  }


 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, double _Val ) const
  {
  char _Buf [ 8 + 36 + 64 ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed
   && _Val * (0.5) != _Val )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, ( size_t ) _Precision,
    :: sprintf_s ( _Buf, sizeof ( _Buf ),
     _Ffmt ( _Fmt, 0, _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, long double _Val ) const
  {
  char _Buf [ 8 + 36 + 64 ], _Fmt [ 8 ];
  streamsize _Precision = _Iosbase . precision ( ) <= 0
   && ! ( _Iosbase . flags ( ) & ios_base :: fixed )
    ? 6 : _Iosbase . precision ( );
  int _Significance = 36 < _Precision
   ? 36 : ( int ) _Precision;
  _Precision -= _Significance;
  size_t _Beforepoint = 0;
  size_t _Afterpoint = 0;

  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) == ios_base :: fixed )
   {
   bool _Signed = _Val < 0;
   if ( _Signed )
    _Val = - _Val;

   for (; (9.9999999999999997e+034) <= _Val && _Beforepoint < 5000; _Beforepoint += 10 )
    _Val /= (10000000000.0);

   if ( 0 < _Val )
    for (; 10 <= _Precision && _Val <= (1e-035)
     && _Afterpoint < 5000; _Afterpoint += 10 )
     {
     _Val *= (10000000000.0);
     _Precision -= 10;
     }

   if ( _Signed )
    _Val = - _Val;
   }

  return ( _Fput ( _Dest, _Iosbase, _Fill, _Buf,
   _Beforepoint, _Afterpoint, ( size_t ) _Precision,
    :: sprintf_s ( _Buf, sizeof ( _Buf ),
     _Ffmt ( _Fmt, 'L', _Iosbase . flags ( ) ),
     _Significance, _Val ) ) );
  }

 virtual _OutIt do_put ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const void * _Val ) const
  {
  char _Buf [ 2 * 32 ];

  return ( _Iput ( _Dest, _Iosbase, _Fill, _Buf,
   :: sprintf_s ( _Buf, sizeof ( _Buf ), "%p", _Val ) ) );
  }

private :
 char * __cdecl _Ffmt ( char * _Fmt,
  char _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showpoint )
   * _Ptr ++ = '#';
  * _Ptr ++ = '.';
  * _Ptr ++ = '*';
  if ( _Spec != '\000' )
   * _Ptr ++ = _Spec;

  ios_base :: fmtflags _Ffl = _Flags & ios_base :: floatfield;
  if ( _Flags & ios_base :: uppercase )
   * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
    : _Ffl == ios_base :: hexfloat ? 'A'
    : _Ffl == ios_base :: scientific ? 'E' : 'G';
  else
   * _Ptr ++ = _Ffl == ios_base :: fixed ? 'f'
    : _Ffl == ios_base :: hexfloat ? 'a'
    : _Ffl == ios_base :: scientific ? 'e' : 'g';

  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Fput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, const char * _Buf,
   size_t _Beforepoint, size_t _Afterpoint,
    size_t _Trailing, size_t _Count ) const
  {
  ;
  size_t _Prefix = 0 < _Count && ( * _Buf == '+' || * _Buf == '-' )
   ? 1 : 0;

  const char * _Exps;
  if ( ( _Iosbase . flags ( ) & ios_base :: floatfield ) != ios_base :: hexfloat )
   _Exps = "eE";
  else
   {
   _Exps = "pP";
   if ( _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
    && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) )
    _Prefix += 2;
   }
  const size_t _Eoff =
   :: strcspn ( & _Buf [ 0 ], _Exps );
  char _Dp [ 2 ] = { "." };
  _Dp [ 0 ] = :: localeconv ( ) -> decimal_point [ 0 ];
  const size_t _Poff =
   :: strcspn ( & _Buf [ 0 ], & _Dp [ 0 ] );

  const ctype < _Elem > & _Ctype_fac =
   use_facet < ctype < _Elem > > ( _Iosbase . getloc ( ) );
  const _Elem _E0 = _Ctype_fac . widen ( '0' );
  _Mystr _Groupstring ( _Count, _Elem ( 0 ) );
  _Ctype_fac . widen ( & _Buf [ 0 ], & _Buf [ _Count ], & _Groupstring [ 0 ] );

  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const _Elem _Kseparator = _Punct_fac . thousands_sep ( );

  size_t _Off = _Beforepoint;
  if ( _Poff == _Count )
   {
   _Off += _Eoff;
   _Groupstring . insert ( _Eoff, _Beforepoint, _E0 );
   }
  else
   {
   _Off += _Poff;
   _Groupstring . insert ( _Eoff, _Trailing, _E0 );
   _Groupstring . insert ( _Poff + 1, _Afterpoint, _E0 );
   _Groupstring [ _Poff ] = _Punct_fac . decimal_point ( );
   _Groupstring . insert ( _Poff, _Beforepoint, _E0 );
   }

  const char * _Pg = & _Grouping [ 0 ];
  while ( * _Pg != 127 && '\000' < * _Pg
   && ( size_t ) * _Pg < _Off - _Prefix )
   {
   _Groupstring . insert ( _Off -= * _Pg, ( size_t ) 1, _Kseparator );
   if ( '\000' < _Pg [ 1 ] )
    ++ _Pg;
   }

  _Count = _Groupstring . size ( );
  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );

  _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 char * __cdecl _Ifmt ( char * _Fmt,
  const char * _Spec, ios_base :: fmtflags _Flags ) const
  {
  char * _Ptr = _Fmt;
  * _Ptr ++ = '%';

  if ( _Flags & ios_base :: showpos )
   * _Ptr ++ = '+';
  if ( _Flags & ios_base :: showbase )
   * _Ptr ++ = '#';
  if ( _Spec [ 0 ] != 'L' )
   * _Ptr ++ = _Spec [ 0 ];
  else

   {
   * _Ptr ++ = 'I';
   * _Ptr ++ = '6';
   * _Ptr ++ = '4';
   }

  ios_base :: fmtflags _Basefield = _Flags & ios_base :: basefield;
  * _Ptr ++ = _Basefield == ios_base :: oct ? 'o'
   : _Basefield != ios_base :: hex ? _Spec [ 1 ]
   : _Flags & ios_base :: uppercase ? 'X' : 'x';
  * _Ptr = '\000';
  return ( _Fmt );
  }

 _OutIt __cdecl _Iput ( _OutIt _Dest,
  ios_base & _Iosbase, _Elem _Fill, char * _Buf, size_t _Count ) const
  {
  ;
  size_t _Prefix = 0 < _Count && ( * _Buf == '+' || * _Buf == '-' )
   ? 1 : 0;
  if ( ( _Iosbase . flags ( ) & ios_base :: basefield ) == ios_base :: hex
   && _Prefix + 2 <= _Count && _Buf [ _Prefix ] == '0'
   && ( _Buf [ _Prefix + 1 ] == 'x' || _Buf [ _Prefix + 1 ] == 'X' ) )
   _Prefix += 2;

  const ctype < _Elem > & _Ctype_fac =
   use_facet < ctype < _Elem > > ( _Iosbase . getloc ( ) );
  _Mystr _Groupstring ( _Count, _Elem ( 0 ) );
  _Ctype_fac . widen ( & _Buf [ 0 ], & _Buf [ _Count ], & _Groupstring [ 0 ] );

  const _Mypunct & _Punct_fac = use_facet < _Mypunct > ( _Iosbase . getloc ( ) );
  const string _Grouping = _Punct_fac . grouping ( );
  const char * _Pg = & _Grouping [ 0 ];
  if ( * _Pg != 127 && '\000' < * _Pg )
   {
   const _Elem _Kseparator = _Punct_fac . thousands_sep ( );
   while ( * _Pg != 127 && '\000' < * _Pg
    && ( size_t ) * _Pg < _Count - _Prefix )
    {
    _Count -= * _Pg;
    _Groupstring . insert ( _Count, 1, _Kseparator );
    if ( '\000' < _Pg [ 1 ] )
     ++ _Pg;
    }
   }

  _Count = _Groupstring . size ( );
  size_t _Fillcount = _Iosbase . width ( ) <= 0
   || ( size_t ) _Iosbase . width ( ) <= _Count
    ? 0 : ( size_t ) _Iosbase . width ( ) - _Count;

  ios_base :: fmtflags _Adjustfield =
   _Iosbase . flags ( ) & ios_base :: adjustfield;
  if ( _Adjustfield != ios_base :: left
   && _Adjustfield != ios_base :: internal )
   {
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   }
  else if ( _Adjustfield == ios_base :: internal )
   {
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );
   _Dest = _Rep ( _Dest, _Fill, _Fillcount );
   _Fillcount = 0;
   }
  else
   _Dest = _Put ( _Dest, & _Groupstring [ 0 ], _Prefix );

  _Dest = _Put ( _Dest, & _Groupstring [ _Prefix ], _Count - _Prefix );
  _Iosbase . width ( 0 );
  return ( _Rep ( _Dest, _Fill, _Fillcount ) );
  }

 _OutIt __cdecl _Put ( _OutIt _Dest,
  const _Elem * _Ptr, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest, ++ _Ptr )
   * _Dest = * _Ptr;
  return ( _Dest );
  }

 _OutIt __cdecl _Rep ( _OutIt _Dest,
  _Elem _Ch, size_t _Count ) const
  {
  for (; 0 < _Count; -- _Count, ++ _Dest )
   * _Dest = _Ch;
  return ( _Dest );
  }
 };
#line 1565 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
template< class _Elem, class 
#line 1566
_OutIt> locale::id 
#line 1567
num_put< _Elem, _OutIt> ::id; 
#line 1572
template locale::id numpunct< char> ::id;
#line 1573
template class __declspec(dllimport) num_get< char, istreambuf_iterator< char, char_traits< char> > > ;
#line 1575
template class __declspec(dllimport) num_put< char, ostreambuf_iterator< char, char_traits< char> > > ;
#line 1578
template locale::id numpunct< __wchar_t> ::id;
#line 1579
template class __declspec(dllimport) num_get< __wchar_t, istreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1581
template class __declspec(dllimport) num_put< __wchar_t, ostreambuf_iterator< __wchar_t, char_traits< __wchar_t> > > ;
#line 1593 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
}
#line 1595
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ios"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4189)
#line 1596 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\xlocnum"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ios"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 17
template < class _Elem,
 class _Traits >
 class basic_ios
  : public ios_base
 {
public :
 typedef basic_ios < _Elem, _Traits > _Myt;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ctype < _Elem > _Ctype;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_ios ( _Mysb * _Strbuf )
  {
  init ( _Strbuf );
  }

 virtual ~ basic_ios ( ) throw ( )
  {
  }

 void clear ( iostate _State = goodbit,
  bool _Reraise = false )
  {
  ios_base :: clear ( ( iostate ) ( _Mystrbuf == 0
   ? ( int ) _State | ( int ) badbit : ( int ) _State ), _Reraise );
  }

 void clear ( io_state _State )
  {
  clear ( ( iostate ) _State );
  }

 void setstate ( iostate _State,
  bool _Reraise = false )
  {
  if ( _State != goodbit )
   clear ( ( iostate ) ( ( int ) rdstate ( ) | ( int ) _State ), _Reraise );
  }

 void setstate ( io_state _State )
  {
  setstate ( ( iostate ) _State );
  }

 _Myt & copyfmt ( const _Myt & _Right )
  {
  _Tiestr = _Right . tie ( );
  _Fillch = _Right . fill ( );
  ios_base :: copyfmt ( _Right );
  return ( * this );
  }

 _Myos * tie ( ) const
  {
  return ( _Tiestr );
  }

 _Myos * tie ( _Myos * _Newtie )
  {
  _Myos * _Oldtie = _Tiestr;
  _Tiestr = _Newtie;
  return ( _Oldtie );
  }

 _Mysb * rdbuf ( ) const
  {
  return ( _Mystrbuf );
  }

 _Mysb * rdbuf ( _Mysb * _Strbuf )
  {
  _Mysb * _Oldstrbuf = _Mystrbuf;
  _Mystrbuf = _Strbuf;
  clear ( );
  return ( _Oldstrbuf );
  }

 locale imbue ( const locale & _Loc )
  {
  locale _Oldlocale = ios_base :: imbue ( _Loc );
  if ( rdbuf ( ) != 0 )
   rdbuf ( ) -> pubimbue ( _Loc );
  return ( _Oldlocale );
  }

 _Elem fill ( ) const
  {
  return ( _Fillch );
  }

 _Elem fill ( _Elem _Newfill )
  {
  _Elem _Oldfill = _Fillch;
  _Fillch = _Newfill;
  return ( _Oldfill );
  }

 char narrow ( _Elem _Ch, char _Dflt = '\000' ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . narrow ( _Ch, _Dflt ) );
  }

 _Elem widen ( char _Byte ) const
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( getloc ( ) );
  return ( _Ctype_fac . widen ( _Byte ) );
  }

 void move ( _Myt & _Right )
  {
  if ( this != & _Right )
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this -> swap ( _Right );
   }
  }

 void move ( _Myt && _Right )
  {
  if ( this != & _Right )
   {
   _Mystrbuf = 0;
   _Tiestr = 0;
   this -> swap ( _Right );
   }
  }

 void swap ( _Myt & _Right ) throw ( )
  {
  ios_base :: swap ( _Right );
  :: std :: swap ( _Fillch, _Right . _Fillch );
  :: std :: swap ( _Tiestr, _Right . _Tiestr );
  }

 void set_rdbuf ( _Mysb * _Strbuf )
  {
  _Mystrbuf = _Strbuf;
  }

protected :
 void init ( _Mysb * _Strbuf = 0,
  bool _Isstd = false )
  {
  _Init ( );
  _Mystrbuf = _Strbuf;
  _Tiestr = 0;
  _Fillch = widen ( ' ' );

  if ( _Mystrbuf == 0 )
   setstate ( badbit );

  if ( _Isstd )
   _Addstd ( this );
  }

  basic_ios ( )
  {
  }

private :
 _Mysb * _Mystrbuf;
 _Myos * _Tiestr;
 _Elem _Fillch;

public :
  basic_ios ( const _Myt & ) = delete;
 _Myt & operator = ( const _Myt & ) = delete;
 };
#line 196
template class __declspec(dllimport) basic_ios< char, char_traits< char> > ;
#line 198
template class __declspec(dllimport) basic_ios< __wchar_t, char_traits< __wchar_t> > ;
#line 209 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ios"
inline ios_base &__cdecl boolalpha(ios_base &_Iosbase) 
#line 210
{ 
#line 211
_Iosbase.setf(_Iosb< int> ::boolalpha); 
#line 212
return _Iosbase; 
#line 213
} 
#line 215
inline ios_base &__cdecl dec(ios_base &_Iosbase) 
#line 216
{ 
#line 217
_Iosbase.setf(_Iosb< int> ::dec, _Iosb< int> ::basefield); 
#line 218
return _Iosbase; 
#line 219
} 
#line 221
inline ios_base &__cdecl defaultfloat(ios_base &_Iosbase) 
#line 222
{ 
#line 223
_Iosbase.unsetf(_Iosb< int> ::floatfield); 
#line 224
return _Iosbase; 
#line 225
} 
#line 227
inline ios_base &__cdecl fixed(ios_base &_Iosbase) 
#line 228
{ 
#line 229
_Iosbase.setf(_Iosb< int> ::fixed, _Iosb< int> ::floatfield); 
#line 230
return _Iosbase; 
#line 231
} 
#line 233
inline ios_base &__cdecl hex(ios_base &_Iosbase) 
#line 234
{ 
#line 235
_Iosbase.setf(_Iosb< int> ::hex, _Iosb< int> ::basefield); 
#line 236
return _Iosbase; 
#line 237
} 
#line 239
inline ios_base &__cdecl hexfloat(ios_base &_Iosbase) 
#line 240
{ 
#line 241
_Iosbase.setf(_Iosb< int> ::hexfloat, _Iosb< int> ::floatfield); 
#line 242
return _Iosbase; 
#line 243
} 
#line 245
namespace tr1 { 
#line 246
using std::hexfloat;
#line 247
}
#line 249
inline ios_base &__cdecl internal(ios_base &_Iosbase) 
#line 250
{ 
#line 251
_Iosbase.setf(_Iosb< int> ::internal, _Iosb< int> ::adjustfield); 
#line 252
return _Iosbase; 
#line 253
} 
#line 255
inline ios_base &__cdecl left(ios_base &_Iosbase) 
#line 256
{ 
#line 257
_Iosbase.setf(_Iosb< int> ::left, _Iosb< int> ::adjustfield); 
#line 258
return _Iosbase; 
#line 259
} 
#line 261
inline ios_base &__cdecl noboolalpha(ios_base &_Iosbase) 
#line 262
{ 
#line 263
_Iosbase.unsetf(_Iosb< int> ::boolalpha); 
#line 264
return _Iosbase; 
#line 265
} 
#line 267
inline ios_base &__cdecl noshowbase(ios_base &_Iosbase) 
#line 268
{ 
#line 269
_Iosbase.unsetf(_Iosb< int> ::showbase); 
#line 270
return _Iosbase; 
#line 271
} 
#line 273
inline ios_base &__cdecl noshowpoint(ios_base &_Iosbase) 
#line 274
{ 
#line 275
_Iosbase.unsetf(_Iosb< int> ::showpoint); 
#line 276
return _Iosbase; 
#line 277
} 
#line 279
inline ios_base &__cdecl noshowpos(ios_base &_Iosbase) 
#line 280
{ 
#line 281
_Iosbase.unsetf(_Iosb< int> ::showpos); 
#line 282
return _Iosbase; 
#line 283
} 
#line 285
inline ios_base &__cdecl noskipws(ios_base &_Iosbase) 
#line 286
{ 
#line 287
_Iosbase.unsetf(_Iosb< int> ::skipws); 
#line 288
return _Iosbase; 
#line 289
} 
#line 291
inline ios_base &__cdecl nounitbuf(ios_base &_Iosbase) 
#line 292
{ 
#line 293
_Iosbase.unsetf(_Iosb< int> ::unitbuf); 
#line 294
return _Iosbase; 
#line 295
} 
#line 297
inline ios_base &__cdecl nouppercase(ios_base &_Iosbase) 
#line 298
{ 
#line 299
_Iosbase.unsetf(_Iosb< int> ::uppercase); 
#line 300
return _Iosbase; 
#line 301
} 
#line 303
inline ios_base &__cdecl oct(ios_base &_Iosbase) 
#line 304
{ 
#line 305
_Iosbase.setf(_Iosb< int> ::oct, _Iosb< int> ::basefield); 
#line 306
return _Iosbase; 
#line 307
} 
#line 309
inline ios_base &__cdecl right(ios_base &_Iosbase) 
#line 310
{ 
#line 311
_Iosbase.setf(_Iosb< int> ::right, _Iosb< int> ::adjustfield); 
#line 312
return _Iosbase; 
#line 313
} 
#line 315
inline ios_base &__cdecl scientific(ios_base &_Iosbase) 
#line 316
{ 
#line 317
_Iosbase.setf(_Iosb< int> ::scientific, _Iosb< int> ::floatfield); 
#line 318
return _Iosbase; 
#line 319
} 
#line 321
inline ios_base &__cdecl showbase(ios_base &_Iosbase) 
#line 322
{ 
#line 323
_Iosbase.setf(_Iosb< int> ::showbase); 
#line 324
return _Iosbase; 
#line 325
} 
#line 327
inline ios_base &__cdecl showpoint(ios_base &_Iosbase) 
#line 328
{ 
#line 329
_Iosbase.setf(_Iosb< int> ::showpoint); 
#line 330
return _Iosbase; 
#line 331
} 
#line 333
inline ios_base &__cdecl showpos(ios_base &_Iosbase) 
#line 334
{ 
#line 335
_Iosbase.setf(_Iosb< int> ::showpos); 
#line 336
return _Iosbase; 
#line 337
} 
#line 339
inline ios_base &__cdecl skipws(ios_base &_Iosbase) 
#line 340
{ 
#line 341
_Iosbase.setf(_Iosb< int> ::skipws); 
#line 342
return _Iosbase; 
#line 343
} 
#line 345
inline ios_base &__cdecl unitbuf(ios_base &_Iosbase) 
#line 346
{ 
#line 347
_Iosbase.setf(_Iosb< int> ::unitbuf); 
#line 348
return _Iosbase; 
#line 349
} 
#line 351
inline ios_base &__cdecl uppercase(ios_base &_Iosbase) 
#line 352
{ 
#line 353
_Iosbase.setf(_Iosb< int> ::uppercase); 
#line 354
return _Iosbase; 
#line 355
} 
#line 356
}
#line 359
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ostream"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4189 4390)
#line 360 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ios"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ostream"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#line 35 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ostream"
#pragma vtordisp(push, 2)
#line 38
template < class _Elem,
 class _Traits >
 class basic_ostream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_ostream < _Elem, _Traits > _Myt;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef ostreambuf_iterator < _Elem, _Traits > _Iter;
 typedef num_put < _Elem, _Iter > _Nput;

 explicit basic_ostream (
  basic_streambuf < _Elem, _Traits > * _Strbuf,

  bool _Isstd = false )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_ostream ( _Uninitialized, bool _Addit = true )
  {
  if ( _Addit )
   this -> _Addstd ( this );
  }

protected :
  basic_ostream ( _Myt && _Right )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   _Myios :: swap ( _Right );
  }

public :
  basic_ostream ( const _Myt & ) = delete;
 _Myt & operator = ( const _Myt & ) = delete;

 virtual ~ basic_ostream ( ) throw ( )
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 class _Sentry_base
  {
 public :
   _Sentry_base ( _Myt & _Ostr )
   : _Myostr ( _Ostr )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( ) throw ( )
   {
   if ( _Myostr . rdbuf ( ) != 0 )
    _Myostr . rdbuf ( ) -> _Unlock ( );
   }

  _Myt & _Myostr;

 private :
  _Sentry_base & operator = ( const _Sentry_base & );
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( _Myt & _Ostr )
   : _Sentry_base ( _Ostr )
   {
   if ( _Ostr . good ( ) && _Ostr . tie ( ) != 0 && _Ostr . tie ( ) != & _Ostr )
    _Ostr . tie ( ) -> flush ( );
   _Ok = _Ostr . good ( );
   }

   ~ sentry ( ) throw ( )
   {

   if ( ! :: std :: uncaught_exception ( ) )
    this -> _Myostr . _Osfx ( );




   }

  explicit operator bool ( ) const
   {
   return ( _Ok );
   }

 private :
  bool _Ok;

 public :
   sentry ( const sentry & ) = delete;
  sentry & operator = ( const sentry & ) = delete;
  };

 bool opfx ( )
  {
  if ( this -> good ( ) && _Myios :: tie ( ) != 0 && _Myios :: tie ( ) != this )
   _Myios :: tie ( ) -> flush ( );
  return ( this -> good ( ) );
  }

 void osfx ( )
  {
  _Osfx ( );
  }

 void _Osfx ( )
  {
  try {
  if ( this -> good ( ) && this -> flags ( ) & ios_base :: unitbuf )
   if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
    _Myios :: setstate ( ios_base :: badbit );
  } catch ( ... ) {
  }
  }























 _Myt & operator << ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  ;
  return ( ( * _Pfn ) ( * this ) );
  }

 _Myt & operator << ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ;
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 _Myt & operator << ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ;
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 _Myt & operator << ( _Bool _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );
   ios_base :: fmtflags _Bfl =
    this -> flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned short ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }










 _Myt & operator << ( unsigned short _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );
   ios_base :: fmtflags _Bfl =
    this -> flags ( ) & ios_base :: basefield;
   long _Tmp = ( _Bfl == ios_base :: oct
    || _Bfl == ios_base :: hex )
    ? ( long ) ( unsigned int ) _Val : ( long ) _Val;

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Tmp ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned int _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( unsigned long ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned long _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator << ( __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( unsigned __int64 _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator << ( float _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), ( double ) _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( long double _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( const void * _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nput & _Nput_fac = use_facet < _Nput > ( this -> getloc ( ) );

   try {
   if ( _Nput_fac . put ( _Iter ( _Myios :: rdbuf ( ) ), * this,
    _Myios :: fill ( ), _Val ) . failed ( ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator << ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   for ( int_type _Meta = _Traits :: eof ( );; _Copied = true )
    {
    try {
    _Meta = _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta )
     ? _Strbuf -> sgetc ( ) : _Strbuf -> snextc ( );
    } catch ( ... ) {
     _Myios :: setstate ( ios_base :: failbit );
     throw;
    }

    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     break;

    try {
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
      _Myios :: rdbuf ( ) -> sputc (
       _Traits :: to_char_type ( _Meta ) ) ) )
      {
      _State |= ios_base :: badbit;
      break;
      }
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

  this -> width ( 0 );
  _Myios :: setstate ( _Strbuf == 0 ? ios_base :: badbit
   : ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 _Myt & put ( _Elem _Ch )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputc ( _Ch ) ) )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & write ( const _Elem * _Str,
  streamsize _Count )
  {





  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( ! _Ok )
   _State |= ios_base :: badbit;
  else
   {
   try {
   if ( _Myios :: rdbuf ( ) -> sputn ( _Str, _Count ) != _Count )
    _State |= ios_base :: badbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & flush ( )
  {
  if ( _Myios :: rdbuf ( ) != 0 )
   {
   const sentry _Ok ( * this );

   if ( _Ok && _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
    _Myios :: setstate ( ios_base :: badbit );
   }
  return ( * this );
  }

 _Myt & seekp ( pos_type _Pos )
  {
  const sentry _Ok ( * this );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 _Myt & seekp ( off_type _Off, ios_base :: seekdir _Way )
  {
  const sentry _Ok ( * this );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: out ) == _BADOFF )
   _Myios :: setstate ( ios_base :: failbit );
  return ( * this );
  }

 pos_type tellp ( )
  {
  const sentry _Ok ( * this );

  if ( ! this -> fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: out ) );
  else
   return ( pos_type ( _BADOFF ) );
  }
 };
#line 626 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ostream"
#pragma vtordisp(pop)
#line 683
template class __declspec(dllimport) basic_ostream< char, char_traits< char> > ;
#line 685
template class __declspec(dllimport) basic_ostream< __wchar_t, char_traits< __wchar_t> > ;
#line 697 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ostream"
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const char * _Val )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) :: strlen ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  for (; _State == ios_base :: goodbit && 0 < _Count; -- _Count, ++ _Val )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( * _Val ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 744
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, char _Ch )
 {
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename basic_ostream < _Elem, _Traits > :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  const ctype < _Elem > & _Ctype_fac = use_facet < ctype < _Elem > > ( _Ostr . getloc ( ) );
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ctype_fac . widen ( _Ch ) ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 783
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr,
  const char * _Val )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 830
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, char _Ch )
 {
 typedef char _Elem;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 869
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, const _Elem * _Val )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 streamsize _Count = ( streamsize ) _Traits :: length ( _Val );
 streamsize _Pad = _Ostr . width ( ) <= 0 || _Ostr . width ( ) <= _Count
  ? 0 : _Ostr . width ( ) - _Count;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Val, _Count ) != _Count )
   _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 916
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr, _Elem _Ch )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;

 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( _Ok )
  {
  streamsize _Pad = _Ostr . width ( ) <= 1 ? 0 : _Ostr . width ( ) - 1;

  try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; _State == ios_base :: goodbit && 0 < _Pad;
    -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     _State |= ios_base :: badbit;

  if ( _State == ios_base :: goodbit
   && _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ch ) ) )
   _State |= ios_base :: badbit;

  for (; _State == ios_base :: goodbit && 0 < _Pad;
   -- _Pad )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
    _State |= ios_base :: badbit;
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . width ( 0 );
 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 956
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const signed char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }
#line 963
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, signed char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }
#line 970
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, const unsigned char * _Val )
 {
 return ( _Ostr << ( const char * ) _Val );
 }
#line 977
template < class _Traits > inline
 basic_ostream < char, _Traits > & operator << (
  basic_ostream < char, _Traits > & _Ostr, unsigned char _Ch )
 {
 return ( _Ostr << ( char ) _Ch );
 }
#line 984
template < class _Elem,
 class _Traits,
 class _Ty > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > && _Ostr, const _Ty & _Val )
 {
 return ( _Ostr << _Val );
 }
#line 994
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl endl ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Ostr . widen ( '\n' ) );
 _Ostr . flush ( );
 return ( _Ostr );
 }
#line 1004
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl ends ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . put ( _Elem ( ) );
 return ( _Ostr );
 }
#line 1013
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  __cdecl flush ( basic_ostream < _Elem, _Traits > & _Ostr )
 {
 _Ostr . flush ( );
 return ( _Ostr );
 }
#line 1023
template < class _Elem,
 class _Traits > inline
 basic_ostream < _Elem, _Traits > &
  operator << ( basic_ostream < _Elem, _Traits > & _Ostr,
   const error_code & _Errcode )
 {
 return ( _Ostr << _Errcode . category ( ) . name ( ) << ':' << _Errcode . value ( ) );
 }
#line 1031
}
#line 1034
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4189)
#line 1035 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\ostream"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
#pragma pack ( push, 8 )
#line 15
namespace std { 
#pragma vtordisp(push, 2)
#line 19
template < class _Elem,
 class _Traits >
 class basic_istream
  : virtual public basic_ios < _Elem, _Traits >
 {
public :
 typedef basic_istream < _Elem, _Traits > _Myt;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef basic_streambuf < _Elem, _Traits > _Mysb;
 typedef istreambuf_iterator < _Elem, _Traits > _Iter;
 typedef ctype < _Elem > _Ctype;
 typedef num_get < _Elem, _Iter > _Nget;











 explicit basic_istream ( _Mysb * _Strbuf,
  bool _Isstd = false )

  : _Chcount ( 0 )
  {
  _Myios :: init ( _Strbuf, _Isstd );
  }

  basic_istream ( _Uninitialized )
  {
  this -> _Addstd ( this );
  }

protected :
  basic_istream ( _Myt && _Right )
  : _Chcount ( _Right . _Chcount )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: move ( _Right ) );
  _Right . _Chcount = 0;
  }

 _Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  _Myios :: swap ( _Right );
  :: std :: swap ( _Chcount, _Right . _Chcount );
  }

public :
  basic_istream ( const _Myt & ) = delete;
 _Myt & operator = ( const _Myt & ) = delete;

 virtual ~ basic_istream ( ) throw ( )
  {
  }

 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;


 class _Sentry_base
  {
 public :
   _Sentry_base ( _Myt & _Istr )
   : _Myistr ( _Istr )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Lock ( );
   }

   ~ _Sentry_base ( ) throw ( )
   {
   if ( _Myistr . rdbuf ( ) != 0 )
    _Myistr . rdbuf ( ) -> _Unlock ( );
   }

  _Myt & _Myistr;

 private :
  _Sentry_base & operator = ( const _Sentry_base & );
  };

 class sentry
  : public _Sentry_base
  {
 public :
  explicit sentry ( _Myt & _Istr, bool _Noskip = false )
   : _Sentry_base ( _Istr )
   {
   _Ok = this -> _Myistr . _Ipfx ( _Noskip );
   }

  explicit operator bool ( ) const
   {
   return ( _Ok );
   }

 private :
  bool _Ok;

 public :
   sentry ( const sentry & ) = delete;
  sentry & operator = ( const sentry & ) = delete;
  };

 bool _Ipfx ( bool _Noskip = false )
  {
  if ( this -> good ( ) )
   {
   if ( _Myios :: tie ( ) != 0 )
    _Myios :: tie ( ) -> flush ( );

   if ( ! _Noskip && this -> flags ( ) & ios_base :: skipws )
    {
    const _Ctype & _Ctype_fac = use_facet < _Ctype > ( this -> getloc ( ) );

    try {
    int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

    for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
     if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
      {
      _Myios :: setstate ( ios_base :: eofbit );
      break;
      }
     else if ( ! _Ctype_fac . is ( _Ctype :: space,
      _Traits :: to_char_type ( _Meta ) ) )
      break;
    } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
    }

   if ( this -> good ( ) )
    return ( true );
   }
  _Myios :: setstate ( ios_base :: failbit );
  return ( false );
  }

 bool ipfx ( bool _Noskip = false )
  {
  return ( _Ipfx ( _Noskip ) );
  }

 void isfx ( )
  {
  }























 _Myt & operator >> ( _Myt & ( __cdecl * _Pfn ) ( _Myt & ) )
  {
  ;
  return ( ( * _Pfn ) ( * this ) );
  }

 _Myt & operator >> ( _Myios & ( __cdecl * _Pfn ) ( _Myios & ) )
  {
  ;
  ( * _Pfn ) ( * ( _Myios * ) this );
  return ( * this );
  }

 _Myt & operator >> ( ios_base & ( __cdecl * _Pfn ) ( ios_base & ) )
  {
  ;
  ( * _Pfn ) ( * ( ios_base * ) this );
  return ( * this );
  }

 _Myt & operator >> ( _Bool & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 32768 ) || 32767 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = ( short ) _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }










 _Myt & operator >> ( unsigned short & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   long _Tmp = 0;
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Tmp );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }

   if ( _State & ios_base :: failbit
    || _Tmp < ( - 2147483647 - 1 ) || 2147483647 < _Tmp )
    _State |= ios_base :: failbit;
   else
    _Val = _Tmp;
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned int & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned long & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator >> ( __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( unsigned __int64 & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }


 _Myt & operator >> ( float & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );
  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( long double & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );
   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( void * & _Val )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const sentry _Ok ( * this );

  if ( _Ok )
   {
   const _Nget & _Nget_fac = use_facet < _Nget > ( this -> getloc ( ) );

   try {
   _Nget_fac . get ( _Iter ( _Myios :: rdbuf ( ) ), _Iter ( 0 ),
    * this, _State, _Val );
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & operator >> ( _Mysb * _Strbuf )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  bool _Copied = false;
  const sentry _Ok ( * this );

  if ( _Ok && _Strbuf != 0 )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
       _Strbuf -> sputc ( _Traits :: to_char_type ( _Meta ) ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     _Copied = true;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( ! _Copied ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 int_type get ( )
  {
  int_type _Meta = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   else
    {
    _Myios :: rdbuf ( ) -> sbumpc ( );
    ++ _Chcount;
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 _Myt & get ( _Elem * _Str, streamsize _Count )
  {
  return ( get ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & get ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (; 0 < -- _Count; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Traits :: to_char_type ( _Meta ) == _Delim )
     break;
    else
     {
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _Chcount == 0
   ? _State | ios_base :: failbit : _State );
  * _Str = _Elem ( );
  return ( * this );
  }

 _Myt & get ( _Elem & _Ch )
  {
  int_type _Meta = get ( );
  if ( ! _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _Ch = _Traits :: to_char_type ( _Meta );
  return ( * this );
  }

 _Myt & get ( _Mysb & _Strbuf )
  {
  return ( get ( _Strbuf, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & get ( _Mysb & _Strbuf, _Elem _Delim )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     try {
      _Elem _Ch = _Traits :: to_char_type ( _Meta );
      if ( _Ch == _Delim
       || _Traits :: eq_int_type ( _Traits :: eof ( ),
        _Strbuf . sputc ( _Ch ) ) )
       break;
     } catch ( ... ) {
      break;
     }
     ++ _Chcount;
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  if ( _Chcount == 0 )
   _State |= ios_base :: failbit;
  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & getline ( _Elem * _Str, streamsize _Count )
  {
  return ( getline ( _Str, _Count, _Myios :: widen ( '\n' ) ) );
  }

 _Myt & getline ( _Elem * _Str,
  streamsize _Count, _Elem _Delim )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   int_type _Metadelim = _Traits :: to_int_type ( _Delim );

   try {
   int_type _Meta = _Myios :: rdbuf ( ) -> sgetc ( );

   for (;; _Meta = _Myios :: rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( _Meta == _Metadelim )
     {
     ++ _Chcount;
     _Myios :: rdbuf ( ) -> sbumpc ( );
     break;
     }
    else if ( -- _Count <= 0 )
     {
     _State |= ios_base :: failbit;
     break;
     }
    else
     {
     ++ _Chcount;
     * _Str ++ = _Traits :: to_char_type ( _Meta );
     }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  * _Str = _Elem ( );
  _Myios :: setstate ( _Chcount == 0 ? _State | ios_base :: failbit : _State );
  return ( * this );
  }

 _Myt & ignore ( streamsize _Count = 1,
  int_type _Metadelim = _Traits :: eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok && 0 < _Count )
   {
   try {
   for (;; )
    {
    int_type _Meta;
    if ( _Count != 2147483647 && -- _Count < 0 )
     break;
    else if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Meta = _Myios :: rdbuf ( ) -> sbumpc ( ) ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else
     {
     ++ _Chcount;
     if ( _Meta == _Metadelim )
      break;
     }
    }
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & read ( _Elem * _Str, streamsize _Count )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   const streamsize _Num = _Myios :: rdbuf ( ) -> sgetn ( _Str, _Count );
   _Chcount += _Num;
   if ( _Num != _Count )
    _State |= ios_base :: eofbit | ios_base :: failbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 streamsize readsome ( _Elem * _Str,
  streamsize _Count )
  {
  ;
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  const sentry _Ok ( * this, true );
  streamsize _Num;

  if ( ! _Ok )
   _State |= ios_base :: failbit;
  else if ( ( _Num = _Myios :: rdbuf ( ) -> in_avail ( ) ) < 0 )
   _State |= ios_base :: eofbit;
  else if ( 0 < _Num )
   read ( _Str, _Num < _Count ? _Num : _Count );

  _Myios :: setstate ( _State );
  return ( gcount ( ) );
  }

 int_type peek ( )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  _Chcount = 0;
  int_type _Meta = 0;
  const sentry _Ok ( * this, true );

  if ( ! _Ok )
   _Meta = _Traits :: eof ( );
  else
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Meta = _Myios :: rdbuf ( ) -> sgetc ( ) ) )
    _State |= ios_base :: eofbit;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( _Meta );
  }

 _Myt & putback ( _Elem _Ch )
  {
  _Chcount = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sputbackc ( _Ch ) ) )
    _State |= ios_base :: badbit | _Oldstate;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 _Myt & unget ( )
  {
  _Chcount = 0;
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( _Ok )
   {
   try {
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
    _Myios :: rdbuf ( ) -> sungetc ( ) ) )
    _State |= ios_base :: badbit | _Oldstate;
   } catch ( ... ) { _Myios :: setstate ( ios_base :: badbit, true ); }
   }

  _Myios :: setstate ( _State );
  return ( * this );
  }

 streamsize gcount ( ) const
  {
  return ( _Chcount );
  }

 int sync ( )
  {
  const sentry _Ok ( * this, true );

  if ( _Myios :: rdbuf ( ) == 0 )
   return ( - 1 );
  else if ( _Myios :: rdbuf ( ) -> pubsync ( ) == - 1 )
   {
   _Myios :: setstate ( ios_base :: badbit );
   return ( - 1 );
   }
  else
   return ( 0 );
  }

 _Myt & seekg ( pos_type _Pos )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekpos ( _Pos,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( _State | ios_base :: failbit );
  return ( * this );
  }

 _Myt & seekg ( off_type _Off, ios_base :: seekdir _Way )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  ios_base :: iostate _Oldstate = _Myios :: rdstate ( );
  _Myios :: clear ( _Oldstate & ~ ios_base :: eofbit );
  const sentry _Ok ( * this, true );

  if ( ! this -> fail ( )
   && ( off_type ) _Myios :: rdbuf ( ) -> pubseekoff ( _Off, _Way,
    ios_base :: in ) == _BADOFF )
   _Myios :: setstate ( _State | ios_base :: failbit );
  return ( * this );
  }

 pos_type tellg ( )
  {
  const sentry _Ok ( * this, true );

  if ( ! this -> fail ( ) )
   return ( _Myios :: rdbuf ( ) -> pubseekoff ( 0,
    ios_base :: cur, ios_base :: in ) );
  else
   return ( pos_type ( _BADOFF ) );
  }

private :
 streamsize _Chcount;
 };
#line 895 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
#pragma vtordisp(pop)
#line 923
template class __declspec(dllimport) basic_istream< char, char_traits< char> > ;
#line 924
template class __declspec(dllimport) basic_istream< __wchar_t, char_traits< __wchar_t> > ;
#line 934 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
template < class _Elem,
 class _Traits >
 class basic_iostream
 : public basic_istream < _Elem, _Traits >,
  public basic_ostream < _Elem, _Traits >
 {
public :
 typedef basic_iostream < _Elem, _Traits > _Myt;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_ios < _Elem, _Traits > _Myios;
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef typename _Traits :: int_type int_type;
 typedef typename _Traits :: pos_type pos_type;
 typedef typename _Traits :: off_type off_type;

 explicit basic_iostream ( basic_streambuf < _Elem, _Traits > * _Strbuf )
  : _Myis ( _Strbuf, false ),
   _Myos ( _Noinit, false )
  {
  }

protected :
  basic_iostream ( _Myt && _Right )
  : _Myis ( _Right . rdbuf ( ), false ),
   _Myos ( _Noinit, false )
  {
  _Myios :: init ( );
  _Myios :: move ( :: std :: forward < _Myt > ( _Right ) );
  }

 _Myt & operator = ( _Myt && _Right )
  {
  this -> swap ( _Right );
  return ( * this );
  }

 void swap ( _Myt & _Right )
  {
  if ( this != & _Right )
   _Myios :: swap ( _Right );
  }

public :
  basic_iostream ( const _Myt & ) = delete;
 _Myt & operator = ( const _Myt & ) = delete;

 virtual ~ basic_iostream ( ) throw ( )
  {
  }
 };
#line 992
template class __declspec(dllimport) basic_iostream< char, char_traits< char> > ;
#line 993
template class __declspec(dllimport) basic_iostream< __wchar_t, char_traits< __wchar_t> > ;
#line 1004 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem * _Str )
 {
 ;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;
 ios_base :: iostate _State = ios_base :: goodbit;
 _Elem * _Str0 = _Str;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

  try {
  streamsize _Count = 0 < _Istr . width ( ) ? _Istr . width ( ) : 2147483647;
  typename _Myis :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );
  _Elem _Ch;
  for (; 0 < -- _Count; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Ch = _Traits :: to_char_type ( _Meta ) )
     || _Ch == _Elem ( ) )
    break;
   else
    * _Str ++ = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 * _Str = _Elem ( );
 _Istr . width ( 0 );
 _Istr . setstate ( _Str == _Str0 ? _State | ios_base :: failbit : _State );
 return ( _Istr );
 }
#line 1045
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr, _Elem & _Ch )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 typename _Myis :: int_type _Meta;
 ios_base :: iostate _State = ios_base :: goodbit;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  try {
  _Meta = _Istr . rdbuf ( ) -> sbumpc ( );
  if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
   _State |= ios_base :: eofbit | ios_base :: failbit;
  else
   _Ch = _Traits :: to_char_type ( _Meta );
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 1071
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }
#line 1078
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, signed char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 1085
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char * _Str )
 {
 return ( _Istr >> ( char * ) _Str );
 }
#line 1092
template < class _Traits > inline
 basic_istream < char, _Traits > & operator >> (
  basic_istream < char, _Traits > & _Istr, unsigned char & _Ch )
 {
 return ( _Istr >> ( char & ) _Ch );
 }
#line 1099
template < class _Elem,
 class _Traits,
 class _Ty > inline
 basic_istream < _Elem, _Traits > &
  operator >> ( basic_istream < _Elem, _Traits > && _Istr, _Ty & _Val )
 {
 return ( _Istr >> _Val );
 }
#line 1109
template < class _Elem,
 class _Traits > inline
 basic_istream < _Elem, _Traits > &
  __cdecl ws ( basic_istream < _Elem, _Traits > & _Istr )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef ctype < _Elem > _Ctype;

 if ( ! _Istr . eof ( ) )
  {
  ios_base :: iostate _State = ios_base :: goodbit;
  const typename _Myis :: sentry _Ok ( _Istr, true );

  if ( _Ok )
   {
   const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );

   try {
   for ( typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );;
    _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
     {
     _State |= ios_base :: eofbit;
     break;
     }
    else if ( ! _Ctype_fac . is ( _Ctype :: space,
     _Traits :: to_char_type ( _Meta ) ) )
     break;
   } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
   }

  _Istr . setstate ( _State );
  }
 return ( _Istr );
 }
#line 1145
__declspec(dllimport) inline basic_istream< char, char_traits< char> >  &__cdecl 
#line 1146
ws(basic_istream< char, char_traits< char> >  &_Istr) 
#line 1147
{ 
#line 1148
typedef char _Elem; 
#line 1149
typedef char_traits< char>  _Traits; 
#line 1151
if (!_Istr.eof()) 
#line 1152
{ 
#line 1153
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
#line 1154
const basic_istream< char, char_traits< char> > ::sentry _Ok(_Istr, true); 
#line 1156
if (_Ok) 
#line 1157
{ 
#line 1158
const ctype< char>  &_Ctype_fac = use_facet< ctype< char> > (_Istr.getloc()); 
#line 1161
try { 
#line 1162
for (char_traits< char> ::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc()) { 
#line 1164
if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
#line 1165
{ 
#line 1166
_State |= _Iosb< int> ::eofbit; 
#line 1167
break; 
#line 1168
} else { 
#line 1169
if (!_Ctype_fac.is(ctype< char> ::space, _Traits::to_char_type(_Meta))) { 
#line 1171
break; }  }  }  
#line 1172
} catch (...) { _Istr.setstate(_Iosb< int> ::badbit, true); }  
#line 1173
}  
#line 1175
_Istr.setstate(_State); 
#line 1176
}  
#line 1177
return _Istr; 
#line 1178
} 
#line 1180
__declspec(dllimport) inline basic_istream< __wchar_t, char_traits< __wchar_t> >  &__cdecl 
#line 1181
ws(basic_istream< __wchar_t, char_traits< __wchar_t> >  &_Istr) 
#line 1182
{ 
#line 1183
typedef __wchar_t _Elem; 
#line 1184
typedef char_traits< __wchar_t>  _Traits; 
#line 1186
if (!_Istr.eof()) 
#line 1187
{ 
#line 1188
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
#line 1189
const basic_istream< __wchar_t, char_traits< __wchar_t> > ::sentry _Ok(_Istr, true); 
#line 1191
if (_Ok) 
#line 1192
{ 
#line 1193
const ctype< __wchar_t>  &_Ctype_fac = use_facet< ctype< __wchar_t> > (_Istr.getloc()); 
#line 1196
try { 
#line 1197
for (char_traits< __wchar_t> ::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc()) { 
#line 1199
if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
#line 1200
{ 
#line 1201
_State |= _Iosb< int> ::eofbit; 
#line 1202
break; 
#line 1203
} else { 
#line 1204
if (!_Ctype_fac.is(ctype< __wchar_t> ::space, _Traits::to_char_type(_Meta))) { 
#line 1206
break; }  }  }  
#line 1207
} catch (...) { _Istr.setstate(_Iosb< int> ::badbit, true); }  
#line 1208
}  
#line 1210
_Istr.setstate(_State); 
#line 1211
}  
#line 1212
return _Istr; 
#line 1213
} 
#line 1216
__declspec(dllimport) inline basic_istream< unsigned short, char_traits< unsigned short> >  &__cdecl 
#line 1217
ws(basic_istream< unsigned short, char_traits< unsigned short> >  &_Istr) 
#line 1218
{ 
#line 1219
typedef unsigned short _Elem; 
#line 1220
typedef char_traits< unsigned short>  _Traits; 
#line 1222
if (!_Istr.eof()) 
#line 1223
{ 
#line 1224
ios_base::iostate _State = (_Iosb< int> ::goodbit); 
#line 1225
const basic_istream< unsigned short, char_traits< unsigned short> > ::sentry _Ok(_Istr, true); 
#line 1227
if (_Ok) 
#line 1228
{ 
#line 1229
const ctype< unsigned short>  &_Ctype_fac = use_facet< ctype< unsigned short> > (_Istr.getloc()); 
#line 1232
try { 
#line 1233
for (char_traits< unsigned short> ::int_type _Meta = _Istr.rdbuf()->sgetc(); ; _Meta = _Istr.rdbuf()->snextc()) { 
#line 1235
if (_Traits::eq_int_type(_Traits::eof(), _Meta)) 
#line 1236
{ 
#line 1237
_State |= _Iosb< int> ::eofbit; 
#line 1238
break; 
#line 1239
} else { 
#line 1240
if (!_Ctype_fac.is(ctype< unsigned short> ::space, _Traits::to_char_type(_Meta))) { 
#line 1242
break; }  }  }  
#line 1243
} catch (...) { _Istr.setstate(_Iosb< int> ::badbit, true); }  
#line 1244
}  
#line 1246
_Istr.setstate(_State); 
#line 1247
}  
#line 1248
return _Istr; 
#line 1249
} 
#line 1251 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
}
#line 1254
#pragma warning(pop)
#line 10 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iterator"
#pragma warning(push,3)
#line 1255 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\istream"
#pragma pack ( pop )
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iterator"
#pragma pack ( push, 8 )
#line 14
namespace std { 
#line 16
template < class _Container >
 class back_insert_iterator
  : public _Outit
 {
public :
 typedef back_insert_iterator < _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: value_type _Valty;

 explicit back_insert_iterator ( _Container & _Cont )
  : container ( :: std :: addressof ( _Cont ) )
  {
  }

 _Myt & operator = ( const _Valty & _Val )
  {
  container -> push_back ( _Val );
  return ( * this );
  }

 _Myt & operator = ( _Valty && _Val )
  {
  container -> push_back ( :: std :: forward < _Valty > ( _Val ) );
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };
#line 61
template< class _Container> 
#line 62
struct _Is_checked_helper< back_insert_iterator< _Container> >  : public true_type { 
#line 65
}; 
#line 68
template < class _Container > inline
 back_insert_iterator < _Container > back_inserter ( _Container & _Cont )
 {
 return ( :: std :: back_insert_iterator < _Container > ( _Cont ) );
 }
#line 75
template < class _Container >
 class front_insert_iterator
  : public _Outit
 {
public :
 typedef front_insert_iterator < _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: value_type _Valty;

 explicit front_insert_iterator ( _Container & _Cont )
  : container ( :: std :: addressof ( _Cont ) )
  {
  }

 _Myt & operator = ( const _Valty & _Val )
  {
  container -> push_front ( _Val );
  return ( * this );
  }

 _Myt & operator = ( _Valty && _Val )
  {
  container -> push_front ( :: std :: forward < _Valty > ( _Val ) );
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 };
#line 120
template< class _Container> 
#line 121
struct _Is_checked_helper< front_insert_iterator< _Container> >  : public true_type { 
#line 124
}; 
#line 127
template < class _Container > inline
 front_insert_iterator < _Container > front_inserter ( _Container & _Cont )
 {
 return ( :: std :: front_insert_iterator < _Container > ( _Cont ) );
 }
#line 134
template < class _Container >
 class insert_iterator
  : public _Outit
 {
public :
 typedef insert_iterator < _Container > _Myt;
 typedef _Container container_type;
 typedef typename _Container :: value_type _Valty;

 insert_iterator ( _Container & _Cont, typename _Container :: iterator _Where )
  : container ( :: std :: addressof ( _Cont ) ), iter ( _Where )
  {
  }

 _Myt & operator = ( const _Valty & _Val )
  {
  iter = container -> insert ( iter, _Val );
  ++ iter;
  return ( * this );
  }

 _Myt & operator = ( _Valty && _Val )
  {
  iter = container -> insert ( iter, :: std :: forward < _Valty > ( _Val ) );
  ++ iter;
  return ( * this );
  }

 _Myt & operator * ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( )
  {
  return ( * this );
  }

 _Myt & operator ++ ( int )
  {
  return ( * this );
  }

protected :
 _Container * container;
 typename _Container :: iterator iter;
 };
#line 182
template< class _Container> 
#line 183
struct _Is_checked_helper< insert_iterator< _Container> >  : public true_type { 
#line 186
}; 
#line 189
template < class _Container > inline
 insert_iterator < _Container > inserter ( _Container & _Cont,
  typename _Container :: iterator _Where )
 {
 return ( :: std :: insert_iterator < _Container > ( _Cont, _Where ) );
 }
#line 198
template < class _Ty,
 class _Elem = char,
 class _Traits = char_traits < _Elem >,
 class _Diff = ptrdiff_t >
 class istream_iterator
  : public iterator < input_iterator_tag, _Ty, _Diff,
   const _Ty *, const _Ty & >
 {
 typedef istream_iterator < _Ty, _Elem, _Traits, _Diff > _Myt;
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_istream < _Elem, _Traits > istream_type;

 typedef const _Ty * pointer;

 istream_iterator ( )
  : _Myistr ( 0 )
  {
  }

 istream_iterator ( istream_type & _Istr )
  : _Myistr ( & _Istr )
  {
  _Getval ( );
  }

 const _Ty & operator * ( ) const
  {
  return ( _Myval );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myt & operator ++ ( )
  {
  _Getval ( );
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 bool _Equal ( const _Myt & _Right ) const
  {
  return ( _Myistr == _Right . _Myistr );
  }

protected :
 void _Getval ( )
  {
  if ( _Myistr != 0 && ! ( * _Myistr >> _Myval ) )
   _Myistr = 0;
  }

 istream_type * _Myistr;
 _Ty _Myval;
 };
#line 264
template< class _Ty, class 
#line 265
_Elem, class 
#line 266
_Traits, class 
#line 267
_Diff> 
#line 268
struct _Is_checked_helper< istream_iterator< _Ty, _Elem, _Traits, _Diff> >  : public true_type { 
#line 271
}; 
#line 274
template < class _Ty,
 class _Elem,
 class _Traits,
 class _Diff > inline
 bool operator == (
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right )
 {
 return ( _Left . _Equal ( _Right ) );
 }
#line 285
template < class _Ty,
 class _Elem,
 class _Traits,
 class _Diff > inline
 bool operator != (
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Left,
  const istream_iterator < _Ty, _Elem, _Traits, _Diff > & _Right )
 {
 return ( ! ( _Left == _Right ) );
 }
#line 298
template < class _Ty,
 class _Elem = char,
 class _Traits = char_traits < _Elem > >
 class ostream_iterator
  : public _Outit
 {
public :
 typedef _Elem char_type;
 typedef _Traits traits_type;
 typedef basic_ostream < _Elem, _Traits > ostream_type;

 ostream_iterator ( ostream_type & _Ostr,
  const _Elem * _Delim = 0 )
  : _Myostr ( & _Ostr ), _Mydelim ( _Delim )
  {
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator = ( const _Ty & _Val )
  {
  * _Myostr << _Val;
  if ( _Mydelim != 0 )
   * _Myostr << _Mydelim;
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator * ( )
  {
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator ++ ( )
  {
  return ( * this );
  }

 ostream_iterator < _Ty, _Elem, _Traits > & operator ++ ( int )
  {
  return ( * this );
  }

protected :
 const _Elem * _Mydelim;
 ostream_type * _Myostr;
 };
#line 343
template< class _Ty, class 
#line 344
_Elem, class 
#line 345
_Traits> 
#line 346
struct _Is_checked_helper< ostream_iterator< _Ty, _Elem, _Traits> >  : public true_type { 
#line 349
}; 
#line 350
}
#line 352
namespace stdext { 
#line 353
using std::iterator_traits;
#line 354
using std::size_t;
#line 357
template < class _Iterator >
 class checked_array_iterator
 {
public :
 typedef checked_array_iterator < _Iterator > _Myt;

 typedef typename iterator_traits < _Iterator > :: iterator_category
  iterator_category;
 typedef typename iterator_traits < _Iterator > :: value_type
  value_type;
 typedef typename iterator_traits < _Iterator > :: difference_type
  difference_type;
 typedef typename iterator_traits < _Iterator > :: difference_type
  distance_type;
 typedef typename iterator_traits < _Iterator > :: pointer
  pointer;
 typedef typename iterator_traits < _Iterator > :: reference
  reference;

 checked_array_iterator ( )
  : _Myarray ( ), _Mysize ( 0 ), _Myindex ( 0 )
  {
  }

 checked_array_iterator ( _Iterator _Array, size_t _Size,
  size_t _Index = 0 )
  : _Myarray ( _Array ), _Mysize ( _Size ), _Myindex ( _Index )
  {
  { if ( ! ( _Index <= _Size ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  }

 _Iterator base ( ) const
  {
  return ( _Myarray + _Myindex );
  }

 typedef _Iterator _Unchecked_type;

 _Myt & _Rechecked ( _Unchecked_type _Right )
  {
  _Myindex = _Right - _Myarray;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( base ( ) );
  }

 reference operator * ( ) const
  {
  { if ( ! ( _Myarray != 0 && _Myindex < _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };

  return ( _Myarray [ _Myindex ] );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myt & operator ++ ( )
  {
  { if ( ! ( _Myarray != 0 && _Myindex < _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };

  ++ _Myindex;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  { if ( ! ( _Myarray != 0 && 0 < _Myindex ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };

  -- _Myindex;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  { if ( ! ( _Myarray != 0 && _Myindex + _Off <= _Mysize ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };

  _Myindex += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  { if ( ! ( _Myarray == _Right . _Myarray ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myindex - _Right . _Myindex );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  { if ( ! ( _Myarray == _Right . _Myarray ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myindex == _Right . _Myindex );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myt & _Right ) const
  {
  { if ( ! ( _Myarray == _Right . _Myarray ) ) { ( ( void ) 0 ); :: _invalid_parameter_noinfo_noreturn ( ); }; };
  return ( _Myindex < _Right . _Myindex );
  }

 bool operator > ( const _Myt & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myt & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myt & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

private :
 _Iterator _Myarray;
 size_t _Mysize;
 size_t _Myindex;
 };
#line 522 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iterator"
template < class _Iterator > inline
 typename checked_array_iterator < _Iterator > :: _Unchecked_type
  _Unchecked ( checked_array_iterator < _Iterator > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 529
template < class _Iterator > inline
 checked_array_iterator < _Iterator > &
  _Rechecked ( checked_array_iterator < _Iterator > & _Iter,
   typename checked_array_iterator < _Iterator >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 538
template < class _Iterator > inline
 checked_array_iterator < _Iterator > operator + (
  typename checked_array_iterator < _Iterator > :: difference_type _Off,
  checked_array_iterator < _Iterator > _Next )
 {
 return ( _Next += _Off );
 }
#line 546
template < class _Iterator > inline
 checked_array_iterator < _Iterator > make_checked_array_iterator (
  _Iterator _Array, size_t _Size, size_t _Index = 0 )
 {
 return ( checked_array_iterator < _Iterator > ( _Array, _Size, _Index ) );
 }
#line 554
template < class _Iterator >
 class unchecked_array_iterator
 {
public :
 typedef unchecked_array_iterator < _Iterator > _Myt;

 typedef typename iterator_traits < _Iterator > :: iterator_category
  iterator_category;
 typedef typename iterator_traits < _Iterator > :: value_type
  value_type;
 typedef typename iterator_traits < _Iterator > :: difference_type
  difference_type;
 typedef typename iterator_traits < _Iterator > :: difference_type
  distance_type;
 typedef typename iterator_traits < _Iterator > :: pointer
  pointer;
 typedef typename iterator_traits < _Iterator > :: reference
  reference;

 unchecked_array_iterator ( )
  : _Myptr ( )
  {
  }

 explicit unchecked_array_iterator ( _Iterator _Ptr )
  : _Myptr ( _Ptr )
  {
  }

 _Iterator base ( ) const
  {
  return ( _Myptr );
  }

 typedef _Iterator _Unchecked_type;

 _Myt & _Rechecked ( _Unchecked_type _Right )
  {
  _Myptr = _Right;
  return ( * this );
  }

 _Unchecked_type _Unchecked ( ) const
  {
  return ( base ( ) );
  }

 reference operator * ( ) const
  {
  return ( * _Myptr );
  }

 pointer operator -> ( ) const
  {
  return ( :: std :: pointer_traits < pointer > :: pointer_to ( * * this ) );
  }

 _Myt & operator ++ ( )
  {
  ++ _Myptr;
  return ( * this );
  }

 _Myt operator ++ ( int )
  {
  _Myt _Tmp = * this;
  ++ * this;
  return ( _Tmp );
  }

 _Myt & operator -- ( )
  {
  -- _Myptr;
  return ( * this );
  }

 _Myt operator -- ( int )
  {
  _Myt _Tmp = * this;
  -- * this;
  return ( _Tmp );
  }

 _Myt & operator += ( difference_type _Off )
  {
  _Myptr += _Off;
  return ( * this );
  }

 _Myt operator + ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp += _Off );
  }

 _Myt & operator -= ( difference_type _Off )
  {
  return ( * this += - _Off );
  }

 _Myt operator - ( difference_type _Off ) const
  {
  _Myt _Tmp = * this;
  return ( _Tmp -= _Off );
  }

 difference_type operator - ( const _Myt & _Right ) const
  {
  return ( _Myptr - _Right . _Myptr );
  }

 reference operator [ ] ( difference_type _Off ) const
  {
  return ( * ( * this + _Off ) );
  }

 bool operator == ( const _Myt & _Right ) const
  {
  return ( _Myptr == _Right . _Myptr );
  }

 bool operator != ( const _Myt & _Right ) const
  {
  return ( ! ( * this == _Right ) );
  }

 bool operator < ( const _Myt & _Right ) const
  {
  return ( _Myptr < _Right . _Myptr );
  }

 bool operator > ( const _Myt & _Right ) const
  {
  return ( _Right < * this );
  }

 bool operator <= ( const _Myt & _Right ) const
  {
  return ( ! ( _Right < * this ) );
  }

 bool operator >= ( const _Myt & _Right ) const
  {
  return ( ! ( * this < _Right ) );
  }

private :
 _Iterator _Myptr;
 };
#line 704
template < class _Iterator > inline
 typename unchecked_array_iterator < _Iterator > :: _Unchecked_type
  _Unchecked ( unchecked_array_iterator < _Iterator > _Iter )
 {
 return ( _Iter . _Unchecked ( ) );
 }
#line 711
template < class _Iterator > inline
 unchecked_array_iterator < _Iterator > &
  _Rechecked ( unchecked_array_iterator < _Iterator > & _Iter,
   typename unchecked_array_iterator < _Iterator >
    :: _Unchecked_type _Right )
 {
 return ( _Iter . _Rechecked ( _Right ) );
 }
#line 720
template < class _Iterator > inline
 unchecked_array_iterator < _Iterator > operator + (
  typename unchecked_array_iterator < _Iterator > :: difference_type _Off,
  unchecked_array_iterator < _Iterator > _Next )
 {
 return ( _Next += _Off );
 }
#line 728
template < class _Iterator > inline
 unchecked_array_iterator < _Iterator > make_unchecked_array_iterator (
  _Iterator _Ptr )
 {
 return ( unchecked_array_iterator < _Iterator > ( _Ptr ) );
 }
#line 734
}
#line 737
#pragma warning(pop)
#line 9 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string"
#pragma warning(push,3)
#line 13
#pragma warning(disable: 4189)
#pragma warning(disable: 4172)
#line 738 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\iterator"
#pragma pack ( pop )
#line 8 "E:/Program Files (x86)/Microsoft Visual Studio 12.0/VC/bin/../../VC/INCLUDE\\string"
#pragma pack ( push, 8 )
#line 16
namespace std { 
#line 18
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 typedef ctype < _Elem > _Ctype;
 typedef basic_istream < _Elem, _Traits > _Myis;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef typename _Mystr :: size_type _Mysizt;

 ios_base :: iostate _State = ios_base :: goodbit;
 bool _Changed = false;
 const typename _Myis :: sentry _Ok ( _Istr );

 if ( _Ok )
  {
  const _Ctype & _Ctype_fac = use_facet < _Ctype > ( _Istr . getloc ( ) );
  _Str . erase ( );

  try {
  _Mysizt _Size = 0 < _Istr . width ( )
   && ( _Mysizt ) _Istr . width ( ) < _Str . max_size ( )
    ? ( _Mysizt ) _Istr . width ( ) : _Str . max_size ( );
  typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

  for (; 0 < _Size; -- _Size, _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Ctype_fac . is ( _Ctype :: space,
    _Traits :: to_char_type ( _Meta ) ) )
    break;
   else
    {
    _Str . append ( 1, _Traits :: to_char_type ( _Meta ) );
    _Changed = true;
    }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Istr . width ( 0 );
 if ( ! _Changed )
  _State |= ios_base :: failbit;
 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 69
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str,
  const _Elem _Delim )
 {
 typedef basic_istream < _Elem, _Traits > _Myis;

 ios_base :: iostate _State = ios_base :: goodbit;
 bool _Changed = false;
 const typename _Myis :: sentry _Ok ( _Istr, true );

 if ( _Ok )
  {
  try {
  _Str . erase ( );
  const typename _Traits :: int_type _Metadelim =
   _Traits :: to_int_type ( _Delim );
  typename _Traits :: int_type _Meta = _Istr . rdbuf ( ) -> sgetc ( );

  for (;; _Meta = _Istr . rdbuf ( ) -> snextc ( ) )
   if ( _Traits :: eq_int_type ( _Traits :: eof ( ), _Meta ) )
    {
    _State |= ios_base :: eofbit;
    break;
    }
   else if ( _Traits :: eq_int_type ( _Meta, _Metadelim ) )
    {
    _Changed = true;
    _Istr . rdbuf ( ) -> sbumpc ( );
    break;
    }
   else if ( _Str . max_size ( ) <= _Str . size ( ) )
    {
    _State |= ios_base :: failbit;
    break;
    }
   else
    {
    _Str += _Traits :: to_char_type ( _Meta );
    _Changed = true;
    }
  } catch ( ... ) { ( _Istr ) . setstate ( ios_base :: badbit, true ); }
  }

 if ( ! _Changed )
  _State |= ios_base :: failbit;
 _Istr . setstate ( _State );
 return ( _Istr );
 }
#line 122
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > && _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( getline ( _Istr, _Str, _Istr . widen ( '\n' ) ) );
 }
#line 132
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & operator >> (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( :: std :: move ( _Istr ) >> _Str );
 }
#line 142
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str,
  const _Elem _Delim )
 {
 return ( getline ( :: std :: move ( _Istr ), _Str, _Delim ) );
 }
#line 153
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_istream < _Elem, _Traits > & getline (
  basic_istream < _Elem, _Traits > & _Istr,
  basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 return ( getline ( :: std :: move ( _Istr ), _Str, _Istr . widen ( '\n' ) ) );
 }
#line 163
template < class _Elem,
 class _Traits,
 class _Alloc > inline
 basic_ostream < _Elem, _Traits > & operator << (
  basic_ostream < _Elem, _Traits > & _Ostr,
  const basic_string < _Elem, _Traits, _Alloc > & _Str )
 {
 typedef basic_ostream < _Elem, _Traits > _Myos;
 typedef basic_string < _Elem, _Traits, _Alloc > _Mystr;
 typedef typename _Mystr :: size_type _Mysizt;

 ios_base :: iostate _State = ios_base :: goodbit;
 _Mysizt _Size = _Str . size ( );
 _Mysizt _Pad = _Ostr . width ( ) <= 0 || ( _Mysizt ) _Ostr . width ( ) <= _Size
  ? 0 : ( _Mysizt ) _Ostr . width ( ) - _Size;
 const typename _Myos :: sentry _Ok ( _Ostr );

 if ( ! _Ok )
  _State |= ios_base :: badbit;
 else
  {
 try {
  if ( ( _Ostr . flags ( ) & ios_base :: adjustfield ) != ios_base :: left )
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }

  if ( _State == ios_base :: goodbit
   && _Ostr . rdbuf ( ) -> sputn ( _Str . c_str ( ), ( streamsize ) _Size )
    != ( streamsize ) _Size )
    _State |= ios_base :: badbit;
  else
   for (; 0 < _Pad; -- _Pad )
    if ( _Traits :: eq_int_type ( _Traits :: eof ( ),
     _Ostr . rdbuf ( ) -> sputc ( _Ostr . fill ( ) ) ) )
     {
     _State |= ios_base :: badbit;
     break;
     }
  _Ostr . width ( 0 );
  } catch ( ... ) { ( _Ostr ) . setstate ( ios_base :: badbit, true ); }
  }

 _Ostr . setstate ( _State );
 return ( _Ostr );
 }
#line 226
inline int stoi(const string &_Str, size_t *_Idx = 0, int 
#line 227
_Base = 10) 
#line 228
{ 
#line 229
const char *_Ptr = _Str.c_str(); 
#line 230
char *_Eptr; 
#line 231
(*_errno()) = 0; 
#line 232
long _Ans = ::strtol(_Ptr, &_Eptr, _Base); 
#line 234
if (_Ptr == _Eptr) { 
#line 235
_Xinvalid_argument("invalid stoi argument"); }  
#line 236
if (((*_errno()) == 34) || ((_Ans < ((-2147483647) - 1)) != ((2147483647) < _Ans))) { 
#line 237
_Xout_of_range("stoi argument out of range"); }  
#line 238
if (_Idx != (0)) { 
#line 239
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 240
return (int)_Ans; 
#line 241
} 
#line 243
inline long stol(const string &_Str, size_t *_Idx = 0, int 
#line 244
_Base = 10) 
#line 245
{ 
#line 246
const char *_Ptr = _Str.c_str(); 
#line 247
char *_Eptr; 
#line 248
(*_errno()) = 0; 
#line 249
long _Ans = ::strtol(_Ptr, &_Eptr, _Base); 
#line 251
if (_Ptr == _Eptr) { 
#line 252
_Xinvalid_argument("invalid stol argument"); }  
#line 253
if ((*_errno()) == 34) { 
#line 254
_Xout_of_range("stol argument out of range"); }  
#line 255
if (_Idx != (0)) { 
#line 256
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 257
return _Ans; 
#line 258
} 
#line 260
inline unsigned long stoul(const string &_Str, size_t *_Idx = 0, int 
#line 261
_Base = 10) 
#line 262
{ 
#line 263
const char *_Ptr = _Str.c_str(); 
#line 264
char *_Eptr; 
#line 265
(*_errno()) = 0; 
#line 266
unsigned long _Ans = ::strtoul(_Ptr, &_Eptr, _Base); 
#line 268
if (_Ptr == _Eptr) { 
#line 269
_Xinvalid_argument("invalid stoul argument"); }  
#line 270
if ((*_errno()) == 34) { 
#line 271
_Xout_of_range("stoul argument out of range"); }  
#line 272
if (_Idx != (0)) { 
#line 273
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 274
return _Ans; 
#line 275
} 
#line 277
inline _Longlong stoll(const string &_Str, size_t *_Idx = 0, int 
#line 278
_Base = 10) 
#line 279
{ 
#line 280
const char *_Ptr = _Str.c_str(); 
#line 281
char *_Eptr; 
#line 282
(*_errno()) = 0; 
#line 283
_Longlong _Ans = ::_strtoi64(_Ptr, &_Eptr, _Base); 
#line 285
if (_Ptr == _Eptr) { 
#line 286
_Xinvalid_argument("invalid stoll argument"); }  
#line 287
if ((*_errno()) == 34) { 
#line 288
_Xout_of_range("stoll argument out of range"); }  
#line 289
if (_Idx != (0)) { 
#line 290
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 291
return _Ans; 
#line 292
} 
#line 294
inline _ULonglong stoull(const string &_Str, size_t *_Idx = 0, int 
#line 295
_Base = 10) 
#line 296
{ 
#line 297
const char *_Ptr = _Str.c_str(); 
#line 298
(*_errno()) = 0; 
#line 299
char *_Eptr; 
#line 300
_ULonglong _Ans = ::_strtoui64(_Ptr, &_Eptr, _Base); 
#line 302
if (_Ptr == _Eptr) { 
#line 303
_Xinvalid_argument("invalid stoull argument"); }  
#line 304
if ((*_errno()) == 34) { 
#line 305
_Xout_of_range("stoull argument out of range"); }  
#line 306
if (_Idx != (0)) { 
#line 307
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 308
return _Ans; 
#line 309
} 
#line 311
inline float stof(const string &_Str, size_t *_Idx = 0) 
#line 312
{ 
#line 313
const char *_Ptr = _Str.c_str(); 
#line 314
(*_errno()) = 0; 
#line 315
char *_Eptr; 
#line 316
float _Ans = (float)::strtod(_Ptr, &_Eptr); 
#line 318
if (_Ptr == _Eptr) { 
#line 319
_Xinvalid_argument("invalid stof argument"); }  
#line 320
if ((*_errno()) == 34) { 
#line 321
_Xout_of_range("stof argument out of range"); }  
#line 322
if (_Idx != (0)) { 
#line 323
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 324
return _Ans; 
#line 325
} 
#line 327
inline double stod(const string &_Str, size_t *_Idx = 0) 
#line 328
{ 
#line 329
const char *_Ptr = _Str.c_str(); 
#line 330
(*_errno()) = 0; 
#line 331
char *_Eptr; 
#line 332
double _Ans = ::strtod(_Ptr, &_Eptr); 
#line 334
if (_Ptr == _Eptr) { 
#line 335
_Xinvalid_argument("invalid stod argument"); }  
#line 336
if ((*_errno()) == 34) { 
#line 337
_Xout_of_range("stod argument out of range"); }  
#line 338
if (_Idx != (0)) { 
#line 339
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 340
return _Ans; 
#line 341
} 
#line 343
inline long double stold(const string &_Str, size_t *_Idx = 0) 
#line 344
{ 
#line 345
const char *_Ptr = _Str.c_str(); 
#line 346
(*_errno()) = 0; 
#line 347
char *_Eptr; 
#line 348
long double _Ans = ::strtod(_Ptr, &_Eptr); 
#line 350
if (_Ptr == _Eptr) { 
#line 351
_Xinvalid_argument("invalid stold argument"); }  
#line 352
if ((*_errno()) == 34) { 
#line 353
_Xout_of_range("stold argument out of range"); }  
#line 354
if (_Idx != (0)) { 
#line 355
(*_Idx) = ((size_t)(_Eptr - ((char *)_Ptr))); }  
#line 356
return _Ans; 
#line 357
} 
#line 360
inline int stoi(const wstring &_Str, size_t *_Idx = 0, int 
#line 361
_Base = 10) 
#line 362
{ 
#line 363
const __wchar_t *_Ptr = _Str.c_str(); 
#line 364
__wchar_t *_Eptr; 
#line 365
(*_errno()) = 0; 
#line 366
long _Ans = ::wcstol(_Ptr, &_Eptr, _Base); 
#line 368
if (_Ptr == _Eptr) { 
#line 369
_Xinvalid_argument("invalid stoi argument"); }  
#line 370
if (((*_errno()) == 34) || ((_Ans < ((-2147483647) - 1)) != ((2147483647) < _Ans))) { 
#line 371
_Xout_of_range("stoi argument out of range"); }  
#line 372
if (_Idx != (0)) { 
#line 373
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 374
return (int)_Ans; 
#line 375
} 
#line 377
inline long stol(const wstring &_Str, size_t *_Idx = 0, int 
#line 378
_Base = 10) 
#line 379
{ 
#line 380
const __wchar_t *_Ptr = _Str.c_str(); 
#line 381
__wchar_t *_Eptr; 
#line 382
(*_errno()) = 0; 
#line 383
long _Ans = ::wcstol(_Ptr, &_Eptr, _Base); 
#line 385
if (_Ptr == _Eptr) { 
#line 386
_Xinvalid_argument("invalid stol argument"); }  
#line 387
if ((*_errno()) == 34) { 
#line 388
_Xout_of_range("stol argument out of range"); }  
#line 389
if (_Idx != (0)) { 
#line 390
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 391
return _Ans; 
#line 392
} 
#line 394
inline unsigned long stoul(const wstring &_Str, size_t *_Idx = 0, int 
#line 395
_Base = 10) 
#line 396
{ 
#line 397
const __wchar_t *_Ptr = _Str.c_str(); 
#line 398
__wchar_t *_Eptr; 
#line 399
(*_errno()) = 0; 
#line 400
unsigned long _Ans = ::wcstoul(_Ptr, &_Eptr, _Base); 
#line 402
if (_Ptr == _Eptr) { 
#line 403
_Xinvalid_argument("invalid stoul argument"); }  
#line 404
if ((*_errno()) == 34) { 
#line 405
_Xout_of_range("stoul argument out of range"); }  
#line 406
if (_Idx != (0)) { 
#line 407
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 408
return _Ans; 
#line 409
} 
#line 411
inline _Longlong stoll(const wstring &_Str, size_t *_Idx = 0, int 
#line 412
_Base = 10) 
#line 413
{ 
#line 414
const __wchar_t *_Ptr = _Str.c_str(); 
#line 415
__wchar_t *_Eptr; 
#line 416
(*_errno()) = 0; 
#line 417
_Longlong _Ans = ::_wcstoi64(_Ptr, &_Eptr, _Base); 
#line 419
if (_Ptr == _Eptr) { 
#line 420
_Xinvalid_argument("invalid stoll argument"); }  
#line 421
if ((*_errno()) == 34) { 
#line 422
_Xout_of_range("stoll argument out of range"); }  
#line 423
if (_Idx != (0)) { 
#line 424
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 425
return _Ans; 
#line 426
} 
#line 428
inline _ULonglong stoull(const wstring &_Str, size_t *_Idx = 0, int 
#line 429
_Base = 10) 
#line 430
{ 
#line 431
const __wchar_t *_Ptr = _Str.c_str(); 
#line 432
(*_errno()) = 0; 
#line 433
__wchar_t *_Eptr; 
#line 434
_ULonglong _Ans = ::_wcstoui64(_Ptr, &_Eptr, _Base); 
#line 436
if (_Ptr == _Eptr) { 
#line 437
_Xinvalid_argument("invalid stoull argument"); }  
#line 438
if ((*_errno()) == 34) { 
#line 439
_Xout_of_range("stoull argument out of range"); }  
#line 440
if (_Idx != (0)) { 
#line 441
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 442
return _Ans; 
#line 443
} 
#line 445
inline float stof(const wstring &_Str, size_t *_Idx = 0) 
#line 446
{ 
#line 447
const __wchar_t *_Ptr = _Str.c_str(); 
#line 448
(*_errno()) = 0; 
#line 449
__wchar_t *_Eptr; 
#line 450
float _Ans = (float)::wcstod(_Ptr, &_Eptr); 
#line 452
if (_Ptr == _Eptr) { 
#line 453
_Xinvalid_argument("invalid stof argument"); }  
#line 454
if ((*_errno()) == 34) { 
#line 455
_Xout_of_range("stof argument out of range"); }  
#line 456
if (_Idx != (0)) { 
#line 457
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 458
return _Ans; 
#line 459
} 
#line 461
inline double stod(const wstring &_Str, size_t *_Idx = 0) 
#line 462
{ 
#line 463
const __wchar_t *_Ptr = _Str.c_str(); 
#line 464
(*_errno()) = 0; 
#line 465
__wchar_t *_Eptr; 
#line 466
double _Ans = ::wcstod(_Ptr, &_Eptr); 
#line 468
if (_Ptr == _Eptr) { 
#line 469
_Xinvalid_argument("invalid stod argument"); }  
#line 470
if ((*_errno()) == 34) { 
#line 471
_Xout_of_range("stod argument out of range"); }  
#line 472
if (_Idx != (0)) { 
#line 473
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 474
return _Ans; 
#line 475
} 
#line 477
inline long double stold(const wstring &_Str, size_t *_Idx = 0) 
#line 478
{ 
#line 479
const __wchar_t *_Ptr = _Str.c_str(); 
#line 480
(*_errno()) = 0; 
#line 481
__wchar_t *_Eptr; 
#line 482
long double _Ans = ::wcstod(_Ptr, &_Eptr); 
#line 484
if (_Ptr == _Eptr) { 
#line 485
_Xinvalid_argument("invalid stold argument"); }  
#line 486
if ((*_errno()) == 34) { 
#line 487
_Xout_of_range("stold argument out of range"); }  
#line 488
if (_Idx != (0)) { 
#line 489
(*_Idx) = ((size_t)(_Eptr - ((__wchar_t *)_Ptr))); }  
#line 490
return _Ans; 
#line 491
} 
#line 500
inline string to_string(int _Val) 
#line 501
{ 
#line 502
char _Buf[2 * 32]; 
#line 504
::sprintf_s(_Buf, sizeof _Buf, "%d", _Val); 
#line 505
return ((string)(_Buf)); 
#line 506
} 
#line 508
inline string to_string(unsigned _Val) 
#line 509
{ 
#line 510
char _Buf[2 * 32]; 
#line 512
::sprintf_s(_Buf, sizeof _Buf, "%u", _Val); 
#line 513
return ((string)(_Buf)); 
#line 514
} 
#line 516
inline string to_string(long _Val) 
#line 517
{ 
#line 518
char _Buf[2 * 32]; 
#line 520
::sprintf_s(_Buf, sizeof _Buf, "%ld", _Val); 
#line 521
return ((string)(_Buf)); 
#line 522
} 
#line 524
inline string to_string(unsigned long _Val) 
#line 525
{ 
#line 526
char _Buf[2 * 32]; 
#line 528
::sprintf_s(_Buf, sizeof _Buf, "%lu", _Val); 
#line 529
return ((string)(_Buf)); 
#line 530
} 
#line 532
inline string to_string(_Longlong _Val) 
#line 533
{ 
#line 534
char _Buf[2 * 32]; 
#line 536
::sprintf_s(_Buf, sizeof _Buf, "%I64d", _Val); 
#line 537
return ((string)(_Buf)); 
#line 538
} 
#line 540
inline string to_string(_ULonglong _Val) 
#line 541
{ 
#line 542
char _Buf[2 * 32]; 
#line 544
::sprintf_s(_Buf, sizeof _Buf, "%I64u", _Val); 
#line 545
return ((string)(_Buf)); 
#line 546
} 
#line 548
inline string to_string(long double _Val) 
#line 549
{ 
#line 550
typedef back_insert_iterator< basic_string< char, char_traits< char> , allocator< char> > >  _Iter; 
#line 551
typedef num_put< char, back_insert_iterator< basic_string< char, char_traits< char> , allocator< char> > > >  _Nput; 
#line 552
const _Nput &_Nput_fac = use_facet< num_put< char, back_insert_iterator< basic_string< char, char_traits< char> , allocator< char> > > > > (locale()); 
#line 553
ostream _Ios((streambuf *)0); 
#line 554
string _Str; 
#line 556
_Ios.setf(_Iosb< int> ::fixed); 
#line 557
_Nput_fac.put(((_Iter)(_Str)), _Ios, ' ', _Val); 
#line 558
return _Str; 
#line 559
} 
#line 561
inline string to_string(double _Val) 
#line 562
{ 
#line 563
return to_string((long double)_Val); 
#line 564
} 
#line 566
inline string to_string(float _Val) 
#line 567
{ 
#line 568
return to_string((long double)_Val); 
#line 569
} 
#line 578
inline wstring to_wstring(int _Val) 
#line 579
{ 
#line 580
__wchar_t _Buf[2 * 32]; 
#line 582
::swprintf_s(_Buf, sizeof _Buf / sizeof(__wchar_t), L"\x25\x64", _Val); 
#line 583
return ((wstring)(_Buf)); 
#line 584
} 
#line 586
inline wstring to_wstring(unsigned _Val) 
#line 587
{ 
#line 588
__wchar_t _Buf[2 * 32]; 
#line 590
::swprintf_s(_Buf, sizeof _Buf / sizeof(__wchar_t), L"\x25\x75", _Val); 
#line 591
return ((wstring)(_Buf)); 
#line 592
} 
#line 594
inline wstring to_wstring(long _Val) 
#line 595
{ 
#line 596
__wchar_t _Buf[2 * 32]; 
#line 598
::swprintf_s(_Buf, sizeof _Buf / sizeof(__wchar_t), L"\x25\x6c\x64", _Val); 
#line 599
return ((wstring)(_Buf)); 
#line 600
} 
#line 602
inline wstring to_wstring(unsigned long _Val) 
#line 603
{ 
#line 604
__wchar_t _Buf[2 * 32]; 
#line 606
::swprintf_s(_Buf, sizeof _Buf / sizeof(__wchar_t), L"\x25\x6c\x75", _Val); 
#line 607
return ((wstring)(_Buf)); 
#line 608
} 
#line 610
inline wstring to_wstring(_Longlong _Val) 
#line 611
{ 
#line 612
__wchar_t _Buf[2 * 32]; 
#line 614
::swprintf_s(_Buf, sizeof _Buf / sizeof(__wchar_t), L"\x25\x49\x36\x34\x64", _Val); 
#line 615
return ((wstring)(_Buf)); 
#line 616
} 
#line 618
inline wstring to_wstring(_ULonglong _Val) 
#line 619
{ 
#line 620
__wchar_t _Buf[2 * 32]; 
#line 622
::swprintf_s(_Buf, sizeof _Buf / sizeof(__wchar_t), L"\x25\x49\x36\x34\x75", _Val); 
#line 623
return ((wstring)(_Buf)); 
#line 624
} 
#line 626
inline wstring to_wstring(long double _Val) 
#line 627
{ 
#line 628
typedef back_insert_iterator< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > >  _Iter; 
#line 629
typedef num_put< __wchar_t, back_insert_iterator< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > > >  _Nput; 
#line 630
const _Nput &_Nput_fac = use_facet< num_put< __wchar_t, back_insert_iterator< basic_string< __wchar_t, char_traits< __wchar_t> , allocator< __wchar_t> > > > > (locale()); 
#line 631
ostream _Ios((streambuf *)0); 
#line 632
wstring _Str; 
#line 634
_Ios.setf(_Iosb< int> ::fixed); 
#line 635
_Nput_fac.put(((_Iter)(_Str)), _Ios, L'\x20', _Val); 
#line 636
return _Str; 
#line 637
} 
#line 639
inline wstring to_wstring(double _Val) 
#line 640
{ 
#line 641
return to_wstring((long double)_Val); 
#line 642
} 
#line 644
inline wstring to_wstring(float _Val) 
#line 645
{ 
#line 646
return to_wstring((long double)_Val); 
#line 647
} 
#line 648
}
#line 651
#pragma warning(pop)
#pragma pack ( pop )
#line 36 "e:\\github\\whippletree\\queueInterface.cuh"
template< bool TWarnings = true> 
#line 37
class Queue { 
#line 40
public: static const bool needTripleCall = false; 
#line 41
static const bool supportReuseInit = false; 
#line 42
static const int globalMaintainMinThreads = 0; 
#line 43
static int globalMaintainSharedMemory(int Threads) { return 0; } 
#line 44
static const int requiredShared = 0; 
#line 46
__inline void init() 
#line 47
{int volatile ___ = 1;
#line 49
::exit(___);}
#if 0
#line 47
{ 
#line 48
if (TWarnings) { printf("Warning: Queue does not implement init\n"); }  
#line 49
} 
#endif
#line 51 "e:\\github\\whippletree\\queueInterface.cuh"
template< class PROCEDURE> __inline bool 
#line 52
enqueueInitial(typename PROCEDURE::ExpectedData data) 
#line 53
{int volatile ___ = 1;(void)data;
#line 56
::exit(___);}
#if 0
#line 53
{ 
#line 54
if (TWarnings) { printf("Error: Queue does not implement enqueueInitial\n"); }  
#line 55
return false; 
#line 56
} 
#endif
#line 58 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class PROCEDURE> __inline bool 
#line 59
enqueueInitial(typename PROCEDURE::ExpectedData *data) 
#line 60
{int volatile ___ = 1;(void)data;
#line 63
::exit(___);}
#if 0
#line 60
{ 
#line 61
if (TWarnings) { printf("Error: Queue does not implement enqueueInitial<int,Proc>\n"); }  
#line 62
return false; 
#line 63
} 
#endif
#line 65 "e:\\github\\whippletree\\queueInterface.cuh"
template< class PROCEDURE> __inline bool 
#line 66
enqueue(typename PROCEDURE::ExpectedData data) 
#line 67
{int volatile ___ = 1;(void)data;
#line 70
::exit(___);}
#if 0
#line 67
{ 
#line 68
if (TWarnings) { printf("Error: Queue does not implement enqueue\n"); }  
#line 69
return false; 
#line 70
} 
#endif
#line 72 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class PROCEDURE> __inline bool 
#line 73
enqueue(typename PROCEDURE::ExpectedData *data) 
#line 74
{int volatile ___ = 1;(void)data;
#line 77
::exit(___);}
#if 0
#line 74
{ 
#line 75
if (TWarnings) { printf("Error: Queue does not implement enqueue<Threads>\n"); }  
#line 76
return false; 
#line 77
} 
#endif
#line 79 "e:\\github\\whippletree\\queueInterface.cuh"
template< bool MultiProcedure> __inline int 
#line 80
dequeue(void *&data, int *&procId, int maxShared = -1) 
#line 81
{int volatile ___ = 1;(void)data;(void)procId;(void)maxShared;
#line 84
::exit(___);}
#if 0
#line 81
{ 
#line 82
if (TWarnings) { printf("Error: Queue does not implement dequeue\n"); }  
#line 83
return 0; 
#line 84
} 
#endif
#line 86 "e:\\github\\whippletree\\queueInterface.cuh"
template< bool MultiProcedure> __inline int 
#line 87
dequeueSelected(void *&data, int procId, int maxNum = -1) 
#line 88
{int volatile ___ = 1;(void)data;(void)procId;(void)maxNum;
#line 91
::exit(___);}
#if 0
#line 88
{ 
#line 89
if (TWarnings) { printf("Error: Queue does not implement dequeueSelected\n"); }  
#line 90
return 0; 
#line 91
} 
#endif
#line 93 "e:\\github\\whippletree\\queueInterface.cuh"
template< bool MultiProcedure> __inline int 
#line 94
dequeueStartRead(void *&data, int *&procId, int maxShared = -1) 
#line 95
{int volatile ___ = 1;(void)data;(void)procId;(void)maxShared;
#line 98
::exit(___);}
#if 0
#line 95
{ 
#line 96
if (TWarnings) { printf("Error: Queue does not implement dequeuePointer\n"); }  
#line 97
return 0; 
#line 98
} 
#endif
#line 100 "e:\\github\\whippletree\\queueInterface.cuh"
template< class PROCEDURE> __inline int 
#line 101
reserveRead(int maxNum = -1) 
#line 102
{int volatile ___ = 1;(void)maxNum;
#line 105
::exit(___);}
#if 0
#line 102
{ 
#line 103
if (TWarnings) { printf("Error: Queue does not implement reserveRead\n"); }  
#line 104
return 0; 
#line 105
} 
#endif
#line 106 "e:\\github\\whippletree\\queueInterface.cuh"
template< class PROCEDURE> __inline int 
#line 107
startRead(void *&data, int num) 
#line 108
{int volatile ___ = 1;(void)data;(void)num;
#line 111
::exit(___);}
#if 0
#line 108
{ 
#line 109
if (TWarnings) { printf("Error: Queue does not implement startRead\n"); }  
#line 110
return -1; 
#line 111
} 
#endif
#line 112 "e:\\github\\whippletree\\queueInterface.cuh"
template< class PROCEDURE> __inline void 
#line 113
finishRead(int id, int num) 
#line 114
{int volatile ___ = 1;(void)id;(void)num;
#line 116
::exit(___);}
#if 0
#line 114
{ 
#line 115
if (TWarnings) { printf("Error: Queue does not implement finishRead\n"); }  
#line 116
} 
#endif
#line 118 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void numEntries(int *counts) 
#line 119
{int volatile ___ = 1;(void)counts;
#line 121
::exit(___);}
#if 0
#line 119
{ 
#line 120
if (TWarnings) { printf("Error: Queue does not implement numEntries\n"); }  
#line 121
} 
#endif
#line 124 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void record() 
#line 125
{int volatile ___ = 1;
#line 127
::exit(___);}
#if 0
#line 125
{ 
#line 126
if (TWarnings) { printf("Error: Queue does not implement record\n"); }  
#line 127
} 
#endif
#line 128 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void reset() 
#line 129
{int volatile ___ = 1;
#line 131
::exit(___);}
#if 0
#line 129
{ 
#line 130
if (TWarnings) { printf("Error: Queue does not implement reset\n"); }  
#line 131
} 
#endif
#line 134 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void workerStart() 
#line 135
{int volatile ___ = 1;::exit(___);}
#if 0
#line 135
{ } 
#endif
#line 136 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void workerMaintain() 
#line 137
{int volatile ___ = 1;::exit(___);}
#if 0
#line 137
{ } 
#endif
#line 138 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void workerEnd() 
#line 139
{int volatile ___ = 1;::exit(___);}
#if 0
#line 139
{ } 
#endif
#line 140 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void globalMaintain() 
#line 141
{int volatile ___ = 1;::exit(___);}
#if 0
#line 141
{ } 
#endif
#line 143 "e:\\github\\whippletree\\queueInterface.cuh"
static std::string name() 
#line 144
{ 
#line 145
if (TWarnings) { 
#line 146
return "UnnamedQueuing"; } else { 
#line 148
return ""; }  
#line 149
} 
#line 150
}; 
#line 152
template< class ProcedureInfo, template< class >  class RealQueue, template< class >  class MatchMaker> 
#line 153
class QueueEnqueueWrapper : public RealQueue< ProcedureInfo>  { 
#line 157
public: 
#line 156
template< class PROCEDURE> __inline bool 
#line 157
enqueueInitial(typename PROCEDURE::ExpectedData data) 
#line 158
{int volatile ___ = 1;(void)data;
#line 160
::exit(___);}
#if 0
#line 158
{ 
#line 159
return RealQueue< ProcedureInfo> ::template enqueueInitial< typename MatchMaker< PROCEDURE> ::Match> (data); 
#line 160
} 
#endif
#line 162 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class PROCEDURE> __inline bool 
#line 163
enqueueInitial(typename PROCEDURE::ExpectedData *data) 
#line 164
{int volatile ___ = 1;(void)data;
#line 166
::exit(___);}
#if 0
#line 164
{ 
#line 165
return RealQueue< ProcedureInfo> ::template enqueueInitial< typename MatchMaker< PROCEDURE> ::Match> (data); 
#line 166
} 
#endif
#line 168 "e:\\github\\whippletree\\queueInterface.cuh"
template< class PROCEDURE> __inline bool 
#line 169
enqueue(typename PROCEDURE::ExpectedData data) 
#line 170
{int volatile ___ = 1;(void)data;
#line 172
::exit(___);}
#if 0
#line 170
{ 
#line 171
return RealQueue< ProcedureInfo> ::template enqueue< typename MatchMaker< PROCEDURE> ::Match> (data); 
#line 172
} 
#endif
#line 174 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class PROCEDURE> __inline bool 
#line 175
enqueue(typename PROCEDURE::ExpectedData *data) 
#line 176
{int volatile ___ = 1;(void)data;
#line 178
::exit(___);}
#if 0
#line 176
{ 
#line 177
return RealQueue< ProcedureInfo> ::template enqueue< threads, typename MatchMaker< PROCEDURE> ::Match> (data); 
#line 178
} 
#endif
#line 179 "e:\\github\\whippletree\\queueInterface.cuh"
}; 
#line 181
template< class TAdditionalData> 
#line 182
class BasicQueue { 
#line 186
public: __inline void init() 
#line 187
{int volatile ___ = 1;
#line 189
::exit(___);}
#if 0
#line 187
{ 
#line 188
printf("Warning: BasicQueue does not implement init\n"); 
#line 189
} 
#endif
#line 191 "e:\\github\\whippletree\\queueInterface.cuh"
template< class Data> __inline bool 
#line 192
enqueueInitial(Data data, TAdditionalData additionalData) 
#line 193
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 196
::exit(___);}
#if 0
#line 193
{ 
#line 194
printf("Error: BasicQueue does not implement enqueueInitial\n"); 
#line 195
return false; 
#line 196
} 
#endif
#line 198 "e:\\github\\whippletree\\queueInterface.cuh"
template< int Threads, class Data> __inline bool 
#line 199
enqueueInitial(Data *data, TAdditionalData additionalData) 
#line 200
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 203
::exit(___);}
#if 0
#line 200
{ 
#line 201
printf("Error: BasicQueue does not implement enqueueInitial\n"); 
#line 202
return false; 
#line 203
} 
#endif
#line 205 "e:\\github\\whippletree\\queueInterface.cuh"
template< class Data> __inline bool 
#line 206
enqueue(Data data, TAdditionalData additionalData) 
#line 207
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 210
::exit(___);}
#if 0
#line 207
{ 
#line 208
printf("Error: BasicQueue does not implement enqueue\n"); 
#line 209
return false; 
#line 210
} 
#endif
#line 212 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class Data> __inline bool 
#line 213
enqueue(Data *data, TAdditionalData additionalData) 
#line 214
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 217
::exit(___);}
#if 0
#line 214
{ 
#line 215
printf("Error: BasicQueue does not implement enqueue<Threads>\n"); 
#line 216
return false; 
#line 217
} 
#endif
#line 219 "e:\\github\\whippletree\\queueInterface.cuh"
__inline int dequeue(void *data, TAdditionalData *addtionalData, int maxnum) 
#line 220
{int volatile ___ = 1;(void)data;(void)addtionalData;(void)maxnum;
#line 223
::exit(___);}
#if 0
#line 220
{ 
#line 221
printf("Error: BasicQueue does not implement dequeue\n"); 
#line 222
return 0; 
#line 223
} 
#endif
#line 225 "e:\\github\\whippletree\\queueInterface.cuh"
__inline int reserveRead(int maxnum, bool only_read_all = false) 
#line 226
{int volatile ___ = 1;(void)maxnum;(void)only_read_all;
#line 229
::exit(___);}
#if 0
#line 226
{ 
#line 227
printf("Error: BasicQueue does not implement reserveRead\n"); 
#line 228
return 0; 
#line 229
} 
#endif
#line 230 "e:\\github\\whippletree\\queueInterface.cuh"
__inline int startRead(void *&data, TAdditionalData *addtionalData, int pos, int num) 
#line 231
{int volatile ___ = 1;(void)data;(void)addtionalData;(void)pos;(void)num;
#line 234
::exit(___);}
#if 0
#line 231
{ 
#line 232
printf("Error: BasicQueue does not implement startRead\n"); 
#line 233
return -1; 
#line 234
} 
#endif
#line 235 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void finishRead(int id, int num) 
#line 236
{int volatile ___ = 1;(void)id;(void)num;
#line 238
::exit(___);}
#if 0
#line 236
{ 
#line 237
printf("Error: BasicQueue does not implement finishRead\n"); 
#line 238
} 
#endif
#line 240 "e:\\github\\whippletree\\queueInterface.cuh"
template< class SortInfo> __inline bool 
#line 241
sort(unsigned threads) 
#line 242
{int volatile ___ = 1;(void)threads;
#line 245
::exit(___);}
#if 0
#line 242
{ 
#line 243
printf("Error: BasicQueue does not implement sort\n"); 
#line 244
return false; 
#line 245
} 
#endif
#line 247 "e:\\github\\whippletree\\queueInterface.cuh"
static std::string name() 
#line 248
{ 
#line 249
return "UnnamedBasicQueue"; 
#line 250
} 
#line 251
}; 
#line 254
template<> class BasicQueue< void>  { 
#line 257
public: __inline void init() 
#line 258
{int volatile ___ = 1;
#line 260
::exit(___);}
#if 0
#line 258
{ 
#line 259
printf("Warning: BasicQueue does not implement init\n"); 
#line 260
} 
#endif
#line 262 "e:\\github\\whippletree\\queueInterface.cuh"
template< class Data> __inline bool 
#line 263
enqueueInitial(Data data) 
#line 264
{int volatile ___ = 1;(void)data;
#line 267
::exit(___);}
#if 0
#line 264
{ 
#line 265
printf("Error: BasicQueue does not implement enqueueInitial\n"); 
#line 266
return false; 
#line 267
} 
#endif
#line 269 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class Data> __inline bool 
#line 270
enqueueInitial(Data *data) 
#line 271
{int volatile ___ = 1;(void)data;
#line 274
::exit(___);}
#if 0
#line 271
{ 
#line 272
printf("Error: BasicQueue does not implement enqueueInitial*\n"); 
#line 273
return false; 
#line 274
} 
#endif
#line 276 "e:\\github\\whippletree\\queueInterface.cuh"
template< class Data> __inline bool 
#line 277
enqueue(Data data) 
#line 278
{int volatile ___ = 1;(void)data;
#line 281
::exit(___);}
#if 0
#line 278
{ 
#line 279
printf("Error: BasicQueue does not implement enqueue\n"); 
#line 280
return false; 
#line 281
} 
#endif
#line 283 "e:\\github\\whippletree\\queueInterface.cuh"
template< int threads, class Data> __inline bool 
#line 284
enqueue(Data *data) 
#line 285
{int volatile ___ = 1;(void)data;
#line 288
::exit(___);}
#if 0
#line 285
{ 
#line 286
printf("Error: BasicQueue does not implement enqueue<Threads>\n"); 
#line 287
return false; 
#line 288
} 
#endif
#line 290 "e:\\github\\whippletree\\queueInterface.cuh"
__inline int dequeue(void *data, int maxnum) 
#line 291
{int volatile ___ = 1;(void)data;(void)maxnum;
#line 294
::exit(___);}
#if 0
#line 291
{ 
#line 292
printf("Error: BasicQueue does not implement dequeue\n"); 
#line 293
return 0; 
#line 294
} 
#endif
#line 296 "e:\\github\\whippletree\\queueInterface.cuh"
__inline int reserveRead(int maxnum, bool only_read_all = false) 
#line 297
{int volatile ___ = 1;(void)maxnum;(void)only_read_all;
#line 300
::exit(___);}
#if 0
#line 297
{ 
#line 298
printf("Error: BasicQueue does not implement reserveRead\n"); 
#line 299
return 0; 
#line 300
} 
#endif
#line 301 "e:\\github\\whippletree\\queueInterface.cuh"
__inline int startRead(void *&data, int pos, int num) 
#line 302
{int volatile ___ = 1;(void)data;(void)pos;(void)num;
#line 305
::exit(___);}
#if 0
#line 302
{ 
#line 303
printf("Error: BasicQueue does not implement startRead\n"); 
#line 304
return -1; 
#line 305
} 
#endif
#line 306 "e:\\github\\whippletree\\queueInterface.cuh"
__inline void finishRead(int id, int num) 
#line 307
{int volatile ___ = 1;(void)id;(void)num;
#line 309
::exit(___);}
#if 0
#line 307
{ 
#line 308
printf("Error: Queue does not implement finishRead\n"); 
#line 309
} 
#endif
#line 311 "e:\\github\\whippletree\\queueInterface.cuh"
template< class SortInfo> __inline bool 
#line 312
sort(unsigned threads) 
#line 313
{int volatile ___ = 1;(void)threads;
#line 316
::exit(___);}
#if 0
#line 313
{ 
#line 314
printf("Error: BasicQueue does not implement sort\n"); 
#line 315
return false; 
#line 316
} 
#endif
#line 318 "e:\\github\\whippletree\\queueInterface.cuh"
static std::string name() 
#line 319
{ 
#line 320
return "UnnamedBasicQueue"; 
#line 321
} 
#line 322
}; 
#line 325
typedef Queue< false>  ZeroQueue; 
#line 327
template< class ProcInfo> 
#line 328
class IgnoreQueue : public ZeroQueue { }; 
#line 331
template< class Q> static void 
#line 332
__wrapper__device_stub_initQueue(Q *&q) {exit(1);}
#if 0
#line 333
{ 
#line 334
(q->init()); 
#line 335
} 
#endif
#line 331 "e:\\github\\whippletree\\queueInterface.cuh"
template< class Q> void 
#line 332
initQueue(Q *q) 
#line 333
{__wrapper__device_stub_initQueue<Q>(q);
#line 335
return;}
#if 0
#line 333
{ 
#line 334
(q->init()); 
#line 335
} 
#endif
#line 337 "e:\\github\\whippletree\\queueInterface.cuh"
template< unsigned Size> 
#line 338
class Min16 { 
#line 341
public: static const unsigned Compute = Size; 
#line 342
}; 
#line 353
template<> class Min16< 0U>  { public: static const unsigned Compute = 16U; }; 
#line 354
template<> class Min16< 1U>  { public: static const unsigned Compute = 16U; }; 
#line 355
template<> class Min16< 2U>  { public: static const unsigned Compute = 16U; }; 
#line 356
template<> class Min16< 3U>  { public: static const unsigned Compute = 16U; }; 
#line 357
template<> class Min16< 4U>  { public: static const unsigned Compute = 16U; }; 
#line 358
template<> class Min16< 5U>  { public: static const unsigned Compute = 16U; }; 
#line 359
template<> class Min16< 6U>  { public: static const unsigned Compute = 16U; }; 
#line 360
template<> class Min16< 7U>  { public: static const unsigned Compute = 16U; }; 
#line 361
template<> class Min16< 8U>  { public: static const unsigned Compute = 16U; }; 
#line 362
template<> class Min16< 9U>  { public: static const unsigned Compute = 16U; }; 
#line 363
template<> class Min16< 10U>  { public: static const unsigned Compute = 16U; }; 
#line 364
template<> class Min16< 11U>  { public: static const unsigned Compute = 16U; }; 
#line 365
template<> class Min16< 12U>  { public: static const unsigned Compute = 16U; }; 
#line 366
template<> class Min16< 13U>  { public: static const unsigned Compute = 16U; }; 
#line 367
template<> class Min16< 14U>  { public: static const unsigned Compute = 16U; }; 
#line 368
template<> class Min16< 15U>  { public: static const unsigned Compute = 16U; }; 
#line 69 "e:\\github\\whippletree\\tools/types.h"
typedef unsigned uint; 
#line 70
typedef unsigned short ushort; 
#line 72
namespace Tools { 
#line 75
struct dim { 
#line 78
union { 
#line 80
struct { 
#line 81
uint x, y, z; 
#line 82
}; 
#line 83
uint d[3]; 
#line 84
}; 
#line 85
dim(uint _x, uint _y = 1, uint _z = 1) : x(_x), y(_y), z(_z) 
#line 87
{ 
#line 88
} 
#line 89
}; 
#line 90
}
#line 76 "e:\\github\\whippletree\\tools/utils.h"
namespace Tools { 
#line 80
class CudaError : public std::runtime_error { 
#line 83
static std::string genErrorString(cudaError error, const char *file, int line) 
#line 84
{ 
#line 88
return (((((((((std::string)(file)) + ('('))) + (std::to_string(static_cast< __int64>(line))))) + ("): error: "))) + (cudaGetErrorString(error))); 
#line 89
} 
#line 91
public: CudaError(cudaError error, const char *file, int line) : std::runtime_error(genErrorString(error, file, line)) 
#line 93
{ 
#line 94
} 
#line 96
CudaError(cudaError error) : std::runtime_error(cudaGetErrorString(error)) 
#line 98
{ 
#line 99
} 
#line 101
CudaError(const std::string &msg) : std::runtime_error(msg) 
#line 103
{ 
#line 104
} 
#line 105
}; 
#line 106
inline void checkError(cudaError error, const char *file, int line) 
#line 107
{ 
#line 108
if (error != (cudaSuccess)) { 
#line 109
throw CudaError(error, file, line); }  
#line 110
} 
#line 112
inline void checkError(const char *file, int line) 
#line 113
{ 
#line 114
checkError(cudaGetLastError(), file, line); 
#line 115
} 
#line 117
inline void checkError() 
#line 118
{ 
#line 119
cudaError error = cudaGetLastError(); 
#line 120
if (error != (cudaSuccess)) { 
#line 121
throw ((CudaError)(error)); }  
#line 122
} 
#line 123
}
#line 73 "e:\\github\\whippletree\\tools/common.cuh"
namespace Tools { 
#line 76
template< int PSIZE> 
#line 77
class __PointerEquivalent { 
#line 80
public: typedef unsigned type; 
#line 82
static ::uint isshared(::uint p) 
#line 83
{int volatile ___ = 1;(void)p;
#line 92
::exit(___);}
#if 0
#line 83
{ 
#line 84
::uint res; 
#line 85
__asm {
	.reg .pred t1;
	isspacep.shared t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 92
} 
#endif
#line 93 "e:\\github\\whippletree\\tools/common.cuh"
static ::uint islocal(::uint p) 
#line 94
{int volatile ___ = 1;(void)p;
#line 103
::exit(___);}
#if 0
#line 94
{ 
#line 95
::uint res; 
#line 96
__asm {
	.reg .pred t1;
	isspacep.local t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 103
} 
#endif
#line 104 "e:\\github\\whippletree\\tools/common.cuh"
static ::uint isconst(::uint p) 
#line 105
{int volatile ___ = 1;(void)p;
#line 114
::exit(___);}
#if 0
#line 105
{ 
#line 106
::uint res; 
#line 107
__asm {
	.reg .pred t1;
	isspacep.const, t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 114
} 
#endif
#line 115 "e:\\github\\whippletree\\tools/common.cuh"
static ::uint isglobal(::uint p) 
#line 116
{int volatile ___ = 1;(void)p;
#line 125
::exit(___);}
#if 0
#line 116
{ 
#line 117
::uint res; 
#line 118
__asm {
	.reg .pred t1;
	isspacep.global, t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 125
} 
#endif
#line 127 "e:\\github\\whippletree\\tools/common.cuh"
}; 
#line 129
template<> class __PointerEquivalent< 8>  { 
#line 132
public: typedef unsigned __int64 type; 
#line 134
static uint isshared(unsigned __int64 p) 
#line 135
{int volatile ___ = 1;(void)p;
#line 144
::exit(___);}
#if 0
#line 135
{ 
#line 136
uint res; 
#line 137
__asm {
	.reg .pred t1;
	isspacep.shared t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 144
} 
#endif
#line 145 "e:\\github\\whippletree\\tools/common.cuh"
static uint islocal(unsigned __int64 p) 
#line 146
{int volatile ___ = 1;(void)p;
#line 155
::exit(___);}
#if 0
#line 146
{ 
#line 147
uint res; 
#line 148
__asm {
	.reg .pred t1;
	isspacep.local t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 155
} 
#endif
#line 156 "e:\\github\\whippletree\\tools/common.cuh"
static uint isconst(unsigned __int64 p) 
#line 157
{int volatile ___ = 1;(void)p;
#line 166
::exit(___);}
#if 0
#line 157
{ 
#line 158
uint res; 
#line 159
__asm {
	.reg .pred t1;
	isspacep.const t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 166
} 
#endif
#line 167 "e:\\github\\whippletree\\tools/common.cuh"
static uint isglobal(unsigned __int64 p) 
#line 168
{int volatile ___ = 1;(void)p;
#line 177
::exit(___);}
#if 0
#line 168
{ 
#line 169
uint res; 
#line 170
__asm {
	.reg .pred t1;
	isspacep.global t1, %1;
	selp.u32 	%0, 1, 0, t1;
	}
	
return res; 
#line 177
} 
#endif
#line 179 "e:\\github\\whippletree\\tools/common.cuh"
}; 
#line 180
typedef __PointerEquivalent< 4> ::type PointerEquivalent; 
#line 183
inline uint laneid() 
#line 184
{int volatile ___ = 1;
#line 188
::exit(___);}
#if 0
#line 184
{ 
#line 185
uint mylaneid; 
#line 186
__asm mov.u32 %0, %laneid;
return mylaneid; 
#line 188
} 
#endif
#line 190 "e:\\github\\whippletree\\tools/common.cuh"
inline uint warpid() 
#line 191
{int volatile ___ = 1;
#line 195
::exit(___);}
#if 0
#line 191
{ 
#line 192
uint mywarpid; 
#line 193
__asm mov.u32 %0, %warpid;
return mywarpid; 
#line 195
} 
#endif
#line 196 "e:\\github\\whippletree\\tools/common.cuh"
inline uint nwarpid() 
#line 197
{int volatile ___ = 1;
#line 201
::exit(___);}
#if 0
#line 197
{ 
#line 198
uint mynwarpid; 
#line 199
__asm mov.u32 %0, %nwarpid;
return mynwarpid; 
#line 201
} 
#endif
#line 203 "e:\\github\\whippletree\\tools/common.cuh"
inline uint smid() 
#line 204
{int volatile ___ = 1;
#line 208
::exit(___);}
#if 0
#line 204
{ 
#line 205
uint mysmid; 
#line 206
__asm mov.u32 %0, %smid;
return mysmid; 
#line 208
} 
#endif
#line 211 "e:\\github\\whippletree\\tools/common.cuh"
inline uint gridid() 
#line 212
{int volatile ___ = 1;
#line 216
::exit(___);}
#if 0
#line 212
{ 
#line 213
uint mygridid; 
#line 214
__asm mov.u32 %0, %gridid;
return mygridid; 
#line 216
} 
#endif
#line 226 "e:\\github\\whippletree\\tools/common.cuh"
inline uint nsmid() 
#line 227
{int volatile ___ = 1;
#line 231
::exit(___);}
#if 0
#line 227
{ 
#line 228
uint mynsmid; 
#line 229
__asm mov.u32 %0, %nsmid;
return mynsmid; 
#line 231
} 
#endif
#line 233 "e:\\github\\whippletree\\tools/common.cuh"
inline uint lanemask() 
#line 234
{int volatile ___ = 1;
#line 238
::exit(___);}
#if 0
#line 234
{ 
#line 235
uint lanemask; 
#line 236
__asm mov.u32 %0, %lanemask_eq;
return lanemask; 
#line 238
} 
#endif
#line 240 "e:\\github\\whippletree\\tools/common.cuh"
inline uint lanemask_le() 
#line 241
{int volatile ___ = 1;
#line 245
::exit(___);}
#if 0
#line 241
{ 
#line 242
uint lanemask; 
#line 243
__asm mov.u32 %0, %lanemask_le;
return lanemask; 
#line 245
} 
#endif
#line 247 "e:\\github\\whippletree\\tools/common.cuh"
inline uint lanemask_lt() 
#line 248
{int volatile ___ = 1;
#line 252
::exit(___);}
#if 0
#line 248
{ 
#line 249
uint lanemask; 
#line 250
__asm mov.u32 %0, %lanemask_lt;
return lanemask; 
#line 252
} 
#endif
#line 254 "e:\\github\\whippletree\\tools/common.cuh"
inline uint lanemask_ge() 
#line 255
{int volatile ___ = 1;
#line 259
::exit(___);}
#if 0
#line 255
{ 
#line 256
uint lanemask; 
#line 257
__asm mov.u32 %0, %lanemask_ge;
return lanemask; 
#line 259
} 
#endif
#line 261 "e:\\github\\whippletree\\tools/common.cuh"
inline uint lanemask_gt() 
#line 262
{int volatile ___ = 1;
#line 266
::exit(___);}
#if 0
#line 262
{ 
#line 263
uint lanemask; 
#line 264
__asm mov.u32 %0, %lanemask_gt;
return lanemask; 
#line 266
} 
#endif
#line 267 "e:\\github\\whippletree\\tools/common.cuh"
inline void trap() 
#line 268
{int volatile ___ = 1;
#line 270
::exit(___);}
#if 0
#line 268
{ 
#line 269
__asm trap;
} 
#endif
#line 272 "e:\\github\\whippletree\\tools/common.cuh"
inline void syncthreads(uint lock = 0, int num = -1) 
#line 273
{int volatile ___ = 1;(void)lock;(void)num;
#line 282
::exit(___);}
#if 0
#line 273
{ 
#line 274
if (num == (-1)) 
#line 275
{ 
#line 276
__asm bar.sync %0;
} else 
#line 279
{ 
#line 280
__asm bar.sync %0, %1;
}  
#line 282
} 
#endif
#line 283 "e:\\github\\whippletree\\tools/common.cuh"
inline void arrive(uint lock, uint num) 
#line 284
{int volatile ___ = 1;(void)lock;(void)num;
#line 286
::exit(___);}
#if 0
#line 284
{ 
#line 285
__asm bar.arrive %0, %1;
} 
#endif
#line 287 "e:\\github\\whippletree\\tools/common.cuh"
inline uint syncthreads_count(uint predicate, uint lock = 0, int num = -1) 
#line 288
{int volatile ___ = 1;(void)predicate;(void)lock;(void)num;
#line 299
::exit(___);}
#if 0
#line 288
{ 
#line 289
uint res; 
#line 290
if (num == (-1)) 
#line 291
{ 
#line 292
__asm bar.red.popc.u32 %0, %1, %2;
} else 
#line 295
{ 
#line 296
__asm bar.red.popc.u32 %0, %1, %2, %3;
}  
#line 298
return res; 
#line 299
} 
#endif
#line 300 "e:\\github\\whippletree\\tools/common.cuh"
inline int syncthreads_or(int predicate, uint lock = 0, int num = -1) 
#line 301
{int volatile ___ = 1;(void)predicate;(void)lock;(void)num;
#line 312
::exit(___);}
#if 0
#line 301
{ 
#line 302
int res; 
#line 303
if (num == (-1)) 
#line 304
{ 
#line 305
__asm bar.red.or.pred %0, %1, %2;
} else 
#line 308
{ 
#line 309
__asm bar.red.or.pred %0, %1, %2, %3;
}  
#line 311
return res; 
#line 312
} 
#endif
#line 313 "e:\\github\\whippletree\\tools/common.cuh"
inline int syncthreads_and(int predicate, uint lock = 0, int num = -1) 
#line 314
{int volatile ___ = 1;(void)predicate;(void)lock;(void)num;
#line 325
::exit(___);}
#if 0
#line 314
{ 
#line 315
int res; 
#line 316
if (num == (-1)) 
#line 317
{ 
#line 318
__asm bar.red.and.pred %0, %1, %2;
} else 
#line 321
{ 
#line 322
__asm bar.red.and.pred %0, %1, %2, %3;
}  
#line 324
return res; 
#line 325
} 
#endif
#line 326 "e:\\github\\whippletree\\tools/common.cuh"
inline clock_t __clock() 
#line 327
{int volatile ___ = 1;
#line 337 "e:\\github\\whippletree\\tools/common.cuh"
::exit(___);}
#if 0
#line 327 "e:\\github\\whippletree\\tools/common.cuh"
{ 
#line 328
volatile clock_t hack; 
#line 329
clock_t c; 
#line 331
__asm mov.u32 %0, %%clock;
#line 335 "e:\\github\\whippletree\\tools/common.cuh"
hack = c; 
#line 336
return hack; 
#line 337
} 
#endif
#line 338 "e:\\github\\whippletree\\tools/common.cuh"
inline uint isshared(void *p) 
#line 339
{int volatile ___ = 1;(void)p;
#line 341
::exit(___);}
#if 0
#line 339
{ 
#line 340
return Tools::__PointerEquivalent< 4> ::isshared((PointerEquivalent)p); 
#line 341
} 
#endif
#line 342 "e:\\github\\whippletree\\tools/common.cuh"
inline uint islocal(void *p) 
#line 343
{int volatile ___ = 1;(void)p;
#line 345
::exit(___);}
#if 0
#line 343
{ 
#line 344
return Tools::__PointerEquivalent< 4> ::islocal((PointerEquivalent)p); 
#line 345
} 
#endif
#line 346 "e:\\github\\whippletree\\tools/common.cuh"
inline uint isconst(void *p) 
#line 347
{int volatile ___ = 1;(void)p;
#line 349
::exit(___);}
#if 0
#line 347
{ 
#line 348
return Tools::__PointerEquivalent< 4> ::isconst((PointerEquivalent)p); 
#line 349
} 
#endif
#line 350 "e:\\github\\whippletree\\tools/common.cuh"
inline uint isglobal(void *p) 
#line 351
{int volatile ___ = 1;(void)p;
#line 353
::exit(___);}
#if 0
#line 351
{ 
#line 352
return Tools::__PointerEquivalent< 4> ::isglobal((PointerEquivalent)p); 
#line 353
} 
#endif
#line 355 "e:\\github\\whippletree\\tools/common.cuh"
typedef unsigned __int64 clock64_t; 
#line 357
inline clock64_t __clock64() 
#line 358
{int volatile ___ = 1;
#line 364
::exit(___);}
#if 0
#line 358
{ 
#line 359
volatile clock64_t hack; 
#line 360
clock64_t c; 
#line 361
__asm mov.u64 %0, %%clock64;
hack = c; 
#line 363
return hack; 
#line 364
} 
#endif
#line 367 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 368
divup(T a, T b) { return ((a + b) - 1) / b; } 
#line 371
inline void wait(uint cycles) 
#line 372
{int volatile ___ = 1;(void)cycles;
#line 375
::exit(___);}
#if 0
#line 372
{ 
#line 373
clock_t start = clock(); 
#line 374
while ((clock() - start) < cycles) { ; }  
#line 375
} 
#endif
#line 380 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 381
atomicAddVolatile(volatile T *p, T val) 
#line 382
{int volatile ___ = 1;(void)p;(void)val;
#line 384
::exit(___);}
#if 0
#line 382
{ 
#line 383
return atomicAdd(const_cast< T *>(p), val); 
#line 384
} 
#endif
#line 385 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 386
atomicSubVolatile(volatile T *p, T val) 
#line 387
{int volatile ___ = 1;(void)p;(void)val;
#line 389
::exit(___);}
#if 0
#line 387
{ 
#line 388
return atomicSub(const_cast< T *>(p), val); 
#line 389
} 
#endif
#line 390 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 391
atomicExchVolatile(volatile T *p, T val) 
#line 392
{int volatile ___ = 1;(void)p;(void)val;
#line 394
::exit(___);}
#if 0
#line 392
{ 
#line 393
return atomicExch(const_cast< T *>(p), val); 
#line 394
} 
#endif
#line 395 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 396
atomicMinVolatile(volatile T *p, T val) 
#line 397
{int volatile ___ = 1;(void)p;(void)val;
#line 399
::exit(___);}
#if 0
#line 397
{ 
#line 398
return atomicMin(const_cast< T *>(p), val); 
#line 399
} 
#endif
#line 400 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 401
atomicMaxVolatile(volatile T *p, T val) 
#line 402
{int volatile ___ = 1;(void)p;(void)val;
#line 404
::exit(___);}
#if 0
#line 402
{ 
#line 403
return atomicMax(const_cast< T *>(p), val); 
#line 404
} 
#endif
#line 405 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 406
atomicIncVolatile(volatile T *p, T val) 
#line 407
{int volatile ___ = 1;(void)p;(void)val;
#line 409
::exit(___);}
#if 0
#line 407
{ 
#line 408
return atomicInc(const_cast< T *>(p), val); 
#line 409
} 
#endif
#line 410 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 411
atomicDecVolatile(volatile T *p, T val) 
#line 412
{int volatile ___ = 1;(void)p;(void)val;
#line 414
::exit(___);}
#if 0
#line 412
{ 
#line 413
return atomicDec(const_cast< T *>(p), val); 
#line 414
} 
#endif
#line 415 "e:\\github\\whippletree\\tools/common.cuh"
template< class T> inline T 
#line 416
atomicCASVolatile(volatile T *p, T compare, T val) 
#line 417
{int volatile ___ = 1;(void)p;(void)compare;(void)val;
#line 419
::exit(___);}
#if 0
#line 417
{ 
#line 418
return atomicCAS(const_cast< T *>(p), compare, val); 
#line 419
} 
#endif
#line 435 "e:\\github\\whippletree\\tools/common.cuh"
}
#line 39 "e:\\github\\whippletree\\random.cuh"
namespace whippletree { namespace random { 
#line 42
__inline int warp_rand() 
#line 43
{int volatile ___ = 1;
#line 47
::exit(___);}
#if 0
#line 43
{ 
#line 44
clock_t m1 = ((((40009) + clock()) / (16)) * (19281)) + ((((811) * Tools::smid()) + ((127) * Tools::warpid())) * (8231)); 
#line 45
clock_t m2 = ((36969) * (m1 & (65535))) + (m1 >> 16); 
#line 46
return m2 & (65535); 
#line 47
} 
#endif
#line 50 "e:\\github\\whippletree\\random.cuh"
__inline int rand() 
#line 51
{int volatile ___ = 1;
#line 55
::exit(___);}
#if 0
#line 51
{ 
#line 52
clock_t m1 = ((((40009) + clock()) / (16)) * (19281)) + (((((61) * (__device_builtin_variable_threadIdx.x)) + ((811) * Tools::smid())) + ((127) * Tools::warpid())) * (8231)); 
#line 53
clock_t m2 = ((36969) * (m1 & (65535))) + (m1 >> 16); 
#line 54
return m2 & (65535); 
#line 55
} 
#endif
#line 57 "e:\\github\\whippletree\\random.cuh"
static const int max = 65535; 
#line 58
static const int Range = 65536; 
#line 61
__inline int frand() 
#line 62
{int volatile ___ = 1;
#line 64
::exit(___);}
#if 0
#line 62
{ 
#line 63
return (rand()) / (static_cast< float>(max)); 
#line 64
} 
#endif
#line 67 "e:\\github\\whippletree\\random.cuh"
__inline bool check(int percent) 
#line 68
{int volatile ___ = 1;(void)percent;
#line 70
::exit(___);}
#if 0
#line 68
{ 
#line 69
return rand() < (((max + 1) * percent) / 100); 
#line 70
} 
#endif
#line 73 "e:\\github\\whippletree\\random.cuh"
__inline bool warp_check(int percent) 
#line 74
{int volatile ___ = 1;(void)percent;
#line 76
::exit(___);}
#if 0
#line 74
{ 
#line 75
return warp_rand() < (((max + 1) * percent) / 100); 
#line 76
} 
#endif
#line 79 "e:\\github\\whippletree\\random.cuh"
__inline bool block_check(int percent) 
#line 80
{int volatile ___ = 1;(void)percent;
#line 87
::exit(___);}
#if 0
#line 80
{ 
#line 81
bool res; 
#line 82
__syncthreads(); 
#line 83
if ((__device_builtin_variable_threadIdx.x) == (0)) { 
#line 84
res = check(percent); }  
#line 85
__syncthreads(); 
#line 86
return res; 
#line 87
} 
#endif
#line 89 "e:\\github\\whippletree\\random.cuh"
}}
#line 43 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class TAdditionalData> 
#line 44
struct AdditionalDataInfo { 
#line 46
static const int size = (sizeof(TAdditionalData)); 
#line 47
}; 
#line 50
template<> struct AdditionalDataInfo< void>  { 
#line 52
static const int size = 0; 
#line 53
}; 
#line 55
template< int Mod, int MaxWarps> __inline int 
#line 56
warpBroadcast(int val, int who) 
#line 57
{int volatile ___ = 1;(void)val;(void)who;
#line 71 "e:\\github\\whippletree\\queueHelpers.cuh"
::exit(___);}
#if 0
#line 57 "e:\\github\\whippletree\\queueHelpers.cuh"
{ 
#line 59
volatile int comm[MaxWarps]; 
#line 60
for (int offset = 0; offset < 32; offset += Mod) 
#line 61
{ 
#line 62
if ((Tools::laneid() - offset) == who) { 
#line 63
((comm)[(__device_builtin_variable_threadIdx.x) / (32)]) = val; }  
#line 64
if (Tools::laneid() < (offset + Mod)) { 
#line 65
return (comm)[(__device_builtin_variable_threadIdx.x) / (32)]; }  
#line 66
}  
#line 67
return val; 
#line 71 "e:\\github\\whippletree\\queueHelpers.cuh"
} 
#endif
#line 72 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int Mod> __inline int 
#line 73
warpBroadcast(int val, int who) 
#line 74
{int volatile ___ = 1;(void)val;(void)who;
#line 76
::exit(___);}
#if 0
#line 74
{ 
#line 75
return warpBroadcast< Mod, 32> (val, who); 
#line 76
} 
#endif
#line 78 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int Mod, int MaxWarps> __inline int 
#line 79
warpShfl(int val, int who) 
#line 80
{int volatile ___ = 1;(void)val;(void)who;
#line 102 "e:\\github\\whippletree\\queueHelpers.cuh"
::exit(___);}
#if 0
#line 80 "e:\\github\\whippletree\\queueHelpers.cuh"
{ 
#line 82
volatile int comm[MaxWarps]; 
#line 83
int runid = 0; 
#line 84
int res = val; 
#line 85
for (int offset = 0; offset < 32; offset += Mod) 
#line 86
{ 
#line 87
for (int within = 0; within < Mod; ++within) 
#line 88
{ 
#line 89
if (Tools::laneid() == runid) { 
#line 90
((comm)[(__device_builtin_variable_threadIdx.x) / (32)]) = val; }  
#line 91
if (((Tools::laneid() >= offset) && (Tools::laneid() < (offset + Mod))) && ((runid % Mod) == ((who + 32) % Mod))) { 
#line 94
res = ((comm)[(__device_builtin_variable_threadIdx.x) / (32)]); }  
#line 95
++runid; 
#line 96
}  
#line 97
}  
#line 98
return res; 
#line 102 "e:\\github\\whippletree\\queueHelpers.cuh"
} 
#endif
#line 103 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int Mod> __inline int 
#line 104
warpShfl(int val, int who) 
#line 105
{int volatile ___ = 1;(void)val;(void)who;
#line 107
::exit(___);}
#if 0
#line 105
{ 
#line 106
return warpShfl< Mod, 32> (val, who); 
#line 107
} 
#endif
#line 110 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int Maxrand> __inline void 
#line 111
backoff(int num) 
#line 112
{int volatile ___ = 1;(void)num;
#line 120
::exit(___);}
#if 0
#line 112
{ 
#line 114
volatile int local = __device_builtin_variable_threadIdx.x; 
#line 115
for (int i = 0; i < (whippletree::random::rand() % Maxrand); ++i) 
#line 116
{ 
#line 117
local += ((num * (__device_builtin_variable_threadIdx.x)) / (i + 1234)); 
#line 118
__threadfence(); 
#line 119
}  
#line 120
} 
#endif
#line 123 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uint4 &load(uint4 &dest, const volatile uint4 &src) 
#line 124
{int volatile ___ = 1;(void)dest;(void)src;
#line 127
::exit(___);}
#if 0
#line 124
{ 
#line 125
__asm ld.volatile.global.v4.u32 {%0, %1, %2, %3}, [%4];
return dest; 
#line 127
} 
#endif
#line 129 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uint2 &load(uint2 &dest, const volatile uint2 &src) 
#line 130
{int volatile ___ = 1;(void)dest;(void)src;
#line 133
::exit(___);}
#if 0
#line 130
{ 
#line 131
__asm ld.volatile.global.v2.u32 {%0, %1}, [%2];
return dest; 
#line 133
} 
#endif
#line 135 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uint &load(uint &dest, const volatile uint &src) 
#line 136
{int volatile ___ = 1;(void)dest;(void)src;
#line 139
::exit(___);}
#if 0
#line 136
{ 
#line 137
dest = src; 
#line 138
return dest; 
#line 139
} 
#endif
#line 141 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uint1 &load(uint1 &dest, const volatile uint1 &src) 
#line 142
{int volatile ___ = 1;(void)dest;(void)src;
#line 145
::exit(___);}
#if 0
#line 142
{ 
#line 143
(dest.x) = (src.x); 
#line 144
return dest; 
#line 145
} 
#endif
#line 147 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uchar3 &load(uchar3 &dest, const volatile uchar3 &src) 
#line 148
{int volatile ___ = 1;(void)dest;(void)src;
#line 153
::exit(___);}
#if 0
#line 148
{ 
#line 149
(dest.x) = (src.x); 
#line 150
(dest.y) = (src.y); 
#line 151
(dest.z) = (src.z); 
#line 152
return dest; 
#line 153
} 
#endif
#line 155 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uchar2 &load(uchar2 &dest, const volatile uchar2 &src) 
#line 156
{int volatile ___ = 1;(void)dest;(void)src;
#line 160
::exit(___);}
#if 0
#line 156
{ 
#line 157
(dest.x) = (src.x); 
#line 158
(dest.y) = (src.y); 
#line 159
return dest; 
#line 160
} 
#endif
#line 162 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline uchar1 &load(uchar1 &dest, const volatile uchar1 &src) 
#line 163
{int volatile ___ = 1;(void)dest;(void)src;
#line 166
::exit(___);}
#if 0
#line 163
{ 
#line 164
(dest.x) = (src.x); 
#line 165
return dest; 
#line 166
} 
#endif
#line 169 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uint4 &store(volatile uint4 &dest, const uint4 &src) 
#line 170
{int volatile ___ = 1;(void)dest;(void)src;
#line 173
::exit(___);}
#if 0
#line 170
{ 
#line 171
__asm st.volatile.global.v4.u32 [%0], {%1, %2, %3, %4};
return dest; 
#line 173
} 
#endif
#line 175 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uint2 &store(volatile uint2 &dest, const uint2 &src) 
#line 176
{int volatile ___ = 1;(void)dest;(void)src;
#line 179
::exit(___);}
#if 0
#line 176
{ 
#line 177
__asm st.volatile.global.v2.u32 [%0], {%1, %2};
return dest; 
#line 179
} 
#endif
#line 181 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uint &store(volatile uint &dest, const uint &src) 
#line 182
{int volatile ___ = 1;(void)dest;(void)src;
#line 185
::exit(___);}
#if 0
#line 182
{ 
#line 183
dest = src; 
#line 184
return dest; 
#line 185
} 
#endif
#line 187 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uint1 &store(volatile uint1 &dest, const uint1 &src) 
#line 188
{int volatile ___ = 1;(void)dest;(void)src;
#line 191
::exit(___);}
#if 0
#line 188
{ 
#line 189
(dest.x) = (src.x); 
#line 190
return dest; 
#line 191
} 
#endif
#line 193 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uchar3 &store(volatile uchar3 &dest, const uchar3 &src) 
#line 194
{int volatile ___ = 1;(void)dest;(void)src;
#line 199
::exit(___);}
#if 0
#line 194
{ 
#line 195
(dest.x) = (src.x); 
#line 196
(dest.y) = (src.y); 
#line 197
(dest.z) = (src.z); 
#line 198
return dest; 
#line 199
} 
#endif
#line 201 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uchar2 &store(volatile uchar2 &dest, const uchar2 &src) 
#line 202
{int volatile ___ = 1;(void)dest;(void)src;
#line 206
::exit(___);}
#if 0
#line 202
{ 
#line 203
(dest.x) = (src.x); 
#line 204
(dest.y) = (src.y); 
#line 205
return dest; 
#line 206
} 
#endif
#line 208 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile uchar1 &store(volatile uchar1 &dest, const uchar1 &src) 
#line 209
{int volatile ___ = 1;(void)dest;(void)src;
#line 212
::exit(___);}
#if 0
#line 209
{ 
#line 210
(dest.x) = (src.x); 
#line 211
return dest; 
#line 212
} 
#endif
#line 216 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint TElementSize> 
#line 217
struct StorageElement16 { 
#line 219
static const int num_storage_owords = ((TElementSize + (15)) / (16)); 
#line 221
uint4 storage[num_storage_owords]; 
#line 222
}; 
#line 224
template< int i> 
#line 225
struct StorageDude16 { 
#line 227
template< uint ElementSize> static __inline StorageElement16< ElementSize>  &
#line 228
assign(StorageElement16< ElementSize>  &dest, const StorageElement16< ElementSize>  &src) 
#line 229
{int volatile ___ = 1;(void)dest;(void)src;
#line 233
::exit(___);}
#if 0
#line 229
{ 
#line 230
StorageDude16< i - 1> ::assign(dest, src); 
#line 231
((dest.storage)[i]) = ((src.storage)[i]); 
#line 232
return dest; 
#line 233
} 
#endif
#line 235 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint ElementSize> static __inline StorageElement16< ElementSize>  &
#line 236
load(StorageElement16< ElementSize>  &dest, const volatile StorageElement16< ElementSize>  &src) 
#line 237
{int volatile ___ = 1;(void)dest;(void)src;
#line 241
::exit(___);}
#if 0
#line 237
{ 
#line 238
StorageDude16< i - 1> ::load(dest, src); 
#line 239
::load((dest.storage)[i], (src.storage)[i]); 
#line 240
return dest; 
#line 241
} 
#endif
#line 243 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint ElementSize> static __inline volatile StorageElement16< ElementSize>  &
#line 244
store(volatile StorageElement16< ElementSize>  &dest, const StorageElement16< ElementSize>  &src) 
#line 245
{int volatile ___ = 1;(void)dest;(void)src;
#line 249
::exit(___);}
#if 0
#line 245
{ 
#line 246
StorageDude16< i - 1> ::store(dest, src); 
#line 247
::store((dest.storage)[i], (src.storage)[i]); 
#line 248
return dest; 
#line 249
} 
#endif
#line 250 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 253
template<> struct StorageDude16< 0>  { 
#line 255
template< uint ElementSize> static __inline StorageElement16< ElementSize>  &
#line 256
assign(StorageElement16< ElementSize>  &dest, const StorageElement16< ElementSize>  &src) 
#line 257
{int volatile ___ = 1;(void)dest;(void)src;
#line 260
::exit(___);}
#if 0
#line 257
{ 
#line 258
((dest.storage)[0]) = ((src.storage)[0]); 
#line 259
return dest; 
#line 260
} 
#endif
#line 262 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint ElementSize> static __inline StorageElement16< ElementSize>  &
#line 263
load(StorageElement16< ElementSize>  &dest, const volatile StorageElement16< ElementSize>  &src) 
#line 264
{int volatile ___ = 1;(void)dest;(void)src;
#line 267
::exit(___);}
#if 0
#line 264
{ 
#line 265
::load((dest.storage)[0], (src.storage)[0]); 
#line 266
return dest; 
#line 267
} 
#endif
#line 269 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint ElementSize> static __inline volatile StorageElement16< ElementSize>  &
#line 270
store(volatile StorageElement16< ElementSize>  &dest, const StorageElement16< ElementSize>  &src) 
#line 271
{int volatile ___ = 1;(void)dest;(void)src;
#line 274
::exit(___);}
#if 0
#line 271
{ 
#line 272
::store((dest.storage)[0], (src.storage)[0]); 
#line 273
return dest; 
#line 274
} 
#endif
#line 275 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 278
template< uint ElementSize> __inline StorageElement16< ElementSize>  &
#line 279
assign(StorageElement16< ElementSize>  &dest, const StorageElement16< ElementSize>  &src) 
#line 280
{int volatile ___ = 1;(void)dest;(void)src;
#line 282
::exit(___);}
#if 0
#line 280
{ 
#line 281
return StorageDude16< StorageElement16< ElementSize> ::num_storage_owords - 1> ::assign(dest, src); 
#line 282
} 
#endif
#line 284 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint ElementSize> __inline StorageElement16< ElementSize>  &
#line 285
load(StorageElement16< ElementSize>  &dest, const volatile StorageElement16< ElementSize>  &src) 
#line 286
{int volatile ___ = 1;(void)dest;(void)src;
#line 288
::exit(___);}
#if 0
#line 286
{ 
#line 287
return StorageDude16< StorageElement16< ElementSize> ::num_storage_owords - 1> ::load(dest, src); 
#line 288
} 
#endif
#line 290 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint ElementSize> __inline volatile StorageElement16< ElementSize>  &
#line 291
store(volatile StorageElement16< ElementSize>  &dest, const StorageElement16< ElementSize>  &src) 
#line 292
{int volatile ___ = 1;(void)dest;(void)src;
#line 294
::exit(___);}
#if 0
#line 292
{ 
#line 293
return StorageDude16< StorageElement16< ElementSize> ::num_storage_owords - 1> ::store(dest, src); 
#line 294
} 
#endif
#line 297 "e:\\github\\whippletree\\queueHelpers.cuh"
struct StorageElement8 { 
#line 299
uint2 storage; 
#line 300
}; 
#line 302
__inline StorageElement8 &assign(StorageElement8 &dest, const StorageElement8 &src) 
#line 303
{int volatile ___ = 1;(void)dest;(void)src;
#line 306
::exit(___);}
#if 0
#line 303
{ 
#line 304
(dest.storage) = (src.storage); 
#line 305
return dest; 
#line 306
} 
#endif
#line 308 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline StorageElement8 &load(StorageElement8 &dest, const volatile StorageElement8 &src) 
#line 309
{int volatile ___ = 1;(void)dest;(void)src;
#line 312
::exit(___);}
#if 0
#line 309
{ 
#line 310
load(dest.storage, src.storage); 
#line 311
return dest; 
#line 312
} 
#endif
#line 314 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile StorageElement8 &store(volatile StorageElement8 &dest, const StorageElement8 &src) 
#line 315
{int volatile ___ = 1;(void)dest;(void)src;
#line 318
::exit(___);}
#if 0
#line 315
{ 
#line 316
store(dest.storage, src.storage); 
#line 317
return dest; 
#line 318
} 
#endif
#line 321 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint TElementSize, bool take_eight> 
#line 322
struct StorageElementSelector { 
#line 324
typedef StorageElement16< TElementSize>  type; 
#line 325
}; 
#line 327
template< uint TElementSize> 
#line 328
struct StorageElementSelector< TElementSize, true>  { 
#line 330
typedef StorageElement8 type; 
#line 331
}; 
#line 333
template< uint TElementSize> 
#line 334
struct StorageElementTyping { 
#line 336
typedef typename StorageElementSelector< TElementSize, TElementSize <= (8)> ::type Type; 
#line 337
}; 
#line 340
template<> struct StorageElementTyping< 0U> ; 
#line 343
template<> struct StorageElementTyping< 1U>  { 
#line 345
typedef unsigned char Type; 
#line 346
}; 
#line 348
template<> struct StorageElementTyping< 2U>  { 
#line 350
typedef uchar2 Type; 
#line 351
}; 
#line 353
template<> struct StorageElementTyping< 3U>  { 
#line 355
typedef uchar3 Type; 
#line 356
}; 
#line 358
template<> struct StorageElementTyping< 4U>  { 
#line 360
typedef uint Type; 
#line 361
}; 
#line 365
template< unsigned width> struct selectVectorCopyType; 
#line 369
template<> struct selectVectorCopyType< 16U>  { 
#line 371
typedef uint4 type; 
#line 372
}; 
#line 375
template<> struct selectVectorCopyType< 8U>  { 
#line 377
typedef uint2 type; 
#line 378
}; 
#line 381
template<> struct selectVectorCopyType< 4U>  { 
#line 383
typedef uint1 type; 
#line 384
}; 
#line 387
template<> struct selectVectorCopyType< 3U>  { 
#line 389
typedef uchar3 type; 
#line 390
}; 
#line 393
template<> struct selectVectorCopyType< 2U>  { 
#line 395
typedef uchar2 type; 
#line 396
}; 
#line 399
template<> struct selectVectorCopyType< 1U>  { 
#line 401
typedef uchar1 type; 
#line 402
}; 
#line 404
template< unsigned bytes, int threads = 1> 
#line 405
struct vectorCopy { 
#line 407
static const unsigned byte_width = ((bytes >= (16)) ? 16 : ((bytes >= (8)) ? 8 : ((bytes >= (4)) ? 4 : 1))); 
#line 408
static const unsigned iterations = (bytes / byte_width); 
#line 409
static const unsigned max_threads = ((iterations < (threads)) ? iterations : (threads)); 
#line 410
static const unsigned iterations_threaded = (iterations / max_threads); 
#line 411
static const unsigned vectors_copied = (max_threads * iterations_threaded); 
#line 413
typedef typename selectVectorCopyType< byte_width> ::type vector_type; 
#line 415
static __inline void storeThreaded(volatile void * dest, const void * src, int i); 
#line 416
static __inline void loadThreaded(void * dest, const volatile void * src, int i); 
#line 417
}; 
#line 419
template< int threads> 
#line 420
struct vectorCopy< 0, threads>  { 
#line 422
static __inline void storeThreaded(volatile void *dest, const void *src, int i) {int volatile ___ = 1;(void)dest;(void)src;(void)i;::exit(___);}
#if 0
#line 422
{ } 
#endif
#line 423 "e:\\github\\whippletree\\queueHelpers.cuh"
static __inline void loadThreaded(void *dest, const volatile void *src, int i) {int volatile ___ = 1;(void)dest;(void)src;(void)i;::exit(___);}
#if 0
#line 423
{ } 
#endif
#line 424 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 426
template< unsigned bytes, int threads> __inline void 
#line 427
vectorCopy< bytes, threads> ::storeThreaded(volatile void *dest, const void *src, int i) 
#line 428
{int volatile ___ = 1;(void)dest;(void)src;(void)i;
#line 446
::exit(___);}
#if 0
#line 428
{ 
#line 429
volatile vector_type *const destv = static_cast< volatile vector_type *>(dest); 
#line 430
const vector_type *const srcv = static_cast< const vector_type *>(src); 
#line 432
if (i < max_threads) 
#line 433
{ 
#line 434
volatile vector_type *d = destv + i; 
#line 435
const vector_type *s = srcv + i; 
#line 437
#pragma unroll
for (
#line 437
int j = 0; j < iterations_threaded; ++j) 
#line 438
{ 
#line 439
store(*d, *s); 
#line 440
d += max_threads; 
#line 441
s += max_threads; 
#line 442
}  
#line 443
}  
#line 445
vectorCopy< bytes - (byte_width * vectors_copied), threads> ::storeThreaded(destv + vectors_copied, srcv + vectors_copied, i); 
#line 446
} 
#endif
#line 448 "e:\\github\\whippletree\\queueHelpers.cuh"
template< unsigned bytes, int threads> __inline void 
#line 449
vectorCopy< bytes, threads> ::loadThreaded(void *dest, const volatile void *src, int i) 
#line 450
{int volatile ___ = 1;(void)dest;(void)src;(void)i;
#line 468
::exit(___);}
#if 0
#line 450
{ 
#line 451
vector_type *const destv = static_cast< volatile vector_type *>(dest); 
#line 452
const volatile vector_type *const srcv = static_cast< const volatile vector_type *>(src); 
#line 454
if (i < max_threads) 
#line 455
{ 
#line 456
vector_type *d = destv + i; 
#line 457
const volatile vector_type *s = srcv + i; 
#line 459
#pragma unroll
for (
#line 459
int j = 0; j < iterations_threaded; ++j) 
#line 460
{ 
#line 461
load(*d, *s); 
#line 462
d += max_threads; 
#line 463
s += max_threads; 
#line 464
}  
#line 465
}  
#line 467
vectorCopy< bytes - (byte_width * vectors_copied), threads> ::loadThreaded(destv + vectors_copied, srcv + vectors_copied, i); 
#line 468
} 
#endif
#line 470 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int Threads, class T> __inline void 
#line 471
multiWrite(volatile T *data_out, T *data) 
#line 472
{int volatile ___ = 1;(void)data_out;(void)data;
#line 480
::exit(___);}
#if 0
#line 472
{ 
#line 473
vectorCopy< sizeof(T), Threads> ::storeThreaded(data_out, data, Tools::laneid() % (Threads)); 
#line 480
} 
#endif
#line 482 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int Threads, class T> __inline void 
#line 483
multiRead(T *data, volatile T *data_in) 
#line 484
{int volatile ___ = 1;(void)data;(void)data_in;
#line 492
::exit(___);}
#if 0
#line 484
{ 
#line 485
vectorCopy< sizeof(T), Threads> ::loadThreaded(data, data_in, Tools::laneid() % (Threads)); 
#line 492
} 
#endif
#line 531 "e:\\github\\whippletree\\queueHelpers.cuh"
template< uint TElementSize, class TAdditionalData, uint TQueueSize> 
#line 532
class QueueStorage { 
#line 535
protected: typedef typename StorageElementTyping< TElementSize> ::Type QueueData_T; 
#line 536
typedef typename StorageElementTyping< sizeof(TAdditionalData)> ::Type QueueAddtionalData_T; 
#line 537
volatile QueueData_T storage[TQueueSize]; 
#line 538
volatile QueueAddtionalData_T additionalStorage[TQueueSize]; 
#line 542
public: static std::string name() 
#line 543
{ 
#line 544
return ""; 
#line 545
} 
#line 547
__inline void init() 
#line 548
{int volatile ___ = 1;
#line 549
::exit(___);}
#if 0
#line 548
{ 
#line 549
} 
#endif
#line 551 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline ::uint 
#line 552
prepareData(T data, TAdditionalData additionalData) 
#line 553
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 555
::exit(___);}
#if 0
#line 553
{ 
#line 554
return 0; 
#line 555
} 
#endif
#line 557 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElenent, class T> __inline ::uint 
#line 558
prepareDataParallel(T *data, TAdditionalData additionalData) 
#line 559
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 561
::exit(___);}
#if 0
#line 559
{ 
#line 560
return 0; 
#line 561
} 
#endif
#line 563 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline void 
#line 564
writeData(T data, TAdditionalData additionalData, ::uint2 pos) 
#line 565
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 570
::exit(___);}
#if 0
#line 565
{ 
#line 566
(pos.x) = ((pos.x) % TQueueSize); 
#line 568
((storage)[pos.x]) = (*(reinterpret_cast< QueueData_T *>(&data))); 
#line 569
((additionalStorage)[pos.x]) = (*(reinterpret_cast< QueueAddtionalData_T *>(&additionalData))); 
#line 570
} 
#endif
#line 572 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElenent, class T> __inline void 
#line 573
writeDataParallel(T *data, TAdditionalData additionalData, ::uint2 pos) 
#line 574
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 585
::exit(___);}
#if 0
#line 574
{ 
#line 575
(pos.x) = ((pos.x) % TQueueSize); 
#line 576
multiWrite< TThreadsPerElenent, T> (reinterpret_cast< volatile T *>((storage) + (pos.x)), data); 
#line 577
multiWrite< TThreadsPerElenent, TAdditionalData> (reinterpret_cast< volatile TAdditionalData *>((additionalStorage) + (pos.x)), &additionalData); 
#line 585
} 
#endif
#line 587 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void readData(void *data, TAdditionalData *additionalData, ::uint pos) 
#line 588
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 592
::exit(___);}
#if 0
#line 588
{ 
#line 589
pos = (pos % TQueueSize); 
#line 590
(*(reinterpret_cast< QueueData_T *>(data))) = ((storage)[pos]); 
#line 591
(*(reinterpret_cast< QueueAddtionalData_T *>(additionalData))) = ((additionalStorage)[pos]); 
#line 592
} 
#endif
#line 594 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void *readDataPointers(TAdditionalData *additionalData, ::uint pos) 
#line 595
{int volatile ___ = 1;(void)additionalData;(void)pos;
#line 599
::exit(___);}
#if 0
#line 595
{ 
#line 596
pos = (pos % TQueueSize); 
#line 597
(*(reinterpret_cast< QueueAddtionalData_T *>(additionalData))) = ((additionalStorage)[pos]); 
#line 598
return (void *)((storage) + pos); 
#line 599
} 
#endif
#line 600 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void storageFinishRead(::uint2 pos) 
#line 601
{int volatile ___ = 1;(void)pos;
#line 602
::exit(___);}
#if 0
#line 601
{ 
#line 602
} 
#endif
#line 603 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 605
template< uint TElementSize, uint TQueueSize> 
#line 606
class QueueStorage< TElementSize, void, TQueueSize>  { 
#line 609
protected: typedef typename StorageElementTyping< TElementSize> ::Type QueueData_T; 
#line 610
volatile QueueData_T storage[TQueueSize]; 
#line 614
public: static std::string name() 
#line 615
{ 
#line 616
return ""; 
#line 617
} 
#line 619
__inline void init() 
#line 620
{int volatile ___ = 1;
#line 621
::exit(___);}
#if 0
#line 620
{ 
#line 621
} 
#endif
#line 623 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline ::uint 
#line 624
prepareData(T data) 
#line 625
{int volatile ___ = 1;(void)data;
#line 627
::exit(___);}
#if 0
#line 625
{ 
#line 626
return 0; 
#line 627
} 
#endif
#line 629 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElenent, class T> __inline ::uint 
#line 630
prepareDataParallel(T *data) 
#line 631
{int volatile ___ = 1;(void)data;
#line 633
::exit(___);}
#if 0
#line 631
{ 
#line 632
return 0; 
#line 633
} 
#endif
#line 635 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline void 
#line 636
writeData(T data, ::uint2 pos) 
#line 637
{int volatile ___ = 1;(void)data;(void)pos;
#line 642
::exit(___);}
#if 0
#line 637
{ 
#line 638
(pos.x) = ((pos.x) % TQueueSize); 
#line 640
store((storage)[pos.x], *(reinterpret_cast< QueueData_T *>(&data))); 
#line 642
} 
#endif
#line 644 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElenent, class T> __inline void 
#line 645
writeDataParallel(T *data, ::uint2 pos) 
#line 646
{int volatile ___ = 1;(void)data;(void)pos;
#line 653
::exit(___);}
#if 0
#line 646
{ 
#line 647
(pos.x) = ((pos.x) % TQueueSize); 
#line 648
multiWrite< TThreadsPerElenent, T> (reinterpret_cast< volatile T *>((storage) + (pos.x)), data); 
#line 653
} 
#endif
#line 655 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void readData(void *data, ::uint pos) 
#line 656
{int volatile ___ = 1;(void)data;(void)pos;
#line 659
::exit(___);}
#if 0
#line 656
{ 
#line 657
pos = (pos % TQueueSize); 
#line 658
load(*(reinterpret_cast< QueueData_T *>(data)), (storage)[pos]); 
#line 659
} 
#endif
#line 661 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void *readDataPointers(::uint pos) 
#line 662
{int volatile ___ = 1;(void)pos;
#line 665
::exit(___);}
#if 0
#line 662
{ 
#line 663
pos = (pos % TQueueSize); 
#line 664
return (void *)((storage) + pos); 
#line 665
} 
#endif
#line 667 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void storageFinishRead(::uint2 pos) 
#line 668
{int volatile ___ = 1;(void)pos;
#line 669
::exit(___);}
#if 0
#line 668
{ 
#line 669
} 
#endif
#line 670 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 673
template< uint TElementSize, uint TQueueSize, class TAdditionalData, class QueueStub, class TQueueStorage> 
#line 674
class QueueBuilder : public BasicQueue< TAdditionalData> , protected TQueueStorage, public QueueStub { 
#line 676
static const ::uint ElementSize = (((TElementSize + sizeof(::uint)) - (1)) / sizeof(::uint)); 
#line 680
public: __inline void init() 
#line 681
{int volatile ___ = 1;
#line 684
::exit(___);}
#if 0
#line 681
{ 
#line 682
QueueStub::init(); 
#line 683
TQueueStorage::init(); 
#line 684
} 
#endif
#line 686 "e:\\github\\whippletree\\queueHelpers.cuh"
static ::std::string name() 
#line 687
{ 
#line 688
return QueueStub::name() + TQueueStorage::name(); 
#line 689
} 
#line 691
template< class Data> __inline bool 
#line 692
enqueueInitial(Data data, TAdditionalData additionalData) 
#line 693
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 695
::exit(___);}
#if 0
#line 693
{ 
#line 694
return enqueue< Data> (data, additionalData); 
#line 695
} 
#endif
#line 697 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class Data> bool 
#line 698
enqueue(Data data, TAdditionalData additionalData) 
#line 699
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 713
::exit(___);}
#if 0
#line 699
{ 
#line 700
::int2 pos = make_int2(-1, 0); 
#line 701
::uint addinfo = prepareData(data, additionalData); 
#line 702
do 
#line 703
{ 
#line 704
pos = QueueStub::template enqueuePrep< 1> (pos); 
#line 705
if ((pos.x) >= 0) 
#line 706
{ 
#line 707
writeData(data, additionalData, make_uint2(pos.x, addinfo)); 
#line 708
__threadfence(); 
#line 709
QueueStub::template enqueueEnd< 1> (pos); 
#line 710
}  
#line 711
} while ((pos.x) == (-2)); 
#line 712
return (pos.x) >= 0; 
#line 713
} 
#endif
#line 715 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadssPerElment, class Data> bool 
#line 716
enqueue(Data *data, TAdditionalData additionalData) 
#line 717
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 731
::exit(___);}
#if 0
#line 717
{ 
#line 718
::int2 pos = make_int2(-1, 0); 
#line 719
::uint addinfo = TQueueStorage::template prepareDataParallel< TThreadssPerElment> (data, additionalData); 
#line 720
do 
#line 721
{ 
#line 722
pos = QueueStub::template enqueuePrep< TThreadssPerElment> (pos); 
#line 723
if ((pos.x) >= 0) 
#line 724
{ 
#line 725
TQueueStorage::template writeDataParallel< TThreadssPerElment> (data, additionalData, make_uint2(pos.x, addinfo)); 
#line 726
__threadfence(); 
#line 727
QueueStub::template enqueueEnd< TThreadssPerElment> (pos); 
#line 728
}  
#line 729
} while ((pos.x) == (-2)); 
#line 730
return (pos.x) >= 0; 
#line 731
} 
#endif
#line 733 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline int dequeue(void *data, TAdditionalData *addtionalData, int num) 
#line 734
{int volatile ___ = 1;(void)data;(void)addtionalData;(void)num;
#line 747
::exit(___);}
#if 0
#line 734
{ 
#line 736
::uint2 offset_take = QueueStub::dequeuePrep(num); 
#line 738
if ((__device_builtin_variable_threadIdx.x) < (offset_take.y)) 
#line 739
{ 
#line 740
readData((reinterpret_cast< ::uint *>(data)) + ((__device_builtin_variable_threadIdx.x) * ElementSize), addtionalData + (__device_builtin_variable_threadIdx.x), (offset_take.x) + (__device_builtin_variable_threadIdx.x)); 
#line 741
__threadfence(); 
#line 742
}  
#line 743
__syncthreads(); 
#line 744
QueueStub::dequeueEnd(offset_take); 
#line 745
TQueueStorage::storageFinishRead(offset_take); 
#line 746
return offset_take.y; 
#line 747
} 
#endif
#line 748 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 750
template< uint TElementSize, uint TQueueSize, class QueueStub, class TQueueStorage> 
#line 751
class QueueBuilder< TElementSize, TQueueSize, void, QueueStub, TQueueStorage>  : public BasicQueue< void> , protected TQueueStorage, public QueueStub { 
#line 754
static const ::uint ElementSize = (((TElementSize + sizeof(::uint)) - (1)) / sizeof(::uint)); 
#line 757
public: __inline void init() 
#line 758
{int volatile ___ = 1;
#line 761
::exit(___);}
#if 0
#line 758
{ 
#line 759
QueueStub::init(); 
#line 760
TQueueStorage::init(); 
#line 761
} 
#endif
#line 763 "e:\\github\\whippletree\\queueHelpers.cuh"
static ::std::string name() 
#line 764
{ 
#line 765
return QueueStub::name() + TQueueStorage::name(); 
#line 766
} 
#line 768
template< class Data> __inline bool 
#line 769
enqueueInitial(Data data) 
#line 770
{int volatile ___ = 1;(void)data;
#line 772
::exit(___);}
#if 0
#line 770
{ 
#line 771
return enqueue< Data> (data); 
#line 772
} 
#endif
#line 774 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class Data> bool 
#line 775
enqueue(Data data) 
#line 776
{int volatile ___ = 1;(void)data;
#line 790
::exit(___);}
#if 0
#line 776
{ 
#line 777
::int2 pos = make_int2(-1, 0); 
#line 778
::uint addinfo = prepareData(data); 
#line 779
do 
#line 780
{ 
#line 781
pos = QueueStub::template enqueuePrep< 1> (pos); 
#line 782
if ((pos.x) >= 0) 
#line 783
{ 
#line 784
writeData(data, make_uint2(pos.x, addinfo)); 
#line 785
__threadfence(); 
#line 786
QueueStub::template enqueueEnd< 1> (pos); 
#line 787
}  
#line 788
} while ((pos.x) == (-2)); 
#line 789
return (pos.x) >= 0; 
#line 790
} 
#endif
#line 792 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadssPerElment, class Data> bool 
#line 793
enqueue(Data *data) 
#line 794
{int volatile ___ = 1;(void)data;
#line 808
::exit(___);}
#if 0
#line 794
{ 
#line 795
::int2 pos = make_int2(-1, 0); 
#line 796
::uint addinfo = TQueueStorage::template prepareDataParallel< TThreadssPerElment> (data); 
#line 797
do 
#line 798
{ 
#line 799
pos = QueueStub::template enqueuePrep< TThreadssPerElment> (pos); 
#line 800
if ((pos.x) >= 0) 
#line 801
{ 
#line 802
TQueueStorage::template writeDataParallel< TThreadssPerElment> (data, make_uint2(pos.x, addinfo)); 
#line 803
__threadfence(); 
#line 804
QueueStub::template enqueueEnd< TThreadssPerElment> (pos); 
#line 805
}  
#line 806
} while ((pos.x) == (-2)); 
#line 807
return (pos.x) >= 0; 
#line 808
} 
#endif
#line 810 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline int dequeue(void *data, int num) 
#line 811
{int volatile ___ = 1;(void)data;(void)num;
#line 822
::exit(___);}
#if 0
#line 811
{ 
#line 812
::uint2 offset_take = QueueStub::dequeuePrep(num); 
#line 813
if ((__device_builtin_variable_threadIdx.x) < (offset_take.y)) 
#line 814
{ 
#line 815
TQueueStorage::readData((reinterpret_cast< ::uint *>(data)) + ((__device_builtin_variable_threadIdx.x) * ElementSize), (offset_take.x) + (__device_builtin_variable_threadIdx.x)); 
#line 816
__threadfence(); 
#line 817
}  
#line 818
__syncthreads(); 
#line 819
QueueStub::dequeueEnd(offset_take); 
#line 820
TQueueStorage::storageFinishRead(offset_take); 
#line 821
return offset_take.y; 
#line 822
} 
#endif
#line 823 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 830
template< uint MemSize> 
#line 831
class MemoryAllocFastest { 
#line 833
static const uint AllocElements = (MemSize / sizeof(uint)); 
#line 834
uint allocPointer; 
#line 836
public: volatile uint4 dataAllocation[AllocElements / (4)]; 
#line 838
__inline void init() 
#line 839
{int volatile ___ = 1;
#line 843
::exit(___);}
#if 0
#line 839
{ 
#line 840
::uint lid = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); 
#line 841
if (lid == (0)) { 
#line 842
(allocPointer) = (0); }  
#line 843
} 
#endif
#line 844 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline ::uint allocOffset(::uint size) 
#line 845
{int volatile ___ = 1;(void)size;
#line 851
::exit(___);}
#if 0
#line 845
{ 
#line 846
size = (size / sizeof(::uint)); 
#line 847
::uint p = atomicAdd(&(allocPointer), size) % AllocElements; 
#line 848
while ((p + size) > AllocElements) { 
#line 849
p = (atomicAdd(&(allocPointer), size) % AllocElements); }  
#line 850
return p; 
#line 851
} 
#endif
#line 853 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile ::uint *offsetToPointer(::uint offset) 
#line 854
{int volatile ___ = 1;(void)offset;
#line 856
::exit(___);}
#if 0
#line 854
{ 
#line 855
return (reinterpret_cast< volatile ::uint *>(dataAllocation)) + offset; 
#line 856
} 
#endif
#line 857 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile ::uint *alloc(::uint size) 
#line 858
{int volatile ___ = 1;(void)size;
#line 860
::exit(___);}
#if 0
#line 858
{ 
#line 859
return this->offsetToPointer(this->allocOffset(size)); 
#line 860
} 
#endif
#line 862 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void free(void *p, int size) 
#line 863
{int volatile ___ = 1;(void)p;(void)size;
#line 864
::exit(___);}
#if 0
#line 863
{ 
#line 864
} 
#endif
#line 865 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void freeOffset(int offset, int size) 
#line 866
{int volatile ___ = 1;(void)offset;(void)size;
#line 867
::exit(___);}
#if 0
#line 866
{ 
#line 867
} 
#endif
#line 868 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 872
template< uint MemSize> 
#line 873
class MemoryAlloc { 
#line 875
static const uint AllocSize = (16); 
#line 876
static const uint AllocElements = (MemSize / AllocSize); 
#line 878
uint flags[(AllocElements + (31)) / (32)]; 
#line 879
uint allocPointer; 
#line 881
public: volatile uint4 dataAllocation[AllocElements]; 
#line 883
__inline void init() 
#line 884
{int volatile ___ = 1;
#line 890
::exit(___);}
#if 0
#line 884
{ 
#line 885
::uint lid = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); 
#line 886
for (int i = lid; i < ((AllocElements + (31)) / (32)); i += ((__device_builtin_variable_blockDim.x) * (__device_builtin_variable_gridDim.x))) { 
#line 887
((flags)[i]) = 0; }  
#line 888
if (lid == (0)) { 
#line 889
(allocPointer) = (0); }  
#line 890
} 
#endif
#line 891 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline int allocOffset(::uint size) 
#line 892
{int volatile ___ = 1;(void)size;
#line 910
::exit(___);}
#if 0
#line 892
{ 
#line 893
size = (((size + AllocSize) - (1)) / AllocSize); 
#line 894
for (::uint t = (0); t < (AllocElements / AllocSize); ++t) 
#line 895
{ 
#line 896
int p = atomicAdd(&(allocPointer), size) % AllocElements; 
#line 897
if ((p + size) > AllocElements) { 
#line 898
p = (atomicAdd(&(allocPointer), size) % AllocElements); }  
#line 900
int bigoffset = p / 32; 
#line 901
int withinoffset = p - (bigoffset * 32); 
#line 902
::uint bits = ((1U << size) - 1U) << withinoffset; 
#line 903
::uint oldf = atomicOr((flags) + bigoffset, bits); 
#line 904
if ((oldf & bits) == (0)) { 
#line 905
return p; }  
#line 906
atomicAnd((flags) + bigoffset, oldf | (~bits)); 
#line 907
}  
#line 909
return -1; 
#line 910
} 
#endif
#line 912 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile ::uint *offsetToPointer(int offset) 
#line 913
{int volatile ___ = 1;(void)offset;
#line 915
::exit(___);}
#if 0
#line 913
{ 
#line 914
return reinterpret_cast< volatile ::uint *>((dataAllocation) + offset); 
#line 915
} 
#endif
#line 916 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline int pointerToOffset(void *p) 
#line 917
{int volatile ___ = 1;(void)p;
#line 919
::exit(___);}
#if 0
#line 917
{ 
#line 918
return (reinterpret_cast< volatile ::uint4 *>(p)) - (dataAllocation); 
#line 919
} 
#endif
#line 920 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline volatile ::uint *alloc(::uint size) 
#line 921
{int volatile ___ = 1;(void)size;
#line 923
::exit(___);}
#if 0
#line 921
{ 
#line 922
return this->offsetToPointer(this->allocOffset(size)); 
#line 923
} 
#endif
#line 925 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void free(void *p, int size) 
#line 926
{int volatile ___ = 1;(void)p;(void)size;
#line 928
::exit(___);}
#if 0
#line 926
{ 
#line 927
this->freeOffset(this->pointerToOffset(p), size); 
#line 928
} 
#endif
#line 929 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void freeOffset(int offset, int size) 
#line 930
{int volatile ___ = 1;(void)offset;(void)size;
#line 937
::exit(___);}
#if 0
#line 930
{ 
#line 932
size = (((size + AllocSize) - (1)) / AllocSize); 
#line 933
int bigoffset = offset / 32; 
#line 934
int withinoffset = offset - (bigoffset * 32); 
#line 935
::uint bits = ((1U << size) - 1U) << withinoffset; 
#line 936
atomicAnd((flags) + bigoffset, ~bits); 
#line 937
} 
#endif
#line 938 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 940
template< uint TAvgElementSize, class TAdditionalData, uint TQueueSize, bool TCheckSet = false, template< uint >  class MemAlloc = MemoryAlloc> 
#line 941
class AllocStorage : private MemAlloc< TQueueSize * (TAvgElementSize + (((TAvgElementSize > (8)) || (AdditionalDataInfo< TAdditionalData> ::size > 8)) ? ((sizeof(TAdditionalData) + (15)) / (16)) * (16) : (((TAvgElementSize > (4)) || (AdditionalDataInfo< TAdditionalData> ::size > 4)) ? ((sizeof(TAdditionalData) + (7)) / (8)) * (8) : (4))))>  { 
#line 945
protected: static const int ForceSize = ((TAvgElementSize > (8)) ? 16 : ((TAvgElementSize > (4)) ? 8 : 4)); 
#line 947
static const int PureAdditionalSize = (((sizeof(TAdditionalData) + sizeof(::uint)) - (1)) / sizeof(::uint)); 
#line 948
static const int AdditionalSize = (((TAvgElementSize > (8)) || (sizeof(TAdditionalData) > (8))) ? ((sizeof(TAdditionalData) + (15)) / (16)) * (16) : (((TAvgElementSize > (4)) || (sizeof(TAdditionalData) > (4))) ? ((sizeof(TAdditionalData) + (7)) / (8)) * (8) : (4))); 
#line 951
typedef typename StorageElementTyping< sizeof(TAdditionalData)> ::Type AdditonalInfoElement; 
#line 952
typedef ::StorageElementTyping< 8U> ::Type OffsetData_T; 
#line 953
typedef MemAlloc< TAvgElementSize * TQueueSize>  TMemAlloc; 
#line 955
volatile OffsetData_T offsetStorage[TQueueSize]; 
#line 959
public: static ::std::string name() 
#line 960
{ 
#line 961
return ((::std::string)("Alloced")); 
#line 962
} 
#line 964
__inline void init() 
#line 965
{int volatile ___ = 1;
#line 973
::exit(___);}
#if 0
#line 965
{ 
#line 966
MemAlloc< TQueueSize * (TAvgElementSize + (((TAvgElementSize > (8)) || (AdditionalDataInfo< TAdditionalData> ::size > 8)) ? ((sizeof(TAdditionalData) + (15)) / (16)) * (16) : (((TAvgElementSize > (4)) || (AdditionalDataInfo< TAdditionalData> ::size > 4)) ? ((sizeof(TAdditionalData) + (7)) / (8)) * (8) : (4))))> ::init(); 
#line 967
if (TCheckSet) 
#line 968
{ 
#line 969
::uint lid = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); 
#line 970
for (::uint i = lid; i < ((2) * TQueueSize); i += ((__device_builtin_variable_blockDim.x) * (__device_builtin_variable_gridDim.x))) { 
#line 971
(((::uint *)(offsetStorage))[i]) = (0); }  
#line 972
}  
#line 973
} 
#endif
#line 975 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline ::uint 
#line 976
prepareData(T data, TAdditionalData additionalData) 
#line 977
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 982
::exit(___);}
#if 0
#line 977
{ 
#line 978
::uint p = allocOffset(((((sizeof(T) + AdditionalSize) + ForceSize) - (1)) / ForceSize) * ForceSize); 
#line 979
(*(reinterpret_cast< volatile AdditonalInfoElement *>((reinterpret_cast< volatile ::uint *>(TMemAlloc::dataAllocation)) + p))) = (*(reinterpret_cast< AdditonalInfoElement *>(&additionalData))); 
#line 980
(*(reinterpret_cast< volatile typename StorageElementTyping< sizeof(T)> ::Type *>(((reinterpret_cast< volatile ::uint *>(TMemAlloc::dataAllocation)) + p) + (AdditionalSize / sizeof(::uint))))) = (*(reinterpret_cast< typename StorageElementTyping< sizeof(T)> ::Type *>(&data))); 
#line 981
return p; 
#line 982
} 
#endif
#line 984 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElement, class T> __inline ::uint 
#line 985
prepareDataParallel(T *data, TAdditionalData additionalData) 
#line 986
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 999
::exit(___);}
#if 0
#line 986
{ 
#line 987
if (TThreadsPerElement == 1) { 
#line 988
return prepareData(*data, additionalData); }  
#line 990
int p; 
#line 991
if ((Tools::laneid() % (TThreadsPerElement)) == (0)) { 
#line 992
p = allocOffset(((((sizeof(T) + AdditionalSize) + ForceSize) - (1)) / ForceSize) * ForceSize); }  
#line 993
p = warpBroadcast< TThreadsPerElement> (p, 0); 
#line 995
multiWrite< TThreadsPerElement, TAdditionalData> (reinterpret_cast< volatile TAdditionalData *>((reinterpret_cast< volatile ::uint *>(TMemAlloc::dataAllocation)) + p), &additionalData); 
#line 996
multiWrite< TThreadsPerElement, T> (reinterpret_cast< volatile T *>(((reinterpret_cast< volatile ::uint *>(TMemAlloc::dataAllocation)) + p) + (AdditionalSize / sizeof(::uint))), data); 
#line 998
return p; 
#line 999
} 
#endif
#line 1001 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline void 
#line 1002
writeData(T data, TAdditionalData additionalData, ::uint2 pos) 
#line 1003
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 1015
::exit(___);}
#if 0
#line 1003
{ 
#line 1004
(pos.x) = ((pos.x) % TQueueSize); 
#line 1005
::uint2 o = make_uint2(pos.y, sizeof(T)); 
#line 1007
if (TCheckSet) 
#line 1008
{ 
#line 1009
(o.x) += (1); 
#line 1010
while ((*(((volatile ::uint *)(offsetStorage)) + ((2) * (pos.x)))) != (0)) { 
#line 1011
__threadfence(); }  
#line 1012
}  
#line 1014
((offsetStorage)[pos.x]) = (*(reinterpret_cast< OffsetData_T *>(&o))); 
#line 1015
} 
#endif
#line 1017 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElement, class T> __inline void 
#line 1018
writeDataParallel(T *data, TAdditionalData additionalData, ::uint2 pos) 
#line 1019
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 1022
::exit(___);}
#if 0
#line 1019
{ 
#line 1020
if ((Tools::laneid() % (TThreadsPerElement)) == (0)) { 
#line 1021
writeData(*data, additionalData, pos); }  
#line 1022
} 
#endif
#line 1046 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void storageFinishRead(::uint2 pos) 
#line 1047
{int volatile ___ = 1;(void)pos;
#line 1065
::exit(___);}
#if 0
#line 1047
{ 
#line 1049
if ((__device_builtin_variable_threadIdx.x) < (pos.y)) 
#line 1050
{ 
#line 1051
::uint p = ((pos.x) + (__device_builtin_variable_threadIdx.x)) % TQueueSize; 
#line 1053
OffsetData_T offsetData; 
#line 1054
offsetData = ((offsetStorage)[p]); 
#line 1055
::uint2 offset = *(reinterpret_cast< ::uint2 *>(&offsetData)); 
#line 1057
TMemAlloc::freeOffset(offset.x, offset.y); 
#line 1058
if (TCheckSet) 
#line 1059
{ 
#line 1060
__threadfence(); 
#line 1061
::uint2 o = make_uint2(0, 0); 
#line 1062
((offsetStorage)[p]) = (*(reinterpret_cast< OffsetData_T *>(&o))); 
#line 1063
}  
#line 1064
}  
#line 1065
} 
#endif
#line 1066 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 1068
template< uint TAvgElementSize, uint TQueueSize, bool TCheckSet, template< uint >  class MemAlloc> 
#line 1069
class AllocStorage< TAvgElementSize, void, TQueueSize, TCheckSet, MemAlloc>  : private MemAlloc< TAvgElementSize * TQueueSize>  { 
#line 1072
protected: static const int ForceSize = ((TAvgElementSize > (8)) ? 16 : ((TAvgElementSize > (4)) ? 8 : 4)); 
#line 1075
typedef ::StorageElementTyping< 8U> ::Type OffsetData_T; 
#line 1076
typedef MemAlloc< TAvgElementSize * TQueueSize>  TMemAlloc; 
#line 1078
volatile OffsetData_T offsetStorage[TQueueSize]; 
#line 1082
public: static ::std::string name() 
#line 1083
{ 
#line 1084
return "Alloced"; 
#line 1085
} 
#line 1087
__inline void init() 
#line 1088
{int volatile ___ = 1;
#line 1096
::exit(___);}
#if 0
#line 1088
{ 
#line 1089
MemAlloc< TAvgElementSize * TQueueSize> ::init(); 
#line 1090
if (TCheckSet) 
#line 1091
{ 
#line 1092
::uint lid = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); 
#line 1093
for (::uint i = lid; i < ((2) * TQueueSize); i += ((__device_builtin_variable_blockDim.x) * (__device_builtin_variable_gridDim.x))) { 
#line 1094
(((::uint *)(offsetStorage))[i]) = (0); }  
#line 1095
}  
#line 1096
} 
#endif
#line 1098 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline ::uint 
#line 1099
prepareData(T data) 
#line 1100
{int volatile ___ = 1;(void)data;
#line 1104
::exit(___);}
#if 0
#line 1100
{ 
#line 1101
::uint p = allocOffset((((sizeof(T) + ForceSize) - (1)) / ForceSize) * ForceSize); 
#line 1102
(*(reinterpret_cast< volatile typename StorageElementTyping< sizeof(T)> ::Type *>((reinterpret_cast< volatile ::uint *>(TMemAlloc::dataAllocation)) + p))) = (*(reinterpret_cast< typename StorageElementTyping< sizeof(T)> ::Type *>(&data))); 
#line 1103
return p; 
#line 1104
} 
#endif
#line 1106 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElement, class T> __inline ::uint 
#line 1107
prepareDataParallel(T *data) 
#line 1108
{int volatile ___ = 1;(void)data;
#line 1119
::exit(___);}
#if 0
#line 1108
{ 
#line 1109
if (TThreadsPerElement == 1) { 
#line 1110
return prepareData(*data); }  
#line 1112
int p; 
#line 1113
if ((Tools::laneid() % (TThreadsPerElement)) == (0)) { 
#line 1114
p = allocOffset((((sizeof(T) + ForceSize) - (1)) / ForceSize) * ForceSize); }  
#line 1116
p = warpBroadcast< TThreadsPerElement> (p, 0); 
#line 1117
multiWrite< TThreadsPerElement, T> (reinterpret_cast< volatile T *>((reinterpret_cast< volatile ::uint *>(TMemAlloc::dataAllocation)) + p), data); 
#line 1118
return p; 
#line 1119
} 
#endif
#line 1121 "e:\\github\\whippletree\\queueHelpers.cuh"
template< class T> __inline void 
#line 1122
writeData(T data, ::uint2 pos) 
#line 1123
{int volatile ___ = 1;(void)data;(void)pos;
#line 1135
::exit(___);}
#if 0
#line 1123
{ 
#line 1124
(pos.x) = ((pos.x) % TQueueSize); 
#line 1125
::uint2 o = make_uint2(pos.y, sizeof(T)); 
#line 1127
if (TCheckSet) 
#line 1128
{ 
#line 1129
(o.x) += (1); 
#line 1130
while ((*(((volatile ::uint *)(offsetStorage)) + ((2) * (pos.x)))) != (0)) { 
#line 1131
__threadfence(); }  
#line 1132
}  
#line 1134
((offsetStorage)[pos.x]) = (*(reinterpret_cast< OffsetData_T *>(&o))); 
#line 1135
} 
#endif
#line 1137 "e:\\github\\whippletree\\queueHelpers.cuh"
template< int TThreadsPerElement, class T> __inline void 
#line 1138
writeDataParallel(T *data, ::uint2 pos) 
#line 1139
{int volatile ___ = 1;(void)data;(void)pos;
#line 1142
::exit(___);}
#if 0
#line 1139
{ 
#line 1140
if ((Tools::laneid() % (TThreadsPerElement)) == (0)) { 
#line 1141
writeData(*data, pos); }  
#line 1142
} 
#endif
#line 1164 "e:\\github\\whippletree\\queueHelpers.cuh"
__inline void storageFinishRead(::uint2 pos) 
#line 1165
{int volatile ___ = 1;(void)pos;
#line 1181
::exit(___);}
#if 0
#line 1165
{ 
#line 1166
if ((__device_builtin_variable_threadIdx.x) < (pos.y)) 
#line 1167
{ 
#line 1168
::uint p = ((pos.x) + (__device_builtin_variable_threadIdx.x)) % TQueueSize; 
#line 1169
OffsetData_T offsetData; 
#line 1170
offsetData = ((offsetStorage)[p]); 
#line 1171
::uint2 offset = *(reinterpret_cast< ::uint2 *>(&offsetData)); 
#line 1173
TMemAlloc::freeOffset(offset.x, offset.y); 
#line 1174
if (TCheckSet) 
#line 1175
{ 
#line 1176
__threadfence(); 
#line 1177
::uint2 o = make_uint2(0, 0); 
#line 1178
((offsetStorage)[p]) = (*(reinterpret_cast< OffsetData_T *>(&o))); 
#line 1179
}  
#line 1180
}  
#line 1181
} 
#endif
#line 1182 "e:\\github\\whippletree\\queueHelpers.cuh"
}; 
#line 39 "e:\\github\\whippletree\\segmentedStorage.cuh"
namespace SegmentedStorage { 
#line 42
extern void (*pReinitStorage)(void); 
#line 43
extern void *storage; 
#line 44
template< int TStorageSize, int TBlockSize> 
#line 45
class Storage { 
#line 48
public: static const int StorageSize = TStorageSize; 
#line 49
static const int BlockSize = ((TBlockSize / 16) * 16); 
#line 50
struct Block { 
#line 52
unsigned data[BlockSize / sizeof(int)]; 
#line 53
}; 
#line 56
private: static const int NumBlocks = ((StorageSize - ((16) * sizeof(uint))) / (BlockSize + sizeof(int))); 
#line 58
Block blocks[NumBlocks]; 
#line 60
int count; 
#line 61
unsigned front, back; 
#line 62
volatile int available[NumBlocks]; 
#line 65
public: __inline void init() 
#line 66
{int volatile ___ = 1;
#line 71
::exit(___);}
#if 0
#line 66
{ 
#line 67
(count) = NumBlocks; 
#line 68
(back) = ((front) = (0)); 
#line 69
for (int id = (__device_builtin_variable_threadIdx.x) + ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)); id < NumBlocks; id += ((__device_builtin_variable_gridDim.x) * (__device_builtin_variable_blockDim.x))) { 
#line 70
((available)[id]) = id; }  
#line 71
} 
#endif
#line 73 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline int request() 
#line 74
{int volatile ___ = 1;
#line 87
::exit(___);}
#if 0
#line 74
{ 
#line 75
int c = atomicSub(&(count), 1); 
#line 76
if (c <= 0) 
#line 77
{ 
#line 78
atomicAdd(&(count), 1); 
#line 79
return -1; 
#line 80
}  
#line 81
int p = atomicInc(&(front), NumBlocks - 1); 
#line 82
int id; 
#line 83
while ((id = ((available)[p])) == (-1)) { 
#line 84
__threadfence(); }  
#line 85
((available)[p]) = (-1); 
#line 86
return id; 
#line 87
} 
#endif
#line 89 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void free(int id) 
#line 90
{int volatile ___ = 1;(void)id;
#line 97
::exit(___);}
#if 0
#line 90
{ 
#line 91
int p = atomicInc(&(back), NumBlocks - 1); 
#line 92
while (((available)[p]) != (-1)) { 
#line 93
__threadfence(); }  
#line 94
((available)[p]) = id; 
#line 95
__threadfence(); 
#line 96
atomicAdd(&(count), 1); 
#line 97
} 
#endif
#line 99 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void free(Block *b) 
#line 100
{int volatile ___ = 1;(void)b;
#line 102
::exit(___);}
#if 0
#line 100
{ 
#line 101
free(this->blockToIndex(b)); 
#line 102
} 
#endif
#line 104 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline Block *indexToBlock(int index) 
#line 105
{int volatile ___ = 1;(void)index;
#line 108
::exit(___);}
#if 0
#line 105
{ 
#line 107
return (blocks) + index; 
#line 108
} 
#endif
#line 110 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline int blockToIndex(Block *b) 
#line 111
{int volatile ___ = 1;(void)b;
#line 113
::exit(___);}
#if 0
#line 111
{ 
#line 112
return b - (blocks); 
#line 113
} 
#endif
#line 115 "e:\\github\\whippletree\\segmentedStorage.cuh"
static __inline Storage *get() 
#line 116
{int volatile ___ = 1;
#line 118
::exit(___);}
#if 0
#line 116
{ 
#line 117
return reinterpret_cast< SegmentedStorage::Storage< StorageSize, BlockSize>  *>(storage); 
#line 118
} 
#endif
#line 119 "e:\\github\\whippletree\\segmentedStorage.cuh"
}; 
#line 121
extern void *StoragePointer; 
#line 123
template< int StorageSize, int BlockSize> static void 
#line 124
__wrapper__device_stub_initStorage(void *&data) {exit(1);}
#if 0
#line 125
{ 
#line 126
storage = data; 
#line 127
Storage< StorageSize, BlockSize>  *s = reinterpret_cast< Storage< StorageSize, BlockSize>  *>(data); 
#line 128
(s->init()); 
#line 129
} 
#endif
#line 123 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< int StorageSize, int BlockSize> void 
#line 124
initStorage(void *data) 
#line 125
{__wrapper__device_stub_initStorage<StorageSize,BlockSize>(data);
#line 129
return;}
#if 0
#line 125
{ 
#line 126
storage = data; 
#line 127
Storage< StorageSize, BlockSize>  *s = reinterpret_cast< Storage< StorageSize, BlockSize>  *>(data); 
#line 128
(s->init()); 
#line 129
} 
#endif
#line 131 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< class Storage> void 
#line 132
reinitStorage() 
#line 133
{ 
#line 134
if (StoragePointer == (0)) { 
#line 135
Tools::checkError(cudaMalloc(&StoragePointer, Storage::StorageSize), "e:\\github\\whippletree\\segmentedStorage.cuh", 135); }  
#line 136
(cudaConfigureCall(512, 512)) ? (void)0 : (initStorage< Storage::StorageSize, Storage::BlockSize> )(StoragePointer); 
#line 137
Tools::checkError(cudaDeviceSynchronize(), "e:\\github\\whippletree\\segmentedStorage.cuh", 137); 
#line 138
} 
#line 141
template< class Storage> void 
#line 142
createStorage() 
#line 143
{ 
#line 144
Tools::checkError(cudaMalloc(&StoragePointer, Storage::StorageSize), "e:\\github\\whippletree\\segmentedStorage.cuh", 144); 
#line 145
(cudaConfigureCall(512, 512)) ? (void)0 : (initStorage< Storage::StorageSize, Storage::BlockSize> )(StoragePointer); 
#line 146
Tools::checkError(cudaDeviceSynchronize(), "e:\\github\\whippletree\\segmentedStorage.cuh", 146); 
#line 147
pReinitStorage = (&reinitStorage< Storage> ); 
#line 148
} 
#line 150
void destroyStorage(); 
#line 152
void checkReinitStorage(); 
#line 155
template< uint TQueueSize, uint ElementsPerBlock, class SharedStorage> 
#line 156
class SegmentedQueueStorageBase { 
#line 160
protected: static const int MaxBlocks = (((TQueueSize + ElementsPerBlock) - (1)) / ElementsPerBlock); 
#line 162
template< class QueueData_T, class QueueAddtionalData_T> 
#line 163
struct MyBlock { 
#line 165
volatile QueueData_T storage[ElementsPerBlock]; 
#line 166
volatile QueueAddtionalData_T additionalStorage[ElementsPerBlock]; 
#line 167
int available; 
#line 168
__inline void init() 
#line 169
{int volatile ___ = 1;
#line 171
::exit(___);}
#if 0
#line 169
{ 
#line 170
(*((volatile int *)(&(available)))) = (ElementsPerBlock); 
#line 171
} 
#endif
#line 172 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void use(int num = 1) 
#line 173
{int volatile ___ = 1;(void)num;
#line 174
::exit(___);}
#if 0
#line 173
{ 
#line 174
} 
#endif
#line 175 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline bool doneuse(int num = 1) 
#line 176
{int volatile ___ = 1;(void)num;
#line 178
::exit(___);}
#if 0
#line 176
{ 
#line 177
return atomicSub(&(available), num) <= num; 
#line 178
} 
#endif
#line 179 "e:\\github\\whippletree\\segmentedStorage.cuh"
}; 
#line 181
template< class QueueData_T> 
#line 182
struct MyBlock< QueueData_T, void>  { 
#line 184
volatile QueueData_T storage[ElementsPerBlock]; 
#line 185
int available; 
#line 186
__inline void init() 
#line 187
{int volatile ___ = 1;
#line 189
::exit(___);}
#if 0
#line 187
{ 
#line 188
(*((volatile int *)(&(available)))) = (ElementsPerBlock); 
#line 189
} 
#endif
#line 190 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void use(int num = 1) 
#line 191
{int volatile ___ = 1;(void)num;
#line 192
::exit(___);}
#if 0
#line 191
{ 
#line 192
} 
#endif
#line 193 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline bool doneuse(int num = 1) 
#line 194
{int volatile ___ = 1;(void)num;
#line 196
::exit(___);}
#if 0
#line 194
{ 
#line 195
return atomicSub(&(available), num) <= num; 
#line 196
} 
#endif
#line 197 "e:\\github\\whippletree\\segmentedStorage.cuh"
}; 
#line 199
volatile int useBlocks[MaxBlocks]; 
#line 201
template< class TMyBlock, int Smaller> __inline TMyBlock *
#line 202
acquireBlock(int pos) 
#line 203
{int volatile ___ = 1;(void)pos;
#line 248
::exit(___);}
#if 0
#line 203
{ 
#line 204
int block = pos / ElementsPerBlock; 
#line 205
int blockoffset = (useBlocks)[block]; 
#line 206
if (blockoffset == (-1)) 
#line 207
{ 
#line 208
int localpos = pos - (ElementsPerBlock * block); 
#line 209
if ((Smaller == 0) || (localpos < Smaller)) 
#line 210
{ 
#line 211
blockoffset = (SharedStorage::get()->request()); 
#line 215
if (blockoffset == (-1)) 
#line 216
{ 
#line 217
__threadfence(); 
#line 218
blockoffset = ((useBlocks)[block]); 
#line 219
if (blockoffset == (-1)) 
#line 220
{ 
#line 224
Tools::trap(); 
#line 225
}  
#line 226
} else 
#line 228
{ 
#line 229
((reinterpret_cast< TMyBlock *>((SharedStorage::get()->indexToBlock(blockoffset))))->init()); 
#line 230
int oldid = atomicCAS((int *)((useBlocks) + block), -1, blockoffset); 
#line 231
if (oldid != (-1)) 
#line 232
{ 
#line 236
(SharedStorage::get()->free(blockoffset)); 
#line 237
blockoffset = oldid; 
#line 238
}  
#line 239
}  
#line 240
} else 
#line 242
{ 
#line 243
while ((blockoffset = ((useBlocks)[block])) == (-1)) { 
#line 244
__threadfence(); }  
#line 245
}  
#line 246
}  
#line 247
return reinterpret_cast< TMyBlock *>((SharedStorage::get()->indexToBlock(blockoffset))); 
#line 248
} 
#endif
#line 250 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< class TMyBlock> __inline TMyBlock *
#line 251
getBlock(int pos) 
#line 252
{int volatile ___ = 1;(void)pos;
#line 256
::exit(___);}
#if 0
#line 252
{ 
#line 253
int block = pos / ElementsPerBlock; 
#line 254
int blockoffset = (useBlocks)[block]; 
#line 255
return reinterpret_cast< TMyBlock *>((SharedStorage::get()->indexToBlock(blockoffset))); 
#line 256
} 
#endif
#line 259 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< class TMyBlock> __inline void 
#line 260
storageFinishRead(::uint2 pos) 
#line 261
{int volatile ___ = 1;(void)pos;
#line 279
::exit(___);}
#if 0
#line 261
{ 
#line 262
int mypos = ((pos.x) + (__device_builtin_variable_threadIdx.x)) % TQueueSize; ; 
#line 263
int prevblock = (mypos - 1) / ElementsPerBlock; 
#line 264
int myblock = mypos / ElementsPerBlock; 
#line 265
if (((__device_builtin_variable_threadIdx.x) < (pos.y)) && (((__device_builtin_variable_threadIdx.x) == (0)) || (myblock != prevblock))) 
#line 266
{ 
#line 267
int donelements = min((int)(((myblock + 1) * ElementsPerBlock) - mypos), (int)((pos.y) - (__device_builtin_variable_threadIdx.x))); 
#line 268
int bid = (useBlocks)[myblock]; 
#line 269
TMyBlock *b = reinterpret_cast< TMyBlock *>((SharedStorage::get()->indexToBlock(bid))); 
#line 270
if ((b->doneuse(donelements))) 
#line 271
{ 
#line 272
((useBlocks)[myblock]) = (-1); 
#line 276
(SharedStorage::get()->free(bid)); 
#line 277
}  
#line 278
}  
#line 279
} 
#endif
#line 285 "e:\\github\\whippletree\\segmentedStorage.cuh"
public: static std::string name() 
#line 286
{ 
#line 287
return "SharedStorage"; 
#line 288
} 
#line 290
__inline void init() 
#line 291
{int volatile ___ = 1;
#line 299
::exit(___);}
#if 0
#line 291
{ 
#line 292
int id = ((__device_builtin_variable_blockIdx.x) * (__device_builtin_variable_blockDim.x)) + (__device_builtin_variable_threadIdx.x); 
#line 293
for (int i = id; i < MaxBlocks; i += ((__device_builtin_variable_blockDim.x) * (__device_builtin_variable_gridDim.x))) { 
#line 294
((useBlocks)[i]) = (-1); }  
#line 299
} 
#endif
#line 301 "e:\\github\\whippletree\\segmentedStorage.cuh"
}; 
#line 304
template< uint TElementSize, class TAdditionalData, uint TQueueSize, class SharedStorage> 
#line 305
class SegmentedQueueStorage : public SegmentedQueueStorageBase< TQueueSize, (SharedStorage::BlockSize - sizeof(unsigned)) / (sizeof(TAdditionalData) + TElementSize), SharedStorage>  { 
#line 308
protected: typedef typename StorageElementTyping< TElementSize> ::Type QueueData_T; 
#line 309
typedef typename StorageElementTyping< sizeof(TAdditionalData)> ::Type QueueAddtionalData_T; 
#line 311
static const int ElementsPerBlock = ((SharedStorage::BlockSize - sizeof(::uint)) / (sizeof(TAdditionalData) + TElementSize)); 
#line 312
typedef ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage>  Base; 
#line 313
typedef typename ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::MyBlock MyBlock; 
#line 318
public: 
#line 317
template< class T> __inline ::uint 
#line 318
prepareData(T data, TAdditionalData additionalData) 
#line 319
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 321
::exit(___);}
#if 0
#line 319
{ 
#line 320
return 0; 
#line 321
} 
#endif
#line 323 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< int TThreadsPerElenent, class T> __inline ::uint 
#line 324
prepareDataParallel(T *data, TAdditionalData additionalData) 
#line 325
{int volatile ___ = 1;(void)data;(void)additionalData;
#line 327
::exit(___);}
#if 0
#line 325
{ 
#line 326
return 0; 
#line 327
} 
#endif
#line 329 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< class T> __inline void 
#line 330
writeData(T data, TAdditionalData additionalData, ::uint2 pos) 
#line 331
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 339
::exit(___);}
#if 0
#line 331
{ 
#line 332
(pos.x) = ((pos.x) % TQueueSize); 
#line 333
int localpos = (pos.x) % ElementsPerBlock; 
#line 334
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template acquireBlock< MyBlock, 32> (pos.x); 
#line 335
(b->use()); 
#line 337
((b->storage)[localpos]) = (*(reinterpret_cast< QueueData_T *>(&data))); 
#line 338
((b->additionalStorage)[localpos]) = (*(reinterpret_cast< QueueAddtionalData_T *>(&additionalData))); 
#line 339
} 
#endif
#line 341 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< int TThreadsPerElenent, class T> __inline void 
#line 342
writeDataParallel(T *data, TAdditionalData additionalData, ::uint2 pos) 
#line 343
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 353
::exit(___);}
#if 0
#line 343
{ 
#line 344
(pos.x) = ((pos.x) % TQueueSize); 
#line 345
int localpos = (pos.x) % ElementsPerBlock; 
#line 346
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template acquireBlock< MyBlock, 32> (pos.x); 
#line 347
if (((__device_builtin_variable_threadIdx.x) % (TThreadsPerElenent)) == (0)) { 
#line 348
(b->use()); }  
#line 350
multiWrite< TThreadsPerElenent, T> (reinterpret_cast< volatile T *>((b->storage) + localpos), data); 
#line 351
multiWrite< TThreadsPerElenent, TAdditionalData> (reinterpret_cast< volatile TAdditionalData *>((b->additionalStorage) + localpos), &additionalData); 
#line 353
} 
#endif
#line 355 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void readData(void *data, TAdditionalData *additionalData, ::uint pos) 
#line 356
{int volatile ___ = 1;(void)data;(void)additionalData;(void)pos;
#line 362
::exit(___);}
#if 0
#line 356
{ 
#line 357
pos = (pos % TQueueSize); 
#line 358
int localpos = pos % ElementsPerBlock; 
#line 359
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template getBlock< MyBlock> (pos); 
#line 360
(*(reinterpret_cast< QueueData_T *>(data))) = ((b->storage)[localpos]); 
#line 361
(*(reinterpret_cast< QueueAddtionalData_T *>(additionalData))) = ((b->additionalStorage)[localpos]); 
#line 362
} 
#endif
#line 364 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void *readDataPointers(TAdditionalData *additionalData, ::uint pos) 
#line 365
{int volatile ___ = 1;(void)additionalData;(void)pos;
#line 371
::exit(___);}
#if 0
#line 365
{ 
#line 366
pos = (pos % TQueueSize); 
#line 367
int localpos = pos % ElementsPerBlock; 
#line 368
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template getBlock< MyBlock> (pos); 
#line 369
(*(reinterpret_cast< QueueAddtionalData_T *>(additionalData))) = ((b->additionalStorage)[localpos]); 
#line 370
return (void *)((b->storage) + localpos); 
#line 371
} 
#endif
#line 373 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void storageFinishRead(::uint2 pos) 
#line 374
{int volatile ___ = 1;(void)pos;
#line 376
::exit(___);}
#if 0
#line 374
{ 
#line 375
::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template storageFinishRead< MyBlock> (pos); 
#line 376
} 
#endif
#line 377 "e:\\github\\whippletree\\segmentedStorage.cuh"
}; 
#line 379
template< uint TElementSize, uint TQueueSize, class SharedStorage> 
#line 380
class SegmentedQueueStorage< TElementSize, void, TQueueSize, SharedStorage>  : public SegmentedQueueStorageBase< TQueueSize, (SharedStorage::BlockSize - sizeof(unsigned)) / TElementSize, SharedStorage>  { 
#line 383
protected: typedef typename StorageElementTyping< TElementSize> ::Type QueueData_T; 
#line 385
static const int ElementsPerBlock = ((SharedStorage::BlockSize - sizeof(::uint)) / TElementSize); 
#line 386
typedef ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage>  Base; 
#line 387
typedef typename ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::MyBlock MyBlock; 
#line 392
public: 
#line 391
template< class T> __inline ::uint 
#line 392
prepareData(T data) 
#line 393
{int volatile ___ = 1;(void)data;
#line 395
::exit(___);}
#if 0
#line 393
{ 
#line 394
return 0; 
#line 395
} 
#endif
#line 397 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< int TThreadsPerElenent, class T> __inline ::uint 
#line 398
prepareDataParallel(T *data) 
#line 399
{int volatile ___ = 1;(void)data;
#line 401
::exit(___);}
#if 0
#line 399
{ 
#line 400
return 0; 
#line 401
} 
#endif
#line 403 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< class T> __inline void 
#line 404
writeData(T data, ::uint2 pos) 
#line 405
{int volatile ___ = 1;(void)data;(void)pos;
#line 416
::exit(___);}
#if 0
#line 405
{ 
#line 406
(pos.x) = ((pos.x) % TQueueSize); 
#line 407
int localpos = (pos.x) % ElementsPerBlock; 
#line 408
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template acquireBlock< MyBlock, 32> (pos.x); 
#line 409
(b->use()); 
#line 413
store((b->storage)[localpos], *(reinterpret_cast< QueueData_T *>(&data))); 
#line 416
} 
#endif
#line 418 "e:\\github\\whippletree\\segmentedStorage.cuh"
template< int TThreadsPerElenent, class T> __inline void 
#line 419
writeDataParallel(T *data, ::uint2 pos) 
#line 420
{int volatile ___ = 1;(void)data;(void)pos;
#line 428
::exit(___);}
#if 0
#line 420
{ 
#line 421
(pos.x) = ((pos.x) % TQueueSize); 
#line 422
int localpos = (pos.x) % ElementsPerBlock; 
#line 423
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template acquireBlock< MyBlock, 32> (pos.x); 
#line 424
if (((__device_builtin_variable_threadIdx.x) % (TThreadsPerElenent)) == (0)) { 
#line 425
(b->use()); }  
#line 427
multiWrite< TThreadsPerElenent, T> (reinterpret_cast< volatile T *>((b->storage) + localpos), data); 
#line 428
} 
#endif
#line 430 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void readData(void *data, ::uint pos) 
#line 431
{int volatile ___ = 1;(void)data;(void)pos;
#line 437
::exit(___);}
#if 0
#line 431
{ 
#line 432
pos = (pos % TQueueSize); 
#line 433
int localpos = pos % ElementsPerBlock; 
#line 434
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template getBlock< MyBlock> (pos); 
#line 435
load(*(reinterpret_cast< QueueData_T *>(data)), (b->storage)[localpos]); 
#line 437
} 
#endif
#line 439 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void *readDataPointers(::uint pos) 
#line 440
{int volatile ___ = 1;(void)pos;
#line 445
::exit(___);}
#if 0
#line 440
{ 
#line 441
pos = (pos % TQueueSize); 
#line 442
int localpos = pos % ElementsPerBlock; 
#line 443
MyBlock *b = ::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template getBlock< MyBlock> (pos); 
#line 444
return (void *)((b->storage) + localpos); 
#line 445
} 
#endif
#line 447 "e:\\github\\whippletree\\segmentedStorage.cuh"
__inline void storageFinishRead(::uint2 pos) 
#line 448
{int volatile ___ = 1;(void)pos;
#line 450
::exit(___);}
#if 0
#line 448
{ 
#line 449
::SegmentedStorage::SegmentedQueueStorageBase< TQueueSize, ElementsPerBlock, SharedStorage> ::template storageFinishRead< MyBlock> (pos); 
#line 450
} 
#endif
#line 451 "e:\\github\\whippletree\\segmentedStorage.cuh"
}; 
#line 452
}
#line 5 "E:/github/whippletree/segmentedStorage.cu"
void (*SegmentedStorage::pReinitStorage)(void) = (0); 
#line 7
void *storage; 
#line 9
void *SegmentedStorage::StoragePointer = (0); 
#line 11
void SegmentedStorage::destroyStorage() 
#line 12
{ 
#line 13
if (StoragePointer != (0)) { 
#line 14
Tools::checkError(cudaFree(&StoragePointer), "E:/github/whippletree/segmentedStorage.cu", 14); }  
#line 15
StoragePointer = (0); 
#line 16
pReinitStorage = (0); 
#line 17
} 
#line 19
void SegmentedStorage::checkReinitStorage() 
#line 20
{ 
#line 21
if (pReinitStorage != (0)) { 
#line 22
pReinitStorage(); }  
#line 23
} 
#line 1 "segmentedStorage.compute_20.cudafe1.stub.c"
#define _NV_ANON_NAMESPACE _GLOBAL__N__35_segmentedStorage_compute_20_cpp1_ii_2b81d216
#line 1 "segmentedStorage.compute_20.cudafe1.stub.c"
#include "segmentedStorage.compute_20.cudafe1.stub.c"
#line 1 "segmentedStorage.compute_20.cudafe1.stub.c"
#undef _NV_ANON_NAMESPACE
